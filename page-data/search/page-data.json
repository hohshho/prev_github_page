{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\r\nAWS EC2를 사용해서 구현해야 할 일이 생겨서 간만에 사용하다 잘 안되서 기록해둔다.\r\n\r\n1. AWS EC2 인스턴스 생성\r\n\r\n2. vscode extensions에서 ftp-simple을 설치해준다.\r\n\r\n3. F1을 눌러 ftp-simple : Config - FTP connection setting 실행.  \r\n 다음 사진과 같이 설정해준다.\r\n\r\n![설정 json](./201205_jsoncapture.PNG \"json파일\")\r\n\r\n1. F1 눌러 Remote directory open to workspace 실행하면 된다.\r\n","excerpt":"AWS EC2를 사용해서 구현해야 할 일이 생겨서 간만에 사용하다 잘 안되서 기록해둔다. AWS EC2 인스턴스 생성 vscode extensions에서 ftp-simple을 설치해준다. F1을 눌러 ftp-simple : Config - FTP c…","fields":{"slug":"/vscode_connect_aws/"},"frontmatter":{"date":"Dec 05, 2020","title":"AWS EC2 Visual Studio Code로 사용하기","tags":["AWS"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n백준 DP 단계별 문제에 있는 10844번 문제이다. \r\n\r\n접근이 조금 어려웠던 문제라 풀이를 정리해보려고 한다.  \r\n\r\n## 접근\r\n\r\n일단 이 문제는 DP문제로 2차원 배열을 DP로 사용해야 하는 조금 특이한 점을 가지고 있다.  \r\n\r\n규칙을 찾기 위해 값을 적어보고, 개수를 세보면 아래와 같다.  \r\n(N : 자리수, index : 맨 마지막에오는 숫자)  \r\n```\r\nindex   0 1 2 3 4 5 6 7 8 9\r\nN=1     0 1 1 1 1 1 1 1 1 1  \r\nN=2     1 1 2 2 2 2 2 2 2 1\r\nN=3     1 3 3 4 4 4 4 4 3 2\r\n\r\nex)\r\nN=2 -> (10), (21), (32, 12), (43,23), (54,34), (65,45), (76,56), (87,67), (98,78), (89)\r\n```\r\ndp[N][index] = dp[N-1][index-1] + dp[N-1][index+1]인 점화식을 얻을 수 있다.\r\n\r\n단, 여기서 중요한 점은 index가 0일 경우는 +1 한 값이 허용되고  \r\n9일 경우는 -1 한 경우만 적용되기 때문에 예외 처리를 해줘야 한다.  \r\n\r\n마지막으로 점화식을 정리해보면\r\n```\r\n1) index가 1일 경우\r\ndp[N][index] = dp[N-1][index+1]\r\n\r\n2) index가 1~8일 경우\r\ndp[N][index] = dp[N-1][index-1] + dp[N-1][index+1]\r\n\r\n3) index가 9일 경우\r\ndp[N][index] = dp[N-1][index-1]\r\n\r\n```\r\n\r\n3가지 경우에 따라 분기처리를 하면 된다.\r\n\r\n# Top-down 방식\r\n\r\n## 구현코드\r\n\r\n```java\r\npackage package14;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class num10844 {\r\n\tstatic Long[][] dp;\r\n\tstatic int N;\r\n\tfinal static long MOD = 1000000000;\r\n\t\r\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tN = Integer.parseInt(br.readLine());\r\n\t\tdp = new Long[N+1][10];\r\n\t\t// #1\r\n\t\tfor(int i = 0; i < 10; i++) {\r\n\t\t\tdp[1][i] = 1L;\r\n\t\t}\r\n\r\n\t\tlong result = 0;\r\n\t\t\r\n\t\tfor(int i = 1; i <= 9; i++) {\r\n\t\t\tresult += recur(N, i);\r\n\t\t}\r\n\t\tSystem.out.println(result % MOD);\r\n\t}\r\n\t\r\n\tstatic long recur(int digit, int val) {\t\t\r\n\t\t\r\n\t\tif(digit == 1) {\r\n\t\t\treturn dp[digit][val];\r\n\t\t}\r\n\t\t// #2\r\n\t\tif(dp[digit][val] == null) {\r\n\t\t\tif(val == 0) {\r\n\t\t\t\tdp[digit][val] = recur(digit - 1 ,1);\r\n\t\t\t}\r\n\t\t\telse if(val== 9) {\r\n\t\t\t\tdp[digit][val] = recur(digit - 1, 8);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tdp[digit][val] = recur(digit - 1, val - 1) + recur(digit - 1, val + 1);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn dp[digit][val] % MOD;\r\n\t}\r\n}\r\n\r\n\r\n```\r\n\r\n## 코드설명\r\n 1) N=1인 값들은 값을 초기값으로 값을 넣어준다.\r\n 2) 점화식과 동일하게 상황에 따라 맞는 값을 재귀로 호출한다.\r\n\r\n# Botton-up 방식\r\n\r\n## 구현 코드\r\n\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.InputStreamReader;\r\nimport java.io.IOException;\r\n \r\npublic class Main {\r\n\t\r\n\tfinal static long mod = 1000000000;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\t\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tint N = Integer.parseInt(br.readLine());\r\n\t\t\r\n\t\tlong[][] dp = new long[N + 1][10];\r\n\t\t\r\n\t\tfor(int i = 1; i < 10; i++) {\r\n\t\t\tdp[1][i] = 1; \r\n\t\t}\r\n\t\t\r\n\t\t// 두 번째 자릿수부터 N까지 탐색 \r\n\t\tfor(int i = 2; i <= N; i++) {\r\n\t\t\t\r\n\t\t\tfor(int j = 0; j < 10; j++) {\r\n\t\t\t\t\r\n\t\t\t\tif(j == 0) {\r\n\t\t\t\t\tdp[i][0] = dp[i - 1][1] % mod;\r\n\t\t\t\t}\r\n\t\t\t\telse if (j == 9) {\r\n\t\t\t\t\tdp[i][9] = dp[i - 1][8] % mod;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tdp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j + 1]) % mod;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tlong result = 0;\r\n\t\t\r\n\t\tfor(int i = 0; i < 10; i++) {\r\n\t\t\tresult += dp[N][i];\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(result % mod);\r\n\t}\r\n \r\n}\r\n```\r\n\r\n## 코드설명\r\n - Top-down방식과 동일한데 재귀 부분을 for문으로 두번째 자리부터 N까지 탐색한다.\r\n\r\n\r\n# \r\n<hr>\r\n\r\n아직 DP문제를 많이 풀어보지 않아서 그런지 점화식 만들어 내는 과정이 어렵다... ㅜㅜㅜㅜㅜ  \r\n익숙해질 때까지 열심히 풀어야겠다 (승질 그만내고 ㅎㅎ)","excerpt":"백준 DP 단계별 문제에 있는 10844번 문제이다.  접근이 조금 어려웠던 문제라 풀이를 정리해보려고 한다.   접근 일단 이 문제는 DP문제로 2차원 배열을 DP로 사용해야 하는 조금 특이한 점을 가지고 있다.   규칙을 찾기 위해 값을 적어보고…","fields":{"slug":"/algoPost3/"},"frontmatter":{"date":"Dec 04, 2020","title":"백준 10844 쉬운 계단수 풀이","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"알고리즘 문제를 풀면서 많이 하는 실수를 정리할 필요성을 느꼈다.  \r\n본 포스트는 주의해야 할 실수가 생길 때 마다 update할 예정이다.\r\n\r\n# 백트래킹\r\n > 재귀함수 빠져나오면 상태 값 원래대로 돌려줘야 함.","excerpt":"알고리즘 문제를 풀면서 많이 하는 실수를 정리할 필요성을 느꼈다. 본 포스트는 주의해야 할 실수가 생길 때 마다 update할 예정이다. 백트래킹 재귀함수 빠져나오면 상태 값 원래대로 돌려줘야 함.","fields":{"slug":"/algoMistake/"},"frontmatter":{"date":"Nov 25, 2020","title":"알고리즘 풀 때 많이하는 실수","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n# Comparable\r\n > 클래스의 기본 정렬 기준을 설정하는 인터페이스\r\n\r\n\r\n## 1) 특징\r\n - Comparable 인터페이스 상속 후, compareTo 메소드 오버라이딩\r\n - compareTo메소드 리턴 값은 음수, 0, 양수가 될 수 있다. 음수가 리턴되면 인자의 순서가 아래로 이동\r\n - 자바에서 제공되는 정렬이 가능한 클래스는 모두 Comparable 클래스로 구현되어 있음\r\n \r\n## 2) 구현 코드\r\n\r\n# Comparator\r\n > 기본 정렬과 다르게 정렬하고 싶을 때 이용하는 클래스\r\n## 1) 특징\r\n - 보통 구현 되어있는 sort함수의 2번째 인자로 Comparator 타입을 받아(익명함수) compare 메소드 오버라이딩을 통해 배열 정렬 순서 재정의\r\n - 보통 한번 사용하고 사용하지 않기 때문에 익명객체로 만듬\r\n\r\n## 2) 구현 코드\r\n\r\n# 관련 백준 문제\r\n - 11650, 11651, 1181, 10814","excerpt":"Comparable 클래스의 기본 정렬 기준을 설정하는 인터페이스 1) 특징 Comparable 인터페이스 상속 후, compareTo 메소드 오버라이딩 compareTo메소드 리턴 값은 음수, 0, 양수가 될 수 있다. 음수가 리턴되면 인자의 순서…","fields":{"slug":"/algoPost2/"},"frontmatter":{"date":"Nov 24, 2020","title":"JAVA Comparable, Comparator 사용","tags":["JAVA"],"update":"Dec 04, 2020"}}},{"node":{"rawMarkdownBody":"\n코딩 테스트 준비를 하면서 이전부터 자주 헷갈렸던 순열, 조합, 부분집합의 개념 정리와 JAVA를 사용해 구현하는 방법을 정리해 보려고 한다.  \n\n1) 대표적인 구현 방법  \n2) 각, 방법의 특징    \n\n두가지 사항으로 정리한다.  \n\n# 순열\n\n  - n개의 원소 중, r개를 일렬로 나열하는 수열  \n  - 중복 X / 순서 고려\n\n## 1. next_permutation\n\n### 1) 특징\n - 이게 이해하기 제일 어려웠다.... (나만 어렵나...ㅜㅜ)\n - 무작위 순열의 다음 순열을 구해내는 알고리즘\n - 시작 조건 : 오름차순 / 종료 조건 : 내림차순\n```\n  순서\n  1.Find largest index i such that array[i − 1] < array[i].\n  (If no such i exists, then this is already the last permutation.)\n\n  2.Find largest index j such that j ≥ i and array[j] > array[i − 1].\n\n  3.Swap array[j] and array[i − 1].\n\n  4.Reverse the suffix starting at array[i].\n```\n\n### 2) 구현 코드\n```java\npublic class num1 {\n    public static void main(String[] args) {\n    \tint[] list = new int[]{5,4,3};\n    \t// #1 시작 조건에 맞게 list 오름차순 정렬 (시작조건)\n    \tArrays.sort(list);\n    \tpermutation(list);\n    }\n    // #2 처음 list값 print 후, 다음 순열 찾음\n    public static void permutation(int[] list) {\n        int[] curArray = list;\n        while (true) {\n        \tprintArray(curArray);\n        \tcurArray = nextPermutation(curArray);\n            if (curArray == null) {\n                break;\n            }\n        }\n    }\n    \n    public static int[] nextPermutation(int[] list) {\n    \t  // #3 수열의 바로 앞 값 보다 큰 값 중 가장 큰 index 찾는다. \n        // (가장 적은 차이로 순서를 바꾸기 위해서 가장 큰 index를 찾음) \n        int i = list.length -1;\n        while(i>0 && list[i-1] >= list[i])\n        \ti--;\n        \n        // #6 list가 내림차순으로 정렬되어 있으면 순열을 끝까지 찾은 것 (종료조건)\n        if(i<=0)\n        \treturn null;\n        \n        int j = list.length -1;\n        // #4 다음 수열의 특징 : 이전 순열보다 값이 큼\n        // -> list[i-1] < list[j] 값을 찾고, 값을 바꿔준다.\n        while(list[j] <= list[i-1])\n        \tj--;\n        \n        int temp = list[i-1];\n        list[i - 1] = list[j];\n        list[j] = temp;\n        // #5 a[i] 이후 부분을 오름차순으로 셋팅 \n        j= list.length-1;\n        while (i < j) {\n            temp = list[i];\n            list[i] = list[j];\n            list[j] = temp;\n            i++;\n            j--;\n        }\n        \n        return list;\n    }\n    \n    public static void printArray(int[] array) {\n    \tfor(int i=0;i<array.length;i++)\n    \t\tSystem.out.print(array[i] + \" \");\n    \tSystem.out.println();\n    }\n    \n}\n\n```\n### 3) 코드 흐름\n\n1. 시작 조건에 맞게 list 오름차순 정렬 (시작조건)\n2. 처음 list값 print 후, 다음 순열 찾음\n3. 수열의 바로 앞 값 보다 큰 값 중 가장 큰 index 찾는다.  \n  (가장 적은 차이로 순서를 바꾸기 위해서 가장 큰 index를 찾음)\n4. 다음 수열의 특징 : 이전 순열보다 값이 큼 -> list[i-1] < list[j] 값을 찾고, 값을 바꿔준다.\n5. a[i] 이후 부분을 오름차순으로 셋팅 \n6. list가 내림차순으로 정렬되어 있으면 순열을 끝까지 찾은 것 (종료조건)\n\n### 4) 코드 출력값\n```\n3 4 5 \n3 5 4 \n4 3 5 \n4 5 3 \n5 3 4 \n5 4 3 \n\n```\n\n## 2. Swap\n\n### 1) 특징\n - 재귀함수, 백트래킹\n - 순열의 순서가 보장되지 않는다. (사전식 X)\n\n\n### 2) 구현 코드\n```java\npublic class Main {\n  public static void main(String[] args) {\n  \tint[] arr = {1,2,3};\n  \tpermutation(arr,0,3,3);\n  \tSystem.out.println(Arrays.toString(arr));\n  }\n\n  static void permutation(int[] arr, int depth, int n, int r) {\n  \tif (depth == r) {\n  \t\tarrPrint(arr,r);\n  \t\treturn;\n  \t}\n  \tfor (int i=depth; i<n; i++) {\n      // #1\n  \t\tswap(arr, depth, i);\n      // #2\n  \t\tpermutation(arr, depth + 1, n, r);\n      // #3\n     \tswap(arr, depth, i);\n  \t}\n  }\n\n  static void arrPrint(int[] arr, int r) {\n    for (int i=0 ; i<r; i++)\n    \tSystem.out.print(arr[i] + \" \");\n    System.out.println();\n  }\n\n  static void swap(int[] arr, int depth, int i) {\n    int temp = arr[depth];\n    arr[depth] = arr[i];\n    arr[i] = temp;\n  }\n}\n```\n### 3) 코드 흐름\n\n1. 배열의 첫번째 값부터 하나씩 바꾸면서 swap\n2. depth를 기준(Inex)으로 depth보다 작은 인데스 값들은 고정, depth보다 큰 값들을 가지고 swap\n3. 재귀함수가 종료조건에 의해 return되면 swap을 한번 더 해줘서 이전 상태 유지\n\n\n### 4) 코드 출력값\n```\n1 2 3 \n1 3 2 \n2 1 3 \n2 3 1 \n3 2 1 \n3 1 2 \n[1, 2, 3]\n```\n\n## 3. Visit Index 사용\n\n### 1) 특징\n - DFS, 재귀 함수\n\n\n### 2) 구현 코드\n\n```java\npublic class Main {\n\tpublic static void main(String[] args) {\n\t    int n = 3;\n\t    int[] arr = {1, 2, 3};\n      // #1\n\t    int[] output = new int[n];\n\t    boolean[] visited = new boolean[n];\n\t    perm(arr, output, visited, 0, n, 2);\n\t    System.out.println();\n\t}\n\n\tstatic void perm(int[] arr, int[] output, boolean[] visited, int depth, int n, int r) {\n\t    if (depth == r) {\n\t        print(output, r);\n\t        return;\n\t    }\n\n\t    for (int i = 0; i < n; i++) {\n\t        if (visited[i] != true) {\n\t            visited[i] = true;\n              output[depth] = arr[i];\n              // #2\n\t            perm(arr, output, visited, depth + 1, n, r);\n              // #3\n\t            visited[i] = false;\n\t        }\n\t    }\n\t}\n\n\tstatic void print(int[] arr, int r) {\n\t    for (int i = 0; i < r; i++)\n\t        System.out.print(arr[i] + \" \");\n\t    System.out.println();\n\t}\n\t\n}\n\n```\n### 3) 코드 흐름\n1. output : 코드 출력 값 / visited : 방문 여부 체크\n2. depth -> output 길이라고 생각\n3. 방문 여부 false로 체크 -> 모든 인덱스 방문\n   \n\n### 4) 코드 출력값 \n```\n1 2 \n1 3 \n2 1 \n2 3 \n3 1 \n3 2 \n```\n\n## 관련 백준 문제\n> n과m 시리즈 0 ~ 12\n\n# Reference\n[BaaaaaaaarkingDog님 블로그](https://blog.encrypted.gg/945?category=773649)  \n[뱀귤님 블로그](https://bcp0109.tistory.com/entry/%EC%88%9C%EC%97%B4-Permutation-Java?category=848939)  \n[junhok82님 블로그](https://velog.io/@junhok82/>Java%EB%A1%9C-%EC%88%9C%EC%97%B4Permutation-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0>)\n[Crocus님 블로그](https://www.crocus.co.kr/1240)","excerpt":"코딩 테스트 준비를 하면서 이전부터 자주 헷갈렸던 순열, 조합, 부분집합의 개념 정리와 JAVA를 사용해 구현하는 방법을 정리해 보려고 한다.   대표적인 구현 방법   각, 방법의 특징     두가지 사항으로 정리한다.   순열 n개의 원소 중, …","fields":{"slug":"/algoPost1/"},"frontmatter":{"date":"Nov 23, 2020","title":"순열 정리, 구현","tags":["Algorithm"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}},"staticQueryHashes":["2027115977","694178885"]}