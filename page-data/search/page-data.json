{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n# 17. AWS Lambda\n\n# 18. DynamoDB\n\n# 19. API Gateway\n\n# 20. SAM(Serverless Application Model)\n\n# 21. CDK(Cloud Deveopment Kit)\n\n# 22. Cognito\n\n# 23. Step Function & AppSync\n\n# 24. 고급 자격 증명\n\n# 25. aws 보안 및 암호화 kms, 암호화 SDK, SSM\n\n# 26. etc service\n\n# Reference\n","excerpt":"17. AWS Lambda 18. DynamoDB 19. API Gateway 20. SAM(Serverless Application Model) 21. CDK(Cloud Deveopment Kit) 22. Cognito 23. Step Functi…","fields":{"slug":"/AWSCertifiedDeveloper_3/"},"frontmatter":{"date":"Jul 28, 2023","title":"AWS CertifiedDeveloper - Associate 대비 정리 3","tags":["AWS"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# 7. VPC\n\nVPC : 리소스(지역 리소스)를 배포하기 위한 사설 네트워크\n\n- 서브넷 사용 시 VPC내에서 네트워크 분할 가능\n- 공용 서브넷 인터넷 접근 o, 사설 서브넷 인터넷 접근x\n\n# 8. S3\n\n> 무한 확장 스토리지\n\n## 8.1 Advanced\n\n## 8.2 Security\n\n# 9. AWS CLI, SDK, IAM 역할 및 정책\n\n# 10. CloudFront\n\n# 11. ECS, ECR, Rargate - AWS Docker\n\n# 12. AWS Elastic Beanstalk\n\n# 13. AWS CI/CD\n\n# 14. AWS CloudFormation\n\n# 15. AWS Cloud Watch & X-Ray\n\n# 16. SQS, SNS & Kinesis\n\n# Reference\n","excerpt":"7. VPC VPC : 리소스(지역 리소스)를 배포하기 위한 사설 네트워크 서브넷 사용 시 VPC내에서 네트워크 분할 가능 공용 서브넷 인터넷 접근 o, 사설 서브넷 인터넷 접근x 8. S3 무한 확장 스토리지 8.1 Advanced 8.2 Secu…","fields":{"slug":"/AWSCertifiedDeveloper_2/"},"frontmatter":{"date":"Jul 26, 2023","title":"AWS CertifiedDeveloper - Associate 대비 정리 2","tags":["AWS"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\nAWS를 통해 스케일 조정이 가능한 서비스 및 서버를 제공받는다.\n\n# 1. AWS 개요\n\n## 1.1 AWS의 구성요소\n\n- Regions, Availability Zone, Data Centers, Edge Locations / Points of Presence\n  (리전, 가용영역 범위, 데이터센터, 엣지로케이션 / 전송지점)\n\n리전(Region) : 데이터 센터 집합\n\n- 법률 준수 여부 - 법률 상 데이터가 대상 국가 내에 보관되길 원하는 경우\n- 지연시간 - 서비스를 하려는 국가 근처\n- 요금 - 서비스 요금\n- [리전 테이블](https://aws.amazon.com/ko/cloudfront/features/?whats-new-cloudfront.sort-by=item.additionalFields.postDateTime&whats-new-cloudfront.sort-order=desc)을 통해 리전에서 특정 서비스가 제공되는지 여부 확인 가능\n\n가용영역 (Availablility Zone) : 가용영역은 리전 내 존재 (2 ~ 6개, 보통 3개)\n\n- AZ를 표시할 땐 리전코드(국가코드 + 위치(숫자))와 식별문자(소문자) 조합하여 표현\n- 각각의 가용 영역은 여분의 전원 네트워킹, 통신기능을 갖춘 하나 또는 두개의 데이터 센터\n- 각각의 가용 영역들이 재난 발생에 대비해 서로 분리되어 있다.\n- 동일 리전 내 존재하는 복수의 AZ는 **서로 물리적으로 격리**되어 있지만, 좋은 품질의 네트워크 연결을 통해 논리적으로 연결되어 있다.\n- 서비스를 어느 AZ에 배포할 지는 인스턴스를 만들 때 AWS 사용자가 직접 선택할 수 있고, AWS가 사용자를 위해 선택 가능\n- AZ에 장애가 발생할 경우 `Elastic IP`를 사용해 다른 인스턴스에 신속하게 다시 매핑하여 인스턴스나 소프트웨어의 오류를 마스킹할 수 있다.\n\n전송 지점 : 42개국에 200개가 넘는 전송지점 소유 -> **최소 지연 시간**으로 사용자에게 컨텐츠를 전달하는데 유용\n\n---\n\n## 1.2 AWS 책임\n\nhttps://aws.amazon.com/ko/compliance/shared-responsibility-model/\n\nAWS Shared Responsibility Model에 따르면 다음 중 AWS의 책임\n\n---\n\n## 1.3 AWS Service Level\n\nAWS의 서비스들은 아래와 같이 3종류의 Level 을 가지고 있으며, 각 Level에 따라 해당 서비스에 접근할 수 있는 범위가 달라진다.\n\n- Global Service : ID 및 액세스 관리 (IAM), Route 53(DNS서비스), CloudFront(콘\n  텐츠 전송 네트워크), WAF(웹 애플리케이션 방화벽)\n- Regional Level : VPC, S3, AMI, DynamoDB 등\n- AZ Level : EC2, Subnet, EBS 등\n\n항목별로 간단히 설명하면\n\nGlobal Level은 Region이나 AZ에 상관없이 사용할 수 있다.\n\nObject Storage인 S3를 예로 들면, Regional Level이기 때문에 같은 Region에 있는 서비스(예를 들어 EC2)라면 AZ에 상관없이 S3에 자유롭게 접근할수 있다. 반면에 다른 Region에 있는 EC2라면 기본적인 방법으로는 접근할 수 없다.\n\nlock Storage서비스인 EBS는 AZ Level이기 때문에, 동일 AZ에 있는 서비스만 사용할 수 있다. 반면에 같은 Region이더라도 다른 AZ에 있는 EC2라면 해당 EBS를 사용할 수 없다\n\n화재나 지진 등 AZ단위의 장애발생시 EBS는 영향을 받기 때문에(S3는 영향을 받지 않는다) 장애가 복구되기 전까지는 저장되어 있는 데이터를 사용할 수 없다.\n\n만일 AZ에 문제가 생기더라도 유지되어야 하는 데이터라면, 주기적인 Snapshot을 만들던가 S3같은 Region 단위의 스토리지 서비스를 사용해야 한다.\n\n# 2. IAM\n\nIAM(Identity and Access Management) : 사용자 생성 및 그룹 배치\n\n- 루트 계정은 첫 번째 IAM 사용자와 몇 가지 계정/서비스 관리 작업을 생성할 때만 사용\n- 한사람이 여러개의 그룹을 가질 수 있다. (인라인 정책을 통해 개별 사용자에게 정책 설정 가능)\n- 그룹 별 정책 설정 가능\n- 사용자 권한 설정은 **JSON 문서**를 통해 작성 (editor를 콩해 추가가능)\n- **최소 권한의 원칙 적용**\n- 태그를 통해 사용자, 그룹, aws 내 리소스에 대한 정보추가 가능\n\n---\n\n계정 Tip!\n\n- Aws의 root account는 ID가 숫자형식인데, 계정에 별칭을 줘서 해당 별칭으로 로그인 가능\n- IAM 계정의 aws에 로그인하기 위해서는 `https:{별칭}.signin.aws.amazon.com/console`로 접속  \n   -> 로그인 페이지로 리다이렉트 해준다.\n\n그룹 Tip!\n\nIAM 사용자 그룹에는 IAM 사용자만 포함\n\n<!-- TODO:\n\nhttps://docs.aws.amazon.com/ko_kr/IAM/latest/UserGuide/id_groups.html\n이거 요약 -->\n\n---\n\n## 2.1 JSON 정책 문서 구조\n\n- 문서 상단에 위치하는 정책 전반의 선택적 정보\n- 하나 이상의 개별 문\n\n<!-- TODO: IAM 정책은 하나 이상의 문으로 구성됩니다. IAM 정책의 문은 다음을 제외하고 구성됩니다: -->\n\n<!-- TODO: 이거 좀 중요해보이는데 형식이랑 항목 사항들 좀 더 살펴보자\n[링크](https://docs.aws.amazon.com/ko_kr/IAM/latest/UserGuide/access_policies.html#access_policies-json) -->\n\n| Keyword                         | Description                                                                                                                                                                                                                 |\n| ------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Version                         | 사용하고자 하는 정책 언어의 버전을 지정                                                                                                                                                                                     |\n| ID                              | 정책 식별자                                                                                                                                                                                                                 |\n| Statement                       | 이 주요 정책 요소를 다음 요소의 컨테이너로 사용, 정책에 설명문 둘 이상을 포함 가능                                                                                                                                          |\n| Sid(선택 사항)                  | 선택 설명문 ID를 포함하여 설명문들을 구분                                                                                                                                                                                   |\n| Effect                          | Allow 또는 Deny를 사용하여 정책에서 액세스를 허용하는지 또는 거부하는지 여부를 설명                                                                                                                                         |\n| Principal(일부 상황에서만 필요) | 리소스 기반 정책을 생성하는 경우 액세스를 허용하거나 거부할 계정, 사용자, 역할 또는 페더레이션 사용자를 표시, 사용자 또는 역할에 연결할 IAM 권한 정책을 생성하면 이 요소를 포함 불가능. 보안 주체는 사용자 또는 역할을 의미 |\n| Action                          | 정책이 허용하거나 거부하는 작업 목록                                                                                                                                                                                        |\n| Resource(일부 상황에서만 필요)  | IAM 권한 정책을 생성하는 경우 작업이 적용되는 리소스 목록을 지정, 리소스 기반 정책을 생성하는 경우 이 요소는 선택 사항, 이 요소를 포함하지 않으면 작업이 적용되는 리소스는 정책이 연결된 리소스                             |\n\n```json\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Sid\": \"FirstStatement\",\n      \"Effect\": \"Allow\",\n      \"Action\": [\"iam:ChangePassword\"],\n      \"Resource\": \"*\"\n    },\n    {\n      \"Sid\": \"SecondStatement\",\n      \"Effect\": \"Allow\",\n      \"Action\": \"s3:ListAllMyBuckets\",\n      \"Resource\": \"*\"\n    },\n    {\n      \"Sid\": \"ThirdStatement\",\n      \"Effect\": \"Allow\",\n      \"Action\": [\"s3:List*\", \"s3:Get*\"],\n      \"Resource\": [\"arn:aws:s3:::confidential-data\", \"arn:aws:s3:::confidential-data/*\"],\n      \"Condition\": { \"Bool\": { \"aws:MultiFactorAuthPresent\": \"true\" } }\n    }\n  ]\n}\n```\n\n---\n\n## 2.2 IAM MFA (Multi Factor Authentication)\n\n- IAM은 기본적으로 패스워드를 각종 정책을 통해 설정이 가능하다\n- 추가로 각종 MFA 디바이스를 사용해 보안강화 가능\n\n---\n\nAWS는 3가지 방법을 통해 접근 가능\n\n- AWS Management Console : 비밀번호 + MFA\n- AWS Command Line Interface : 엑세스 키\n- AWS Software Developer Kit : 엑세스 키\n\n## 2.3 IAM Role & Security Tool\n\nAWS는 서비스에 대한 IAM 설정이 가능\n\n- ex) EC2, Lambda\n\n---\n\nAWS security tool은 2가지가 존재한다\n\n- IAM Credentials Report (account - level)\n  - 사용자의 자격증명 상태 표기한 보고서 생성 가능\n- IM Access Advisor (User-level)\n  - 해당 서비스의 권한과 마지막으로 엑세스 시간 확인 가능\n\n-> tool을 통해 권한 사용 여부를 파악해 **최소 권한의 원칙**을 지킬 수 있다.\n\n---\n\n정리해보면 AWS는 IAM기능을 통해 사용자를 추가할 수 있고 사용자에 대한 권한 부여는 **정책**을 통해 관리한다.\n\nAWS 서비스가 다른 AWS 서비스에 대해 작업을 실행하도록 권한을 부여하려면 **IAM Role**을 부여 해 권한 설정 가능\n\n# 3. EC2 (Elastic Compute Cloud)\n\n## 3.1 EC2 Basic\n\nEC2란 Amazon Elastic Compute Cloud의 줄임말로서 AWS에서 제공하는 클라우드 컴퓨팅으로 **컴퓨터를 임대해주는 서비스**로 대표적인 상품이다\n\nEC2는 단순히 하나의 서비스가 아니라 여러 기능을 포괄하는 개념으로 기능에 따라 분류해보면\n\n- EC2 Instance : 가상 머신 임대\n- Network-attached storage : EBS, EFS\n- Hardware storage : EC2 Instance Store\n\nEC2 인스턴스는 네트워크 카드와 IP설정이 가능하고 방화벽 규칙을 적용해 보안 기능을 적용할 수 있다.\n\n부트스트랩 스크립트를 이용해 인스턴스를 **처음 시작할 때** 업데이트나 소프트 웨어 설치같은 작업을 자동화 할 수 있다.(root 권한으로 이루어짐 / 사용자 데이터)\n\n인스턴스의 이름은 다음과 같은 네이밍 컨벤션이 있다.\n\nt2.micro\n\nt : 인스턴스 클래스  \n2 : 버전  \nmicro : 인스턴스 클래스 내 크기\n\n인스턴스의 몇가지 종류에 대해 살펴보면\n\nt : 범용 인스턴스 -> 웹서버, 코트 레포지토리  \nc : 컴퓨팅 최적화 인스턴스(고성능 프로세서 활용) -> batch, 고성능 웹서버  \nm : 메모리 최적화 -> DB, 웹 캐시 저장  \nl, D : 스토리지 최적화 -> 로컬 스토리지의 대규모 데이터 세트에 대한 높은 읽기, 쓰기 엑세스 권한이 필요한 경우 (고성능 DB)\n\n[AWS 인스턴스 종류](https://aws.amazon.com/ko/ec2/instance-types/)\n\n---\n\n### 3.1.1 EC2 Security\n\nEC2는 Security Group(보안그룹)을 trapic(InBound, Outbound) 허용 규칙을 설정할 수 있다. (허용 규칙만 사용)\n\n인스턴스는 여러 보안 그룹을 가질 수 있고, 기본적으로 모든 인바운드 트래픽은 기본적으로 차단되고, 아웃바운드 트래픽은 승인된다.\n\n하나의 인스턴스는 여러 보안그룹을 가질 수 있는데 Region, VPC에 따라 적용 된다.  \n따라서 Region이나 VPC가 변경되는 경우 새로운 보안 그룹을 적용한다\n\n-> **SSH 전용으로 별도의 보안 그룹을 관리**하는 방법이 좋다.\n\n---\n\n### 3.1.2 EC2 Purchasing\n\n| type                   | description                                                                                                                                                                                                                                 |\n| ---------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| On-Semand Instances    | 기본 옵션, 장기 약정이나 선 결제 금액 없이 초단위로 사용한 인스턴스에 대한 요금 지불                                                                                                                                                        |\n| Saving Plans           | 1년 or 3년 기간 동안 시간당 USD로 특정 사용량을 약정해 비용 절감 (약 72%)                                                                                                                                                                   |\n| Reserved Instance(RI)  | 1년 or 3년 기간 동안 인스턴스 유형 또는 지역을 포함해 인스턴스 구성을 예약하고 비용 절감, Convertible Reserved Instance로 설정 시 인스턴스 타입 변경 가능                                                                                   |\n| Spot Instance          | 가장 할인률이 큰데, 짧은 단기 워크로드용 인스턴스로 스팟 가격보다 사용자가 제시한 최고 가격이 더 높을 때만 실행된다 (**중단 되어도 되는 App에 적합, DB X**)                                                                                 |\n| EC2 Dedicated Hosts    | 실제 물리서버 예약, 보안 규정 상 호스트를 타 고객과 공유할 수 없는 수준의 컴플라이언스(compliance)를 지켜야 하는 경우 혹은 기존에 온-프로그레미스 환경에서 보유한 고정 서버 방식의 소프트웨어 라이선스를 재사용하여 비용을 아껴야 하는 경우 |\n| EC2 Dedicated Instance | 인스턴스를 구동하게 되면 그 인스턴스가 할당된 물리적 서버는 같은 AWS 계정(account)의 인스턴스만 할당되어 사용하는 옵션                                                                                                                      |\n\n## 3.2 EC2 Instance Storage\n\n> 물리적 서버에 연결된 하드웨어 드라이브를 `EC2 Instance`라 한다.\n\n주의 할 점으로 EC2 인스턴스를 종료시키면 해당 스토리지 또한 손실된다.\n\n즉, 버퍼나 캐시, 임시콘텐츠를 잠시 저장하는 용도 (최고 I/O성능 제공)\n\n### 3.2.1 AMI(Amaozn Machine Image)\n\n> 소프트웨어 구성이 기재된 템플릿\n\nAMI를 토대로 원하는 **운영체제, 런타임, RAM, 용량, CPU**등이 세팅된 EC2 생성 가능\n\nAMI는 AZ마다 구축이 되며, 다른 AZ에서 사용할 경우 복사한 다음 사용해야 한다.\n\n### 3.2.2 EBS(Elastic Block Store)\n\nEBS : 인스턴스가 실행 중인 동안 연결 가능한 네트워크 드라이브\n\n- 인스턴스가 종료 된 후에도 데이터 유지가능\n- CCP level - 1개의 인스턴스에 하나의 ebs 마운트, Associate level 1개의 인스턴스에 다수의 ebs마운트 가능\n- 특정 Availability zone에 연결 가능\n  - ex) us-east-1a에서 생성된 경우 us-east-1b 연결 불가\n  - snapshot기능 활용 시 볼륨 옮기기는 가능\n- EC2 인스턴스를 통해 EBS Volume을 생성하는 경우 종료 시 삭제 옵션이 default(비활성화 가능)\n  - ex) 인스턴스 시작 후 root 볼륨, EBS볼륨 2가지가 있을 때 인스턴스 삭제하면 root볼륨은 삭제되고, EBS볼륨은 삭제되지 않는다.\n\nEBS는 다양한 볼룸을 가지고 있는데 총 6개의 유형이 있다.\n\n중요한 내용으로는 gp2와 프로비저닝을 마친 IOPS가 있는데 각각 살펴보자\n\n여기서 나오는 IOPS는 (Input/output Operations Per Second)로 저장장치의 속도를 나타낸다.\n\n- gp2는 범용 ssd로 대부분의 워크로드에 이 볼륨을 사용하는 것이 좋다.\n  - 디스크 크기가 증가하면 IO증가 (5334GB / 16000IOPS IOPS최대 더이상 늘리지 못함)\n- 프로비저닝 된 IOPS SSE(io1, io2)는 높은 스토리지 성능과 일관성이 필요한 부분에 사용한다. (64000IOPS)\n  - 독립적으로 IO증가 가능\n- st1(HDD)은 자주 엑세스 하고 처리량이 많은 빅데이터나 로그 처리에 적합\n- sc1은 접근 빈도가 낮은 데이터에 적합 (백업)\n- 부팅 볼륨으로는 gp2, gp3, io1, io2 (ssd)만 가능\n\n추가로 **다중 첨부 기능**을 사용하면 동일한 EBS볼륨을 동일한 AZ(가용영역)에 있는 EC2 인스턴스에 첨부 가능  \n -> io1, io2 제품군에서만 사용이 가능하고 하나의 볼륨은 한번에 **최대16개**의 EC2 인스턴스에 부착 가능\n\n#### EBS SnapShot\n\n> EBS Snapshot : 특정 시점에 백업 된 EBS 볼륨\n\nAZ에서 EBS 볼륨을 마이그래이션 하려면 Snapshot기능 활용  \n **-> 기능 사용 시 볼륨 내 IO를 전부 사용하니 인스턴스가 EBS를 사용중이 아닐 때만 실행해야 한다.**\n\n- EBS Snapshot archive : 75% 저렴하고 복구 시 24시간에서 72시간 소요\n- EBS Recycle Bin : 스냅샷 삭제 시 보관, 1일 ~ 1년 설정 가능\n- FSR(Fast Snapshot Restore) : 스냅샷 완전 초기화 (가격이 비싸다)\n\n### 3.2.3 EFS(Elastic File System)\n\n> 관리형 NFS(Network File System)\n\n- 많은 EC2 인스턴스에 마운트 가능 (16개 까지)\n- 서로 다른 AZ(가용영역)에 있는 EC2도 가능\n- 가용성이 높고, 확장성이 뛰어나면 비용도 gp2 EBS볼륨의 3배 (사용량에 따라 부과, 자동 확장)\n- Linux기반 AMI와만 호환가능\n- KMS를 사용하여 미사용 데이터 암호화 가능\n- 필요에 따라 I/O를 높은 모드로 사용 가능(default 범용)\n\nEFS는 스토리지 클래스라는 기능이 있는데 자주 엑세스 하지 데이터는 **EFS-IA**에 저장 가능\n\n- 사용 시 생명주기 정책을 설정해야 한다.\n- 비용 절감 가능(90%) 단, 검색 시 비용 발생\n\n# 4. ELB(Elastic Load Balanceer) + ASG(Auto Scaling Group)\n\n확장 종류\n\n- 수직적 확장 : 인스턴스 크기 확장 (RDS, Elastic Cache, EC2)\n- 수평적 확장 : 인스턴스 수 확장 (EC2 추가)\n- 고가용성 : 수평 확장과 함께 실행 (RDS 다중 AZ, 여러 AZ에서 동일 APP실행)\n\n## 4.1 ELB\n\n> 여러 서버에 트래픽을 전달해 부하 분산\n\n- 로드 분산\n- 단일 엑세스 지점(DNS) 노출\n- 인스턴스 상태 확인 (ELB Health Checks : 비정상 인스턴스로 트래픽 전송x)\n- 웹사이트에 SSL 제공\n- App에서 사용할 수 있는 static DNS이름 제공\n- ALB의 경우 동일한 클라이언트에 대한 트래픽이 동일한 인스턴스로 리다이렉트 할 수 있는 기능을 제공하는데 **ELB Sticky Session**이라 한다\n  - Application 기반 쿠키는 AWSALBAPP라는 이름을 가지고, 로드밸런서에서 생성되는 기간 기반 쿠키는 AWSALB라는 이름을 가짐\n\n종류\n\n- CLN (Class Load Balancer) : HTTP, HTTPS, TCP\n  - app개수만큼 로드 밸런서 필요\n- ALB (Application Load Balancer) : HTTP, HTTPS, WebSocket\n  - 자신의 이름에 해당하는 `리스너 ID`, 사용자 요청을 건네줄 판단 기준이 되는 `규칙` 보유\n  - 경로 기반 라우팅\n  - 쿼리 문자열과 헤더 기반 라우팅\n  - 호스트 이름 기반 라우팅\n  - MSA기반, Container기반 App에 가장 좋은 로드 밸런서 (포트 매핑 기능 존재)\n  - X-Forwarded-For헤더로 사용자 IP전달해 사용자 구별\n- NLB (Network Load Balancer) : HTTP, HTTPS,TLS, UDP\n  - **AZ당 하나의 정적 IP**를 가지며 탄력적 IP할당\n  - AWS프리티어에는 포함되지 않고 높은 성능이 필요할 때 사용\n- GWLB (Gateway Load Balancer) : 레이어 3(네트워크 계층)에서 작동 (IP프로토콜)\n  - 네트워크의 모든 트래픽이 방화벽을 통과하게 하거나 침입 탐지 및 방지 시스템에 사용\n  - 6081포트를 사용하고 GENEVE 프로토콜\n\n## 4.2 Cross-Zon Load Balancing\n\n> 교차 영역 로드밸런싱을 사용할 경우 모든 AZ의 등록된 인스턴스에 고르게 분산된다.\n\n- ALB : 기본적으로 활성화, AZ간 데이터에 대한 요금 x\n- NLB : 기본적으로 비활성화, 활성할 경우 AZ간 데이터에 대한 요금 지불\n\n## 4.3 SSL / SNI\n\n> SSL사용 시 암호화 통신 가능\n\nSNI : 하나의 웹 서버에 여러 SSL을 로드해 여러 웹사이트 지원\n\n최신 프로토콜이며 클라이언트가 초기 SSl 핸드셰이크에서 대상 서버의 호스트 이름 나타내도록 요구 (ALB, NLB, CloudFront에서 작동)\n\n## 4.4 Connection Draining(등록 취소 지연)\n\n> 인스턴스가 등록 취소, 비정상인 상태에 있을 때 어느정도 시간을 주어 활성 요청을 완료할 수 있게 설정하는 기능\n\n- 취소중인 인스턴스로 새요청 전송 중지 시간 1~3600 (기본 300)\n\n## 4.5 Auto Scaling 그룹\n\n> 트래픽에 따라 ec2 추가 및 제거\n\n- 기능은 무료, EC2 인스턴스와 같은 리소스 비용만 추가\n- 스케일링 정책 정의 필요 (최소 크기, 최대 크기, 초기 용량)\n- CloudWatch를 통해 경보 가능\n- 정책 설정 시 참고 지표 : CPU사용률, RequestCountPerTarge률(인스턴스 당 요청 수) 등\n\n---\n\n정책\n\n- Target Tracking Scaling (대상 추적 스케일링) : 기준선 설정 (ex - CPU)\n- Simple / Step (단순, 단계) 스케일링 : 몇가지 조건에 따라 설정\n- Scheduled Actions(예약된 작업) : 사용 패턴을 바탕으로 스케일링\n- Predictive Scaling(예측 기반) : 시간에 걸쳐 과거 로드를 분석하고 예측된 정보를 바탕으로 스케일링\n- Scaling Cooldown : 스케일링 작업이 끝날 때 마다 안정화 시간을 가짐, 새로운 지표의 양상을 사펴보기 위함\n  - 요청을 빨리 처리하고 cooldown 시간을 줄이기 위해선 즉시 사용 가능한 AMI사용\n\n---\n\n**Instance Refresh**\n\n- 모든 EC2 인스턴스 재 생성\n- 구성 변경에 따라 인스턴스 교체 할 때, Auto Scaling 그룹에 포함된 인스턴스 수가 많을 때 사용\n- AMI에 새로운 데이터 스크립트가 있는 경우 유용\n\n# 5. RDS + Aurora + ElastiCache\n\n- Postgres, MySQL, Oracle, MSSQL, Aurora\n- 백업 및 복원 지원\n- 모니터링 대시보드\n- DR(재해 복구)를 위한 다중 AZ지원\n- 스토리지를 동적으로 늘릴 수 있도록 지원\n\n**DB 복제**\n\n- DB Replica : 최대 15개의 읽기 전용 인스턴스 지원 (약간의 시간차가 있어 데이터가 일치하지 않을 수 있음)\n  - 같은 지역 / 다른 AZ 무료 , 다른 지역 일 경우 유료\n- Multi-AZ 복제(재해 복구) : 가용성 향상 (데이터 항상 일치, 복제 된 예비 인스턴스에서 읽기작업 불가)\n  - 재해 복구를 대비해 읽기 전용 복제본도 다중 AZ로 설정 가능\n- Single-AZ to Multi AZ : 다운 타임이 전혀 없고, DB 수정 클릭 후 다중 AZ기능 활성화\n  - 내부적으로 1) 스냅샷 생성 2) 새 AZ에 DB 생성 3) 동기화 설정\n\n---\n\n**AuroraDB**\n\n> AWS 최적화 RDS\n\n- 복제 프로세스가 MySQL보다 빠르다.\n- 비용이 20% 높지만 효율적\n- 백업 없이 언제든지 데이터 복원 가능\n\nAurora Cluster 엔드 포인트 유형\n\n- 클러스터 엔드 포인트 : writer에서 쓰는 엔드포인트, Failover가 발생해서 reader가 writer가 되면 자동 연결\n- 리더 엔드 포인트 : reader에서 쓰이는 엔드 포인트\n  - DNS 기반의 Round Robin방식으로 로드밸런싱 기능 제공\n  - reader 사용 불가 혹은 삭제같은 갑작스러운 outage 발생 시 다른 reader 사용하도록 유도\n- 커스텀 엔드 포인트 : writer, reader 바라볼 지 선택 가능\n- 인스턴스 엔드 포인트 : 인스턴스 자체 고유 엔드포인트\n\nAurora Cluster의 엔드포인트는 단순히 인스턴스를 바라보게 하는 수준에 그치지 않고\n\nload balancing 등 여러 기능을 포함하고 있다.\n\nAWS서비스를 사용한다면 ip 주소나 host이름을 사용하는 온프레미스와는 다르게 가능한 엔드포인트를 사용하여 RDS 및 Aurora Cluster를 사용하도록 권장한다\n\n---\n\n## 5.2 RDS 보안\n\n암호화\n\n- KMS를 사용해 마스터와 복제본 암호화\n- 마스터 DB가 암호화 되지 않은 DB는 암호화된 읽기전용 복제본 생성 불가\n- IAM을 사용하여 DB접근 가능\n- DB에 ssl 강제 적용 시 모든 DB사용자에게 `REQUIRE SSL SQL`문 실행\n\n## 5.3 RDS Proxy\n\n- Proxy를 사용하면 APP이 데이터 베이스로 설정된 연결을 풀링하고 공유 가능\n- DB 리소스 부하를 줄이고 커넥션을 최소화 하여 효율성 향상\n- DB에 대한 IAM 인증을 시행하고 자격 증명을 AWS Secrets Manager에 안전하게저장\n- RDS Proxy는 공개적으로 액세스 할 수 없고, VPC에서 엑세스 해야 함\n\n## 5.4 Elastic Cache\n\n- Elastic cache가 Redis또는 Memcached가져 오는 것\n\nex) DB캐시, 사용자 세션 저장\n\n- 읽기 전용 복제본 최대 5개\n\n**캐시 전략**\n\n- write Through : 데이터가 DB에 기록될 때 마다 데이터를 추가 or 업데이트, 쓰기가 길지만 읽기가 빠르고, 데이터가 항상 캐시에 업데이트\n- Lazy Loading : 필요할 때만 캐시에 데이터 로드\n\nRedis용 Amazon MemoryDB -> 초고속 성능, 다중 AZ 트랜잭션 로그를 사용한 내구성 있는 인메모리 데이터 스토리지\n\n**캐시 제거 및 TTL**\n\n3가지 전략 사용\n\n- 명시적 삭제\n- 캐시 메모리가 가득 차있거나 사용 하지 않을 때 (LRU)\n- 항목 당 사용 가능 시간 설정 (TTL)\n\n# 6. Route 53\n\nRoute 53을 통해 DNS 등록 가능\n\n- 사용자가 DNS레코드를 업데이트 할 수 있음\n- A, AAA, CNAME, NS(필수)\n- CAA, DS, MX, NAPTR 등 제공\n- A : 호스트 이름 (IPv4)\n- AAAA : 호스트 이름 (IPv6)\n- CNAME : 또 다른 도메인 주소로 매핑시키는 형태의 DNS 레코드 타입\n- NS : DNS 서버가 참조하는 다른 DNS 서버\n- TTL : 클라이언트가 레코드를 캐시에 저장하는 시간\n\nCNAME vs ALIAS\n\nCNAME : 호스트 이름이 다른 호스트 이름으로 라우팅 가능\nALIAS : 호스트 이름이 특정 AWS 리소스(로드 밸런서, cloud front) 로 라우팅 가능\n\n- 별칭 레코드는 루트 및 비루트 도메인에 모두 작동 (CNAME은 루트 도메인 이름이 아닌 경우에만 가능)\n\n- ALIAS사용 시 TTL설정 불가능 (Route 53이 자동 설정)\n- ELB, CloudFront, API Gateway, Elastic Beanstalk, S3, VPC, Route 53 Record(Same Hosted Zone)\n- **EC2의 DNS 이름에 대해서는 별칭 레코드 불가능**\n\n**호스팅 영역**\n\n퍼블릭 호스팅 영역 : 인터넷에서 트래픽을 라우팅 하는 방법 지정\n\n프라이블 호스팅 영역 : 하나 이상의 VPC내에서 트래픽을 라우팅 하는 방법 지정\n\n영역당 매월 0.5USD\n\n## 6.1 Route 정책\n\n1. 단순\n\n   - 일반적으로 트래픽을 단일 리소스로 보내는 방식\n\n2. 가중치\n\n   - 레코드에 상대적 가중치 할당  \n     ex) 지역간 로드 밸런싱, 새로운 app버전 테스트\n\n3. 지연시간 (Latency)\n\n   - 대기시간이 가장 짧은 곳으로 연결\n\n4. 장애 조치 (Failover)\n\n   - 기본 EC2인스턴스와 보조 EC2인스턴스를 두고 기본 인스턴스가 장애 발생 시 보조 인스턴스로 전송\n\n5. Trffic flow (트래픽 플로우 및 지리적 근접성)\n\n   - 사용자 위치 기반으로 라우팅\n   - 기본 레코드 필수 (위치에 해당하는 항목이 없는 경우)\n\n6. IP\n\n   - 사용자 IP기반으로 라우팅\n\n7. 다중 값\n\n   - 트래픽을 여러 리소스로 라우팅 할 때 사용\n\nRoute 53을 DNS 서비스 공급자로 사용 시 **퍼블릭 호스팅 영역 생성 및 타사 레지스트리 NS레코드 업데이트**\n\n---\n\nTip!!\n\n요금 관련 설정\n\n- builing - bills 페이지에서 확인 가능\n- 프리티어 사용 시 builing - freetier 페이지에서 사용량 확인 가능\n- Cost Management - Budgets 에서 설정한 사용량 초과 시 메일 알림 기능\n\n# Reference\n\n![AWS JSON 정책 문서 구조](https://docs.aws.amazon.com/ko_kr/IAM/latest/UserGuide/access_policies.html#access_policies-json)\n","excerpt":"AWS를 통해 스케일 조정이 가능한 서비스 및 서버를 제공받는다. 1. AWS 개요 1.1 AWS의 구성요소 Regions, Availability Zone, Data Centers, Edge Locations / Points of Presence\n…","fields":{"slug":"/AWSCertifiedDeveloper_1/"},"frontmatter":{"date":"Jul 24, 2023","title":"AWS CertifiedDeveloper - Associate 대비 정리 1","tags":["AWS"],"update":"Jul 25, 2023"}}},{"node":{"rawMarkdownBody":"\n# 0. 시작하기 전에\n\n기존에 [Junhobaik님의 블로그 테마](https://github.com/junhobaik/junhobaik.github.io)를 사용하며 블로그를 운영하고 있었는데 기능이나 UI를 변경하고 싶은 부분이 있어 작업하는데 생각보다 어려움이 많아 미루고 있었다.\n\n사이드 프로젝트를 하나 구상중인데 블로그 만들면서 리액트 리마인드 하는게 어떤가 하는 생각이 들었고, 미루고 미루던 블로그 제작을 시작한다ㅋ\n\n작업 과정을 3개의 글로 정리할 예정이다.\n\n1. Gatsby 프레임워크와 GraphQL\n\n2. 프로젝트의 전체적인 구성과 페이지 작업\n\n3. Gatsby Plougin 추가 및 기능 구현\n\n그럼 빠르게 달려보자 🏃🏻\n\n---\n\n# 1. What is Gatsby?\n\n본격적인 시작에 앞서 블로그 제작을 하는데 사용하는 Gatsby프레임 워크에 대해 알아보자\n\nGatsby는 React를 사용하는 JAM Stack 기반 프레임 워크다.\n\n## 1.1 Headless CMS 🤔\n\n## 1.1 Let's Start Understanding JAM Stack\n\nJAM Stack의 공식 문서에 나온 정의는 다음과 같다.\n\n> Jamstack은 데이터 및 비즈니스 로직에서 웹 경험 계층을 분리하여 유연성, 확장성, 성능 및 유지관리성을 향상시키는 아키텍처 접근 방식\n\n`JAM Stack`은 **Javascript, API, MarkUp Stack의 약자**로, Javascript와 API Html이나 css등을 칭하는 MarkUp으로 이루어진 웹 구성 방법이다.\n\n![](JamStackArchitecture.png)\n\n위 그림에서 보듯이 웹 사이트는 대부분 서버의 데이터를 통해서 웹페이지를 사용자에게 노출한다.\n\n그렇기 때문에 **화면 렌더링 + API통신**단계를 가지게 되고, 페이지 로딩에 시간이 걸리게 된다.\n\n이 과정을 조금 자세히 이해하기 위해선 SSR, CSR, SPA란 단어가 등장하는데 간략히 한줄 요약 해보면\n\n| keyword              | description                                                                                                                                        |\n| -------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |\n| SSR                  | 서버측에서 렌더링 과정이 일어난다.                                                                                                                 |\n| CSR                  | 클라이언트 측에서 렌더링 과정이 일어난다.                                                                                                          |\n| Traditional web site | 서버에 요청하면 SSR을 통해 HTML을 만들어 제공                                                                                                      |\n| SPA                  | 처음 요청받은 페이지만 SSR을 통해 만들어 제공하고 이후 과정은 사용자의 동작에 따라 사용자단에서 처리 -> push state로 history를 바꿔주면서 page변경 |\n\n반면에 JAMStack은 [디커플링](https://jamstack.org/glossary/decoupling/) 및 [사전 렌더링 원칙](https://jamstack.org/glossary/pre-render/)을 기반으로 아키텍처가 구성이 되어 있는데\n\n**SSG(Static Site Generator)나 Template Engine(Webpack 등)을 이용해 각종 마크업 요소, API를 통해 생성된 정적 웹 사이트를 생성(build)하고, 서버는 정적인 페이지만을 제공**  \n-> 클라이언트 별 동적 기능은 설정된 [마이크로서비스](https://jamstack.org/glossary/microservice/)(API)를 통해 처리\n\n**즉, 사용자에게 화면을 보여주기 위한 시간이 단축된다.**\n\n---\n\n좀 더 구체적으로 JamStack의 장점을 정리하면\n\n1. 높은 성능\n\n- 페이지의 빌드시간 최소화\n- 브라우저에서 첫 응답을 받기까지 걸리는 TTFB(Time to First Byte)를 최소화하는데 미리 빌드된 파일을 CDN을 통해 제공하는 방법이 Best\n\n2. 높은 보안성\n\n- 서버 측 프로세스가 Microservice API로 추상화 되며 공격 영역이 줄어듬\n\n3. 적은 비용의 확장성\n\n- CDN을 통해 쉽게 확장 가능\n\n---\n\nGatsby의 장점을 3가지로 요약하면 다음과 같다.\n\n1. React기반 SSG (Static Site Generator)\n\n2. 다양한 Plugin System\n\n3. Graphql 사용해 간편한 Data 관리\n\n---\n\n<!-- ## 1.2 Graphql -->\n\n<!-- TODO: 기본 문법 정리-->\n<!--TODO: https://www.inflearn.com/course/lecture?courseSlug=gatsby-%EA%B8%B0%EC%88%A0%EB%B8%94%EB%A1%9C%EA%B7%B8&unitId=76333&tab=curriculum-->\n\n---\n\nGatsby를 제대로 사용하기 위한 사전 지식은 여기까지 정리하고\n\n다음편에선 Gatsby의 폴더 구조를 파악하고 페이지 작업을 해보자 💪🏻\n\n# Reference\n\n[Jamstack Document](https://jamstack.org/)\n[Jamstack vs Conventional Web Architecture - Which One is Right for you? - dev.to](https://dev.to/ionos/jamstack-vs-conventional-web-architecture-which-one-is-right-for-you-38la)\n","excerpt":"0. 시작하기 전에 기존에 Junhobaik님의 블로그 테마를 사용하며 블로그를 운영하고 있었는데 기능이나 UI를 변경하고 싶은 부분이 있어 작업하는데 생각보다 어려움이 많아 미루고 있었다. 사이드 프로젝트를 하나 구상중인데 블로그 만들면서 리액트 …","fields":{"slug":"/gatsbyBlog_1/"},"frontmatter":{"date":"Jul 17, 2023","title":"Gatsby Blog Theme 제작기 1 (Gatsby & GraphQL)","tags":["gatsby"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n여러 기업들은 자사에서 데이터센터나 기계실을 보유하여 온프레미스 환경에서 가동시키던 부분을\n\n효율적인 자원 활용을 위해 클라우드 상의 가상 인스턴스로 옮기고 시스템을 구축한다\n\n또한 확장성을 고려해 MSA(Micro Service Architecture) 아키텍처를 적용하며\n\n여러개의 나뉘어진 App을 하나의 Application 처럼 동작할 수 있게 시스템을 구축한다.\n\n이와같은 분산환경을 적용하면 아래와 같은 장점이 있다.\n\n1. 개별 서비스가 다른 서비스에 영향을 주지 않으면서 작동 (높은 가용성)\n\n2. 향후 확장 및 새로운 기능 추가 용이 (높은 확장성)\n\n3. 개발자들이 각각의 서비스를 파악하고 개선하기에 용이해짐 (편리한 엑세스)\n\n4. 기존 모놀로식 방법에 비해 배포에 따른 우려사항들이 적어짐\n\n기존 [VM (Virtual Machine)](https://www.redhat.com/en/topics/virtualization/what-is-a-virtual-machine)으로도 MSA환경을 구축할 수 있지만\n\n컴퓨터를 가상화하는 기술이 발전하고 점점 가벼워지면서 컨테니어 기술은 더욱더 인기가 많아지고 있다.\n\nVM은 [하이퍼바이저](https://www.redhat.com/ko/topics/virtualization/what-is-a-hypervisor)를 사용해 각 머신별로 독립적인 하드웨어 자원을 제공하고\n\n그 자원위에 별도의 OS를 띄운다.\n\n반면에 컨테이너의 경우 리눅스 OS내부에서 커널을 이용하여 리소스를 컨테이너 별로 나눠서 격리시키기\n\n때문에 별도의 OS없이 구동이 된다.\n\n그럼 효율적인 인프라 구성을 위해 컨테이너의 대표 기술인 도커에 대해 알아보자\n\n# Container\n\n> 소프트웨어 서비스를 실행하는 데 필요한 1. 특정 버전의 프로그래밍 언어 런타임 및 2. 라이브러리와 같은 종속 항목과 3. 애플리케이션 코드를 함께 포함하는 `경량 패키지`\n\n- 이미지를 기반으로 하는 격리된 소프트웨어 유닛, 이미지를 실행중인 인스턴스\n- 중요한 특징으로 컨테이너는 서로 분리되어 있으며, 디폴트로 공유 데이터나 상태가 없다.\n\n![](VMvsDocker.png)\n\nContainer와 VM을 비교해보면 다음과 같은 특성이 있다.\n\n- 컨테이너는 VM보다 경량화 되어있다.\n- 컨테이너는 OS수준에서 가상화 되고, VM은 하드웨어 수준에서 가상화 된다.  \n  -> 메모리, CPU 등 효율적인 자원 사용\n- `Linux커널과 Cgroups 및 네임스페이스 등 커널의 기능`을 사용해 프로세스를  \n  분리함으로써 **독립적으로 실행**할 수 있다.\n- 컨테이너는 OS커널을 공유하며 VM에 필요한 것보다 적은 메모리 사용\n- 컨테이너는 무상태 (Volume에 할당되어 있으면 로컬 호스트 머신의 폴더로 미러링 하거나 복사 가능)\n\n이러한 컨테이너의 장점 때문에 Linux Container기술이 발전 했지만\n\nLinux Container 컨테이너 기술은 사용하기 어렵고 대중화하기에는 한계가 있었다.\n\n이러한 기술을 도입하기 편리하게 개발된 기술이 **`Docker`**이다.\n\n# LXC vs Docker\n\n![](LXCvsDocker.png)\n\nLinux Container(LXC)는 단일 컨트롤 호스트 상에서 여러개의 고립된 리눅스 시스템 (컨테이너)들을 실행하기 위한 OS 레벨 가상화 기술이다.\n\nDocker는 단일 애플리케이션을 실행하는데 중점을 둔 컨테이너 기술이다.\n\n즉, 세분화된 접근 방식에 차이가 있는데\n\nLXC는 전체 애플리케이션을 하나로 실행하는 반면에\n\nDocker는 애플리케이션을 개별 프로세스로 세분화하고 이를 위한 툴을 제공한다.\n\n추가로 더 자세히 정리된 링크 남긴다.\n\n[Linex컨테이너란? - Red Hat](https://www.redhat.com/ko/topics/containers/whats-a-linux-container)  \n[Table of contents LXC vs Docker: Which Container Platform Is Right for You?](https://earthly.dev/blog/lxc-vs-docker/)  \n[Docker 그리고 Linux 컨테이너 기술들](http://www.opennaru.com/openshift/container/what-is-the-difference-between-docker-lxd-and-lxc/)\n\n# Docker\n\n그럼 이제부터 Docker에 대해 자세히 알아보자\n\n> Docker Inc.에 의해 개발 된 Go 언어로 작성된 소프트웨어로 컨테이너를 생성하고 관리하기 위한 도구이다.\n\nDocker를 실행 하면 Docker Engine이라는\n\n컨테이너를 구축 및 실행하는 오픈 소스 호스트 소프트웨어가 실행되며\n\n이 위에 Libraries, Dependencies, Tools, App이 실행 된다.\n\n도커를 사용하면 아래와 같은 장점을 가진다.\n\n- Docker Engine을 이용하기 때문에 **호스트 운영체제의 영향을 받지 않음**\n- 설정 파일(Dockerfile)로 동일한 환경을 가지기 때문에 **공유, 재구축 및 배포가 매우 쉬움**\n- 설정 파일을 통한 **이미지 버전 관리**\n- 이미지가 레이어 구조를 가지기 때문에 **차분 빌드가 가능**\n- 다양한 기능의 API (Docker API를 이용하여 관리 App 개발 가능)\n- Docker registry를 사용해 이미지 관리(저장, 배포) 가능 (public, private)\n\n## Images & Containers\n\nDocker의 핵심 요소인 Image와 Container에 대해 정리해보자\n\n정의는 다음과 같다.\n\n#### Image\n\n> 1. 모든 설정 명령과 2. 모든 코드가 포함된 공유 가능한 패키지\n\ndocker의 이미지를 registry를 통해 검색할 수 있는데 default 주소는 dockerhub이다.  \n(docker search 명령어를 통해 검색)\n\n```bash\n$ docker search {검색 할 레지스트리 명} --filter=stars=10\n\n# --filter=stars=n : star 수가 n개 이상인 결과만 표시\n```\n\nImage는 name : tag로 나뉘어 있는데\n\nname 부분은 image의 이름을 나타내고\n\ntag는 이미지의 버전을 기록한다.\n\n#### Container\n\n> 이미지의 구체적인 실행 인스턴스\n\nContainer에서 구동시킬 Image는 Container Repository에서 docker pull로 다운로드 되거나\n\nDockerFile을 참조해 _docker build_ 명령어로 커스텀 이미지를 생성한다.\n\nDockerFile엔 자체 이미지를 빌드할 때 실행하려는 도커에 대한 명령이 포함한다.\n\n```Dockerfile\nFROM {image name} # 이름 지정\n\nWORKDIR # 명령어를 수행 할 디렉토리 지정\n\nCOPY {이미지의 외부 경로} {이미지 내부 경로} # 어떤 파일이 이미지에 들어가는지 설정 (절대 경로가 좋다)\n\nEXPOSE # 로컬 시스템에 노출 시킬 포트 설정\n\nRUN # 실행 할 명령어\n\n```\n\nDockerFile에서 RUN, CMD 2가지 명령어가 비슷한 역할을 해 헷갈릴 수 있는데\n\nRUN 명령어는 **이미지 생성 시 실행** 하고\n\nCMD 명령어는 **이미지 기반으로 컨테이너 시작 시 실행**한다.\n\n작성한 DOCKERFILE을 build 수행 하였다면 run명령어를 통해 Container를 실행 가능하다.\n\nDocker는 모든 명령어를 기반으로 하는 이미지 레이어 생성 -> 모든 명령 결과를 캐시\n\n다시 빌드할 때 변경사항이 없으면 캐시 된 내용을 사용해 실행한다.  \n-> **`레이어 기반 아키텍처`** 라 한다.\n\n---\n\n그럼 레이어 기반 아키텍처를 자세히 이해하기 전에 UFS에 대해 잠깐 알아보고 가자\n\n#### Union File System\n\nDocker의 이미지는 Union File System기반으로 동작하는\n\n**`Storage Driver`**에 의해 파일 시스템으로 복수의 *Layer*가 구현된다.  \n(Storage Driver가 파일 I/O 수행)\n\nUFS란, 여러 개의 파일 시스템을 하나의 파일 시스템에 마운트 하는 기능이다.\n\n![](OverlayDriver.png)\n\n각 layer 간의 파일들을 취합해서 하나의 파일시스템으로 만들고 중복되는 파일의 경우, “상위” layer 가 “하위” layer 의 있는 파일을 대체하는 방식이다\n\nUFS 를 통해, Dockerfile 명령어를 실행한 결과 파일 시스템을 하나의 docker layer 로 만들고, 이 layer 들을 겹겹이 쌓아서 merge 된 최종 결과물이 docker 이미지가 된다.\n\n---\n\n즉, Docker는 UFS의 CoW(Copy on Write)전략을 활용해 레이어의 역할을 나눠\n\n동일한 파일 시스템을 공유하며 독립적으로 실행한다\n\n![](DockerLayer.png)\n\n도커의 컨테이너 레이어 구조는 **컨테이너 레이어**와 **이미지 레이어**로 분류한다.\n\n각각의 특징을 살펴보면 아래와 같다.\n\n컨테이너 레이어\n\n- 쓰기 가능한 레이어\n- 컨테이너가 생성된 후 변경작업은 이 레이어에서 이루어 진다.\n- 각 컨테이너마다 최상단 레이어에 생성되어 컨테이너마다 고유한 상태를 가진다.\n\n이미지 레이어\n\n- 읽기 전용 레이어\n- 다른 컨테이너와 공유\n\n![](DockerImageLayer.png)\n\n다시 Docker의 레이어 동작방식을 정리해보면\n\n하위 레이어(base layer) 위에 새로운 Layer가 쌓일 경우, 하위 layer는 READ ONLY 상태로 변경되고\n\n상위 layer에서 하위 layer를 복사하여 사용(CoW)하기 때문에, 상위 layer는 하위 layer에 아무런 영향을 주지 않는다.\n\n즉, 이미지 레이어를 통해 동일한 이미지가 생성되고\n\n컨테이너 레이어를 통해 이미지에 대한 생성을 공유 하면서도 고유한 데이터 상태를 가질 수 있다.\n\n---\n\nDocker에서 특정 iamge를 이용해 container를 기동하는 것은\n\n**모든 Layer를 결합하여 사용자에게 하나의 File system으로 제공하는 것이다**\n\n추가로\n\n도커에서 관리되는 모든 레이어와 관련된 정보는 호스트 파일 시스템의 _/var/lib/docker_ 폴더에 저장되며\n\n이 영역을 Docker Area 또는 Backing Filesystem이라 부른다.\n\n이러한 레이어 기반 아키텍처 덕분에 크게 2가지 이점이 생긴다.\n\n---\n\n첫번째는 빌드 시간 단축이다.\n\nDockerfile에 정의된 명령어 중\n\nRUN, ADD, COPY 3단계가 레이어로 저장이 된다.  \n(CMD, LABEL, ENV, EXPOSE 등 메타 정보를 다루는 부분은 임시 레이어로 생성되지만 저장되지 않는다.)\n\n레이어 기반 아키텍처를 이해하면 다음과 같은 최적화가 가능하다.\n\n```Dockerfile\n# node가 설치된 docker 이미지를 가져온다.\nFrom node\n\n# /app 폴더 내부에서 실행될 것임을 설정\nWORKDIR /app\n\n# 현재 Dockerfile 경로에 있는 파일들 전부를 도커 이미지 내부 /app 경로에 복사\nCOPY . /app\n\n# package.json 파일을 설치\nRUN npm install\n\n# 만약 node 앱에 80포트로 서버를 열어놨다면 container의 외부 포트를 설정\nEXPOSE 80\n\n# 마지막 server.js 파일을 실행\nRUN node server.js\n\n# CMD의 경우 이미지 기반으로 컨테이너가 실행 될 때 실행\n# CMD [\"node\", \"server.js\"]\n```\n\n위의 설정파일의 경우엔 소스를 수정해 파일을 하나라도 변경 할 경우\n\nnpm install이 실행되어 종속된 파일을 전부 다시 받게되는데\n\n```Dockerfile\n# node가 설치된 docker 이미지를 가져온다.\nFrom node\n\n# /app 폴더 내부에서 실행될 것임을 설정\nWORKDIR /app\n\n# 현재 package.json 파일만 /app 경로에 복사\nCOPY package.json /app\n\n# package.json 파일을 설치\nRUN npm install\n\n# 현재 Dockerfile 경로에 있는 파일들 전부를 도커 이미지 내부 /app 경로에 복사\nCOPY . /app\n\n# 만약 node 앱에 80포트로 서버를 열어놨다면 container의 외부 포트를 설정\nEXPOSE 80\n\n# 마지막 server.js 파일을 실행\nRUN node server.js\n```\n\npackage.json을 app경로에 복사 한 후 나머지 실행파일을 /app경로로 복사한다면\n\npackage.json파일이 바뀌지 않아서 package를 다시 받지 않고 실행된다.\n\n**즉, 이미지를 빌드할 때 필요한 부분만 다시 실행하여 이미지 생성 속도를 높일 수 있다**  \n(빌드 시간 단축)\n\n---\n\n두번째는 이러한 레이어 기반 아키텍처 덕분에 롤백 기능을 활용할 수 있고\n\nLayer를 활용해 **`지속적 통합 및 배포(CI/CD)`**를 수행하는 데 도움을 준다.\n\n---\n\n추가로 base가 되는 image layer(read-only layer)에 있는 내용을 변경하고 싶을 땐\n\n해당 data 를 Writable layer 로 먼저 Copy 한 후 이를 변경하는 기법을 사용해야 한다.\n\nCoW기법은 동작 구조 상 다음과 같은 단점을 가질 수 있다는 부분을 알고있어야 한다.\n\n- data 를 먼저 복제(Copy)한 후 변경을 수행해야 하므로 성능 하락(Performance Overhead)이 존재한다.\n- 하위 layer 에 있는 원본 data와 상위 layer 에 변경된 data 도 유지해야 하므로 disk space를 많이 사용할 수 있다.\n\n## Docker Command\n\nDocker의 동작방식을 살펴봤으니 다시 돌아와 사용하기 위한 명령어를 살펴보자\n\n리눅스에서 도커 엔진을 제어하기 위한 명령어는 아래와 같다.\n\n```bash\n# Docker 데몬 상태 확인\n$ sudo systemctl status docker\n\n# Docker demon 시작/중지\n$ sudo systemctl start/stop docker\n\n# Docker 데몬 사용/미사용 설정\n$ sudo systemctl enabloe/disable docker\n```\n\nDocker 명령어의 기본적인 형태는 아래와 같다.\n\n```bash\n$ docker [command] (option) [target] (arguments)\n```\n\nstart vs run -> attached 모드 vs Detached 모드\n\n#### 1. build\n\n> Dockerfile로 부터 image 생성\n\n```bash\n$ docker build [options] . -t \"app/container_name\"    # name\n```\n\n#### 2. run\n\n> image를 기반으로 컨테이너를 만들어 실행 (생성, 실행)\n\n```bash\n$ docker run {options} {이미지 명}\n\n  # -a, --attach               # attach stdout/err\n  # -i, --interactive          # attach stdin (interactive)\n  # -t, --tty                  # pseudo-tty\n  #     --name NAME            # name your image\n  # -p, --publish 5000:5000    # port map\n  #     --expose 5432          # expose a port to linked containers\n  # -P, --publish-all          # publish all ports\n  #     --link container:alias # linking\n  # -v, --volume `pwd`:/app    # mount (absolute paths needed)\n  # -e, --env NAME=hello       # env vars\n```\n\n#### 3. start\n\n> 컨테이너 실행\n\n```bash\n$ docker start [options] CONTAINER\n  # -a, --attach        # attach stdout/err\n  # -i, --interactive   # attach stdin\n```\n\n#### 4. create\n\n> 컨테이너 생성\n\n```bash\n$ docker create [options] IMAGE\n\n# ex\n$ docker create --name app_redis_1 \\\n  --expose 6379 \\\n  redis:3.0.2\n\n# -d : detached mode (백그라운드 모드)\n# -p : 포트 연결\n# -v : volume 설정\n# -e : 컨테이너 내에서 사용할 환경변수 설정\n# --name : 컨테이너 이름 설정\n# --it : 터미널 입력 옵션 (컨테이너의 표준 입력과 로컬 컴퓨터 입력 연결)\n# --rm : 프로세스 종료 시 컨테이너 자동 제거\n# --restart : docker desktop 실행 시 container 자동 실행 여부 (default : no)\n\n```\n\n#### 5. attach\n\n> 이미 실행 중인 컨테이너에 연결\n\n```bash\n$ docker attach {이미지}:{태그}\n```\n\n#### 6. ps / kill\n\n> 실행중인 모든 container 노출\n\n```bash\n$ docker ps -a\n$ docker kill $ID\n\n# -a : 현재 존재하는 모든 컨테이너의 목록 출력\n```\n\n#### 7. cp\n\n```bash\n$ docker cp\n\n```\n\n> 복사 명령어, 도커 내부의 로그 파일을 꺼내올 때 유용\n\n#### 8. stop\n\n> 컨테이너 종료\n\n```bash\n$ docker stop {Container ID}\n```\n\n#### 9. rm\n\n> 도커 컨테이너 삭제\n\n```bash\n$ docker rm {컨테이너 명}\n```\n\n#### 10. rmi\n\n> 도커 이미지 삭제\n\n```bash\n$ docker rmi {이미지 명}\n# -f : 컨테이너도 강제 삭제\n```\n\n#### 10. push / pull\n\n> 레지스트리에 push / pull\n\n```bash\n$ docker pull {이미지 이름}:{태그}\n$ docker\n```\n\n#### 11. rename\n\n> 컨테이너 이름 변경\n\n```bash\n$ docker rename {기존 이름} {변경하고자 하는 이름}\n```\n\n#### 12. log\n\n> 컨테이너 로그 조회\n\n```bash\n$ docker container logs -t {컨테이너 식별자}\n```\n\n#### 13. prune\n\n> 사용하지 않는 Docker 오브젝트 삭제\n\n[Prune unused Docker objects](https://docs.docker.com/config/pruning/)\n\n```bash\n$ docker container prune # 사용하지 않는 컨테이너 삭제\n$ docker image prune # 사용하지 않는 이미지 삭제\n$ docker volume prune # 컨테이너와 연결되어 있지 않은 모든 볼륨 삭제\n$ docker system prune # 컨테이너, 이미지, 볼륨, 네트워크 전부 삭제\n```\n\n#### 14. image / container\n\nimage 관련\n\n| command              | descriptioin                                   |\n| -------------------- | ---------------------------------------------- |\n| docker image build   | Dockerfile에서 이미지 빌드                     |\n| docker image history | 이미지의 history 표시                          |\n| docker image ls      | 이미지 나열                                    |\n| docker image prune   | 사용하지 않는 이미지 제거                      |\n| docker image pull    | 레지스트리에서 이미지 또는 저장소 가져오기     |\n| docker image push    | 이미지 또는 저장소를 레지스트리에 푸시         |\n| docker image rm      | 하나 이상의 이미지 제거                        |\n| docker image tag     | SOURCE_IMAGE를 참조하는 TARGET_IMAGE 태그 생성 |\n\ncommand 관련\n\n| Command                  | description                                                   |\n| ------------------------ | ------------------------------------------------------------- |\n| docker container attach  | 실행 중인 컨테이너에 로컬 표준 입력, 출력 및 오류 스트림 연결 |\n| docker container commit  | 컨테이너의 변경 사항에서 새 이미지 만들기                     |\n| docker container cp      | 컨테이너와 로컬 파일 시스템 간에 파일/폴더 복사               |\n| docker container create  | 새 컨테이너 만들기                                            |\n| docker container exec    | 실행 중인 컨테이너에서 명령 실행                              |\n| docker container inspect | 하나 이상의 컨테이너에 대한 자세한 정보 표시                  |\n| docker container kill    | 하나 이상의 실행 중인 컨테이너 종료                           |\n| docker container logs    | 컨테이너의 로그 가져오기                                      |\n| docker container ls      | 컨테이너 나열                                                 |\n| docker container pause   | 하나 이상의 컨테이너 내 모든 프로세스 일시 중지               |\n| docker container port    | 컨테이너에 대한 포트 매핑 또는 특정 매핑 나열                 |\n| docker container prune   | 중지된 모든 컨테이너 제거                                     |\n| docker container rename  | 컨테이너 이름 바꾸기                                          |\n| docker container restart | 하나 이상의 컨테이너 다시 시작                                |\n| docker container rm      | 하나 이상의 컨테이너 제거                                     |\n| docker container run     | 새 컨테이너에서 명령 실행                                     |\n| docker container start   | 하나 이상의 중지된 컨테이너 시작                              |\n| docker container stop    | 하나 이상의 실행 중인 컨테이너 중지                           |\n| docker container top     | 컨테이너의 실행 중인 프로세스 표시                            |\n| docker container unpause | 하나 이상의 컨테이너 내의 모든 프로세스 일시 중지 해제        |\n\n![](dockerCheet.png)\n\n---\n\n여태까지 살펴본 기본 커맨드를 통해 Docker를 사용할 수 있다.\n\nDocker 내에서 외부 데이터를 사용하고, 저장하기 위해선 2가지 개념에 대해 알아야 한다.\n\nContainer내 데이터를 호스트 컴퓨터로 꺼내오기 위해 **`Volumes`** 와\n\nContainer내에서 호스트 컴퓨터의 자원을 활용하기 위한 **`Bind Mount`**다.\n\n## Volumes\n\nVolume은 호스트 컴퓨터 내 폴더로 컨테이너와 매핑해 데이터를 **영구적으로 사용**하는 방법이다.  \n(컨테이너가 종료된 후에도 볼륨이 유지된다.)\n\nVolume은 **Named Volume, Anonymous Volume** 두가지 방법으로 지정 가능 하다.\n\n### Named Volume\n\nVolume에 이름을 지정해 사용하는 방법은 DockerFile에 명시하거나 명령어를 통해 지정해주는 방식이 있다.\n\n```DockerFile\n# DockerFile 내부\n\nVOLUME [ \"/app/log\" ]\n```\n\n명령어를 통해 Volume을 생성하고 확인하기 위해선 아래 명령어들을 사용한다\n\n```bash\n$ docker volume create app_vol\n$ docker volume ls\n```\n\n상세한 Volume 정보를 확인하기 위해선 아래 명령어를 사용한다\n\n```bash\n$ docker volume inspect app_log\n```\n\n![](volumeInspect.png)\n\nDocker 실행 시 volume지정은 -v 옵션으로 volume의 이름과 경로를 지정한다\n\n```bash\n$ docker run -d -p 3000:80 --rm --name exampleApp -v app_log:/app/log first:latest\n```\n\n위의 명령어로 container를 실행 후 inspect 명령어를 통해 container정보를 확인해보면 아래와 같이  \nmount된 정보를 확인할 수 있다.\n\n```bash\n$ docker inspect exampleApp | grep -A 12 \"Mounts\"\n```\n\n![](containerVolumeMount.png)\n\n### Anonymous Volume\n\n아무 설정없이 컨테이너를 시작하면 자동으로 Anonymous Volume이 생성되는데\n\n--rm 옵션을 넣어 컨테이너 시작하면 종료 시 자동으로 익명 Volume 제거 된다.  \n(옵션 없이 시작하면 제거되지 않는다.)\n\n--rm옵션 없이 컨테이너를 재시작 할 경우 **새로운 익명 볼륨이 계속 생성된다.**\n\n아래 두 명령어를 통해 볼륨 삭제 가능하다\n\n```bash\n$ docker volume rm VOL_NAME\n$ docker volume prune\n```\n\n주의할 점으로 Volume을 삭제 시 Volume이 마운트 되어있으면 삭제가 되지 않으니  \n연결된 container를 모두 삭제 하고 제거해야 한다.\n\n### Bind Mount\n\n여태까지 컨테이너의 내부에 있는 데이터를 호스트 컴퓨터에 저장해 데이터를 유지시켰는데\n\n반대로 컨테이너에서 호스트 컴퓨터 파일을 읽기 위해서는 **Bind Mount**기능을 사용해야 한다.\n\n## Containers & Networking\n\n## Multi-Container Project\n\n## Using Docker-Compose\n\n## Utility Container\n\n# 추가로 더 알아 볼 내용\n\n- Docker registry를 사용해 이미지 관리\n\n# Reference\n\n[Storage drivers - Docker docs](https://docs.docker.com/storage/storagedriver/)  \n[Multi-stage builds - Docker docs](https://docs.docker.com/build/building/multi-stage/)  \n[도커 컨테이너 까보기(1) - Protocol, Registry](http://cloudrain21.com/examination-of-docker-protocol-registry)  \n[도커 컨테이너 까보기(2) – Container Size, UFS](http://cloudrain21.com/examination-of-docker-containersize-ufs)  \n[What are Containers? - Google Cloud](https://cloud.google.com/learn/what-are-containers?hl=en)  \n[What's a Linux container? - Red Hat](https://www.redhat.com/en/topics/containers/whats-a-linux-container)  \n[Docker 그리고 Linux 컨테이너 기술들](http://www.opennaru.com/openshift/container/what-is-the-difference-between-docker-lxd-and-lxc/)  \n[Table of contents LXC vs Docker: Which Container Platform Is Right for You?](https://earthly.dev/blog/lxc-vs-docker/)  \n[Docker란? - Red Hat](https://www.redhat.com/ko/topics/containers/what-is-docker)  \n[Docker란 무엇인가? - OCI](https://www.oracle.com/kr/cloud/cloud-native/container-registry/what-is-docker/)\n[What is a hypervisor? - Red Hat](https://www.redhat.com/ko/topics/virtualization/what-is-a-hypervisor)  \n[What is a virtual machine (VM)? - Red Hat](https://www.redhat.com/en/topics/virtualization/what-is-a-virtual-machine)  \n[Containers vs VMs](https://www.redhat.com/en/topics/containers/containers-vs-vms)\n[Docker Cheatsheet [2023 Updated] - Collabnix](https://collabnix.com/docker-cheatsheet/)\n","excerpt":"여러 기업들은 자사에서 데이터센터나 기계실을 보유하여 온프레미스 환경에서 가동시키던 부분을 효율적인 자원 활용을 위해 클라우드 상의 가상 인스턴스로 옮기고 시스템을 구축한다 또한 확장성을 고려해 MSA(Micro Service Architecture…","fields":{"slug":"/Docker/"},"frontmatter":{"date":"Apr 10, 2023","title":"Docker를 톺아보자","tags":["Docker"],"update":"Jul 30, 2023"}}},{"node":{"rawMarkdownBody":"\n# OAuth 2.0 Client\n\n> OAuth 2.0 인가 프레임워크의 역할 중 인가 서버 및 리소스 서버와의 통신을 담당하는 클라이언트의 기능을 필터 기반으로 구현한 모듈\n\n## OAuth 2.0 Login API\n\n> 어플리케이션 사용자를 외부 OAuth2.0 Provider나 OpenID Connect 1.0 Provider 계정으로 로그인 할 수 있는 기능 제공\n\n- 권한 부여 유형 중 Authorization Code 방식을 사용\n\n## OAuth 2.0 Client API\n\n> 인가 서버의 권한 부여 유형에 따른 엔드 포인트와 직접 통신할 수 있는 API 제공\n\n- 권한 부여 종류\n  - Client Credentials\n  - Resource Owner Password Credentials\n  - Refresh Token\n- 리소스 서버와 연동해서 Token을 가지고 원하는 데이터를 가지고 오는 기능 구현 가능\n\n## OAuth 2.0 Client Fundamentals\n\n### Client 권한 설정 과정\n\n![](clientRegistrationFlow.png)\n\n1. application.yml에 환경 설정 파일에 **클라이언트, 인가서버 엔드포인트 설정**\n2. 환경설정에 있는 정보가 **OAuth2ClientProperties**의 각 속성에 바인딩\n3. **ClientRegistration**클래스에 인가서버로 권한부여 요청을 하기 위한 OAuth2ClientProperties가 저장된다.\n4. OAuth2Client는 ClientRegistration을 참조해 권한 요청을 위한 매개변수를 구성하고 인가 서버와 통신한다.\n\n### Client Registration 초기화 과정\n\n![](clientRegistraionConfigFlow.png)\n\n1. **OAuth2ClientRegistrationRepositoryConfiguration**에서  \n   **OAuth2ClientPropertiesRegistrationAdapter의 getClientRegistration함수**를 실행\n\n   - (ClientRegistrationRepository 빈이 존재하지 않을 경우 실행)\n\n2. getClientRegistration 함수 내에서 ClientRegistrations객체의  \n   fromIssuerLocation가 실행되는데 application.yml에 issuer-uri의 OIDC, AUTH 경로에 요청해 필요한 메타데이터 값을 가져온다\n\n요약\n\n- Client Registration은 인가 서버에 요청해 메타 데이터값을 가져오는데 yml 설정으로 값을 수동으로 지정해 줄 수 있다.\n- ClientRepository를 @Bean으로 등록해 yml 설정 없이 코드로 설정 가능\n\n#### ClientRegistration 상세 값\n\n| title                      | Description                                                                                                                                                                              |\n| -------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| registrationId             | ClientRegistration을 식별할 수 있는 유니크한 ID.                                                                                                                                         |\n| clientId                   | 클라이언트 식별자.                                                                                                                                                                       |\n| clientSecret               | 클라이언트 secret.                                                                                                                                                                       |\n| clientAuthenticationMethod | provider에서 클라이언트를 인증 시 사용 메소드 <br> basic, post, none (public 클라이언트).                                                                                                |\n| authorizationGrantType     | 네 가지 권한 부여 타입 정의 <br>(authorization_code, implicit, client_credentials, password)                                                                                             |\n| redirectUriTemplate        | 클라이언트에 등록한 리다이렉트 URL<br> 사용자의 인증으로 클라이언트에 접근 권한을 부여하고 나면, 인가 서버가 이 URL로 최종 사용자의 브라우저를 리다이렉트                                |\n| Scopes                     | 인가 요청 플로우에서 클라이언트가 요청한 openid, 이메일, 프로필 등의 scope.                                                                                                              |\n| clientName                 | 클라이언트를 나타내는 이름                                                                                                                                                               |\n| authorizationUri           | 인가 서버의 인가 엔드포인트 URI.                                                                                                                                                         |\n| tokenUri                   | 인가 서버의 토큰 엔드포인트 URI.                                                                                                                                                         |\n| jwkSetUri                  | 인가 서버에서 JSON 웹 키 (JWK) 셋을 가져올 때 사용할 URI. 이 키 셋엔 ID 토큰의 JSON Web Signature (JWS) 를 검증할 때 사용할 암호키가 있으며, UserInfo 응답을 검증할 때도 사용할 수 있다. |\n| configurationMetadata      | OpenID Provider 설정 정보로서 application.properties 에 spring.security.oauth2.client.provider.[providerId].issuerUri를 설정했을 때만 사용할 수 있다.                                    |\n\n### Client Repository\n\n> OAuth2.0 & OpenID Connect1.0의 ClientRegistration 저장소 역할\n\n- 인가 서버에 일차적으로 저장된 클라이언트 등록 정보의 일부를 검색하는 기능 제공\n- 자동 설정을 사용하면 ClientRegistrationRepository도 ApplicationContext내 @Bean으로 등록하므로 필요하면 원하는 곳에 의존성 주입이 가능  \n  -> 등록된 클라이언트 정보를 가져올 수 있다.\n\n### 자동 설정에 의한 초기화 과정\n\n![](AutoconfigInitialize.png)\n\n1. OAuth2ImportSelector에서 설정 클래스에 따라 class load\n\n2. 위 이미지 와 같이 로드되고 **OAuth2ClientWebMvcSecurityConfiguration**에서 2개의 클래스 로드\n\n3. DefaultOAuth2AuthorizedClientManager는 실제 권한 부여 요청에 따라 작업을 담당하는 클래스\n\n4. HandlerMethodArgumentResolver 는 웹 mvc관련 클래스\n\nDefaultOAuth2AuthorizedClientManager가 실제 권한 부여 작업 담당 클래스로 중요!\n\nBean 등록 과정\n\n![](OAuth2ClientAutoConfiguration.png)\n\nOAuth2ClientRegistrationRepositoryConfiguration은 위에서 살펴본 부분이고\n\nOAuth2WebSecurityConfiguration을 살펴보면 InMemoryOAuth2AuthorizedClientService에서 OAuth2AuthorizedClient를 관리 한다\n\n**OAuth2AuthorizedClient**는 인가서버로 부터 권한 부여가 되면 승인된 정보들이 저장되는데 **Client정보, accessToken, refreshToken, 사용자 정보 같은 것들이 저장되고 이 객체를 Spring MVC에서 참조해 사용**\n\n## OAuth 2.0 Client - oauth2Login()\n\n> OAuth2.0 Client Module을 통해서 클라이언트가 인가 서버로 부터 권한 부여 받고, 사용자 인증 처리, 권한 체크까지 인증 처리\n\noauth2.0 config 설정을 통해 http.oauth2Login()이 실행이 되면\n\nForm방식과 동일하게 OAuth2LoginConfigurer클래스가 init, configure 함수를 초기화 한다.\n\ninit함수부터 먼저 살펴보면\n\n![](OAuth2.0LoginApiInit.png)\n\n1. OAuth2LoginAuthenticationFilter 인증 필터가 생성되는데 설정한 경로로 요청이 오면 Authorization Code Grant Type 방식에서 code를 가지고 AccessToken을 발급하는 단계를 담당한다.  \n   (default : /login/oauth2/code/\\*)\n\n2. OAuth2LoginAuthenticationProvider 는 실제로 OAuth2.0 인가서버와 통신하는 기능을 담당한다.\n\n3. OidcAuthorizationCodeAuthenticationProvider 는 OpenID 프로토콜을 통해 사용자 정보를 가져온다.\n\n4. DefaultLoginPageGeneratingFilter는 실제 로그인 페이지가 필요한데 해당 페이지를 생성해 주는 기능 담당\n\n![](LoginApiConfigure.png)\n\nconfigure함수를 살펴보면 OAuth2AuthorizationRequestRedirectFilter가 생성되는데 해당 필터는 Authorization Code Grant Type 방식에서 code를 발급해주는 기능 담당\n\n![](LoginApiConfigurerConfig.png)\n\n마지막으로 Configurer가 가지고 있는 속성파일을 보면 4개의 Config를 가지고 있다\n\n1. AuthorizationEndpointConfig : code 발급 요청 시 설정 파일\n\n2. RedirectionEndpointConfig : 인가서버에서 클라이언트에게 코드를 발급하기 위해 redirect하는데 이 정보를 관리\n\n3. TokenEndpointConfig : AccessToken을 요청할 때 인가 서버에 요청하는데 이 때 사용되는 속성\n\n4. UserInfoEndpointConfig : AccessToken을 가지고 인가서버에서 User정보를 가지고 올 때 관련된 url나 설정 된 정보를 가지고 있는 config\n\n### Authorization Code - 주요 클래스\n\n#### 1) OAuth2AuthorizationRequestRedirectFilter\n\n-> 권한 코드 부여 흐름 시작  \n -> 해당 필터의 동작 조건 : AuthorizationRequestMatcher : /oauth2/authorization/{registrationId}\\*  \n -> AuthorizationEndpointConfig. authorizationRequestBaseUri 를 통해 재정의 가능\n\n#### 2) DefaultOAuth2AuthorizationRequestResolver\n\n- 웹 요청에 대하여 **OAuth2AuthorizationRequest 객체** 생성\n- /oauth2/authorization/{registrationId} 와 일치하는지 확인해서 일치하면 registrationId를 추출하고 이를 사용해서 ClientRegistration을 가져와 OAuth2AuthorizationRequest 빌드\n\n#### 3) OAuth2AuthorizationRequest\n\n- 토큰 엔드포인트 요청 파라미터를 담은 객체로서 인가 응답을 연계하고 검증할 때 사용  \n  (임시 코드를 받기위한 서버의 엔드 포인트)\n\n![](OAuth2AuthorizationRequest.png)\n\n#### 4) OAuth2AuthorizationRequestRepository\n\n- 인가 요청을 시작한 시점부터 인가 요청을 받는 시점까지 (리다이렉트) OAuth2AuthorizationRequest 유지\n\n### Authorization Code Grant Type - get code\n\n![](AuthorizationFlow.png)\n\n1. oauth2/authorization/{registrationId}로 request 요청이 오면 **OAuth2AuthorizationRequestRedirectFilter**가 받고 DefaultOAuth2AuthorizationRequestResolver가 요청 정보와 가지고 있는 requestMatcher값을 비교\n\n2. 값이 동일하면 /login/oauth2/code/{registrationId} 경로를 생성 하면서 OAuth2AutorizationRequest객체 생성\n\n3. OAuth2AutorizationRequest 객체를 세션에 저장  \n   (세션을 사용하지 않을 경우 쿠키에 저장해서 참조하도록 repository 객체 재정의 가능)\n\n4. 인가서버에서 검증 후 code와 state값을 담아 반환한다.\n\n   - 1번에서 값이 동일하지 않을경우 AuthenticationEntryPoint에 설정된 Url로 이동 ()\n\n요약하면 Authorization Code Grant Type 첫번째 code를 받는 기능을 담당하는 Filter가  \n**OAuth2AuthorizationRequestRedirectFilter**\n\n### Authorization AccessToken 주요 클래스\n\n#### 1) OAuth2LoginAuthenticationFilter\n\n- 인가서버로부터 리다이렉트 되면서 전달된 code 를 인가서버의 Access Token 으로 교환\n- Access Token 이 저장된 OAuth2LoginAuthenticationToken을 AuthenticationManager에 위임하여 UserInfo 정보를 요청해서 최종 사용자에 로그인\n- OAuth2AuthorizedClientRepository를 사용하여 OAuth2AuthorizedClient 를 저장한다.\n- 인증에 성공 시 OAuth2AuthenticationToken 이 생성, SecurityContext에 저장되며 인증 처리를 완료\n- /login/oauth2/code/\\*로 url이 매핑된다\n\n#### 2) OAuth2LoginAuthenticationProvider\n\n- Access Token 으로 교환하고 이 토큰을 사용하여 UserInfo 처리를 담당\n- Scope 에 openid 유,무에 따라 OAuth처리 Provider, OpenId처리 Provider 호출\n\n#### 3) OAuth2AuthorizationCodeAuthenticationProvider\n\n- 권한 코드 부여 흐름을 처리하는 AuthenticationProvider\n- 인가서버에 Authorization Code 와 AccessToken 의 교환을 담당하는 클래스\n\n#### 4) OidcAuthorizationCodeAuthenticationProvider\n\n- OpenID Connect Core 1.0 권한 코드 부여 흐름을 처리하는 AuthenticationProvider 이며 요청 Scope 에 openid 가 존재할 경우 실행\n\n#### 5) DefaultAuthorizationCodeTokenResponseClient\n\n- 인가서버의 token 엔드 포인트로 통신을 담당하며 AccessToken 을 받은 후 OAuth2AccessTokenResponse 에 저장하고 반환한다\n\n### Authorization Code Grant Type - get AccessToken\n\n![](AccessTokenFlow.png)\n\n1. code를 받아오면 **OAuth2LoginAuthenticationFilter** 실행\n2. OAuth2AuthorizationRequest(세션에 저장 된), OAuth2AccessTokenResponse(인가 서버로 부터 받은)를 가진 OAuth2LoginTuthenticationToken을 저장\n3. **OAuth2LoginAuthenticationProvider**에서 AccessToken을 가져옴(/token)\n4. 가져온 OAuth2AuthorizationCodeAuthentication Token을 사용해 **DefaultOAuth2UserService**에서 인가서버로 부터 사용자 정보를 가져온다.\n\n추가로\n\n- Code 가지고 있는 객체는 RequestEntity<OAuth2AuthorizationRequest>\n\n- AccessToken가지고 있는 객체는 ResponseEntity<OAuth2AccessTokenResponse>\n\n### OAuth2UserService\n\n> AccessToken을 사용해 리소스 소유자의 정보를 가져오며 OAuth2User타입의 객체를 리턴한다.\n\n- 구현체는 **DefaultOAuth2UserService와 OidcUserService**가 있다.\n\n#### DefaultOAuth2UserService\n\n> 표준 OAuth2.0 Provider를 지원하는 구현체\n\n- OAuth2User 반환\n  - OAuth2.0 Provider에 연결된 사용자 주체\n  - 사용자 인증정보를 가지고 있다 (name, email, phone number, address)\n  - 기본 구현체는 **DefaultOAuth2User**이며 Authentication principal에 저장\n\n#### OidcUserService\n\n> OpenID Connect 1.0 Provider를 지원하는 구현체\n\n- OidcUserRequest의 ID Token을 통해 인증처리, 필요 시 DefaultOAuth2UserService 사용\n- OidcUser타입 반환\n  - 최종 사용자의 인증 정보인 Claims을 포함\n  - 기본 구현체는 **DefaultOidcUser** 이며 인증 이후 Authentication principal에 저장\n  - ID토큰은 개인키로 서명이 되어있기 때문에 정해진 알고리즘을 통해 검증하고 Oidc 객체를 생성해야 한다.\n\n<!-- TODO: Flow나중에 정리 OAuth2 로그인 구현 - Oauth 2.0 User 모델 소개(1) 10분 경-->\n\n여기까진 Login 과정으로 SecurityConfig에\n\n```java\n    @Bean\n    SecurityFilterChain oauth2SecurityFilterChain(HttpSecurity http) throws Exception {\n        http.authorizeRequests((requests) -> requests.anyRequest().authenticated());\n        http.oauth2Login(Customizer.withDefaults());\n        return http.build();\n    }\n```\n\n으로 실행된다\n\n### OpenID Logout\n\n- 클라이언트는 로그아웃 엔드포인트를 사용하여 웹 브라우저에 대한 세션과 쿠키를 지운다.\n- 클라이언트 로그아웃 성공 후 OidcClientInitiatedLogoutSuccessHandler 를 호출하여 OpenID Provider 세션 로그아웃 요청\n- OpenID Provider 로그아웃이 성공하면 지정된 위치로 리다이렉트 한다\n- 로그아웃 엔드 포인트는 end_session_endpoint 로 정의되어 있다\n\n```java\n@Configuration(proxyBeanMethods = false)\npublic class OAuth2ClientConfig {\n\n    @Autowired\n    private ClientRegistrationRepository clientRegistrationRepository;\n\n    @Bean\n    SecurityFilterChain oauth2SecurityFilterChain(HttpSecurity http) throws Exception {\n        http.authorizeRequests((requests) -> requests.anyRequest().authenticated());\n        http.oauth2Login(Customizer.withDefaults());\n        http.logout()\n                .logoutSuccessHandler(oidcLogoutSuccessHandler())\n                .invalidateHttpSession(true)\n                .clearAuthentication(true)\n                .deleteCookies(\"JSESSIONID\");\n\n        return http.build();\n    }\n\n    private OidcClientInitiatedLogoutSuccessHandler oidcLogoutSuccessHandler() {\n        OidcClientInitiatedLogoutSuccessHandler successHandler = new OidcClientInitiatedLogoutSuccessHandler(clientRegistrationRepository);\n        successHandler.setPostLogoutRedirectUri(\"http://localhost:8081/login\");\n        return successHandler;\n    }\n}\n```\n\n### MVC에서 인증 객체 참조 방법\n\n```java\n    // 1.Authentication 객체로 전달 받기\n    @GetMapping(\"/user\")\n    public OAuth2User user(Authentication authentication){\n        OAuth2User oAuth2User = (OAuth2User)authentication.getPrincipal();\n\n        // 2. ContextHolder에서 꺼내오기\n        OAuth2AuthenticationToken oAuth2AuthenticationToken = (OAuth2AuthenticationToken) SecurityContextHolder.getContext().getAuthentication();\n        OAuth2User oAuth2User2 = oAuth2AuthenticationToken.getPrincipal();\n        System.out.println(\"oAuth2User = \" + oAuth2User);\n        System.out.println(\"oAuth2User2 = \" + oAuth2User2);\n        return oAuth2User;\n    }\n\n    // 3. AuthenticationPrincipal 어노테이션 사용\n    @GetMapping(\"/oauth2User\")\n    public OAuth2User oauth2User(@AuthenticationPrincipal OAuth2User oAuth2User){\n        System.out.println(\"oAuth2User = \" + oAuth2User);\n        return oAuth2User;\n    }\n\n    @GetMapping(\"/oidcUser\")\n    public OidcUser oidcUser(@AuthenticationPrincipal OidcUser oidcUser){\n        System.out.println(\"oidcUser = \" + oidcUser);\n        return oidcUser;\n    }\n```\n\n### OAuth2 Custom\n\n![](oauth2configurer.png)\n\noauth2LoginConfig 설정 클래스를 살펴보면 4개의 하위 config설정 클래스가 있다.\n\n이 설정 클래스들의 값을 변경하면 requestMatcher가 요청을 처리할 url경로를 변경할 수 있다.\n\n#### AuthorizationBaseUrl & RedirectionBaseUrl 변경\n\n![](AuthorizationBaseUrlRedirectionBaseUrl.png)\n\nAuthorization Code Grant Type 로그인 과정에서\n\ncode를 받아올 때 사용하는 base url과 code를 받아온 후 App으로 리다이렉트 해주는 redirection base url을 변경 할 수 있다.\n\n1. config 설정 파일에 oauth2LoginConfig 설정 변경, yml파일에 등록한 client redirect-uri 변경\n\n```java\n// application.yml\nredirect-uri: http://localhost:8081/login/v1/oauth2/code/keycloak\n\n// Config\n        http\n                .oauth2Login(oauth2 -> oauth2\n                        .loginPage(\"/login\")\n//                        .loginProcessingUrl(\"/login/v1/oauth2/code/*\")\n                        .authorizationEndpoint(authorizationEndpointConfig ->\n                                authorizationEndpointConfig.baseUri(\"/oauth2/v1/authorization\"))\n                        .redirectionEndpoint(redirectionEndpointConfig ->\n                                redirectionEndpointConfig.baseUri(\"/login/v1/oauth2/code/*\"))\n                );\n```\n\n2. 인가 서버의 valid post logout redirect url 설정 추가\n\n#### PCKE 사용\n\npcke방식 grant type을 설정하려면 Code Challenge를 암호화 해서 사용해야 하는데 OAuth2AuthorizationRequestResolver를 상속받은 구현체를 만들어 resolve함수를 custom 해야한다.\n\nresolve 로직을 간단히 요약하면 request 요청에 registrationId를 **keycloakWithPKCE**(yml 파일에서 해당 이름으로 매칭 시켜 놓음) 값이 있을 경우에 대한 분기처리를 한다.\n\n```java\n// config\n    @Bean\n    SecurityFilterChain oauth2SecurityFilterChain(HttpSecurity http) throws Exception {\n        http.authorizeRequests((requests) -> requests.antMatchers(\"/home\").permitAll()\n                .anyRequest().authenticated());\n        http.oauth2Login(authLogin ->\n                authLogin.authorizationEndpoint(authEndpoint ->\n                        authEndpoint.authorizationRequestResolver(customOAuth2AuthenticationRequestResolver())));\n        http.logout().logoutSuccessUrl(\"/home\");\n\n        return http.build();\n    }\n\n    private OAuth2AuthorizationRequestResolver customOAuth2AuthenticationRequestResolver() {\n        return new CustomOAuth2AuthorizationRequestResolver(clientRegistrationRepository, \"/oauth2/authorization\");\n    }\n\n// CustomOAuth2AuthorizationRequestResolver\npublic class CustomOAuth2AuthorizationRequestResolver implements OAuth2AuthorizationRequestResolver {\n    ...\n\n    public CustomOAuth2AuthorizationRequestResolver(ClientRegistrationRepository clientRegistrationRepository, String authorizationRequestBaseUri) {\n\n        this.clientRegistrationRepository = clientRegistrationRepository;\n        this.authorizationRequestMatcher = new AntPathRequestMatcher(\n                authorizationRequestBaseUri + \"/{\" + REGISTRATION_ID_URI_VARIABLE_NAME + \"}\");\n\n        defaultResolver = new DefaultOAuth2AuthorizationRequestResolver(clientRegistrationRepository, authorizationRequestBaseUri);\n    }\n\n    @Override\n    public OAuth2AuthorizationRequest resolve(HttpServletRequest request) {\n        String registrationId = resolveRegistrationId(request);\n        if (registrationId == null) {\n            return null;\n        }\n        ClientRegistration clientRegistration = clientRegistrationRepository.findByRegistrationId(registrationId);\n        if(registrationId.equals(\"keycloakWithPKCE\")){\n            OAuth2AuthorizationRequest oAuth2AuthorizationRequest = defaultResolver.resolve(request);\n            return customResolve(oAuth2AuthorizationRequest, clientRegistration);\n\n        }\n        return defaultResolver.resolve(request);\n    }\n\n    @Override\n    public OAuth2AuthorizationRequest resolve(HttpServletRequest request, String clientRegistrationId) {\n        ClientRegistration clientRegistration = clientRegistrationRepository.findByRegistrationId(clientRegistrationId);\n        if(clientRegistrationId.equals(\"keycloakWithPKCE\")){\n            OAuth2AuthorizationRequest oAuth2AuthorizationRequest = defaultResolver.resolve(request);\n            return customResolve(oAuth2AuthorizationRequest, clientRegistration);\n        }\n        return defaultResolver.resolve(request,clientRegistrationId);\n    }\n    private OAuth2AuthorizationRequest customResolve(OAuth2AuthorizationRequest authorizationRequest, ClientRegistration clientRegistration) {\n\n        Map<String,Object> extraParam = new HashMap<>();\n        extraParam.put(\"customName1\",\"customValue1\");\n        extraParam.put(\"customName2\",\"customValue2\");\n        extraParam.put(\"customName3\",\"customValue3\");\n\n        OAuth2AuthorizationRequest.Builder builder = OAuth2AuthorizationRequest\n                .from(authorizationRequest)\n                .additionalParameters(extraParam)\n                ;\n        DEFAULT_PKCE_APPLIER.accept(builder);\n\n        return builder.build();\n    }\n    ...\n}\n```\n\n## OAuth 2.0 Client - oauth2Client()\n\n- OAuth2AuthorizedClient 는 인가받은 클라이언트를 의미하는 클래스\n- OAuth2AuthorizedClient 는 AccessToken 과 RefreshToken 을 ClientRegistration (클라이언트)와 권한을 부여한 최종 사용자인 Principal과 함께 묶는다.\n- OAuth2AuthorizedClient 의 AccessToken 을 사용해서 리소스 서버의 자원에 접근, 인가서버와의 통신으로 토큰을 검증\n\n<!-- TODO: 이거 어떤거 말하는지 확인해야 함\nOAuth2.0 Login() 인증, 인가 포함\nOAuth2.0 Client() 인가처리는 가능하지만 최종 사용자의 인증은 처리 x -->\n\n### OAuth2.0 Client 주요 클래스\n\n#### AuthorizationCodeGrantConfigurer\n\n> 해당 클래스는 위에서 코드를 받아오기 위한 3개의 클래스를 생성하고, 추가로 accessToken을 받아오기 위한 **OAuth2AuthorizationCodeGrantFilter**도 생성\n\n#### OAuth2AuthorizedClientRepository\n\n> 다른 웹 요청이 와도 동일한 OAuth2AuthorizedClient 를 유지하는 역할\n\n#### OAuth2AuthorizedClientService\n\n> OAuth2AuthorizedClientService 는 어플리케이션 레벨에서 OAuth2AuthorizedClient 를 관리(저장, 조회, 삭제 )\n\n#### OAuth2AuthorizedClientManager\n\n> OAuth2AuthorizedClient 를 전반적으로 관리하는 인터페이스\n\n![](OAuth2AuthorizedClientManagerStructure.png)\n\n- Client Credentials Flow, Resource Owner Password Flow, Refresh Token Flow 3개의 권한 부여 방식 사용\n- OAuth2AuthorizedClientService 나 OAuth2AuthorizedClientRepository 에 OAuth2AuthorizedClient 저장을 위임한 후 OAuth2AuthorizedClient 최종 반환\n- HttpServletRequest는 DefaultOAuth2AuthorizedClientManager 클래스가 처리\n- 데몬, 백그라운드 실행 시 AuthorizedClientServiceOAuth2AuthorizedClientManager 클래스가 처리\n\n### OAuth2 client - Resource Owner Password Flow\n\n#### 인증 처리\n\n![](ResourceOwnerPasswordFlow.png)\n\nResource Owner Password 인증을 살펴보면\n\n1. 인증하는데 필요한 요청 정보를 **OAuth2AuthorizeRequest**에 담아 ClientManager로 보낸다.\n\n2. OAuth2AuthorizedClient 객체가 있는지 확인\n\n3. OAuth2AuthorizedClient가 없을 경우 OAuth2AutorizationContext객체를 생성해 **PasswordOAuth2AuthorizedClientProvider 전달하고 클라이언트 인가 처리**\n\n4. AccessToken과 RefreshToken 로직 분기 처리 후 필요 시 인가 서버로 **DefaultPasswordTokenResponseClient**클래스를 사용해 처리\n\n#### 인가처리\n\n![](restAuthorizationFlow.png)\n\n인증 처리가 끝나면 위와 같이 AccessToken을 사용해 사용자 정보를 가져올 수 있다.\n\n#### 구현\n\n- 인증 처리를 하기 위해선 username과 password를 처리하는 기능이 필요해 **contextAttributesMapper**를 구현해 OAuth2AutorizedClientManager에 등록시켜야 한다.\n\n```java\n// OAuth2ClientConfig\n    @Bean\n    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n        http.authorizeRequests(authRequest -> authRequest\n                .antMatchers(\"/\",\"/oauth2Login\",\"/client\").permitAll()\n                .anyRequest().authenticated());\n        http\n//                .oauth2Login(Customizer.withDefaults())\n                .oauth2Client(Customizer.withDefaults());\n        return http.build();\n    }\n\n// AppConfig\n@Configuration\npublic class AppConfig {\n\n    @Bean\n    public DefaultOAuth2AuthorizedClientManager authorizedClientManager(ClientRegistrationRepository clientRegistrationRepository,\n                                                                        OAuth2AuthorizedClientRepository authorizedClientRepository) {\n\n        OAuth2AuthorizedClientProvider authorizedClientProvider =\n                OAuth2AuthorizedClientProviderBuilder.builder()\n                        .authorizationCode()\n                        .clientCredentials()\n                        .password(passwordGrantBuilder -> {\n                            passwordGrantBuilder.clockSkew(Duration.ofSeconds(3600));\n                        })\n                        .refreshToken(refreshTokenGrantBuilder -> refreshTokenGrantBuilder.clockSkew(Duration.ofSeconds(3600)))\n                        .build();\n\n        DefaultOAuth2AuthorizedClientManager authorizedClientManager =\n                new DefaultOAuth2AuthorizedClientManager(\n                        clientRegistrationRepository, authorizedClientRepository);\n        authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);\n        authorizedClientManager.setContextAttributesMapper(contextAttributesMapper());\n\n        return authorizedClientManager;\n    }\n\n    private Function<OAuth2AuthorizeRequest, Map<String, Object>> contextAttributesMapper() {\n        return authorizeRequest -> {\n            Map<String, Object> contextAttributes = Collections.emptyMap();\n            HttpServletRequest servletRequest = authorizeRequest.getAttribute(HttpServletRequest.class.getName());\n\n            String username = servletRequest.getParameter(OAuth2ParameterNames.USERNAME);\n            String password = servletRequest.getParameter(OAuth2ParameterNames.PASSWORD);\n\n            if (StringUtils.hasText(username) && StringUtils.hasText(password)) {\n                contextAttributes = new HashMap<>();\n\n                // `PasswordOAuth2AuthorizedClientProvider` requires both attributes\n                contextAttributes.put(OAuth2AuthorizationContext.USERNAME_ATTRIBUTE_NAME, username);\n                contextAttributes.put(OAuth2AuthorizationContext.PASSWORD_ATTRIBUTE_NAME, password);\n            }\n            return contextAttributes;\n        };\n    }\n}\n```\n\n코드를 간략히 설명하면\n\n1. **DefaultOAuth2AutorizedClientManager** 객체 생성\n\n2. setAuthorizedClientProvider 함수로 Provider 등록\n\n3. parameter 처리 부분이 있는 contextAttributesMapper 함수를 등록한다.\n\nDefaultOAuth2AuthorizedClientManager 객체를 통해 동작 확인 가능\n\nConfig 설정은 끝이고\n\n실제 로그인 기능을 구현하기 위해서 Controller 구현해야 한다.\n\n```java\n@Controller\npublic class LoginController {\n\n    @Autowired\n    DefaultOAuth2AuthorizedClientManager authorizedClientManager;\n\n    @Autowired\n    OAuth2AuthorizedClientRepository authorizedClientRepository;\n\n    private Duration clockSkew = Duration.ofSeconds(3600);\n\n    private Clock clock = Clock.systemUTC();\n\n    @GetMapping(\"/oauth2Login\")\n    public String oauth2Login(Model model, HttpServletResponse servletResponse, HttpServletRequest servletRequest) throws IOException {\n\n        Authentication principal = SecurityContextHolder.getContext().getAuthentication();\n\n        if (principal == null) {\n            principal = new AnonymousAuthenticationToken(\"anonymous\",\"anonymousUser\", AuthorityUtils.createAuthorityList(\"ROLE_ANONYMOUS\"));\n        }\n\n        OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest\n                .withClientRegistrationId(\"keycloak\")\n                .principal(principal)\n                .attribute(HttpServletRequest.class.getName(), servletRequest)\n                .attribute(HttpServletResponse.class.getName(), servletResponse)\n                .build();\n\n        OAuth2AuthorizationSuccessHandler authorizationSuccessHandler = (authorizedClient, authentication, attributes) ->\n                authorizedClientRepository\n                        .saveAuthorizedClient(authorizedClient, authentication,\n                                (HttpServletRequest) attributes.get(HttpServletRequest.class.getName()),\n                                (HttpServletResponse) attributes.get(HttpServletResponse.class.getName()));\n        authorizedClientManager.setAuthorizationSuccessHandler(authorizationSuccessHandler);\n\n        OAuth2AuthorizedClient oAuth2AuthorizedClient = authorizedClientManager.authorize(authorizeRequest);\n\n        if (oAuth2AuthorizedClient != null && hasTokenExpired(oAuth2AuthorizedClient.getAccessToken())\n                && oAuth2AuthorizedClient.getRefreshToken() != null) {\n            ClientRegistration.withClientRegistration(oAuth2AuthorizedClient.getClientRegistration()).authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN);\n            oAuth2AuthorizedClient = authorizedClientManager.authorize(authorizeRequest);\n        }\n\n        if(oAuth2AuthorizedClient != null) {\n\n            ClientRegistration clientRegistration = oAuth2AuthorizedClient.getClientRegistration();\n            OAuth2AccessToken accessToken = oAuth2AuthorizedClient.getAccessToken();\n            OAuth2RefreshToken refreshToken = oAuth2AuthorizedClient.getRefreshToken();\n\n            OAuth2UserService oAuth2UserService = new DefaultOAuth2UserService();\n\n            // 사용자 정보 가져오는 함수\n            OAuth2User oauth2User = oAuth2UserService.loadUser(new OAuth2UserRequest(\n                    oAuth2AuthorizedClient.getClientRegistration(), accessToken));\n\n            // 권한 매핑\n            SimpleAuthorityMapper simpleAuthorityMapper = new SimpleAuthorityMapper();\n            simpleAuthorityMapper.setPrefix(\"\"); // SYSTEM_ 이런식으로 prefix 줄 수 있음\n            Collection<? extends GrantedAuthority> authorities = simpleAuthorityMapper.mapAuthorities(oauth2User.getAuthorities());\n            OAuth2AuthenticationToken oAuth2AuthenticationToken = new OAuth2AuthenticationToken(oauth2User, authorities, clientRegistration.getRegistrationId());\n\n            SecurityContext context = SecurityContextHolder.createEmptyContext();\n            context.setAuthentication(oAuth2AuthenticationToken);\n            SecurityContextHolder.setContext(context);\n\n            authorizationSuccessHandler.onAuthorizationSuccess(oAuth2AuthorizedClient, oAuth2AuthenticationToken, createAttributes(servletRequest, servletResponse));\n            model.addAttribute(\"oAuth2AuthenticationToken\",oAuth2AuthenticationToken);\n        }\n\n        return \"home\";\n    }\n\n    private static Map<String, Object> createAttributes(HttpServletRequest servletRequest, HttpServletResponse servletResponse) {\n        Map<String, Object> attributes = new HashMap<>();\n        attributes.put(HttpServletRequest.class.getName(), servletRequest);\n        attributes.put(HttpServletResponse.class.getName(), servletResponse);\n        return attributes;\n    }\n\n    @GetMapping(\"/logout\")\n    public String logout(HttpServletRequest servletRequest, HttpServletResponse servletResponse, Authentication authentication){\n        SecurityContextLogoutHandler logoutHandler = new SecurityContextLogoutHandler();\n        logoutHandler.logout(servletRequest, servletResponse, authentication);\n        return \"index\";\n    }\n\n    private boolean hasTokenExpired(OAuth2Token token) {\n        return this.clock.instant().isAfter(token.getExpiresAt().minus(this.clockSkew));\n    }\n}\n```\n\n### Client Credentials, Refresh Token\n\nCredentials는 Resource Owner Password Flow 로직과 대부분 유사한데\n\n권한 부여에 따른 처리 하는 클래스들이 차이가 난다.\n\n해당 부분의 Config를 수정하면서 구현\n\nRefresh Token은 위에 적용이 되어있는데 App Config와 controller에 처리하는 부분을 추가하면 된다.\n\n### Custom Login Filter\n\n이전까지 과정은 Client Manager를 이용해 Spring MVC에서 Login Controller에서 인가처리를 했는데\n\nSpring Security에서 지원하는 Filter 기반으로 적용이 가능\n\n인가 처리 로직은 이전과 동일하고 Config 설정에서 Filter 등록을 한다.\n\n```java\n@Configuration(proxyBeanMethods = false)\npublic class OAuth2ClientConfig {\n\n    @Autowired\n    private DefaultOAuth2AuthorizedClientManager authorizedClientManager;\n\n    @Autowired\n    private OAuth2AuthorizedClientRepository authorizedClientRepository;\n\n    @Bean\n    SecurityFilterChain oauth2SecurityFilterChain(HttpSecurity http) throws Exception {\n                http.authorizeRequests((requests) -> requests.antMatchers(\"/\",\"/oauth2Login\",\"/logout\").permitAll().anyRequest().authenticated());\n        http\n//                .oauth2Login().and()\n                .oauth2Client()\n                .and()\n                .addFilterBefore(customOAuth2LoginAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)\n        ;\n        return http.build();\n    }\n\n    public CustomOAuth2LoginAuthenticationFilter customOAuth2LoginAuthenticationFilter() throws Exception {\n        CustomOAuth2LoginAuthenticationFilter customOAuth2LoginAuthenticationFilter =\n                new CustomOAuth2LoginAuthenticationFilter(authorizedClientManager,authorizedClientRepository);\n        customOAuth2LoginAuthenticationFilter.setAuthenticationSuccessHandler((request, response, authentication) -> {\n            response.sendRedirect(\"/home\");\n        });\n        return customOAuth2LoginAuthenticationFilter;\n    }\n```\n\ncustomOAuth2LoginAuthenticationFilter 설정을 살펴보면\n\n```java\npublic class CustomOAuth2LoginAuthenticationFilter extends AbstractAuthenticationProcessingFilter {\n\n    public static final String DEFAULT_FILTER_PROCESSES_URI = \"/oauth2Login/**\";\n    private OAuth2AuthorizedClientRepository authorizedClientRepository;\n    private DefaultOAuth2AuthorizedClientManager oAuth2AuthorizedClientManager;\n    private OAuth2AuthorizationSuccessHandler authorizationSuccessHandler;\n\n    private OAuth2AuthorizationFailureHandler authorizationFailureHandler;\n\n    private Duration clockSkew = Duration.ofSeconds(3600);\n\n    private Clock clock = Clock.systemUTC();\n\n    public CustomOAuth2LoginAuthenticationFilter(DefaultOAuth2AuthorizedClientManager oAuth2AuthorizedClientManager, OAuth2AuthorizedClientRepository oAuth2AuthorizedClientRepository) {\n        super(DEFAULT_FILTER_PROCESSES_URI);\n        this.oAuth2AuthorizedClientManager = oAuth2AuthorizedClientManager;\n        this.authorizedClientRepository = oAuth2AuthorizedClientRepository;\n\n        this.authorizationSuccessHandler = (authorizedClient, authentication, attributes) ->\n                authorizedClientRepository\n                        .saveAuthorizedClient(authorizedClient, authentication,\n                                (HttpServletRequest) attributes.get(HttpServletRequest.class.getName()),\n                                (HttpServletResponse) attributes.get(HttpServletResponse.class.getName()));\n        this.oAuth2AuthorizedClientManager.setAuthorizationSuccessHandler(authorizationSuccessHandler);\n    }\n\n    @Override\n    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException, IOException, ServletException {\n\n        Authentication principal = SecurityContextHolder.getContext().getAuthentication();\n\n        if (principal == null) {\n            principal = new AnonymousAuthenticationToken(\"anonymous\", \"anonymousUser\", AuthorityUtils.createAuthorityList(\"ROLE_ANONYMOUS\"));\n        }\n\n        OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest\n                .withClientRegistrationId(\"keycloak\")\n                .principal(principal)\n                .attribute(HttpServletRequest.class.getName(), request)\n                .attribute(HttpServletResponse.class.getName(), response)\n                .build();\n\n        OAuth2AuthorizedClient oAuth2AuthorizedClient = oAuth2AuthorizedClientManager.authorize(authorizeRequest);\n\n        if (oAuth2AuthorizedClient != null && hasTokenExpired(oAuth2AuthorizedClient.getAccessToken())\n                && oAuth2AuthorizedClient.getRefreshToken() != null) {\n            ClientRegistration.withClientRegistration(oAuth2AuthorizedClient.getClientRegistration()).authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN);\n            oAuth2AuthorizedClient = oAuth2AuthorizedClientManager.authorize(authorizeRequest);\n        }\n\n        if (oAuth2AuthorizedClient != null) {\n            ClientRegistration clientRegistration = oAuth2AuthorizedClient.getClientRegistration();\n            OAuth2AccessToken accessToken = oAuth2AuthorizedClient.getAccessToken();\n            OAuth2RefreshToken refreshToken = oAuth2AuthorizedClient.getRefreshToken();\n\n            OAuth2UserService oAuth2UserService = new DefaultOAuth2UserService();\n            OAuth2User oauth2User = oAuth2UserService.loadUser(new OAuth2UserRequest(\n                    oAuth2AuthorizedClient.getClientRegistration(), accessToken));\n\n            SimpleAuthorityMapper simpleAuthorityMapper = new SimpleAuthorityMapper();\n            Collection<? extends GrantedAuthority> authorities = simpleAuthorityMapper.mapAuthorities(oauth2User.getAuthorities());\n            OAuth2AuthenticationToken oAuth2AuthenticationToken = new OAuth2AuthenticationToken(oauth2User, authorities, clientRegistration.getRegistrationId());\n\n            // 인증 받은 사용자를 저장해줘야 한다.\n            authorizationSuccessHandler.onAuthorizationSuccess(oAuth2AuthorizedClient, oAuth2AuthenticationToken, createAttributes(request, response));\n\n            return oAuth2AuthenticationToken;\n        }\n\n        return null;\n\n    }\n\n    private static Map<String, Object> createAttributes(HttpServletRequest servletRequest, HttpServletResponse servletResponse) {\n        Map<String, Object> attributes = new HashMap<>();\n        attributes.put(HttpServletRequest.class.getName(), servletRequest);\n        attributes.put(HttpServletResponse.class.getName(), servletResponse);\n        return attributes;\n    }\n\n    private boolean hasTokenExpired(OAuth2Token token) {\n        return this.clock.instant().isAfter(token.getExpiresAt().minus(this.clockSkew));\n    }\n}\n```\n\n코드 설명을 간략히 하면\n\n1. CustomOAuth2LoginAuthenticationFilter 생성자 내부에서 default url설정을 해 어떤 경로로 들어오면 filter처리를 할 지 등록시켜 준다.  \n   (AbstractAuthenticationProcessingFilter 생성자에서 url 등록)\n2. config설정을 보면 UsernamePasswordAuthenticationFilter 앞에 Filter가 동작하도록 설정해서 MVC Controller에서 처리하는 부분과 다르게 SecurityContextHolder안에 Token이 존재하지 않아 principal이 null일 경우 AnonymousAuthenticationToken을 만들어주는 로직이 필요\n3. 나머지는 위에 MVC 처리 부분과 동일하다\n\n# Reference\n\n- [스프링 시큐리티 OAuth2 - Spring Boot 기반으로 개발하는 Spring Security OAuth2](https://www.inflearn.com/course/%EC%A0%95%EC%88%98%EC%9B%90-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0/dashboard)\n","excerpt":"OAuth 2.0 Client OAuth 2.0 인가 프레임워크의 역할 중 인가 서버 및 리소스 서버와의 통신을 담당하는 클라이언트의 기능을 필터 기반으로 구현한 모듈 OAuth 2.0 Login API 어플리케이션 사용자를 외부 OAuth2.0 P…","fields":{"slug":"/SpringSecurity2_2/"},"frontmatter":{"date":"Feb 08, 2023","title":"Spring Security OAuth2.0 Client","tags":["Spring"],"update":"Feb 13, 2023"}}},{"node":{"rawMarkdownBody":"\n## SecurityBuilder, SecurityConfigurer\n\n### SecurityConfigurer\n\n> Http요청과 관련된 보안 처리를 담당하는 필터들을 생성하고 인증 및 인가 초기화 작업\n\n### SecurityBuilder\n\n> 빌더 클래스로 웹 보안을 구성하는 빈 객체와 설정클래스 생성 ex) WebSeucrity, HttpSecurity\n\n![](SecurityBuilder.png)\n\n- AutoConfiguration이 SecurityBuilder를 생성하면 SecurityConfigurer를 초기화 (init, configure)\n- WebSecurity, HttpSecurity 순을 객체 생성\n- SecurityFilterChain이름을 가진 FilterChainProxy생성\n\n## 인증, 인가 흐름\n\n## Cors\n\n# OAuth2.0 이해\n\n> 자신이 소유한 리소스에 소프트웨어 애플리케이션이 접근할 수 있도록 허용해 줌으로써 접근 권한을 위임해주는 개방형 표준 프로토콜(인가)\n\n## 주요 용어\n\nAuthentication(인증)\n\n- 접근 자격이 있는지 검증\n\nAuthorization(인가)\n\n- 자원에 접근할 권한 부여\n- 인가가 완료되면 리소스 접근 권한이 담긴 Access Token이 클라이언트에게 부여\n\nAccess Token\n\n- 리소스 서버에 접근 시 사용되는 만료 기간이 있는 Token\n- 유형으로 식별자 타입(Identifier Type) / 자체 포함 타입 (Self-contained Type) 2가지가 있다.\n\n- 식별자 타입 : Resource server로 부터 유저 정보를 가져오기 위한 식별자만 존재\n- 자체 포함 타입 : JWT 토큰 형식으로 유의미한 정보 포함 (개인키 - 공개키 방식으로 암호화)\n\nRefresh Token\n\n- Access Token 만료시 이를 갱신하기 위한 용도로 사용하는 Token\n\nAuthorization Code\n\n- 권한 부여 흐름에서 사용되며, 이 코드는 클라이언트가 액세스 토큰과 교환 할 임시 코드\n\n## OAuth 2.0 Role\n\n> OAuth 2.0의 매커니즘은 다음 네가지 종류의 역할을 담당하는 주체에 의해 이루어지는 권한 부여 체계\n\n### 1. Resource Owner (자원 소유자)\n\n> 리소스 소유자 또는 사용자. 보호된 자원에 접근할 수 있는 자격을 부여해 주는 주체\n\n- 개념적으로는 리소스 소유자가 자격을 부여하는 것이지만 일반적으로 권한 서버가 리소스 소유자와 클라이언트 사이에서 중개 역할을 수행\n\n### 2. Resource Server (보호자원 서버)\n\n> 사용자의 보호된 자원을 호스팅하는 서버\n\n### 3. Authorization Server (인가 서버)\n\n> 인증, 인가를 수행하는 서버로 클라이언트의 접근 자격을 확인하고 Access Token을 발급하여 권한 부여\n\n### 4. Clinet\n\n> 보호 자원을 사용하려고 접근 요청하는 App\n\n## OAuth2.0 Grant Type\n\n### 매개 변수 용어\n\n| keyword       | description                                                                                                                                                                      |\n| ------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| client_id     | 인가 서버에 등록된 클라이언트의 고유 키                                                                                                                                          |\n| client_secret | 인가서버에 등록된 클라이언트 client_id 에 대해 생성된 비밀 값                                                                                                                    |\n| response_type | - App이 권한 부여 코드 흐름을 시작하고 있음을 인증 서버에 알림 <br> - code, token, id_token 이 있으며 token, id_token 은 implicit 권한 부여 유형에서 지원해야 함                 |\n| grant_type    | 권한 부여 타입 지정 - authorization_code, password, client_credentials, refresh_token                                                                                            |\n| redirect_uri  | - 사용자가 응용 프로그램을 성공적으로 승인하면 권한 부여 서버가 사용자를 다시 응용 프로그램으로 리디렉션 <br> - redirect_uri 는 인증 코드를 생성할 때 사용된 redirect_uri을 검증 |\n| scope         | 어플리케이션이 사용자 데이터에 접근하는 것을 제한하기 위해 사용(email profile read write)                                                                                        |\n| state         | - 응용 프로그램은 임의의 문자열을 생성하고 요청에 포함하고 사용자가 앱을 승인한 후 서버로부터 동일한 값이 반환되는지 확인 <br> - CSRF 공격 을 방지하는 데 사용                   |\n\n### 1. Authorization Code Grant Type\n\n![](AuthorizationCode.png)\n\n- Authorization Code 획득 후 해당 Code로 Access Token을 획득\n- Token검증 시 일반적으로 resource server가 자체적으로 Token검증\n- 액세스 토큰이 사용자 또는 브라우저에 표시되지 않고 애플리케이션에 다시 전달하는 가장 안전한 방법이므로 토큰이 다른 사람에게 누출될 위험이 줄어듬\n\ncode 요청 시 파라미터\n\n| Parameter     | description                                                                                                                                                                        | 필수 |\n| ------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---- |\n| response_type | 권한 부여 동의 요청 시 포함되는 값으로 권한 부여 방식에 대한 설정 ex) code                                                                                                         | o    |\n| client_id     | 권한 서버에 등록한 client id                                                                                                                                                       | o    |\n| redirect_url  | 권한 서버가 요청에 대한 응답을 보낼 url                                                                                                                                            | x    |\n| scope         | email profile                                                                                                                                                                      | x    |\n| state         | CSRF 공격에 대비하기 위해 클라이언트가 권한서버에 요청 시 포함하는 임의의 문자열 <br> 클라이언트가 요청 시 state를 포함시켰다면 권한 서버는 동일한 값을 클라이언트에게 전송해야 함 | x    |\n\nAccessToken 요청 시 파라미터\n\n| Parameter     | description                                                                                  | 필수 |\n| ------------- | -------------------------------------------------------------------------------------------- | ---- |\n| grant_type    | Access Token 획득 요청 시 포함되는 값으로 권한 부여 방식에 대한 설정 <br> authorization_code | o    |\n| code          | 권한 서버로 부터 받은 code                                                                   | o    |\n| redirect_url  | 권한 서버가 요청에 대한 응답을 보낼 url                                                      | o    |\n| client_id     | 권한 서버에 등록한 client id                                                                 | o    |\n| client_secret | 권한 서버로 부터 발급 된 secret값                                                            | o    |\n\n### 2. Implicit Grant Type (Deprecated)\n\n![](Implicit.png)\n\n보안상의 이유로 deprecated\n\n### 3. Resource Owner Password Credentials Grant Type (Deprecated)\n\n![](ResourceOwnerPasswordCredentials.png)\n\n- 애플리케이션이 사용자 이름과 암호를 액세스 토큰으로 교환할 때 사용\n- 타사 어플리케이션이 이 권한을 사용하도록 허용해서는 안되고 고도의 신뢰할 자사 어플리케이션에서만 사용\n\n| Parameter     | description                           | 필수 |\n| ------------- | ------------------------------------- | ---- |\n| grant_type    | 권한 부여 유형은 password             | o    |\n| username      | 응용프로그램에 입력한 사용자 이름     | o    |\n| password      | 응용프로그램에 입력한 사용자 비밀번호 | o    |\n| client_id     | 권한 서버에 등록한 client id          | o    |\n| client_secret | 권한 서버로 부터 발급 된 secret값     | o    |\n| scope         | Scopes                                | x    |\n\n### 4. Client Credentials Grant Type\n\n![](ClientCredentials.png)\n\n- 데몬이나 백그라운드에서 서버대 서버 통신하는데 주로 사용\n- 애플리케이션이 리소스 소유자인 동시에 클라이언트 역할\n- Client Id 와 Client Secret 을 통해 액세스 토큰을 바로 발급 받을 수 있기 때문에 Refresh Token 을 제공하지 않음\n- Client 정보를 기반으로 하기 때문에 사용자 정보를 제공하지 않음\n\n| Parameter     | description                       | 필수 |\n| ------------- | --------------------------------- | ---- |\n| grant_type    | client_credentials                | o    |\n| client_id     | 권한 서버에 등록한 client id      | o    |\n| client_secret | 권한 서버로 부터 발급 된 secret값 | o    |\n| scope         |                                   | x    |\n\n### 5. Refresh token Grant Type\n\n![](RefreshToken.png)\n\n- Access Token이 만료 되었을 때 refresh Token이 유효하다면 재발급 하기 위한 용도\n\n| Parameter     | description                       | 필수 |\n| ------------- | --------------------------------- | ---- |\n| grant_type    | refresh_token                     | o    |\n| client_id     | 권한 서버에 등록한 client id      | o    |\n| client_secret | 권한 서버로 부터 발급 된 secret값 | o    |\n| refresh_token | refresh token 값                  | o    |\n\n### 6. RKCE-enhanced Authorization Code Grant Type\n\n#### PKCE(Proof Key for Code Exchange, RFC - 6749) 란?\n\n- 코드 교환을 위한 증명 키로서 CSRF 및 삽입 공격을 방지하기 위한 **Authorization Code Grant Flow 확장 버전**\n- 권한 부여 코드 요청 시 Code Verifier와 Code Challenge를 추가해 Authorization Code Grant Flow에서 Authrozization Code를 탈취 당했을 때 Access Token을 발급하지 못하도록 차단\n- 모바일 앱, 단일 페이지 앱, OAuth2 클라이언트, 클라이언트 압호를 사용하는 웹서버에서 실행되는 앱에서 사용 용\n\n[](https://tonyxu-io.github.io/pkce-generator/)\n\n# OAuth2.0 Open ID Connect\n\n> OAuth 2.0 프로토콜 위에 구축된 ID 계층으로 OAuth 2.0을 확장하여 인증 방식을 표준화 한 OAuth2.0 기반의 인증 프로토콜\n\nscope 지정 시 openid를 포함하면 OpenID Connect 사용이 가능하며 인증에 대한 정보는 ID 토큰(ID Token)이라고 하는 JSON 웹 토큰(JWT)로 반환된다.\n\nOpenID는 OAuth2.0위에서 인증을 위해 동작하는 인증 전용 프로토콜이고,\n\nOAuth2.0은 인가를 위한 프레임 워크. 즉 권한 획득이 목적이다.\n\n## OpenID Connect Discovery 1.0 Provider Metadata\n\n> OpenID Connect를 사용하기 위해 필요한 모든 엔드 포인트 및 공개 키 위치 정보를 포함하여 OpenID 공급자의 구성에 대한 클레임 집합을 나타낸다.\n\n- 검색 문서 경로 : **/.well-known/openid-configuration**\n  - 모든 인가서버에서 해당 규칙으로 구현이 되어있다.\n\nkeyCloak의 configuration 정보를 살펴보자\n\n## OpenID Connect 1.0\n\n> OpenID Connect 1.0은 OAuth 2.0 프로토콜 위에 구축된 ID 계층으로 OAuth 2.0을 확장하여 인증 방식을 표준화 한 OAuth 2.0 기반의 인증 프로토콜\n\n- scope 지정 시 “openid” 를 포함하면 OpenID Connect 사용이 가능하며 인증에 대한 정보는 ID 토큰 (ID Token )이라고 하는 JSON 웹 토큰(JWT) 으로 반환\n- OpenID Connect는 클라이언트가 사용자 ID를 확인할 수 있게 하는 보안 토큰인 ID Token 제공\n\n### ID Token\n\n- ID 토큰은 사용자가 인증 되었음을 증명하는 결과물로서 OIDC 요청 시 access token 과 함께 클라이언트에게 전달되는 토큰이다\n- ID 토큰은 JWT(JSON 웹 토큰)으로 표현되며 헤더, 페이로드 및 서명으로 구성된다\n- ID 토큰은 개인 키로 발급자가 서명하는 것으로서 토큰의 출처를 보장하고 변조되지 않았음을 보장한다.\n- 어플리케이션은 공개 키로 ID 토큰을 검증 및 유효성을 검사하고 만료여부 등 토큰의 클레임을 확인 한다\n- 클라이언트는 클레임 정보에 포함되어 있는 사용자명, 이메일을 활용하여 인증 관리를 할 수 있다\n\n### ID Token vs Access Token\n\nID Token\n\n- API 요청에 사용해서는 안되며 사용자의 신원확인을 위해 사용되어져야 한다\n- 서명이 되었기 때문에 사용자가 인증 되었음을 증명\n\nAccessToken\n\n- 인증을 위해 사용해서는 안되며 리소스에 접근하기 위해 사용되어져야 한다\n- AccessToken은 사용자가 인증을 할 수 있는 수단은 되지만, Token 자체가 인증이 되었음을 증명 할 수는 없다.\n\n### Scope\n\n| scope   | description                                                             |\n| ------- | ----------------------------------------------------------------------- |\n| openid  | 필수, 클라이언트가 OpenID Connect 요청을 하고 있음을 인증 서버에 알린다 |\n| profile | 기본 프로필 클레임에 대한 액세스 요청                                   |\n| email   | 이메일 및 email_verified 클레임에 대한 액세스 요청                      |\n| address | 주소 클레임에 대한 액세스 요청                                          |\n| phone   | phone_number 및 phone_number_verified 클레임에 대한 액세스 요청         |\n\n# Reference\n\n- [스프링 시큐리티 OAuth2 - Spring Boot 기반으로 개발하는 Spring Security OAuth2](https://www.inflearn.com/course/%EC%A0%95%EC%88%98%EC%9B%90-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0/dashboard)\n- [OAuth 2.0 동작 방식의 이해|작성자 MDS인텔리전스](https://blog.naver.com/mds_datasecurity/222182943542)\n","excerpt":"SecurityBuilder, SecurityConfigurer SecurityConfigurer Http요청과 관련된 보안 처리를 담당하는 필터들을 생성하고 인증 및 인가 초기화 작업 SecurityBuilder 빌더 클래스로 웹 보안을 구성하는 …","fields":{"slug":"/SpringSecurity2_1/"},"frontmatter":{"date":"Feb 06, 2023","title":"Spring Security OAuth2.0 개념 파악하기","tags":["Spring"],"update":"Feb 07, 2023"}}},{"node":{"rawMarkdownBody":"\n해당 포스팅은 정수원님의  \n[스프링 시큐리티 - Spring Boot 기반으로 개발하는 Spring Security](https://www.inflearn.com/course/%EC%BD%94%EC%96%B4-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0/dashboard) 강의를 참고하여 작성했습니다.\n\n강의 예제는 원리 이해하는 부분은 [springboot starter 3.0.1](https://github.com/spring-projects/spring-boot/releases/tag/v3.0.1)\n(security 6.0.1), 구현하는 부분은 Springboot 2.7.3을 사용해 진행\n\n<!-- TODO: https://lelecoder.com/140 보고 필터 관련 글 써보자 -->\n\n# 용어 정리\n\n인증 : 어떤 개체(사용자 또는 장치)의 신원을 확인하는 과정  \n인가 : 어떤 개체가 어떤 리소스에 접근할 수 있는지 또는 어떤 동작을 수행할 수 있는지를 검증하는 것, 즉 접근 권한을 얻는 일\n\n# 기본 API 및 Filter\n\n## 자동 구성 항목\n\nSpring Security 의존성 추가 시 자동 구성\n\n- 모든 요청은 인증이 되어야 접근\n- 인증 방식 Form 로그인 방식 / httpBasic 로그인 방식 제공\n- 기본 로그인 페이지 제공 (기본 계정 : id : user / password 랜덤 문자열)\n- CSRF 공격 방지\n- 세션 고정 보호\n- 보안 헤더 통합\n\n추가로 계정 추가, 권한 추가, DB연동 등 작업 필요\n\n```java\n@Configuration\n@EnableWebSecurity // WebSecurity Configuration, Web보안 활성화\npublic class SecurityConfig{\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        // 인가 정책\n        http\n                .authorizeHttpRequests((authz) -> authz // 규칙 지정\n                        .anyRequest().authenticated() // 모든 요청이 인증을 요청하게 설정\n                )\n                // 인증 정책\n                .formLogin(withDefaults());\n        return http.build();\n    }\n}\n```\n\n[http요청 승인](https://docs.spring.io/spring-security/reference/servlet/authorization/authorize-http-requests.html)\n\n설정하고 서버를 실행하면 user계정의 password가 실행 마다 변경되면서 console창에 노출이 되는데\n\napplication.properties파일에 이를 명시할 수 있다.\n\n```yml\nspring.security.user.name=user\nspring.security.user.password=1111\n```\n\n## Login Form 인증 과정\n\n![](loginFormProccess.png)\n\n1. **UsernamePasswordAuthenticationFilter** 에서 요청 ID, Password를 통해 Token을 생성한다\n\n2. 생성한 token을 **AuthenticationManager**에서 확인한다.\n\n3. 실패 시\n   3.1) [SecurityContextHolder](https://docs.spring.io/spring-security/reference/servlet/authentication/architecture.html#servlet-authentication-securitycontextholder)에서 인증 정보가 지워진다.  \n   3.2) [RememberMeServices.loginFail](https://docs.spring.io/spring-security/site/docs/6.0.1/api/org/springframework/security/web/authentication/RememberMeServices.html)이 호출된다.  \n   3.3) SecurityConfig에서 설정한 **AuthenticationFailureHandler**가 호출 된다.\n4. 성공 시  \n   4.1) **SessionAuthenticationStrategy**에 새로운 로그인을 알린다.  \n   4.2)[SecurityContextHolder](https://docs.spring.io/spring-security/reference/servlet/authentication/architecture.html#servlet-authentication-securitycontextholder)에 인증정보(username, password, authorities(사용자의 권한 정보)) 저장  \n   4.3) ApplicationEventPublisher 생성  \n   4.4) SecurityConfig에서 설정한 **AuthenticationSuccessHandler**가 호출 된다.\n\n```java\nhttp\n        .formLogin() // form 로그인 인증 기능 적용\n//                .loginPage(\"/loginPage\")\n        .defaultSuccessUrl(\"/\")\n        .failureUrl(\"/login\")\n        .usernameParameter(\"username\")\n        .passwordParameter(\"password\")\n        .loginProcessingUrl(\"/login_proc\")\n        .successHandler(new AuthenticationSuccessHandler() {\n            // 요청, 응답, 인증 객체\n            @Override\n            public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\n                System.out.println(authentication.getName());\n                response.sendRedirect(\"/\");\n            }\n        })\n        .failureHandler(new AuthenticationFailureHandler() {\n            @Override\n            public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {\n\n                response.sendRedirect(\"/login\");\n            }\n        })\n        .permitAll();\n```\n\n## Logout과정\n\nCompositeLogoutHandler의 구성을 살펴보면 logout handler로 CookieClearing, CsrfLogoutHandler, SecurityContextLogoutHandler, LogoutSuccessEventPublishingLogoutHandler이 구성되어 있다\n\nlogout시 동작을 대략적으로 정리해보면\n\n1. HTTP 세션 무효화\n2. 구성된 모든 RememberMe 인증 정리\n3. SecurityContextHolder.clearContext()\n4. 리다이렉션\n\n```java\nhttp\n        .logout()\n        .logoutUrl(\"/logout\")\n        .logoutSuccessUrl(\"login\")\n        .addLogoutHandler(new LogoutHandler() {\n            @Override\n            public void logout(HttpServletRequest request, HttpServletResponse response, authentication authentication) {\n                HttpSession session = request.getSession();\n                session.invalidate();\n            }\n        })\n        .logoutSuccessHandler(new LogoutSuccessHandler() {\n            @Override\n            public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\n                    response.sendRedirect(\"/login\");\n                }\n            })\n        .deleteCookies(\"remember-me\")\n```\n\n[Spring security logout](https://docs.spring.io/spring-security/reference/servlet/authentication/logout.html)\n\n## RememberMe 인증 (영구 로그인 인증)\n\n> **토근 기반 인증**을 사용해 세션이 만료되고 웹 브라우저가 종료된 후에도 App이 사용자를 기억하는 기능\n\nSpring Security는 2가지 방법 제공\n\n- 1. 해싱을 사용하여 쿠키 기반 토큰의 보안 유지 기능 (보통 14일)\n- 2. DB / 기타 영구 저장 매커니즘을 사용해 생성된 토큰 저장\n\n[영구 저장 토큰 방식](https://docs.spring.io/spring-security/reference/servlet/authentication/rememberme.html#remember-me-persistent-token)\n\n### 인증 과정\n\n1. 세션이 만료 되었거나, Security Context에 인증 정보가 없는 경우(인증 객체가 Null인 경우) **RememberMeAuthenticationFilter**가 탐지\n\n2. Token 일치 여부 -> User계정 확인 -> 새로운 Authentication 생성\n\n```java\nhttp\n  .rememberMe()\n  .rememberMeParameter(\"remember\") // 파라미터 변경 / 기본 파라미터 명은 remember-me\n  .tokenValiditySeconds(3600) // remeberme 시간 설정 가능 / default(14)\n  .alwaysRemember(false); // 기능이 활성화 되지 않아도 항상 리하는 것 여부 / default false\n  userDetailsService(userDetailsService); // 사용자 계정을 조회하는 과정 (필수로 설정 해야한다)\n```\n\n- rememberMeParameter 이름을 화면상의 이름과 일치 시켜 준다.\n- 사용 시 remember-me 쿠키값이 추가된다.\n\n### 정리\n\n- Remember Me기능 사용 시, 스프링 시큐리티는 인증 객체 관련 정보를 Remember Me 쿠키에 저장한 후 사용자에게 전달\n- Remember Me 쿠키가 유효하면 JSESSIONID가 없어도 Remember Me 쿠키를 통해 로그인 처리\n\n## 익명사용자 필터\n\n> AnonymousAuthenticationFilter가 처리 하는데, 익명 사용자와 인증 사용자를 구분해서 처리하기 위한 용도\n\nAuthentication을 검사하고 사용자의 Authentication정보가 아니라면 AnonymousAuthenticationToken을 생성 후 SecurityContext에 넣는다.\n\n- 화면에서 인증 여부를 구현할 때 isAnonymous()와 isAuthenticated()로 구분해서 사용\n- 인증 객체를 세션에 저장하지 않는다.\n- 사용자가 인증을 받지 않았으면 인증되지 않은 사용자의 토큰을 만들어 인증된 사용자와 구분하기 위한 용도\n\n잠시 정리를 해보면 Spring Security는 기본적으로  \n**SecurityContextHolder 내부의 SecurityContext에 인증정보가 담긴 Authentication 객체 값이 존재**  \n해야 하는 구조로 **익명 사용자라 할지라도 Authentication 객체가 null이 아니다**\n\n## 동시 세션 제어\n\n> 동일한 계정으로 접속했을 때 만들어지는 세션을 제어하는 방법\n\n1. 이전 사용자 세션 만료\n\n   > 동일 계정으로 누군가 로그인 했을 때, 이전에 사용하던 사용자의 세션을 만료\n\n2. 현재 사용자 인증 실패\n   > 이미 동일 계정으로 접속하고 있는 사람이 있을 경우, 현재 인증 요청한 사용자의 인증 과정에서 인증 예외 처리\n\n```java\n// 동시 세션 제어\nhttp\n        .sessionManagement()\n        .maximumSessions(1)                 // 최대 허용 가능 세션 수 (1) , -1 -> 무제한 로그인 세션 허용\n        .maxSessionsPreventsLogin(false)    // true : 현재 사용자 인증 실패, false : 기존 사용자 인증 실패\n//      .invalidSessionUrl(\"/invalid\")      // 세션이 유효하지 않을 경우 이동 할 페이지\n        .expiredUrl(\"/expired\");            // 세션이 만료 된 경우 이동 할 페이지\n```\n\n## 세션 고정 보호\n\n```java\n// 세션 고정 보호\nhttp\n        .sessionManagement()    // 세션 관리 설정 모드 사용.\n        .sessionFixation()\n            .changeSessionId(); // 기존 사용자의 세션에 Session ID만 변경\n//          .none();            //세션 고정 보호를 하지 않음.\n//          .newSession()       // 인증 성공 시 새로운 세션 사용\n```\n\n## 세션 정책\n\n> 세션 생성, 사용 여부를 설정 가능 (ALWAYS, IF_REQUIRED, NEVER, STATELESS)\n\n```java\n// 세션 정책\nhttp\n        .sessionManagement()\n//      .sessionCreationPolicy(SessionCreationPolicy.ALWAYS);     // Spring Security가 항상 세션 설정\n        .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED);  // 필요 시 생성(default)\n//      .sessionCreationPolicy(SessionCreationPolicy.NEVER);      // 생성x, 존재하면 사용\n//      .sessionCreationPolicy(SessionCreationPolicy.STATELESS);  // 생성x, 존재해도 사용x (JWT 사용 시)\n```\n\n## SessionManagementFilter, ConcurrentSessionFilter\n\nSessionManagementFilter는\n\n- 동시 세션 제어\n- 세션 고정 보호\n- 세션 관리\n- 세션 생성 정책 설정\n\n4가지 기능을 수행하는데 동시 세션을 관리하는데 있어서 ConcurrentSessionFilter의 도움을 받는다.\n\n**사용자 요청이 들어올 때 마다, ConcurrentSessionFilter를 통해 매번 세션이 만료되었는지 확인**\n-> 만료 되었으면 **1. 로그아웃, 2. 세션 만료를 사용자에게 알림**\n\n## 권한 설정과 표현식\n\n> URL과 Method에 대해 권한 설정\n\n### 선언적 방식\n\n> URL과 Method 방식 존재\n\n#### 1. URL\n\n> HttpSecurity 객체를 사용해 설정\n\n```java\nhttp\n    .requestMatchers(\"/users/**\").hasRole(\"USER\");\n```\n\n<details>\n<summary><b>Http 객체 설정 (Toggle)</b></summary>\n\n| Method                     | Describe                                                                              |\n| -------------------------- | ------------------------------------------------------------------------------------- |\n| hasRole(String)            | 사용자가 주어진 역할이 있다면 접근 허용                                               |\n| hasAuthority(String)       | 사용자가 주어진 권한이 있다면 접근 허용 ex) hasAuthority('read')                      |\n| hasAnyRole(String...,)     | 사용자가 주어진 권한이 있다면 접근 허용. (하나라도 있으면 , 로 구분)                  |\n| hasAnyAuthority(String...) | 사용자가 주어진 권한 중 어떤 것이라도 있따면 접근 허용                                |\n| hasIpAddress(String)       | 주어진 IP로부터 요청이 온 경우 접근 허용                                              |\n| permitAll()                | 모든 요청 허용                                                                        |\n| denyAll()                  | 모든 요청 접근 차단                                                                   |\n| isAuthenticated()          | 로그인 인증을 받은 사용자는 권한에 관계 없이 허용, 익명 사용자는 로그인 페이지로 이동 |\n| isFullyAuthenticated()     | 자동 로그인하지 않고 로그인 인증을 한 사용자는 권한에 관계 없이 허용                  |\n| isAnonymous()              | 권한이 없는 익명의 사용자만 접근을 허용함 (로그인되어 권한이 있으면 접근 불가)        |\n| isRememberMe()             | 자동 로그인 대상 사용자의 경우 접근을 허용                                            |\n\n</details>\n\n</br>\n\n#### Method\n\n> @Pre and @Post Annotations 어노테이션을 이용해 권한 설정\n\n[@Pre and @Post Annotations doc](https://docs.spring.io/spring-security/reference/servlet/authorization/expression-based.html#_method_security_expressions)\n\n### 2. 동적 방식 (DB연동)\n\n뒤에서 설명\n\n### 주의 사항\n\n- 경로 표현을 생략하는 경우 **모든 요청은 인증을 받아야 접근 가능**\n- 구체적인 경로는 앞에 작성, 뒤로 갈 수록 큰 범위의 경로 설정\n- 하위 경로 표현 시 \\*\\*로 표현\n\n## 예외 처리 및 요청 캐시 필터\n\n> 에러 처리 기능은 **ExceptionTranslationFilter()**가 처리\n\n- AuthenticationException -> 인증 예외 / AccessDeniedException -> 인가 예외\n- RequestCache -> 사용자의 요청 정보 세션에 저장\n- SavedRequest -> 사용자의 request 파라미터, 헤더값 등 저장\n\n```java\nSavedRequest savedRequest = requestCache.getRequest(request, response);\n```\n\n### AuthenticationException\n\n```java\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        ...\n        http\n                .exceptionHandling()\n                .authenticationEntryPoint(new AuthenticationEntryPoint() {\n                    @Override\n                    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {\n                        response.sendRedirect(\"/login\");\n                    }\n                })\n                .accessDeniedHandler(new AccessDeniedHandler() {\n                    @Override\n                    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException {\n                        response.sendRedirect(\"denied\");\n                    }\n                });\n\n    }\n```\n\n## CSRF처리\n\n> Spring Security는 기본적으로 CSRF 사용 설정이 되어있으며, X-CSRF-TOKEN값을 헤더에 추가한다\n\nview template, Spring form 태그 사용 시 csrf토큰이 자동으로 설정\n\n기본적인 폼태그 사용할 땐 \\_csrf 값으로 추가\n\n# 주요 아키텍처\n\n![](DelegatingFilterAndFilterChainProxy.png)\n\n#### Servlet Container\n\n- **SecurityFilterAutoConfiguration**에서 springSecurityFilterChain을 가져올 수 있게 DelegatingFilterProxy가 생성\n\n#### Spring Container\n\n- **WebSecurityConfiguration** 클래스에서 WebSecurity 클래스가 **springSecurityFilterChain이름으로 생성된 Bean들을 FilterChainProxy로 생성**시켜 준다.\n\n**모든 요청은 DelegatingFilterProxy에서 시작**\n\n## DelegatingFilterProxy\n\nFilter는 Servlet 2.3에서 부터 제공되는 기술로  \n**서블렛을 통해 어떤 요청이 들어올 때 서블릿 자원에 들어오기 전에 처리**  \n즉, 요청에 대한 최종 접근 전, 후로 처리할 수 있게 하는 것이다.\n\n이 필터는 서블릿 스펙의 기술이며 Servlet 컨테이너에서 생성되고, 실행이 되기 때문에  \nSpring에서 만든 Bean을 Injection 해서 사용할 수 없다.\n\nSpring이 사용하는 기능을 사용하기 위해\n\n**DelegatingFilterProxy**는 **ApplicationContext**에서  \n**springSecurityFilterChain이름을 가진 스프링 빈(FilterChainProxy)을 찾아서 그 빈에게 요청을 위임**한다\n\n## FilterChainProxy\n\n![](filterChainProxy.png)\n\n1. springSecurityFilterChain의 이름으로 생성되는 필터 빈\n2. DelegatingFilterProxy로 부터 요청을 위임받고 실제 보안 처리\n3. SpringSecurity 초기화 시 생성되는 필터들을 관리하고 제어\n4. 사용자 요청을 필터 순서대로 호출하여 전달\n5. 모든 Filter를 통과 시 보안 처리 완료\n\n## Filter 초기화 다중 보안 설정\n\n> 여러개의 SecurityFilterChain 클래스를 만들어 url에 따라 다른 보안 정책이 적용될 수 있게 설정하면 WebSecurity에서 FilterChainProxy가 만들어 질 때 url에 따라 다른 정책이 적용될 수 있게 filter chain이 생성된다.\n\n```java\n    @Bean\n    @Order(1)\n    public SecurityFilterChain apiFilterChain(HttpSecurity http) throws Exception {\n        http\n                .securityMatcher(\"/api/**\")\n                .authorizeHttpRequests(authorize -> authorize\n                        .anyRequest().hasRole(\"ADMIN\")\n                )\n                .httpBasic(withDefaults());\n        return http.build();\n    }\n\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        ...\n    }\n```\n\n![](securityFilterChains.png)\n\n[multiple-httpsecurity- instances - Spring Security Doc](https://docs.spring.io/spring-security/reference/servlet/configuration/java.html#_multiple_httpsecurity_instances)\n\n## 인증(Authentication)\n\n> 어떤 개체(사용자 또는 장치)의 신원을 확인하는 과정\n\n[인증 흐름](#login-form-%EC%9D%B8%EC%A6%9D-%EA%B3%BC%EC%A0%95)과 같이 진행이 되고 생성되는 Authentication Token의 구조를 살펴보면\n\n1. principal : 사용자 ID 또는 User객체\n2. credentials : 사용자 비밀번호, 대부분의 경우에 인증된 후 값이 지워져서 유출되지 않는다.\n3. authorities : 인증된 사용자의 권한 목록\n4. details : 인증 부가 정보\n5. Authenticated : 인증 여부\n\n로 이루어져 있다.\n\nUsernamePasswordAuthenticationFilter -> Authentication 객체  \n-> AuthenticationManager의 구현체 ProviderManager가 인증 처리\n\n### SecurityContext\n\n> 필요 시 언제든지 Authentication 객체를 꺼내 쓸 수 있게 저장되는 저장소\n\n- ThreadLocal에 저장되어 아무 곳에서나 참조 가능\n- 인증 완료 시, Httpsession에 저장 (App내 전역적인 참조 가능)\n\n### SecurityContextHolder\n\n> SecurityContext를 감싸고 있는 wrapper 클래스\n\n- SecurityContext객체 저장 방식\n  - MODE_THREADLOCAL : 스레드 당 SecurityContext 객체 할당 (default)\n  - MODE_INHERITABLETHREADLOCAL : 메인 스레드와 자식 스레드에 관하여 동일한 SecurityContext를 유지\n  - MODE_GLOBAL : 응용 프로그램에서 단 하나의 SecurityContext저장 (static 변수로)\n\n![](SecurityContextHolderFlow.png)\n\n- ThreadLocal에 SecurityContextHolder를 담고 있다.\n- HttpSession에 SPRING_SECURITY_CONTEXT이름으로 저장\n\nSecurityContextHolder에서 인증정보 가져오는 방법\n\n```java\nAuthentication authentication = SecurityContextHolder.getContext().getAuthentication();\n```\n\n### SecurityPersistenceFilter\n\n> SecurityContext 객체의 생성, 저장, 조회\n\n- 여러 필터들이 Authentication 객체를 쓸 수 있도록 하기 위해서 SecurityContextPersistenceFilter는 2번째에 위치\n- SecurityContextPersistenceFilter에서 인증 전인지, 인증 후인지를 판단 SecurityContext에 Authentication 객체 존재 유무 결정\n\n#### 익명 사용자\n\n- 새로운 SecurityContext 객체를 생성하여 SecurityContextHolder에 저장\n- AnonymouseAuthenticationFilter에서 AnonymousAuthenticationToken 객체를 SecurityContext에 저장\n\n#### 인증 시\n\n- 새로운 SecurityContext객체를 생성하여 SecurityContextHolder에 저장\n- UsernamePasswordAuthenticationFilter에서 인증 성공 후 SecurityContext 에 UsernamePasswordAuthentication 객체를 SecurityContext에 저장\n- 인증이 최종 완료되면 Session 에 SecurityContext를 저장\n\n#### 인증 후\n\n- Session에서 SecurityContext 꺼내 SecurityContextHolder에서 저장\n- SecurityContext안에 Authentication 객체가 존재하면 계속 인증을 유지\n\n#### 최종 응답 시 공통\n\n- SecurityContextHolder안의 SecurityContext객체에서 보관하던 인증정보 반드시 초기화\n- 초기화 시 SecurityContextHolder.clearContext() 사용\n\n#### SecurityPersistenceFilter Flow\n\n![](SecurityPersistenceFilter.png)\n\n1. FilterChainProxy에 2번째 위치하며 모든 요청에서 수행\n2. 내부적으로 HttpSecurityContextRepository가 SecurityContext객체 생성, 조회하는 역할을 하는 로직 수행  \n   a. 인증 전\n\n   - 새로운 컨텍스트 생성 (SecurityContext는 null)\n   - 인증 필터(AuthFilter)가 인증 처리\n   - 인증객체(Authentication)생성 후 SecurityContext 객체안에 저장\n   - Session에 SecurityContext저장\n\n   b. 인증 후\n\n   - Session에서 SecurityContext가 있는지 확인\n   - SecurityContext를 꺼내 SecurityContextHolder에 저장\n\n### 인증 흐름 (Authentication Flow)\n\n![](AuthenticationFlow.png)\n\n1. UsernamePasswordAuthenticationFilter는 요청을 가로채서 Authentication(인증정보) 생성\n2. AuthenticationManager는 적절한 Provider를 찾아 인증 처리 위임\n3. AuthenticationProvider는 실제 ID/PW 인증 처리를 하는데 ID의 경우 UserDetailsService를 사용해 조회 -> 조회 한 UserDetails 정보로 PW 검증\n4. AuthenticationProvider는 인증 성공 후 유저정보(UserDetails) + 권한 정보(authorities) 담아 토큰 생성\n5. UsernamePasswordAuthenticationFilter가 인증 객체를 전달 받아 SecurityContext에 인증 정보 저장\n\n### AuthenticationManager\n\n![](AuthenticationManager.png)\n\n> AuthenticationProvider 목록 중에서 인증 처리 요건에 맞는 AuthenticationProvider를 찾아 인증 처리 위임\n\n- AuthenticationManager 는 인터페이스로 실제 구현체는 **ProviderManager**\n- ProviderManager에 인증 처리 요건에 맞는 것이 없을 경우 부모 ProviderManager에서 탐색 후 처리\n\n### AuthenticationProvider\n\n![](AuthenticationProvider.png)\n\n- AuthenticationProvider 는 인터페이스로 2개의 메서드 존재\n  - authenticate(authentication) : 실제적인 인증처리를 위한 검증 메서드\n  - supports(authentication): 인증처리가 가능한 Provider인지 검사하는 메서드\n- 아이디 검증\n\n  - 존재 -> UserDetails 반환 / 존재 x -> UserNotFoundException\n\n- 패스워드 검증\n\n  - 반환된 UserDetails에 저장된 password와 로그인시 입력한 패스워드(authentication.password)가 일치하는지 비교\n  - 일치하지 않을 경우 BadCredentialException 발생\n  - 일반적으로 패스워드를 저장할 때 Password Encoder를 이용해 암호화 하여 저장하기 때문에 해당 클래스(PasswordEncoder)를 이용해 두 암호를 비교\n\n- 추가 검증\n  - 추가적으로 사용자가 정의한 검증 조건 검증\n  - 검증이 모두 성공하면 최종적으로 인증객체를 생성 후 AuthenticationManager에 전달\n\n## 인가(Authorization)\n\n> 어떤 개체가 어떤 리소스에 접근할 수 있는지 접근 권한 할당\n\n### 시큐리티가 지원하는 권한 계층\n\n- 웹 계층 : URL요청에 따른 메뉴 혹은 화면단위의 레벨 보안\n- 서비스 계층 : 메소드 같은 기능 단위의 레벨 보안\n- 도메인 계층 : 객체 단위의 레벨 보안\n\n### AuthorizationFilter\n\n> 마지막에 위치한 필터로 승인, 거부를 최종적으로 결정\n\n![](FilterSecurityInterceptor.png)\n\n- 인증객체 없이 보호자원에 접근을 시도하면 AuthenticationException 발생\n- 인증 후 자원에 접근 가능한 권한이 존재하지 않을 경우 AccessDeniedException 을 발생\n- HTTP 자원의 보안을 처리하는 필터 (URL방식으로 접근 할 경우 동작)\n- 권한 처리를 AccessDecisionManager에게 맡김\n\n### AccessDecisionManager\n\n> 인증,요청,권한 정보를 이용해서 사용자의 자원접근을 허용/거부 여부를 최종 결정하는 주체\n\n- 여러 개의 Voter들을 가질 수 있고, Voter들로부터 접근허용, 거부, 보류에 해당하는 각각의 값을 리턴받아 판단, 결정\n\n#### 접근결정의 세 가지 유형 (구현체)\n\n1. AffirmativeBased : OR 연산자와 같은 논리\n2. ConsensusBased : 다수결\n3. UnanimousBased : AND 연산자와 같은 논리\n\n권한 부여 과정에서 판단하는 값 (3가지)\n\n- Authenticaion - 인증정보(user)\n- FilterInvocator - 요청 정보(requestMatchers(\"/user\"))\n- ConfigAttributes - 권한 정보(hasRole(\"USER\"))\n\n```java\nhttp\n    .authorizeHttpRequests((authz) -> authz // 규칙 지정\n            .requestMatchers(\"/user\").hasRole(\"USER\")\n            .requestMatchers(\"/admin/pay\").hasRole(\"ADMIN\")\n            .requestMatchers(\"/admin/**\").hasAnyRole(\"ADMIN\", \"SYS\")\n            .anyRequest().authenticated() // 모든 요청이 인증을 요청하게 설정\n    );\n```\n\n## 정리\n\n![](flow.png)\n\n### 초기화\n\n1. Security가 초기화 될 때 Security Config 구성대로 생성 된 Filters를 **WebSecurity가 FilterChainProxy 생성** (springSecurityFilterChain 이름을 가진다)\n\n2. **DelegatingFilterProxy**가 springSecurityFilterChain이름을 가진 **FilterChainProxy를 찾아 요청을 위임**한다.\n\n### 인증\n\n3. **SecurityPersistenceFilter**가 SecurityContext가 있는지 확인 후, 없으면 **Authentication 객체 생성 후 SecurityContext에 저장**\n\n4. Logout 요청이 없는경우 특별한 동작 x\n\n5. **UsernamePasswordAuthenticationFilter**에서 UserDetailsService로 **ID, PW 검사 후 인증 정보를 더해 SecurityContext에 저장**\n\n6. 인증 성공 시 뒤에있는 Session ManagementFilter 과정도 동시에 처리, **동시 세션에 대한 처리**한다\n\n7. **사용자가 정의한 SuccessHandler 작업 수행, 특정한 경로로 리다이렉트**\n\n8. 다시 요청이 들어와서 SecurityContextPersistenceFilter가 ContextHolder에서 loadContext 후 진행\n\nConcurrentSessionFilter ~ SessionManagementFilter는 해당사항이 있을 경우만 진행\n\n### 인가\n\n9. ExceptionTranslationFilter로 감싸 FilterSecurityInterceptor 인가 필터가 인증 객체부터 검사\n\n10. AccessDecisionManager가 실행\n\n# 인증 구현\n\n## 정적자원 관리\n\n> WebIgnore 설정 시 js, css, image같은 정적 자원들을 보안 필터에서 예외시킨다.\n\n```java\n// SecurityConfig\n\n@Override\npublic void configure(WebSecurity web) throws Exception {\n   web.ignoring().requestMatchers(PathRequest.toStaticResources().atCommonLocations());\n}\n```\n\n![](webIgnore.png)\n\n## PasswordEncoder\n\n> 비밀번호를 안전하게 암호화\n\n기본 타입 : bcrypt\n\n![](passwordEncoder.png)\n\n## UserDetails\n\n> Spring Security에서 사용자의 정보를 담는 인터페이스\n\n```java\n\n// Account, AccountDto 생성\n@Getter\n@Entity\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\npublic class Account implements UserDetails, Serializable {\n    ...\n}\n\n// UserService상속받아 구현체 생성\n@Slf4j\n@Service(\"userService\")\npublic class UserServiceImpl implements UserService {\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @Autowired\n    private RoleRepository roleRepository;\n\n    @Autowired\n    private PasswordEncoder passwordEncoder;\n\n    @Transactional\n    @Override\n    public void createUser(Account account) {\n\n        Role role = roleRepository.findByRoleName(\"ROLE_USER\");\n        Set<Role> roles = new HashSet<>();\n        roles.add(role);\n        account.setUserRoles(roles);\n        userRepository.save(account);\n    }\n    ...\n}\n```\n\n[UserDetails](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/core/userdetails/UserDetails.html), Serializable을 상속해 확장 가능\n\n| 메소드                    | 리턴 타입                              | 설명                                                           | 기본값               |\n| ------------------------- | -------------------------------------- | -------------------------------------------------------------- | -------------------- |\n| getAuthorities()          | Collection<? extends GrantedAuthority> | 계정의 권한 목록을 리턴                                        |                      |\n| getPassword()             | String                                 | 계정의 비밀번호를 리턴                                         |                      |\n| getUsername()             | String                                 | 계정의 고유한 값을 리턴( ex : DB PK값, 중복이 없는 이메일 값 ) |                      |\n| isAccountNonExpired()     | boolean                                | 계정의 만료 여부 리턴                                          | true ( 만료 안됨 )   |\n| isAccountNonLocked()      | boolean                                | 계정의 잠김 여부 리턴                                          | true ( 잠기지 않음 ) |\n| isCredentialsNonExpired() | boolean                                | 비밀번호 만료 여부 리턴                                        | true ( 만료 안됨 )   |\n| isEnabled()               | boolean                                | 계정의 활성화 여부 리턴                                        | true ( 활성화 됨 )   |\n\n- [getUsername() 사용 시 SSO 같은 서버를 만들게 되면 정책에 따라서 중복이 될 수도 있기에 주의](https://programmer93.tistory.com/68)\n- 사용한 Account 엔티티는 반드시 [직렬화(Serializable)](https://devlog-wjdrbs96.tistory.com/268)\n\n## CustomUserDetailsService(DB 연동 구현)\n\n> 사용자 이름, 암호 및 사용자 이름과 암호로 인증하기 위한 기타 속성을 검색하는 데 사용\n\n- UserDetailsService을 상속받아 loadUserByUsername을 구현\n- 1. ID 존재 여부 확인, 2) User 권한 확인 후 security.core.userdetails.User를 상속받은 AccountContext({유저 정보}, 권한)으로 리턴\n- 권한 정보는 **GrantedAutority타입**으로 담아야 함\n- AccountContext를 확장해서 사용 시 정의한 클래스로 객체 생성해 반환\n\n```java\n// AccountContext\n// UserDetails 타입으로 계정에 관한 정보를 넣어주어야 스프링 시큐리티가 요구하는 스펙(인증 메서드를 사용하기 위한 인자 조건)을 맞출 수 있다\n@Data\npublic class AccountContext extends User {\n    private Account account;\n\n    public AccountContext(Account account, List<GrantedAuthority> roles) {\n        super(account.getUsername(), account.getPassword(), roles);\n        this.account = account;\n    }\n}\n\n// UserDetailsServiceImpl\n@Slf4j\n@Service(\"userDetailsService\")\npublic class UserDetailsServiceImpl implements UserDetailsService {\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @Autowired\n    private HttpServletRequest request;\n\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n\n        Account account = userRepository.findByUsername(username);\n        if (account == null) {\n            if (userRepository.countByUsername(username) == 0) {\n                throw new UsernameNotFoundException(\"No user found with username: \" + username);\n            }\n        }\n        Set<String> userRoles = account.getUserRoles()\n                .stream()\n                .map(userRole -> userRole.getRoleName())\n                .collect(Collectors.toSet());\n\n        List<GrantedAuthority> collect = userRoles.stream().map(SimpleGrantedAuthority::new).collect(Collectors.toList());\n        return new AccountContext(account, collect);\n    }\n}\n```\n\n## Form인증 구현\n\n### CustomAuthenticationProvider\n\n> CustomUserDetailsService에서 만든 AccountContext를 검증\n\n구현\n\n1. **AuthenticationProvider** 클래스를 상속받아 인증 절차를 수행하는 authenticate, supports 함수 구현\n2. Security Config 파일에서 authenticationProvider bean 등록\n3. Security Config 파일에서 2에서 생성한 **빈 객체**를 **configure** 설정으로 전달\n\n특징\n\n- supports 함수는 Authentication 객체를 이 AuthenticationProvider가 인증 가능한 클래스인지 확인\n- supports를 통과한 뒤 authenticate 메서드가 호출\n- 만약 JWT token을 사용하고, DB에 저장하고 있다면 이런 정보를 추가로 Token에 담아 전달 가능\n\n```java\n// FormAuthenticationProvider\n@Slf4j\npublic class FormAuthenticationProvider implements AuthenticationProvider {\n\n    @Autowired\n    private UserDetailsService userDetailsService;\n\n    private PasswordEncoder passwordEncoder;\n\n    public FormAuthenticationProvider(PasswordEncoder passwordEncoder) {\n        this.passwordEncoder = passwordEncoder;\n    }\n\n    @Override\n    @Transactional\n    public Authentication authenticate(Authentication authentication) throws AuthenticationException {\n\n        String loginId = authentication.getName();\n        String password = (String) authentication.getCredentials();\n\n        AccountContext accountContext = (AccountContext) userDetailsService.loadUserByUsername(loginId);\n\n        if (!passwordEncoder.matches(password, accountContext.getPassword())) {\n            throw new BadCredentialsException(\"Invalid password\");\n        }\n\n        String secretKey = ((FormWebAuthenticationDetails) authentication.getDetails()).getSecretKey();\n        if (secretKey == null || !secretKey.equals(\"secret\")) {\n            throw new IllegalArgumentException(\"Invalid Secret\");\n        }\n\n        return new UsernamePasswordAuthenticationToken(accountContext.getAccount(), null, accountContext.getAuthorities());\n    }\n\n    @Override\n    public boolean supports(Class<?> authentication) {\n        return authentication.equals(UsernamePasswordAuthenticationToken.class);\n    }\n\n}\n\n// SecurityConfig.java\n@Override\nprotected void configure(AuthenticationManagerBuilder auth) throws Exception {\n    auth.authenticationProvider(authenticationProvider());\n}\n\n@Bean\npublic AuthenticationProvider authenticationProvider() {\n    return new FormAuthenticationProvider(passwordEncoder());\n}\n\n@Override\npublic AuthenticationManager authenticationManagerBean() throws Exception {\n    return super.authenticationManagerBean();\n}\n\n```\n\n추가로 AuthenticationManager를 외부에서 사용하기 위한 설정은 AuthenticationManagerBean 을 이용하여 Sprint Securtiy 밖으로 AuthenticationManager 빼 내야 한다.\n\n#### UserDetails 정보 확장\n\n예제에선 secret_key를 추가로 받아 인증과정에 추가\n\n- Details를 담는 AuthenticationDetailsSource 작성\n- WebAuthenticationDetails\n\n```java\n@Component\npublic class FormAuthenticationDetailsSource implements AuthenticationDetailsSource<HttpServletRequest, WebAuthenticationDetails> {\n    @Override\n    public WebAuthenticationDetails buildDetails(HttpServletRequest context) {\n        return new FormWebAuthenticationDetails(context);\n    }\n}\n\n//사용자가 전달하는 추가적인 파라미터들을 저장\npublic class FormWebAuthenticationDetails extends WebAuthenticationDetails {\n\n    private String secretKey;\n\n    public FormWebAuthenticationDetails(HttpServletRequest request) {\n        super(request);\n        secretKey = request.getParameter(\"secret_key\");\n    }\n\n    public String getSecretKey() {\n        return secretKey;\n    }\n}\n\n// config 추가\nhttp.authenticationDetailsSource(authenticationDetailsSource)\n```\n\n### Login, Logout 처리 및 핸들러 구현\n\n1. login 설정\n\n```java\nhttp\n    .formLogin()\n    .loginPage(\"/login\") // 사용자 정의 로그인 페이지, default: /login\n    .loginProcessingUrl(\"/login\") // 로그인 Form Action Url, default: /login\n    .defaultSeccessUrl(\"/\")\n    .permitAll()\n```\n\n[loginProcessingUrl은 Spring Security가 Form인증을 처리할 경로로 Spring MVC 및 컨트롤러에 요청을 전달하지 않는다.](https://stackoverflow.com/questions/53140629/spring-security-loginpage-vs-loginprocessingurl)\n\n2.  logout\n\n    1. view source에서 logout\n    2. session 해제 Controller 구현 - SecurityContextHolder에서 context를 직접 가져와 해제해준다.\n\n    ```java\n    @GetMapping(value = \"/logout\")\n    public String logout(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n        if (authentication != null) {\n            new SecurityContextLogoutHandler().logout(request, response, authentication);\n        }\n\n        return \"redirect:/login\";\n    }\n    ```\n\n3.  인증 성공 handler 구현\n\nSimpleUrlAuthenticationSuccessHandler 을 상속받아 구현 - 인증 성공 후 페이지 이동 기능 구현\n\n```java\n@Component\n@Slf4j\npublic class FormAuthenticationSuccessHandler extends SimpleUrlAuthenticationSuccessHandler {\n\n    private RequestCache requestCache = new HttpSessionRequestCache();\n\n    private RedirectStrategy redirectStrategy = new DefaultRedirectStrategy();\n\n    @Override\n    public void onAuthenticationSuccess(final HttpServletRequest request, final HttpServletResponse response, final Authentication authentication) throws IOException {\n\n        setDefaultTargetUrl(\"/\");\n\n        SavedRequest savedRequest = requestCache.getRequest(request, response);\n\n        if (savedRequest != null) {\n            String targetUrl = savedRequest.getRedirectUrl();\n            redirectStrategy.sendRedirect(request, response, targetUrl);\n        } else {\n            redirectStrategy.sendRedirect(request, response, getDefaultTargetUrl());\n        }\n    }\n}\n```\n\n4.  인증 실패 handler 구현\n\nSimpleUrlAuthenticationFailureHandler 상속 받아 구현 - exception이 난 경우 에러 처리 구현\n\n```java\n@Component\npublic class FormAuthenticationFailureHandler extends SimpleUrlAuthenticationFailureHandler {\n\n    private RedirectStrategy redirectStrategy = new DefaultRedirectStrategy();\n\n    @Override\n    public void onAuthenticationFailure(final HttpServletRequest request, final HttpServletResponse response, final AuthenticationException exception) throws IOException, ServletException {\n\n        String errorMessage = \"Invalid Username or Password\";\n\n        if (exception instanceof BadCredentialsException) {\n            errorMessage = \"Invalid Username or Password\";\n        } else if (exception instanceof DisabledException) {\n            errorMessage = \"Locked\";\n        } else if (exception instanceof CredentialsExpiredException) {\n            errorMessage = \"Expired password\";\n        }\n\n        setDefaultFailureUrl(\"/login?error=true&exception=\" + errorMessage);\n\n        super.onAuthenticationFailure(request, response, exception);\n\n    }\n}\n```\n\n5.  인증 거부 처리\n\n> 인증은 성공 했지만 권한이 없는 경우\n\nAccessDeniedHandler 을 상속받아 구현한다.\n\n- 인가 예외는 AbstractSecurityInterceptor에서 발생\n- exception 처리는 ExceptionTranslationFilter의 AccessDeniedHandler에서 처리\n\n```java\n@Component\npublic class FormAccessDeniedHandler implements AccessDeniedHandler {\n\n    private String errorPage;\n\n    private ObjectMapper mapper = new ObjectMapper();\n\n    private RedirectStrategy redirectStrategy = new DefaultRedirectStrategy();\n\n    @Override\n    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException {\n\n        if (WebUtil.isAjax(request)) {\n            response.setContentType(MediaType.APPLICATION_JSON_VALUE);\n            response.getWriter().write(this.mapper.writeValueAsString(ResponseEntity.status(HttpStatus.FORBIDDEN)));\n\n        } else {\n            String deniedUrl = errorPage + \"?exception=\" + accessDeniedException.getMessage();\n            redirectStrategy.sendRedirect(request, response, deniedUrl);\n        }\n    }\n\n    public void setErrorPage(String errorPage) {\n        if ((errorPage != null) && !errorPage.startsWith(\"/\")) {\n            throw new IllegalArgumentException(\"errorPage must begin with '/'\");\n        }\n\n        this.errorPage = errorPage;\n    }\n\n}\n\n```\n\n## Ajax 인증\n\n![](AjaxAuthentication.png)\n\nAjaxAuthenticationFilter -> AjaxAuthenticationToken -> AuthenticationManager -> AjaxAuthenticationProvider 순으로 인증처리 흐름\n\n### 1. Ajax 요청 처리 할 Filter 추가\n\n> **AbstractAuthenticationProcessingFilter**을 상속받아 **AjaxAuthenticationFilter** 구현\n\n- AbstractAuthenticationProcessingFilter는 Form 로그인에서 UsernamePassowordAuthenticationFilter가 상속받던 부모 객체로, 맨 처음 인증 처리를 해주는 Filter 추상 클래스이다.\n- **필터 적용 조건 1) url 요청 정보 매칭, 2) 헤더에 X-Requested-With으로 Ajax요청 확인**\n- ObjectMapper을 이용해 request.getReader()로 요청 정보를 읽어서 AccountDto로 매핑\n- AjaxAuthenticationToken에 담아 AuthenticationManager의 authenticate 인증 메서드로 전달하여 인증 처리\n\n```java\npublic class AjaxLoginProcessingFilter extends AbstractAuthenticationProcessingFilter {\n\n    private ObjectMapper objectMapper = new ObjectMapper();\n\n    public AjaxLoginProcessingFilter() {\n        super(new AntPathRequestMatcher(\"/ajaxLogin\", \"POST\"));\n    }\n\n    @Override\n    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response)\n            throws AuthenticationException, IOException {\n\n        if (!HttpMethod.POST.name().equals(request.getMethod()) || !WebUtil.isAjax(request)) {\n            throw new IllegalArgumentException(\"Authentication method not supported\");\n        }\n\n        AccountDto accountDto = objectMapper.readValue(request.getReader(), AccountDto.class);\n\n        if (StringUtils.isEmpty(accountDto.getUsername()) || StringUtils.isEmpty(accountDto.getPassword())) {\n            throw new AuthenticationServiceException(\"Username or Password not provided\");\n        }\n        AjaxAuthenticationToken token = new AjaxAuthenticationToken(accountDto.getUsername(), accountDto.getPassword());\n\n        return this.getAuthenticationManager().authenticate(token);\n    }\n}\n```\n\n### 2. AjaxAuthenticationToken객체 생성\n\n> 인증 정보를 담는 Token 객체 생성, Token 객체를 공통으로 구현하는 AbstractAuthenticationToken 추상 클래스를 상속해 구현\n\n- oken의 구성정보를 직접 손댈 필요는 없기 때문에, UsernamePasswordAuthenticationToken.class의 내용을 그대로 복사\n\n```java\npublic class AjaxAuthenticationToken extends AbstractAuthenticationToken {\n\n    private final Object principal;\n    private Object credentials;\n\n    public AjaxAuthenticationToken(Object principal, Object credentials) {\n        super(null);\n        this.principal = principal;\n        this.credentials = credentials;\n        setAuthenticated(false);\n    }\n\n    public AjaxAuthenticationToken(Object principal, Object credentials, Collection<? extends GrantedAuthority> authorities) {\n        super(authorities);\n        this.principal = principal;\n        this.credentials = credentials;\n        super.setAuthenticated(true);\n    }\n\n    @Override\n    public Object getCredentials() {\n        return this.credentials;\n    }\n\n    @Override\n    public Object getPrincipal() {\n        return this.principal;\n    }\n}\n\n```\n\n추가로 설정한 Filter를 사용하기 위해선 AuthenticationManager에 등록(set) 시켜야 한다.\n\n```java\n// AuthenticationManager bean override\n@Override\npublic AuthenticationManager authenticationManagerBean() throws Exception {\n    return super.authenticationManagerBean();\n}\n\n@Bean\npublic AjaxLoginProcessingFilter ajaxLoginProcessingFilter() throws Exception {\n    AjaxLoginProcessingFilter ajaxLoginProcessingFilter = new AjaxLoginProcessingFilter();\n    ajaxLoginProcessingFilter.setAuthenticationManager(authenticationManagerBean()); // 등록\n    return ajaxLoginProcessingFilter;\n}\n```\n\n### 3. 인증 처리 할 AjaxAuthenticationProvider 구현\n\nProvider는 Form 방법과 동일하게 작성 (반환 시 AjaxAuthenticationToken)\n\n### 4. 인증 성공, 실패 처리 핸들러 구현\n\n성공, 실패 handler 처리는 Form과 동일하게 생성 내용은 같아 생략\n\n설정한 handler함수들은 위에서 사용한 ajaxLoginProcessingFilter를 사용해서 AuthenticationManager에 등록시킨다.\n\n(ProcessingFilter에서 set 메서드들을 이용하여 handler들을 추가)\n\n### 5. 인가 설정\n\n인가 처리는 FilterSecurityInterceptor가 수행\n\n1. 인증을 받지 않는 익명 사용자의 접근처리\n2. 인증을 받은 사용자의 권한 정보 처리\n\n에 대한 처리를 한다.\n\n#### 5.1) 인증을 받지 않는 익명 사용자의 접근처리\n\n> AuthenticationEntryPoint를 상속받은 구현체 구현 / 익명 사용자가 인증이 필요한 자원에 접근한 경우, commence 메서드가 호출됨\n\n```java\npublic class AjaxLoginAuthenticationEntryPoint implements AuthenticationEntryPoint {\n\n    //익명 사용자가 인증이 필요한 자원에 접근한 경우, commence 메서드가 호출됨\n    @Override\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException e) throws IOException, ServletException {\n        response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"UnAuthorized\");\n    }\n}\n```\n\n#### 5.2) 인증을 받은 사용자의 권한 정보 처리\n\n> AccessDeniedHandler를 상속받고, handler 메서드를 Override 해준다.\n\n구현체를 모두 작성하였으면 설정 파일에 authenticationEntryPoint, accessDeniedHandler 메서드를 추가  \n각 객체들을 그대로 사용할 것이기 때문에 따로 Bean으로 만들지 않고 new 키워드를 통해 바로 생성\n\n### 6. Bean 설정 및 Ajax용 SecurityConfig 설정 추가\n\n1. Ajax용 Config가 Form Config보다 먼저 로드되게 설정 -> @Order(0)\n\n```java\n// config\nhttp\n    .addFilterBefore(ajaxLoginProcessingFilter(), UsernamePasswordAuthenticationFilter.class) //기존 필터 앞에 위치할때 사용하는 method\n    .authenticationEntryPoint(new AjaxLoginAuthenticationEntryPoint())\n    .accessDeniedHandler(new AjaxAccessDeniedHandler())\n\nhttp.csrf().disable() //기본적으로 csrf 토큰값을 들고 요청을 해야되는데, 임시적으로 off 한다.\n\n\n@Override\npublic AuthenticationManager authenticationManagerBean() throws Exception {\n    return super.authenticationManagerBean();\n}\n\n@Bean\npublic AjaxLoginProcessingFilter ajaxLoginProcessingFilter() throws Exception {\n    AjaxLoginProcessingFilter ajaxLoginProcessingFilter = new AjaxLoginProcessingFilter();\n    ajaxLoginProcessingFilter.setAuthenticationManager(authenticationManagerBean());\n        //인증 성공, 실패 시 handler 처리\n    ajaxLoginProcessingFilter.setAuthenticationSuccessHandler(ajaxAuthenticationSuccessHandler());\n    ajaxLoginProcessingFilter.setAuthenticationFailureHandler(ajaxAuthenticationFailureHandler());\n    return ajaxLoginProcessingFilter;\n}\n```\n\n### DSLs\n\n강의에선 dsl을 사용해 Configurer 클래스를 생성해 Config 부분을 나눠  \nfilter, handler, 환경설정 메서드의 set을 만든다\n\n공식 문서에서는 AbstractHttpConfigurer를 상속받아 설명하는데  \n강의에서는 AbstractHttpConfigurer를 상속받은 AbstractAuthenticationFilterConfigurer를 상속받아 Configurer를 구현한다.\n\n사실 이해하기 힘들어서 해당 부분은 코드 읽고 넘어간다.\n\n추후에 config파일을 나눌 일이 있으면 해당 document를 참고해서 작성하자\n\n[Spring Security 6.0.1 document](https://docs.spring.io/spring-security/reference/servlet/configuration/java.html#jc-custom-dsls)  \n[Spring Security 5.3.2 document - 토리맘의 한글라이즈 프로젝트](https://godekdls.github.io/Spring%20Security/javaconfiguration/#164-custom-dsls)\n\n### Ajax Login, CSRF 설정\n\ncsrf token값은 header에 meta태그나 form태그의 hidden속성을 주고 ajax요청 시 csrfHeader에 csrfToken을 함께 보내준다.\n\n- csrf Filter는 disable 처리를 하지 않는 한 자동 처리\n- 헤더에 토큰을 포함 시킬 경우 **X-CSRF-TOKEN**, **X-XSRF-TOKEN**\n- form에 담을 경우 파라미터 명 **\\_csrf**\n\n추가로 CSRF토큰에 대해 잘 정리해둔 블로그 글이 있어 링크 남긴다.  \n[[스프링 Security] CSRF 토큰 이야기 - 그래서 개발자는 뭘 하면 되죠](https://binchoo.tistory.com/46)\n\n# 인가 프로세스 DB연동\n\n강의 진행을 위해 설정 클래스(config)에서 관련된 코드 모두 제거\n\n## URL 방식 처리\n\n### URL 방식 기본 동작 원리\n\n> FilterSecurityInterceptor가 AccessDecisionManager에게 **인증, 요청, 권한정보**를 담아서 전달해주어 인증 및 인가처리\n\n![](AuthorizationProcess.png)\n\n1. FilterChainProxy에 있는 **FilterSecurityInterceptor** 에서 사용자는 요청받은 url정보 처리\n\n2. **FilterInvocationSecurityMetadataSource**의 **RequestMap**객체를 확인하여 url에 매핑되어 있는 권한 정보를 확인\n\n| key      | value                 |\n| -------- | --------------------- |\n| /user    | ROLE_ADMIN, ROLE_USER |\n| /configs | ROLE_ADMIN            |\n\n3. 권한 정보가 있다면 AccessDecisionManager로 **Authentication, FilterInovation, List<ConfigAttribute>**를 넘겨 인가처리\n\n4. 매핑 정보가 없다면 어떤 권한으로 접근해도 허용\n\n### FilterInvocationSecurityMetadataSource\n\n> Url 방식으로 처리할 땐 FilterInvocationSecurityMetadataSource 구현\n\n- Url 자원에 대한 권한 정보 추출\n- AccessDecisionManager에게 전달 해 인가처리 수행\n- DB로 부터 자원 및 권한정보 매핑해 Map으로 관리\n- 사용자의 요청마다 요청정보에 매핑된 권한 정보 확인\n\nUrlFilterInvocationMetadataSource 파일 생성  \n -> getAttributes() 메서드만 구현 / 나머지 DefaultFilterInvocationSecurityMetadataSource 복사해 사용\n\n```java\npublic class UrlFilterInvocationMetadataSource implements FilterInvocationSecurityMetadataSource {\n\n    private LinkedHashMap<RequestMatcher, List<ConfigAttribute>> requestMap = new LinkedHashMap<>();\n\n    @Override\n    public Collection<ConfigAttribute> getAttributes(Object o) throws IllegalArgumentException {\n\n        HttpServletRequest request = ((FilterInvocation) o).getRequest();\n\n        requestMap.put(new AntPathRequestMatcher(\"/mypage\"), Arrays.asList(new SecurityConfig(\"ROLE_USER\"))); // null로 넘어가서 test 용도로 사용\n\n        if(!Objects.isNull(requestMap)) {\n            return requestMap.entrySet().stream().map(entry -> {\n                   RequestMatcher matcher = entry.getKey();\n                   if(matcher.matches(request)){\n                       return entry.getValue(); //권한 정보\n                   } else {\n                       return null;\n                   }\n               })\n               .filter(Objects:nonNull)\n               .flatMap(Collection::stream)\n               .collect(Collectors.toList());\n        }\n        return null;\n    }\n\n    @Override\n    public Collection<ConfigAttribute> getAllConfigAttributes() {\n        Set<ConfigAttribute> allAttributes = new HashSet();\n        Iterator var2 = this.requestMap.entrySet().iterator();\n\n        while(var2.hasNext()) {\n            Map.Entry<RequestMatcher, Collection<ConfigAttribute>> entry = (Map.Entry)var2.next();\n            allAttributes.addAll((Collection)entry.getValue());\n        }\n\n        return allAttributes;\n    }\n\n    @Override\n    public boolean supports(Class<?> clazz) {\n        return FilterInvocation.class.isAssignableFrom(clazz);\n    }\n}\n```\n\n#### getAttributes()\n\n**FilterInvocationSecurityMetadataSource**가 나중에 **FilterSecurityInterceptor**에 의해 호출되는데 이 때 사용되는  \nurl Mapping 정보인 requestMap 객체를 정의\n\n#### Config 설정\n\n```java\n// security config\nhttp.addFilterBefore(customFilterSecurityInterceptor(), FilterSecurityInterceptor.class)\n\n@Bean\npublic FilterSecurityInterceptor customFilterSecurityInterceptor() throws Exception {\n\nFilterSecurityInterceptor filterSecurityInterceptor = new FilterSecurityInterceptor();\n\nfilterSecurityInterceptor.setSecurityMetadataSource(urlFilterInvocationSecurityMetadataSource());\nfilterSecurityInterceptor.setAccessDecisionManager(affirmativeBased()); // 인가 방식 종류 중 affirmativeBased 사용 - 가장 많이 사용하는 방식\nfilterSecurityInterceptor.setAuthenticationManager(authenticationManagerBean());\n\n    return filterSecurityInterceptor;\n}\n\nprivate AccessDecisionManager affirmativeBased() {\n    return new AffirmativeBased(getAccessDecisionVoters());\n}\n\nprivate List<AccessDecisionVoter<?>> getAccessDecisionVoters() {\n    return Arrays.asList(new RoleVoter());\n}\n\n@Bean\npublic FilterInvocationSecurityMetadataSource urlFilterInvocationSecurityMetadataSource() {\n    return new UrlFilterInvocationMetadataSource();\n}\n```\n\n1. custom Interceptor가 먼저 동작하게 config 파일 설정\n\n2. customFilterSecurityInterceptor를 Bean으로 등록시킨다.\n\n추가로 Bean으로 등록시키는 경우는 custom해서 작성한 객체 사용 시 Bean, 기존에 등록된 객체 사용 시 해당 객체를 꺼내와 return\n\nAccessDecisionManager 전략 중 affirmativeBased를 사용하는데 해당 설정은  \n**url에 매칭되는 권한 리스트 중 1개만 존재해도 인가 해주는 전략**\n\n### requestMap DB 연동\n\n#### UrlResourcesMapFactoryBean (권한/자원 정보를 ResurceMap 생성)\n\n> User정보를 DB로부터 가져온 권한/자원 정보를 ResurceMap만드는 구현체 (Bean으로 등록)\n\n```java\npublic class UrlResourcesMapFactoryBean implements FactoryBean<LinkedHashMap<RequestMatcher, List<ConfigAttribute>>> {\n\n    private SecurityResourceService securityResourceService;\n    private LinkedHashMap<RequestMatcher, List<ConfigAttribute>> resourceMap;\n\n    public void setSecurityResourceService(SecurityResourceService securityResourceService) {\n        this.securityResourceService = securityResourceService;\n    }\n\n    @Override\n    public LinkedHashMap<RequestMatcher, List<ConfigAttribute>> getObject() throws Exception {\n\n        if (resourceMap == null) {\n            init();\n        }\n\n        return resourceMap;\n    }\n\n    private void init() {\n        resourceMap = securityResourceService.getResourceList();\n    }\n\n    @Override\n    public Class<?> getObjectType() {\n        return LinkedHashMap.class;\n    }\n\n    @Override\n    public boolean isSingleton() {\n        return true;\n    }\n}\n\n```\n\n- <LinkedHashMap<RequestMatcher, List<ConfigAttribute>> 부분은 role - resource 정보를 불러오기 위해 사용\n\n```java\nrequestMap.put(new AntPathRequestMatcher(\"/mypage\"), Arrays.asList(new SecurityConfig(\"ROLE_USER\")));\n```\n\n위와 같은 느낌으로\n\n즉, 해당 클래스의 역할은 DB로 부터 가져오는 Service객체를 생성해주고 정보를 가져와 FilterInvocationMetadataSource로 전달해주는 역할\n\n### Resource를 가져오는 Service를 생성\n\n```java\n@RequiredArgsConstructor\npublic class SecurityResourceService {\n\n    private final ResourcesRepository resourcesRepository;\n    private final RoleResourceRepository roleResourceRepository;\n\n    public LinkedHashMap<RequestMatcher, List<ConfigAttribute>> getResourceList() {\n\n        LinkedHashMap<RequestMatcher, List<ConfigAttribute>> result = new LinkedHashMap<>();\n        List<Resource> resources = resourcesRepository.findAll();\n        resources.forEach(resource -> {\n            List<ConfigAttribute> configAttributes = new ArrayList<>();\n            Long resourceId = resource.getId();\n            List<RoleResource> roleResources = roleResourceRepository.findAllByResourceId(resourceId);\n            roleResources.forEach(roleResource -> {\n                configAttributes.add(new SecurityConfig(roleResource.getRole().getRoleName())); //ConfigAttribute 타입의 구현체인 SecurityConfig를 넣어준다.\n                result.put(new AntPathRequestMatcher(resource.getResourceName()), configAttributes);\n            });\n        });\n        return result;\n    }\n}\n```\n\n#### Config 파일 설정\n\n작성한 service와 service객체를 만들어주는 Factory Bean을 Security Config 파일에 등록\n\n이전엔 UrlFilterInvocationSecurityMetadataSource를 그대로 사용했는데 urlResourcesMapFactoryBean을 사용하게 변경\n\n```java\n    @Bean\n    public UrlFilterInvocationSecurityMetadataSource urlFilterInvocationSecurityMetadataSource() throws Exception {\n        return new UrlFilterInvocationSecurityMetadataSource(urlResourcesMapFactoryBean().getObject(), securityResourceService);\n    }\n\n    private UrlResourcesMapFactoryBean urlResourcesMapFactoryBean() {\n\n        UrlResourcesMapFactoryBean urlResourcesMapFactoryBean = new UrlResourcesMapFactoryBean();\n        urlResourcesMapFactoryBean.setSecurityResourceService(securityResourceService);\n\n        return urlResourcesMapFactoryBean;\n    }\n}\n```\n\n### DB 접근 권한 실시간 반영\n\n> DB에 자원/권한 정보를 업데이트 시, 실시간으로 ResourceMap에 업데이트\n\n#### UrlFilterInvocationMetadataSource에 reload 메서드 추가\n\n```java\npublic void reload() {\n    LinkedHashMap<RequestMatcher, List<ConfigAttribute>> reloadedMap = securityResourceService.getResourceList();\n    Iterator<Map.Entry<RequestMatcher, List<ConfigAttribute>>> iterator = reloadedMap.entrySet().iterator();\n\n    requestMap.clear(); //기존 정보를 지움\n\n    while (iterator.hasNext()) {\n        Map.Entry<RequestMatcher, List<ConfigAttribute>> entry = iterator.next();\n        requestMap.put(entry.getKey(), entry.getValue());\n    }\n}\n```\n\n#### Controller 수정\n\n```java\n\n    @PostMapping(value=\"/admin/resource/register\")\n    public String createResource(RoleResourcesPo roleResourcesPo) throws Exception {\n        ModelMapper modelMapper = new ModelMapper();\n        RoleResourcesDto roleResourcesDto = modelMapper.map(roleResourcesPo, RoleResourcesDto.class);\n\n        resourcesService.createRoleAndResources(roleResourcesDto);\n\n        urlFilterInvocationMetadataSource.reload(); // 자원 생성 시 reload 추가\n\n        return \"redirect:/admin/resources\";\n\n    }\n\n```\n\n자원 추가 시 urlFilterInvocationMetadataSource를 reload하는 구문을 추가한다.\n\n### 허용 필터\n\n> 인증 및 권한심사, 허용 IP -> ACCESS_ABSTAIN return / 허용 x IP -> 즉시 예외 처리 해 자원 접근 거부를 할 필요가 없는 자원 (/, /home, login ...) 들을 미리 설정해서 바로 리소스 접근이 가능하게 하는 필터\n\n인가 처리 과정\n\n```\nFilterSecurityInterceptor -> AbstractSecurityInterceptor -> List<ConfigAttribute> (null이 아닐 경우) -> AccessDecisionManager\n```\n\nFilterSecurityInterceptor를 상속받아 구현한다.\n\npermitAllFilter라는 이름을 가진 구현체를 구현하는데\n\nurl list (List<RequestMatcher>)를 읽고 설정 한 경로가 있으면 권한 심사 없이 통과하도록 **null값을 리턴**한다\n\n1. FilterSecurityInterceptor를 상속받아 invoke함수 사용\n\n2. PermitAllFilter에서 객체 생성 시 url list를 받을 수 있게 생성자에서 requestMatchers에 대한 list를 생성\n\n3. url list를 검사 할 beforeInvocation 함수 작성\n\n4. 이전 config 설정에서 FilterSecurityInterceptor를 사용한 부분을 PermitAllFilter를 사용하게 수정한다.\n\n5. PermitAllFilter에서 사용하게 될 url을 Config 파일에서 String 배열로 만들어 넣어준다.\n\n(추후에 적용시킬 경우 DB로 불러와 적용시켜도 좋을 것 같다.)\n\n```java\npublic class PermitAllFilter extends FilterSecurityInterceptor {\n\n    private static final String FILTER_APPLIED = \"__spring_security_filterSecurityInterceptor_filterApplied\";\n    private boolean observeOncePerRequest = true;\n\n    private List<RequestMatcher> permitAllRequestMatchers = new ArrayList<>();\n\n    public PermitAllFilter(String... permitAllResources) {\n        for (String resource : permitAllResources) {\n            permitAllRequestMatchers.add(new AntPathRequestMatcher(resource));\n        }\n    }\n\n    @Override\n    protected InterceptorStatusToken beforeInvocation(Object object) {\n\n        boolean permitAll = false;\n        HttpServletRequest request = ((FilterInvocation) object).getRequest();\n        for (RequestMatcher requestMatcher : permitAllRequestMatchers) {\n            if (requestMatcher.matches(request)) {\n                permitAll = true;\n                break;\n            }\n        }\n\n        if (permitAll) {\n            return null;\n        }\n\n        return super.beforeInvocation(object);\n    }\n\n    public void invoke(FilterInvocation fi) throws IOException, ServletException {\n        if ((fi.getRequest() != null)\n                && (fi.getRequest().getAttribute(FILTER_APPLIED) != null)\n                && observeOncePerRequest) {\n            fi.getChain().doFilter(fi.getRequest(), fi.getResponse());\n        } else {\n            if (fi.getRequest() != null && observeOncePerRequest) {\n                fi.getRequest().setAttribute(FILTER_APPLIED, Boolean.TRUE);\n            }\n\n            InterceptorStatusToken token = beforeInvocation(fi);\n\n            try {\n                fi.getChain().doFilter(fi.getRequest(), fi.getResponse());\n            } finally {\n                super.finallyInvocation(token);\n            }\n\n            super.afterInvocation(token, null);\n        }\n    }\n}\n```\n\n### 계층 권한 적용\n\n> RoleHierarchyService를 만들어 Config에 적용시킨다\n\n1. entity, repository, Service 구현 RoleHierarchyService 에서 Spring security에서 지정한 규칙대로 String으로 반환\n\n[Hierarchical Roles - Spring security document](https://docs.spring.io/spring-security/reference/servlet/authorization/architecture.html#authz-hierarchical-roles)\n\n2. getAccessDecisionVoters에서 기본 RoleVoter를 사용하던 부분을 RoleHierarchyVoter가 설정되게 변경\n\n```java\n// entity\n@Entity\n@Table(name = \"ROLE_HIERARCHY\")\n@AllArgsConstructor\n@NoArgsConstructor\n@Getter\n@Setter\n@Builder\npublic class RoleHierarchy implements Serializable {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(name = \"child_name\")\n    private String childName;\n\n    @ManyToOne(cascade = {CascadeType.ALL}, fetch = FetchType.LAZY)\n    @JoinColumn(name = \"parent_name\", referencedColumnName = \"child_name\")\n    private RoleHierarchy parentName;\n\n    @OneToMany(mappedBy = \"parentName\", cascade = {CascadeType.ALL})\n    private Set<RoleHierarchy> roleHierarchy = new HashSet<RoleHierarchy>();\n}\n\n// repository\npublic interface ResourcesRepository extends JpaRepository<Resources, Long> {\n\n    Resources findByResourceNameAndHttpMethod(String resourceName, String httpMethod);\n\n    @Query(\"select r from Resources r join fetch r.roleSet where r.resourceType = 'url' order by r.orderNum desc\")\n    List<Resources> findAllResources();\n\n    @Query(\"select r from Resources r join fetch r.roleSet where r.resourceType = 'method' order by r.orderNum desc\")\n    List<Resources> findAllMethodResources();\n\n    @Query(\"select r from Resources r join fetch r.roleSet where r.resourceType = 'pointcut' order by r.orderNum desc\")\n    List<Resources> findAllPointcutResources();\n}\n\n// Service\n\n    @Bean\n    public PermitAllFilter customFilterSecurityInterceptor() throws Exception {\n\n        PermitAllFilter permitAllFilter = new PermitAllFilter(permitAllResources);\n        permitAllFilter.setSecurityMetadataSource(urlFilterInvocationSecurityMetadataSource());\n        permitAllFilter.setAccessDecisionManager(affirmativeBased());\n        permitAllFilter.setAuthenticationManager(authenticationManagerBean());\n        return permitAllFilter;\n    }\n\n    private AccessDecisionManager affirmativeBased() {\n        AffirmativeBased affirmativeBased = new AffirmativeBased(getAccessDecisionVoters());\n        return affirmativeBased;\n    }\n\n    private List<AccessDecisionVoter<?>> getAccessDecisionVoters() {\n\n        List<AccessDecisionVoter<? extends Object>> accessDecisionVoters = new ArrayList<>();\n        accessDecisionVoters.add(roleVoter());\n\n        return accessDecisionVoters;\n    }\n\n    @Bean\n    public AccessDecisionVoter<? extends Object> roleVoter() {\n\n        RoleHierarchyVoter roleHierarchyVoter = new RoleHierarchyVoter(roleHierarchy());\n        return roleHierarchyVoter;\n    }\n\n    @Bean\n    public RoleHierarchyImpl roleHierarchy() {\n        RoleHierarchyImpl roleHierarchy = new RoleHierarchyImpl();\n        return roleHierarchy;\n    }\n```\n\n추가로 config에서 사용되는 RoleHierarchy를 전달받아야 하는데 강의에서는 ApplicationRunner의 run메소드를 이용해서 RoleHierarchy객체를 전달한다.\n\n```java\n@Component\npublic class SecurityInitializer implements ApplicationRunner {\n\n    @Autowired\n    private RoleHierarchyService roleHierarchyService;\n\n    @Autowired\n    private RoleHierarchyImpl roleHierarchy;\n\n    @Override\n    public void run(ApplicationArguments args) throws Exception {\n        String allHierarchy = roleHierarchyService.findAllHierarchy();\n        roleHierarchy.setHierarchy(allHierarchy);\n    }\n}\n```\n\n<!-- TODO: 나중에 이거 해볼 때 Security server경로 admin -->\n\nconfig에서도 Bean으로 주입받아도 사용 가능 (어느 타이밍에 하던 상관x)\n\n### IP 접속 제한\n\n- Voter에 의한 인가 처리는 AccessDecisionManager가 처리\n- 추가적인 Voter 구현체로 **IpAddressVoter** 구현\n\n#### IPAddressVoter\n\n- 특정 IP만 접근이 가능하도록 심의하는 Voter\n- 가장 먼저 심사, 허용 IP -> ACCESS_ABSTAIN return / 허용 x IP -> 즉시 예외 처리 해 자원 접근 거부\n- ACCESS_ABSTAIN로 리턴 하면 일단 해당 Voter에서는 인가를 승인하되, 다음 Voter로 승인을 보류\n- ACCESS_DENIED로 넘기면 다른 Voter가 판단할 수 있으므로 exception처리\n\n1. 테이블 추가\n\n```java\n@Entity\n@Table(name = \"ACCESS_IP\")\n@Data\n@EqualsAndHashCode(of = \"id\")\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class AccessIp implements Serializable {\n\n    @Id\n    @GeneratedValue\n    @Column(name = \"IP_ID\", unique = true, nullable = false)\n    private Long id;\n\n    @Column(name = \"IP_ADDRESS\", nullable = false)\n    private String ipAddress;\n\n}\n```\n\n2. IpAddressVoter 작성\n\n- AccessDecisionVoter를 상속받는 구현체 작성\n- authentication 객체에서 IP에 대한 정보를 꺼내와 IP 조회 로직 구현\n\n```java\n@RequiredArgsConstructor\npublic class IpAddressVoter implements AccessDecisionVoter {\n\n    private final SecurityResourceService securityResourceService;\n\n    @Override\n    public boolean supports(ConfigAttribute configAttribute) {\n        return true;\n    }\n\n    @Override\n    public boolean supports(Class aClass) {\n        return true;\n    }\n\n    @Override\n    public int vote(Authentication authentication, Object o, Collection collection) {\n\n        //authentication.getDetails에서 사용자 정보를 얻을 수 있으며, WebAuthenticationDetails 객체로 캐스팅 해줘야 사용 가능\n        WebAuthenticationDetails details = (WebAuthenticationDetails) authentication.getDetails();\n        String remoteAddress = details.getRemoteAddress();\n\n        List<String> accessIpList = securityResourceService.getAccessIpList();\n\n        for (String accessIp : accessIpList) {\n            if (accessIp.equals(remoteAddress)) {\n                return ACCESS_ABSTAIN;\n            }\n        }\n\n        throw new AccessDeniedException(\"Invalid Ip Address\");\n\n    }\n}​\n```\n\n3. Security Config 추가\n\n인가 결정을 보류하는 로직이 있기 때문에 **반드시 roleVoter 앞에 위치**\n\n```java\nprivate List<AccessDecisionVoter<?>> getAccessDecisionVoters() {\n        List<AccessDecisionVoter<? extends Object>> accessDecisionVoters = new ArrayList<>();\n        accessDecisionVoters.add(new IpAddressVoter(securityResourceService));\n        accessDecisionVoters.add(roleVoter());\n\n    return accessDecisionVoters;\n}\n```\n\n## Method 방식 인가 처리\n\n> URL별 인가처리가 아닌 **메소드 단위로 인가처리 적용** 가능\n\n- AOP기반으로 동작 (프록시와 어드바이스)\n- 설정 방식 2가지 - 어노테이션 기반, 맵 기반(DB와 연동)\n\n![](Method1.png)  \n![](Method2.png)\n\n### 동작 방식\n\n![](MethodAuthenticationArchitecture.png)\n\n- URL 방식은 Filter가 가로채서 요청 처리\n- Proxy객체에 등록된 Advise가 동작해 요청 처리\n\n### 관련 어노테이션\n\n#### @PreAuthorize, @PostAuthorize\n\n- SpEL(Spring Expression Language) 지원\n- @PreAuthorize(\"hasRole('ROLE_USER')and(#account.username == principal.username)\") 같이 작성 가능\n- PrePostAnnotationSecurityMetadataSource가 처리\n\n#### @Secured, @RolesAllowed\n\n- SpEL을 지원X\n- @Secured(\"ROLE_USER\"), @RolesAllowed(\"ROLE_USER\") 같이 작성 가능\n- SecuredAnnotationSecurityMetadataSource, Jsr250MethodSecurityMetadataSource가 처리\n\n#### @EnableGlobalMethodSecurity\n\n- 메서드 방식의 인가 처리가 가능하게 해준다.\n- 설정 클래스에 선언을 해야 함\n- prePostEnabled = true, securedEnabled = true 등과 같이 속성값을 반드시 true로 변경 해야 해당 어노테이션 사용 가능\n\nPrePostAnnotationSecurityMetadataSource 등은 앞서 살펴본 MethodSecurityMetadataSource 객체를 상속하고 있다.\n\n### 적용 방법\n\n1. config 설정\n\n   - Url 처리 방식에서 UrlResourceMap을 관리하는 것과 동일하게 **MethodResourcesMapFactoryBean**을 생성\n   - url 방식 config와 Method config와 분리해 관리하기 위해 **MethodSecurity**클래스를 만들어 구현\n   - GlobalMethodSecurityConfiguration을 상속받아 작성\n\n```java\n// MethodResourcesMapFactoryBean\n@Slf4j\npublic class MethodResourcesMapFactoryBean implements FactoryBean<LinkedHashMap<String, List<ConfigAttribute>>> {\n\n    private SecurityResourceService securityResourceService;\n    private String resourceType;\n\n    public void setResourceType(String resourceType) {\n        this.resourceType = resourceType;\n    }\n\n    public void setSecurityResourceService(SecurityResourceService securityResourceService) {\n        this.securityResourceService = securityResourceService;\n    }\n\n    private LinkedHashMap<String, List<ConfigAttribute>> resourcesMap;\n\n    public void init() {\n        if (\"method\".equals(resourceType)) {\n            resourcesMap = securityResourceService.getMethodResourceList();\n        } else if (\"pointcut\".equals(resourceType)) {\n            resourcesMap = securityResourceService.getPointcutResourceList();\n        }\n    }\n\n    public LinkedHashMap<String, List<ConfigAttribute>> getObject() {\n        if (resourcesMap == null) {\n            init();\n        }\n        return resourcesMap;\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    public Class<LinkedHashMap> getObjectType() {\n        return LinkedHashMap.class;\n    }\n\n    public boolean isSingleton() {\n        return true;\n    }\n}\n\n\n\n// MethodSecurityConfig\n@Configuration\n//@EnableGlobalMethodSecurity\n@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)\npublic class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {\n\n    @Autowired\n    private SecurityResourceService securityResourceService;\n\n    @Override\n    protected MethodSecurityMetadataSource customMethodSecurityMetadataSource() {\n        return mapBasedMethodSecurityMetadataSource();\n    }\n\n    @Bean\n    public MapBasedMethodSecurityMetadataSource mapBasedMethodSecurityMetadataSource() {\n        return new MapBasedMethodSecurityMetadataSource(methodResourcesMapFactoryBean().getObject());\n    }\n\n    @Bean\n    public MethodResourcesMapFactoryBean methodResourcesMapFactoryBean() {\n        MethodResourcesMapFactoryBean methodResourcesMapFactoryBean = new MethodResourcesMapFactoryBean();\n        methodResourcesMapFactoryBean.setSecurityResourceService(securityResourceService);\n        methodResourcesMapFactoryBean.setResourceType(\"method\");\n        return methodResourcesMapFactoryBean;\n    }\n}\n```\n\n2. Config파일에서 resourcesMap으로 하용 할 service, repository 객체 구현\n\nDB 저장 시 저장 방법\n\n![](saveDb.png)\n\n3. Method에 어노테이션 적용\n\n## AOP 방식\n\n> ProtectPointcutPostProcessor가 DB정보를 읽어 Bean에 해당하는 TargetClass 정보, Method 정보, ConfigAttribute정보를 읽어 MethodSecurityMetadata에 전달\n\n구현하려면 ProtectPointcutPostProcessor을 상속받아 사용해야 하는데 final로 선언되어 있어 확장이 불가능 -> 강의에선 동일한 기능을 하는 클래스 생성해 기능 구현\n\nMethod방식과 동일하게 config 설정, service, repository 구현해 사용\n\nAop방식은 잘 사용할 것 같지 않아서 추후에 실무에서 사용 시 다시 공부해서 적용해야겠다.....\n\n# Reference\n\n- [인증(Authentication) vs. 인가(Authorization)](https://dextto.tistory.com/234)\n- [Spring Security Document](https://docs.spring.io/spring-security/reference/servlet/authentication/passwords/form.html)\n- [스프링 시큐리티 - Spring Boot 기반으로 개발하는 Spring Security](https://www.inflearn.com/course/%EC%BD%94%EC%96%B4-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0/dashboard)\n- [Spring Security UserDetails, UserDetailsService 란? - 삽질중인 개발자](https://programmer93.tistory.com/68)\n- [Spring Security loginPage Vs loginProcessingURL - stackoverflow](https://stackoverflow.com/questions/53140629/spring-security-loginpage-vs-loginprocessingurl)\n- [[스프링 Security] CSRF 토큰 이야기 - 그래서 개발자는 뭘 하면 되죠](https://binchoo.tistory.com/46)\n- [[스프링 시큐리티]23. Method 방식 : 동작방식 및 구조 알아보기 - 컴퓨터 탐험가 찰리](https://whitepro.tistory.com/m/521)\n","excerpt":"해당 포스팅은 정수원님의 스프링 시큐리티 - Spring Boot 기반으로 개발하는 Spring Security 강의를 참고하여 작성했습니다. 강의 예제는 원리 이해하는 부분은 springboot starter 3.0.1\n(security 6.0.1…","fields":{"slug":"/SpringSecurity1/"},"frontmatter":{"date":"Jan 14, 2023","title":"Spring Security Session","tags":["Spring"],"update":"Feb 06, 2023"}}},{"node":{"rawMarkdownBody":"\n# NextJS\n\n> React 기반 JavaScript 프레임워크\n\n## 특징\n\n### 1. 내장 서버 측 렌더링\n\n### 2. 파일기반 라우팅\n\n> 파일과 폴더를 이요해서 라우트 정의\n\n### 3. 풀스택 앱 빌드\n\nNextJS는 사전 렌더링 기능을 내장하기 때문에 public 폴더에 index.js파일이 따로 존재하지 않는다.\n\n## 라우팅\n\n> 파일이 pages 디렉터리에 추가되면 자동으로 경로 사용 가능\n\n- 폴더 구조로 만들면 중첩 경로로 라우팅이 가능하다\n- []로 이름 작성 시 동적 경로로 사용 가능하다 / ex) [param].js\n\n```text\n├── Pages\n      ├── posts\n      │     ├── index.js\n      │     └── [postId].js\n      ├── index.js\n```\n\n라우트 객체에 접근하기 위해선 NextJS에서 사용되는 **useRouter()** 훅을 사용한다.\n\n## Link 컴포넌트\n\n> 페이지를 연결해 주기 위해서 Link 컴포넌트 사용\n\n```React\nimport Link from 'next/link';\n\nfunction Page() {\n    return (\n        ...\n            <Link href=\"/news/nextjs-is-a-great-framework\">NextJS Is A Great Framework</Link>\n        ...\n    );\n}\n\n```\n\n## \\_app.js\n\n> \\_app은 서버로 요청이 들어왔을 때 가장 먼저 실행되는 컴포넌트로, 페이지에 적용할 공통 레이아웃의 역할\n\n## 사전 렌더링\n\n### 1. Static Site Generation (SSG)\n\n> 페이지가 빌드 시 생성, 특정 함수 사용 시 페이지를 렌더링 할 때 함수 사용 후 렌더링\n\n#### 1-1. getStaticProps()\n\n> 페이지 내용이 외부 데이터에 의존할 때 사용\n\n```React\n// pages/posts.js\nexport default Post = (posts) =>{\n    // 렌더링 로직\n}\n\n// 빌드 타임 시 호출\nexport async function getStaticProps({ params }) {\n    // params: 라우트 파라미터들로 이뤄진 객체 (정적 라우트 페이지라면 undefined)\n\n    // API 호출\n    const response = await fetch('https://example.com/posts');\n    const posts = await response.json();\n\n    // 리다이렉션 객체 사용해 리다이렉션\n    if (!posts) {\n      return {\n        redirect: {\n          destination: '/',\n          permanent: false,\n          // statusCode: 301\n        },\n      }\n    }\n\n\n    return {\n        props: { posts }, // Post 컴포넌트가 전달받을 props 객체 (key - value)\n        revalidate: false, // 페이지 재 생성 시간(초)\n        notFound: false // 404 페이지 반환 여부\n    };\n}\n```\n\nTODO:\n\n-\n\n#### 1-2. getStaticPath()\n\n> 동적 경로를 사용할 때, 사전 렌더링 하기 위해서 사용 (getStaticProps와 함께)\n\n```React\n\n```\n\nTODO:\n\n**정리**\n\n- CDN에 의해 캐싱되어 성능 향상이 가능\n- 페이지 내용 -> **getStaticProps()**, 페이지 경로 -> **getStaticPaths**\n- 두 함수는 비동기적으로 프로미스 반환 가능\n- 개발 모드에서는 매 요청마다 호출\n- 함수 내에서 사용되는 로직은 브라우저에 전달되는 js번들에 포함되지 않는다\n\n### 2. Server-side Rendering (SSR)\n\n> 서버 측에서 렌더링 되며 캐시 제어 헤더(Cache-Control 헤더)가 구성된 경우에만 CDN에 캐시\n\n- 빌드 실행중에 실행x\n- 클라이언트 측에서 요청시에 만들어진다.\n- SSG보다 느린 성능\n- 매 요청마다 페이지 내용이 업데이트 되어야 하는 경우\n\n#### 2.1) getServerSideProps()\n\n# TypeScript\n\n> 자바스크립트의 슈퍼셋(superset) 언어\n\n컴파일 명령어\n\n```bash\n# build\nnpx tsc {파일명}\n\n# build 후 바로 실행\nnpx ts-node {파일}\n\n# 컴파일 된 js파일 실행\nnode {빌드 된 파일}\n```\n\n변수 선언 하면서 타입 지정\n\n## 특징\n\n### 1. 타입\n\n| Type                              | Keyward                  |\n| --------------------------------- | ------------------------ |\n| 문자열                            | String                   |\n| 숫자                              | Number                   |\n| 불                                | Boolean                  |\n| 배열                              | number[] / Array<number> |\n| 튜플                              | [string, number]]        |\n| 모든 타입 허용                    | Any                      |\n| undefind, null                    | void                     |\n| 함수 끝에 절대 도달하지 않는 의미 | Never                    |\n\n배열 선언 시 **ReadonlyArray<T>** 사용하면 읽기 전용 배열 생성\n\n```typescript\nlet arr: ReadonlyArray<number> = [1, 2, 3];\n```\n\n### 2. 함수 작성 방법\n\n**3가지 타입 정의**\n\n- 함수의 파라미터(매개변수) 타입\n- 함수의 반환 타입 (타입을 정하지 않을 때 void 사용)\n- 함수의 구조 타입\n\n```typescript\n// b? : number -> 매개변수 만큼 인자 넘기지 않아도 되는 특성 적용\n// b = '100' -> 초기화\nfunction sum(a: number, b: number, ...nums: number[]): number {\n  return a + b;\n}\n```\n\n- **?**을 사용해 매개변수 만큼 인자 넘기지 않아도 되는 특성 적용 가능\n- REST 문법 적용 가능\n\n**this**\n\n> this 타입 지정 가능\n\n예제\n\n```typescript\ninterface App {\n  el: string;\n  counter: number;\n  init(this: App): () => {};\n}\n\nlet app: App = {\n  el: '#app',\n  count: 10,\n  init: function (this: App) {\n    return () => {\n      return this.count;\n    };\n  },\n};\n```\n\n### 3. 인터페이스\n\n```typescript\n// object\ninterface User {\n  name: string;\n  readonly age?: number;\n  hp?: string;\n}\n\n// object extension\ninterface Driver extends Person {\n  skill: string;\n}\n\n// function\ninterface login {\n  (username: string, password: string): boolean;\n}\n\n// class\ninterface Car {\n  carName: string;\n  setName(beer: string): void;\n}\n```\n\n#### readonly vs const\n\n> 변수는 **const** / 프로퍼티 **readonly**\n\n## 타입 추론\n\n> 타입 표기가 없는 경우 타입을 추론한다.\n\n### 가장 적절한 타입(Best Common Type)\n\n> 표현식의 타입을 사용해 \"최적 공통 타입\" 계산\n\n### 문맥상의 타이핑(Contextual Typing)\n\n> 코드의 위치(문맥)를 기준으로 실행\n\n## Union Type\n\n> 타입을 정의할 때 한개 이상의 타입을 사용\n\n```typescript\nfunction go(speed: string, direction: string | number) {\n  // ...\n}\n```\n\n## 타입 별칭\n\n> 타입의 새로운 이름 생성\n\n```typescript\ntype Name = string;\ntype NameResolver = () => string;\ntype NameOrResolver = Name | NameResolver;\n```\n\n## 제네릭\n\n> 타입을 유연하게 처리, 런타임 시 발생할 수 있는 타입에러를 컴파일전에 검출\n\n- 파라미터 타입이나 리턴 타입에 대한 정의를 외부로 미룬다\n- 타입에 대해 유연성, 안정성 확보\n- **런타임 환경에 아무런 영향이 없는 컴파일 시점의 전처리 기술**\n- 유저가 준 인수의 타입을 캡처하고, 사용할 수 있게 해주는 **T** 타입변수 사용\n- 제약 조건 사용 시 **제약 조건을 명시하는 인터페이스 생성** 후 **extends** 키워드로 명시\n\n```typescript\nlet arrayType: number | string;\n\nfunction insertAtBeginning<T extends typeof arrayType>(array: T[], value: T) {\n  const newArray = [value, ...array];\n  return newArray;\n}\n\nconst updatedArray = insertAtBeginning([1, 2, 3], -1);\nconst stringArray = insertAtBeginning(['a', 'b', 'c'], 'd');\n```\n\n사용할 떈 [제네릭 - typescript kr 문서](https://typescript-kr.github.io/pages/generics.html) 보고 참고\n\n보기 편한 Typescript cheet\n\n![](TypeScriptClasses.png)\n\n![](TypeScriptControlFlowAnalysis.png)\n\n![](TypeScriptInterfaces.png)\n\n![](TypeScriptTypes.png)\n\n## React + Typescript\n\n- Typescript로 작성된 React 앱에선 tsx파일 사용 -> jsx문법 사용해서\n\n```typescript\ninterface todoProps {\n  items: Todo[];\n  addTodo: (text: string) => void;\n  removeTodo: (id: string) => void;\n}\n\nfunction NewTodo(props: todoProps) {\n  const todoTextInputRef = useRef<HTMLInputElement>(null);\n  const [isVisible, setIsVisible] = useState<boolean>(false);\n\n  // ...\n\n  return (\n    // rendering code\n  )\n}\n```\n\n컴포넌트를 사용할 때 **interface로 props 타입을 선언**하고 사용하면 된다.\n\n## tsconfig.json\n\n> tsconfig.json파일로 컴파일과 관련된 사항들을 설정한다.\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"es5\",\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"allowJs\": true,\n    \"skipLibCheck\": true,\n    \"esModuleInterop\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"strict\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"node\",\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"noEmit\": true,\n    \"jsx\": \"react-jsx\"\n  },\n  \"include\": [\"src\"]\n}\n```\n\nHTMLInputElement같은 기본 타입을 사용할 수 있는데  \nlib 부분에 dom라이브러리를 추가했기 때문에 사용할 수 있음\n\n[tsconfig 공식 문서](https://www.typescriptlang.org/tsconfig)\n\n# Reference\n\n- [NextJS 공식 문서](https://nextjs.org/docs)\n- [타입스크립트 핸드북](https://joshua1988.github.io/ts/intro.html)\n- [typescript-kr](https://typescript-kr.github.io/)\n- [[JAVA] 제네릭(Generic)이란 - JH Blog](https://jehuipark.github.io/java/java-generic)\n","excerpt":"NextJS React 기반 JavaScript 프레임워크 특징 1. 내장 서버 측 렌더링 2. 파일기반 라우팅 파일과 폴더를 이요해서 라우트 정의 3. 풀스택 앱 빌드 NextJS는 사전 렌더링 기능을 내장하기 때문에 public 폴더에 index…","fields":{"slug":"/reactStudy_4/"},"frontmatter":{"date":"Jan 12, 2023","title":"NextJS, TypeScript","tags":["React"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# 그리디\n\n> 매번 선택에서 최적의 답을 근시안적으로 택하는 알고리즘  \n> (= 관찰을 통해 탐색범위를 줄임)\n\n## 1449번\n\n![](1449.png)\n\n맨 처음 물이 새는 위치부터 테이프를 붙여주는 처리후에\n\nL값 범위 안으로 처리 가능하면 이전 테이프와 거리차를 더해가며 하나의 테이프로 처리 가능한 부분을 탐색\n\n처리가 불가능 할 경우엔 size 초기화, 테이프 개수 1증가한다\n\n```java\npackage greedy;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class num1449 {\n    static int N, L, holes[], cnt = 1;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        String[] NL = br.readLine().split(\" \");\n\n        N = stoi(NL[0]);\n        L = stoi(NL[1]);\n        holes = new int[N];\n\n        String[] input = br.readLine().split(\" \");\n        for (int i = 0; i < N; i++) {\n            holes[i] = stoi(input[i]);\n        }\n        Arrays.sort(holes);\n\n        int pre = holes[0];\n        double size = 0.5;\n        for (int i = 1; i < holes.length; i++) {\n            double diff = holes[i] - pre;\n            pre = holes[i];\n\n            if (size + diff < L) {\n                size += diff;\n                continue;\n            }\n\n            size = 0.5;\n            cnt++;\n        }\n\n        System.out.println(cnt);\n    }\n\n    public static int stoi(String s) {\n        return Integer.parseInt(s);\n    }\n}\n\n```\n\n## 11000번\n\n![](11000.png)\n\nPriority Queue를 2개 사용해서 처리가 중요\n\n1. start, end 시간을 저장하는 Lesson 클래스를 만들어 시작 시간 오름차순으로 첫번째 Priority Queue에 값을 입력받는다.\n\n2. 첫번째 Priority Queue로 반복문을 돌아주면서\n\n   - 2.1) 종료 시간을 저장하는 rooms pq를 확인, 현재 Lesson의 시작시간 보다 종료시간이 작은 경우 완료 처리한다.(삭제)\n\n   - 2.2) end 시간을 저장하는 rooms pq를 사용해 현재 사용중인 room의 종료 시간을 저장한다.\n\n   - 2.3) rooms pq의 사이즈는 현재 사용중인 room의 개수이고, 사용중인 rooms의 최대값을 roomsSize로 관리\n\n```java\npackage greedy;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.PriorityQueue;\n\npublic class num11000 {\n    static int N;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        N = stoi(br.readLine());\n        PriorityQueue<Lesson> q = new PriorityQueue();\n\n        for (int i = 0; i < N; i++) {\n            String[] input = br.readLine().split(\" \");\n            q.add(new Lesson(stoi(input[0]), stoi(input[1])));\n        }\n\n        PriorityQueue<Integer> rooms = new PriorityQueue<>();\n        int roomsSize = 0;\n        while(!q.isEmpty()) {\n            Lesson cur = q.poll();\n\n            if(rooms.isEmpty()) {\n                rooms.add(cur.end);\n                if(roomsSize == 0) {\n                    roomsSize++;\n                }\n                continue;\n            }\n\n            //  start 시간보다 작을 경우 종료 처리\n            while(rooms.peek() <= cur.start) {\n                rooms.poll();\n            }\n\n            rooms.add(cur.end);\n\n            roomsSize = roomsSize < rooms.size() ? rooms.size() : roomsSize;\n        }\n\n        System.out.println(roomsSize);\n    }\n\n    static class Lesson implements Comparable<Lesson>{\n        int start, end;\n\n        Lesson(int start, int end) {\n            this.start = start;\n            this.end = end;\n        }\n\n        @Override\n        public int compareTo(Lesson o) {\n            return this.start - o.start;\n        }\n    }\n\n    public static int stoi(String s) {\n        return Integer.parseInt(s);\n    }\n}\n\n```\n\n## 2212번\n\n![](2212.png)\n\n집중국을 세워 범위를 나눈다.\n\n예제 입력 1을 예시로 들면 K가 2로 범위를 2개로 나눌 수 있다.\n\n센서의 위치는 1, 3, 6, 6, 7, 9 일 때\n\n센서간의 거리는 2, 3, 0, 1, 2가 되는데\n\n센서간의 거리를 정렬해 가장 먼 거리 순으로 제외\n\n예시에선 2개의 범위로 나눌 수 있으니 3을 제거\n\n즉, 센서간의 거리를 가장 큰 K-1개 만큼 제거한 총 합이다.\n\n```java\npackage greedy;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class num2212 {\n    static int N, K, senses[], diff[];\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        N = stoi(br.readLine());\n        K = stoi(br.readLine());\n\n        senses = new int[N];\n        diff = new int[N - 1];\n\n        String[] input = br.readLine().split(\" \");\n\n        for (int i = 0; i < N; i++) {\n            senses[i] = stoi(input[i]);\n        }\n\n        Arrays.sort(senses);\n\n        int pre = senses[0];\n        for (int i = 1; i < N; i++) {\n            int cur = senses[i];\n            diff[i - 1] = cur - pre;\n            pre = cur;\n        }\n\n        Arrays.sort(diff);\n\n        int sum = 0;\n        for (int i = 0; i < diff.length - K + 1; i++){\n            sum += diff[i];\n        }\n\n        System.out.println(sum);\n    }\n\n    public static int stoi(String s) {\n        return Integer.parseInt(s);\n    }\n}\n\n```\n\n# 백트래킹\n\n## 1756번\n\n![](1756.png)\n\nC개 중 N개를 선택할 수 있는 개수를 구하는 조합문제\n\n조건에 모음 1개, 자음 2개 이상이여야 암호로 사용 가능하다는 조건이 있는데\n\n모음과 자음 개수를 백트래킹 해서 재귀함수 탈출 시 조건 검사 후 맞는 값만 결과에 추가\n\n```java\npackage backtracking;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\n\npublic class num1759 {\n    static int L, C;\n    static String[] list;\n    static ArrayList<String> res = new ArrayList<>();\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        String[] input = br.readLine().split(\" \");\n\n        L = stoi(input[0]);\n        C = stoi(input[1]);\n\n        list = br.readLine().split(\" \");\n\n        Arrays.sort(list);\n\n        getStringList(0, \"\", 0, new int[]{0, 0});\n\n        for (String item : res) {\n            System.out.println(item);\n        }\n    }\n\n    public static void getStringList(int depth, String password, int index, int[] check) {\n        if (depth == L) {\n            if (check[0] >= 1 && check[1] >= 2) {\n                res.add(password);\n            }\n            return;\n        }\n\n        for (int i = index; i < C; i++) {\n            int flag = check(list[i]) ? 0 : 1;\n\n            check[flag] += 1;\n            getStringList(depth + 1, password + list[i], i + 1, check);\n            check[flag] -= 1;\n        }\n\n        return;\n    }\n\n    public static boolean check(String item) {\n        return item.equals(\"a\") || item.equals(\"e\") || item.equals(\"i\") || item.equals(\"o\") || item.equals(\"u\");\n    }\n\n    public static int stoi(String s) {\n        return Integer.parseInt(s);\n    }\n}\n\n```\n\n## 1941번\n\n![](1941.png)\n\nbfs로 모든 경우를 탐색하기엔 너무 커서 문제에 주어진 대로\n\n25개 중 7개를 선택하는 조합을 bfs로 탐색하면서\n\n1. 선택한 모든 경우가 인접하는지\n2. 선택한 7가지 중 S가 4개 이상\n\n2가지 조건을 확인해 경우의 수를 구하는 문제\n\n```java\npackage backtracking;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class num1941 {\n    static char[][] map = new char[5][5];\n    static boolean[] visited;\n    static int n = 25, r = 7, res = 0;\n    static int[] dx = {0, 0, -1, 1}, dy = {1, -1, 0, 0};\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        for (int i = 0; i < 5; i++) {\n            map[i] = br.readLine().toCharArray();\n        }\n\n        combination(0, 0, new int[r]);\n\n        System.out.println(res);\n    }\n\n    public static void combination(int idx, int cnt, int[] selected) {\n        if (cnt == r) {\n            bfs(selected);\n            return;\n        }\n\n        for (int i = idx; i < n; i++) {\n            selected[cnt] = i;\n            combination(i + 1, cnt + 1, selected);\n        }\n    }\n\n    public static void bfs(int[] selected) {\n        Queue<Integer> q = new LinkedList<>();\n        visited = new boolean[7];\n\n        visited[0] = true;\n        q.add(selected[0]);\n        int cnt = 1, s = 0;\n\n        while (!q.isEmpty()) {\n            int cur = q.poll();\n            int cx = cur / 5, cy = cur % 5;\n            if (map[cx][cy] == 'S') s++;\n\n            for (int i = 0; i < 4; i++) {\n                for (int next = 1; next < 7; next++) {\n                    if(check(cx + dx[i]) && check(cy + dy[i])) {\n                        if (!visited[next] && selected[next] / 5 == cx + dx[i] && selected[next] % 5 == cy + dy[i]) {\n                            visited[next] = true;\n                            q.add(selected[next]);\n                            cnt++;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (cnt == 7 && s >= 4) {\n            res++;\n        }\n    }\n\n    }\n}\n\n```\n\n## 18809번\n\n![](18809_1.png)\n![](18809_2.png)\n\n```\n1) map값을 입력 받을 때 배양액을 뿌릴 수 있는 곳을 ArrayList로 추가, 전부 추가 후 list길이 계산\n2) 배양액을 놓을 수 있는 위치에 초록색 G개, 빨강색 R개를 고른 조합 구한다.\n3) bfs로 탐색\n  3.1) 배양액을 뿌린 초록색 G개, R개 큐에 추가, 방문 처리\n  3.2) 문제 조건에 맞춰 bfs탐색을 하는데 주의 할 조건으로 같은 시간에 방문한 값들만 꽃이 핀 처리\n```\n\n```java\npackage backtracking;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\npublic class num18809 {\n    static int N, M, G, R, len, res = 0;\n    static int[] arrG, arrR;\n    static int[] X = {-1, 0, 1, 0};\n    static int[] Y = {0, 1, 0, -1};\n    static int[][] map;\n    static Pos[][] visited;\n    static ArrayList<Pos> list = new ArrayList<>();\n    static Queue<Pos> q = new LinkedList<>();\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        String[] input = br.readLine().split(\" \");\n        N = stoi(input[0]);\n        M = stoi(input[1]);\n        G = stoi(input[2]);\n        R = stoi(input[3]);\n\n        map = new int[N][M];\n        arrG = new int[G];\n        arrR = new int[R];\n\n        for (int i = 0; i < N; i++) {\n            input = br.readLine().split(\" \");\n            for (int j = 0; j < M; j++) {\n                map[i][j] = stoi(input[j]);\n                if (map[i][j] == 2) {\n                    list.add(new Pos(i, j, 0));\n                }\n            }\n        }\n\n        len = list.size();\n\n        combination(0, 0, 0);\n\n        System.out.println(res);\n    }\n\n    static void bfs() {\n        visited = new Pos[N][M];\n\n        for (int i = 0; i < G; i++) {\n            Pos p = list.get(arrG[i]);\n            q.offer(p);\n            visited[p.x][p.y] = new Pos(p.time, 'G');\n        }\n\n        for (int i = 0; i < R; i++) {\n            Pos p = list.get(arrR[i]);\n            q.offer(p);\n            visited[p.x][p.y] = new Pos(p.time, 'R');\n        }\n\n        int cnt = 0;\n        while (!q.isEmpty()) {\n            Pos cur = q.poll();\n            int time = visited[cur.x][cur.y].time;\n            char color = visited[cur.x][cur.y].color;\n\n            // Flower가 된 경우에 배양액을 확장시키면 안됨\n            if (visited[cur.x][cur.y].color == 'F')\n                continue;\n\n            for (int d = 0; d < 4; d++) {\n                int nx = cur.x + X[d];\n                int ny = cur.y + Y[d];\n\n                if (!check(nx, ny))\n                    continue;\n\n                if (visited[nx][ny] == null) {\n                    visited[nx][ny] = new Pos(cur.time + 1, color);\n                    q.offer(new Pos(nx, ny, cur.time + 1));\n                } else if (visited[nx][ny].color == 'G' && color == 'R' && visited[nx][ny].time == time + 1) {\n                    cnt++;\n                    visited[nx][ny].color = 'F';\n                } else if (visited[nx][ny].color == 'R' && color == 'G' && visited[nx][ny].time == time + 1) {\n                    cnt++;\n                    visited[nx][ny].color = 'F';\n                }\n            }\n        }\n\n        res = Math.max(res, cnt);\n    }\n\n    static boolean check(int x, int y) {\n        return x >= 0 && y >= 0 && x < N && y < M && map[x][y] != 0;\n    }\n\n    static void combination(int idx, int g, int r) {\n        if (g == G && r == R) {\n            bfs();\n            return;\n        }\n\n        if (g < G) {\n            for (int i = idx; i < len; i++) {\n                arrG[g] = i;\n                combination(i + 1, g + 1, r);\n            }\n        }\n\n        if (r < R) {\n            for (int i = idx; i < len; i++) {\n                arrR[r] = i;\n                combination(i + 1, g, r + 1);\n            }\n        }\n    }\n\n    static class Pos {\n        int x, y, time;\n        char color;\n\n        public Pos(int time, char color) {\n            this.time = time;\n            this.color = color;\n        }\n\n        public Pos(int x, int y, int time) {\n            this.x = x;\n            this.y = y;\n            this.time = time;\n        }\n    }\n\n    public static int stoi(String s) {\n        return Integer.parseInt(s);\n    }\n}\n```\n\n# 분할정복\n\n# DP\n\n> 주어진 문제를 여러개의 부분 문제들로 나누어 푼 다음, 결과들로 주어진 문제 풀이\n\n분할 정복과 비슷하지만  \n**겹치는 문제가 발생하기 때문에 메모제이션 활용**\n\n## 2193번\n\n```java\npackage DP;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\n\npublic class num2193 {\n\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        int n = Integer.parseInt(br.readLine());\n        long [] dp = new long[n+1];\n\n        dp[0] = 0;\n        dp[1] = 1;\n\n        for(int i=2; i<=n; i++)\n            dp[i] = dp[i-1]+dp[i-2];\n\n        System.out.println(dp[n]);\n\n    }\n}\n\n```\n\n## 2240번\n\n```java\npackage DP;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class num2240 {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        String[] TW = br.readLine().split(\" \");\n\n        int T = stoi(TW[0]);\n        int W = stoi(TW[1]);\n\n        // [이동횟수][시간]\n        int[][] dp = new int[W + 1][T + 1];\n\n        for (int i = 1; i <= T; i++) {\n            // 1번 나무, 2번 나무\n            int cur = stoi(br.readLine());\n\n            // 이동하지 않고 자리에 그대로 있는 경우 처리\n            if (cur == 1){\n                dp[0][i] = dp[0][i - 1] + 1;\n            } else {\n                dp[0][i] = dp[0][i - 1];\n            }\n\n            // 움직인 횟수에 대한 받은 자두 값 갱신\n            for (int j = 1; j <= W; j++) {\n                // 나무 1\n                if (j % 2 == 0) {\n                    if (cur == 1) {\n                        dp[j][i] = Math.max(dp[j - 1][i - 1], dp[j][i - 1] + 1);\n                    } else {\n                        dp[j][i] = Math.max(dp[j - 1][i - 1] + 1, dp[j][i - 1]);\n                    }\n\n                }\n                // 나무 2\n                else {\n                    if (cur == 1) {\n                        dp[j][i] = Math.max(dp[j - 1][i - 1] + 1, dp[j][i - 1]);\n                    } else {\n                        dp[j][i] = Math.max(dp[j - 1][i - 1], dp[j][i - 1] + 1);\n                    }\n                }\n            }\n        }\n\n        int ans = 0;\n        for (int i = 0; i <= W; i++)\n            ans = Math.max(ans, dp[i][T]);\n\n        System.out.println(ans);\n\n    }\n\n    public static int stoi(String s) {\n        return Integer.parseInt(s);\n    }\n}\n\n```\n\n## 2294번\n\n![](2294.png)\n\nN 개의 동전으로 K 값을 만드는데 최소 값을 찾는다.\n\n동전을 선택해 값을 만들 수 있는 방법을 배열에 저장하고 갱신하면서 배열에 최소 값을 저장한다.\n\n주의 할 부분으로 dp배열을 초기화 할 때 INF 값으로 초기화 하면\n\n입력  \n3 15  \n12  \n5  \n1\n\n출력  \n-2147483648\n\n와같이 출력이 되는데\n\n![](2294_debug.png)\n\n위 사진과 같이 INF + 1이 되면서 오버플로우가나 Integer.MIN_VALUE값이 저장되어 제대로 갱신되지 않는다\n\nINF - 1 한 값을 사용하거나 적당한 값으로 계산해야 함\n\n```java\npackage DP;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class num2294 {\n    static int N, K, coins[], dp[], INF = Integer.MAX_VALUE - 1, res;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        String[] NK = br.readLine().split(\" \");\n\n        N = stoi(NK[0]);\n        K = stoi(NK[1]);\n\n        coins = new int[N];\n\n        for (int i = 0; i < N; i++) {\n            coins[i] = stoi(br.readLine());\n        }\n\n        dp = new int[K + 1];\n\n        Arrays.fill(dp, INF);\n\n        dp[0] = 0;\n        for (int i = 0; i < N; i++) {\n            for (int j = coins[i]; j <= K; j++) {\n                dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);\n            }\n        }\n\n        System.out.println(dp[K] == INF? -1 : dp[K]);\n    }\n\n    public static int stoi(String s) {\n        return Integer.parseInt(s);\n    }\n}\n\n```\n\n# 구현\n\n## 14499번\n\n![](14499_1.png)\n![](14499_2.png)\n\n생각보다 구현이 빡세다\n\n풀이 핵심은 6개의 값을 가진 주사위 클래스를 만들어\n\n1. Command 마다 주사위 면의 값 변경\n\n2. 지도의 면과 맞닿은 bottom 값 처리이다.\n\n```java\npackage implementation;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class num14499 {\n    static int N, M, x, y, K, map[][], commands[];\n    static ArrayList<Integer> results = new ArrayList<>();\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        String[] input = br.readLine().split(\" \");\n\n        N = stoi(input[0]);\n        M = stoi(input[1]);\n        x = stoi(input[2]);\n        y = stoi(input[3]);\n        K = stoi(input[4]);\n        map = new int[N][M];\n        commands = new int[K];\n\n        for (int i = 0; i < N; i++) {\n            input = br.readLine().split(\" \");\n\n            for (int j = 0; j < M; j++) {\n                map[i][j] = stoi(input[j]);\n            }\n        }\n\n        input = br.readLine().split(\" \");\n\n        Dice dice = new Dice(x, y);\n\n        for(int i = 0; i < K; i++) {\n            commands[i] = stoi(input[i]) - 1;\n\n            int res = dice.run(commands[i]);\n\n            if(res == -1) {\n                continue;\n            }\n\n            results.add(res);\n        }\n\n        for(int result : results) {\n            System.out.println(result);\n        }\n    }\n\n    static class Dice {\n        // 동, 서, 북, 남\n        int[] dx = {0, 0, -1, 1}, dy = {1, -1, 0, 0};\n\n        int x, y; // 현재 좌표\n        int top, left, right, up, down, bottom;\n\n        Dice(int x, int y) {\n            this.x = x;\n            this.y = y;\n            top = 0;\n        }\n\n        public int run(int command) {\n            int nx = this.x + dx[command];\n            int ny = this.y + dy[command];\n\n            // 맵 범위에 벗어나면 명령 무시\n            if(!checkMapPoint(nx, ny)) {\n                return -1;\n            }\n            x = nx;\n            y = ny;\n            // 동\n            if(command == 0) {\n                // 주사위 이동\n                int tmp = left;\n                left = bottom;\n                bottom = right;\n                right = top;\n                top = tmp;\n            }\n            // 서\n            else if(command == 1){\n                int tmp = right;\n                right = bottom;\n                bottom = left;\n                left = top;\n                top = tmp;\n            }\n            // 북\n            else if(command == 2) {\n                int tmp = up;\n                up = top;\n                top = down;\n                down = bottom;\n                bottom = tmp;\n            }\n            // 남\n            else if(command == 3) {\n                int tmp = down;\n                down = top;\n                top = up;\n                up = bottom;\n                bottom = tmp;\n            }\n\n            // 주사위 처리\n            if(map[nx][ny] != 0) {\n                bottom = map[nx][ny];\n                map[nx][ny] = 0;\n            } else {\n                map[nx][ny] = bottom;\n            }\n\n            return top;\n        }\n\n        public boolean checkMapPoint(int x, int y){\n            return x >= 0 && y >= 0 && y < M && x < N;\n        }\n    }\n\n    public static int stoi(String s) {\n        return Integer.parseInt(s);\n    }\n}\n\n```\n\n## 17142번\n\n![](17142_1.png)\n![](17142_2.png)\n\nmap의 정보를 입력받을 때 바이러스의 위치와 빈 공간의 수를 따로 저장한다.\n\n2로 입력받은 바이러스의 총 수에서 M개 만큼 선택해 bfs로 탐색하며 최소 시간을 구해준다.\n\n탐색 시 바이러스를 둘 수 있는 공간은 빈 공간으로 계산하지 않는게 중요\n\n```java\npackage implementation;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class num17142 {\n    static int N, M, map[][], min = Integer.MAX_VALUE, originEmptyCnt = 0;\n    static int[] dx = new int[]{1, -1, 0, 0}, dy = new int[]{0, 0, 1, -1};\n    static boolean[][] visited;\n    static ArrayList<Virus> viruses = new ArrayList<>();\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        String[] NM = br.readLine().split(\" \");\n\n        N = stoi(NM[0]);\n        M = stoi(NM[1]);\n        map = new int[N][N];\n\n        for (int i = 0; i < N; i++) {\n            String[] input = br.readLine().split(\" \");\n            for (int j = 0; j < N; j++) {\n                map[i][j] = stoi(input[j]);\n                if (map[i][j] == 2) {\n                    viruses.add(new Virus(i, j, 0));\n                }else if (map[i][j] == 0) {\n                    originEmptyCnt++;\n                }\n            }\n        }\n\n        selectVirus(0, 0, new Virus[M]);\n\n        if (originEmptyCnt == 0) {\n            System.out.println(0);\n            return;\n        }\n\n        System.out.println(min == Integer.MAX_VALUE ? -1 : min);\n    }\n\n    static void selectVirus(int idx, int cnt, Virus[] selected) {\n        if (cnt == M) {\n            searchVirus(selected, originEmptyCnt);\n            return;\n        }\n\n        for (int i = idx; i < viruses.size(); i++) {\n            selected[cnt] = viruses.get(i);\n            selectVirus(i + 1, cnt + 1, selected);\n        }\n    }\n\n    static void searchVirus(Virus[] list, int emptyCnt) {\n        Queue<Virus> q = new LinkedList<>();\n        visited = new boolean[N][N];\n\n        for (Virus virus : list) {\n            q.add(virus);\n            visited[virus.x][virus.y] = true;\n        }\n\n        while (!q.isEmpty()) {\n            Virus cur = q.poll();\n\n            for (int j = 0; j < 4; j++) {\n                int nx = cur.x + dx[j];\n                int ny = cur.y + dy[j];\n\n                if (!checkMapArea(nx, ny)) continue;\n                if (visited[nx][ny] || map[nx][ny] == 1) continue;\n\n                if (map[nx][ny] == 0) {\n                    emptyCnt--;\n                }\n\n                if (emptyCnt == 0) {\n                    min = Math.min(min, cur.time + 1);\n                    return;\n                }\n\n                q.add(new Virus(nx, ny, cur.time + 1));\n                visited[nx][ny] = true;\n            }\n        }\n    }\n\n    static boolean checkMapArea(int x, int y) {\n        return x >= 0 && y >= 0 && x < N && y < N;\n    }\n\n    static class Virus {\n        int x, y, time;\n\n        Virus(int x, int y, int time) {\n            this.x = x;\n            this.y = y;\n            this.time = time;\n        }\n    }\n\n    public static int stoi(String s) {\n        return Integer.parseInt(s);\n    }\n}\n```\n\n## 21608번\n\n전처리 할게 좀 많다.\n\n값을 입력 받을 때\n\n1. student index 배열\n2. student index로 친한 친구(HashSet)을 저장 할 map\n\n을 입력 받고 값을 받을 때 마다 자리에 넣어준다.\n\n나머진 조건대로 하면 되는데 좋아하는 학생이 동일 할 경우 우선순위를 정하기 위해\n\nPriority Queue를 활용해 값을 입력받는다.\n\n```java\npackage implementation;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class num21608 {\n    static int N, studentLen, res = 0;\n    static Student students[];\n    static HashMap<Integer, HashSet> hashMap = new HashMap<>();\n    static int[][] resultMap;       // 최종 결과 저장\n    static int[][] checkValueMap;   //\n    static int[] dx = new int[]{1, -1, 0, 0}, dy = new int[]{0, 0, 1, -1};\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        N = stoi(br.readLine());\n        studentLen = N * N;\n        students = new Student[studentLen];\n\n        resultMap = new int[N][N];\n\n        for (int i = 0; i < studentLen; i++) {\n            HashMap<Integer, HashSet<Integer>> student = new HashMap<Integer, HashSet<Integer>>();\n\n            String[] input = br.readLine().split(\" \");\n\n            HashSet<Integer> favoriteFriend = new HashSet<>();\n\n            for (int j = 1; j < input.length; j++) {\n                favoriteFriend.add(stoi(input[j]));\n            }\n\n            students[i] = new Student(stoi(input[0]), favoriteFriend);\n            hashMap.put(stoi(input[0]) , favoriteFriend);\n        }\n\n        for (int i = 0; i < studentLen; i++) {\n            // 하나씩 넣음\n            searchStudentPosition(i);\n        }\n\n        calcResult();\n\n        // 결과\n        System.out.println(res);\n\n    }\n\n    public static void searchStudentPosition(int idx) {\n        checkValueMap = new int[N][N];\n        Student student = students[idx];\n        PriorityQueue<Point> possiblePoint = new PriorityQueue<>();\n        int max = 0;\n\n        // 조건 1. 비어있는 칸 중에서 좋아하는 학생이 인접한 칸에 가장 많은 칸으로 자리를 정한다.\n        for (int i = 0; i < studentLen; i++) {\n            int x = i / N, y = i % N, cx, cy;\n            int blankCount = 0;\n\n            // 현재 앉은 자리 있으면 pass\n            if (resultMap[x][y] != 0) {\n                continue;\n            }\n\n            for (int j = 0; j < 4; j++) {\n                cx = dx[j] + x;\n                cy = dy[j] + y;\n\n                if (checkMapRange(cx, cy)) {\n                    // 현재 좌표가 좋아하는 친구인지\n                    if (student.favoriteList.contains(resultMap[cx][cy])) {\n                        checkValueMap[x][y] += 1;\n                    }\n\n                    if(resultMap[cx][cy] == 0) {\n                        blankCount++;\n                    }\n                }\n            }\n\n            if (checkValueMap[x][y] > max) {\n                max = checkValueMap[x][y];\n\n                // 선택 가능한 좌표 리스트 초기화\n                possiblePoint.clear();\n                possiblePoint.add(new Point(x, y, blankCount, checkValueMap[x][y]));\n\n            } else if (checkValueMap[x][y] == max) {\n                possiblePoint.add(new Point(x, y, blankCount, checkValueMap[x][y]));\n            }\n        }\n\n        Point selected = possiblePoint.remove();\n        resultMap[selected.x][selected.y] = student.num;\n\n    }\n\n    public static void calcResult() {\n        for (int i = 0; i < studentLen; i++) {\n            int x = i / N, y = i % N, cx, cy;\n            int count = 0;\n            HashSet map = hashMap.get(resultMap[x][y]);\n\n            for (int j = 0; j < 4; j++) {\n                cx = dx[j] + x;\n                cy = dy[j] + y;\n\n                if (checkMapRange(cx, cy) && map.contains(resultMap[cx][cy])) {\n                    count++;\n                }\n            }\n\n            if(count == 1) {\n                res += 1;\n            } else if (count == 2) {\n                res += 10;\n            } else if (count == 3) {\n                res += 100;\n            } else if (count == 4) {\n                res += 1000;\n            }\n        }\n    }\n\n    static class Point implements Comparable<Point> {\n        int x, y, blank, like;\n\n        Point(int x, int y, int blank, int like) {\n            this.x = x;\n            this.y = y;\n            this.blank = blank;\n            this.like = like;\n        }\n\n        public int compareTo(Point o) {\n            // like 많은 순 -> blank 많은 순 -> y 작은 순 -> x 작은 순\n            if (this.like != o.like) {\n                return o.like - this.like;\n            }\n            if (this.blank != o.blank) {\n                return o.blank - this.blank;\n            }\n            if (this.y != o.y) {\n                return this.y - o.y;\n            }\n            return this.x - o.x;\n        }\n    }\n\n    static class Student {\n        int num;\n        HashSet<Integer> favoriteList;\n\n        Student(int n, HashSet list) {\n            this.num = n;\n            this.favoriteList = list;\n        }\n    }\n\n    public static boolean checkMapRange(int x, int y) {\n        return x >= 0 && y >= 0 && x < N && y < N;\n    }\n\n\n    public static int stoi(String s) {\n        return Integer.parseInt(s);\n    }\n}\n\n\n```\n\n# 이분탐색\n\n## 2467번\n\n![](2467.png)\n\nleft, right 2개 인덱스를 사용해서 값을 더하고 절대값이 가장 작은 값을 찾는다.\n\n절대 값이 기존 값보다 작을 경우 left, right값을 따로 저장\n\n더한 값이 0보다 크면 right감소 0보다 작으면 left 증가\n\n```java\npackage binarySearch;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class num2467 {\n    static int N;\n    static long[] list;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        N = stoi(br.readLine());\n        list = new long[N];\n\n        String[] input = br.readLine().split(\" \");\n\n        for (int i = 0; i < input.length; i++) {\n            list[i] = stol(input[i]);\n        }\n\n        int left = 0;\n        int right = N - 1;\n        int minIdx = 0, maxIdx = 0;\n        long min = Long.MAX_VALUE;\n\n        while (left < right) {\n            long sum = list[left] + list[right];\n            if (min > Math.abs(sum)) {\n                min = Math.abs(sum);\n                minIdx = left;\n                maxIdx = right;\n            }\n\n            if (sum >= 0) {\n                right--;\n            } else {\n                left++;\n            }\n        }\n\n        System.out.println(list[minIdx] + \" \" + list[maxIdx]);\n\n    }\n\n    public static long stol(String s){\n        return Long.parseLong(s);\n    }\n\n    public static int stoi(String s) {\n        return Integer.parseInt(s);\n    }\n}\n\n```\n\n## 14921번\n\n![](14921.png)\n\n이전 문제와 거의 비슷한데 이전 문제에선 0에 가장 가까운 min값을 저장할 때 절대값의 값을 그대로 저장했는데\n\n이 문제는 0에 가장 가까운 값을 그대로 출력해야 해서 비교 시 abs계산을 한다\n\n```java\npackage binarySearch;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class num14921 {\n    static int N;\n    static long[] list;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        N = stoi(br.readLine());\n        list = new long[N];\n\n        String[] input = br.readLine().split(\" \");\n\n        for (int i = 0; i < input.length; i++) {\n            list[i] = stol(input[i]);\n        }\n\n        int left = 0;\n        int right = N - 1;\n        long min = Long.MAX_VALUE;\n\n        while (left < right) {\n            long sum = list[left] + list[right];\n            if (Math.abs(min) > Math.abs(sum)) {\n                min = sum;\n            }\n\n            if (sum >= 0) {\n                right--;\n            } else {\n                left++;\n            }\n        }\n\n        System.out.println(min);\n\n    }\n\n    public static long stol(String s){\n        return Long.parseLong(s);\n    }\n\n    public static int stoi(String s) {\n        return Integer.parseInt(s);\n    }\n}\n\n```\n\n## 2473번\n\n![](2473.png)\n\n기존 이분탐색에서 바같에 for문을 추가해 용액의 개수 - 2만큼 돌면서 첫번째 인덱스로 사용 (총 3개 인덱스 사용)\n\nleft를 첫번째 인덱스 + 1부터 시작해 3개 합을 구해서 이분탐색\n\n```java\npackage binarySearch;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.lang.reflect.Array;\nimport java.util.Arrays;\n\npublic class num2473 {\n    static int N;\n    static long[] list;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        N = stoi(br.readLine());\n        list = new long[N];\n\n        String[] input = br.readLine().split(\" \");\n\n        for (int i = 0; i < input.length; i++) {\n            list[i] = stol(input[i]);\n        }\n\n        Arrays.sort(list);\n\n        int minIdx = 0, maxIdx = 0, midIdx = 0;\n        long min = Long.MAX_VALUE;\n        for (int i = 0; i < N - 2; i++) {\n            int left = i + 1;\n            int right = N - 1;\n\n            while (left < right) {\n                long sum = list[i] + list[left] + list[right];\n\n                if (min > Math.abs(sum)) {\n                    min = Math.abs(sum);\n                    minIdx = i;\n                    midIdx = left;\n                    maxIdx = right;\n                }\n\n                if (sum >= 0) {\n                    right--;\n                } else {\n                    left++;\n                }\n            }\n        }\n\n        System.out.println(list[minIdx] + \" \" + list[midIdx] + \" \" + list[maxIdx]);\n\n    }\n\n    public static long stol(String s) {\n        return Long.parseLong(s);\n    }\n\n    public static int stoi(String s) {\n        return Integer.parseInt(s);\n    }\n}\n\n```\n\n# Reference\n\n[[실전 알고리즘] 0x11강 - 그리디 / BaaaaaaaarkingDog](https://blog.encrypted.gg/975)  \n[동적 계획법(Dynamic Programming) (수정: 2019-02-07) / Ries](https://blog.naver.com/kks227/220777103650)\n","excerpt":"그리디 매번 선택에서 최적의 답을 근시안적으로 택하는 알고리즘 (= 관찰을 통해 탐색범위를 줄임) 1449번  맨 처음 물이 새는 위치부터 테이프를 붙여주는 처리후에 L값 범위 안으로 처리 가능하면 이전 테이프와 거리차를 더해가며 하나의 테이프로 처…","fields":{"slug":"/CodingTest2/"},"frontmatter":{"date":"Dec 06, 2022","title":"유형 별 알고리즘 문제 풀이 (그리디, 백트래킹, 이분탐색, DP, 구현)","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\nn, m, arr을 받아 순열, 조합, 중복 순열, 중복 조합 전부 출력하는 형태로 구현 해보자\n\n정리하고 백트래킹 문제 좀 풀어봐야 겠따\n\n| 종류      | 정의                                                      | 중복 | 순서 |\n| --------- | --------------------------------------------------------- | ---- | ---- |\n| 순열      | n개의 원소 중 r개를 순서를 고려 해 나열                   | X    | O    |\n| 중복 순열 | n개의 원소 중 r개를 중복을 허용하고, 순서 고려해 나열     | O    | O    |\n| 조합      | n개의 원소 중 r개를 순서 생각하지 않고 나열               | X    | X    |\n| 중복 조합 | n개의 원소 중 r개를 중복을 허용하고, 순서를 생각하지 않고 | O    | X    |\n\n# 순열\n\n```java\n    // static int arr[], n, r, totalCnt / ArrayList<int[]> res; / boolean[] visited\n    public static void permutation(int cnt, int[] selected) {\n        if (cnt == r) {\n            totalCnt++;\n\n            int[] saveArr = selected.clone();\n            res.add(saveArr);\n\n            return;\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (visited[i]) {\n                continue;\n            }\n\n            visited[i] = true;\n            selected[cnt] = arr[i];\n            permutation(cnt + 1, selected);\n            visited[i] = false;\n        }\n    }\n```\n\nvisited배열을 사용해서 방문체크를 해 중복 제거하며 전체를 돌 수 있게 한다\n\n## 중복 순열\n\n```java\n    // static int arr[], n, r, totalCnt / ArrayList<int[]> res; / boolean[] visited\n    public static void rePermutation(int cnt, int[] selected) {\n        if (cnt == r) {\n            totalCnt++;\n\n            int[] saveArr = selected.clone();\n            res.add(saveArr);\n\n            return;\n        }\n\n        for (int i = 0; i < n; i++) {\n            selected[cnt] = arr[i];\n            rePermutation(cnt + 1, selected);\n        }\n    }\n```\n\n순열에서 중복 된 값을 처리해주는 visited 배열 제거\n\n# 조합\n\n```java\n    // static int arr[], n, r, totalCnt / ArrayList<int[]> res;\n    public static void combination(int idx, int cnt, int[] selected) {\n        if(cnt == r) {\n            totalCnt++;\n\n            int[] saveArr = selected.clone(); // 객체 복사 - 원본 배열과 별개의 주소값으로 새로운 객체 생성\n            res.add(saveArr);\n\n            return;\n        }\n\n        for(int i = idx; i<n; i++){\n            selected[cnt] = arr[i];\n            combination(i + 1, cnt + 1, selected);\n        }\n    }\n```\n\nindex를 변경해 이전 수 참조할 수 없게 다음 값을 인덱스로 전달\n\n# 중복 조합\n\n```java\n    // static int arr[], n, r, totalCnt / ArrayList<int[]> res;\n    public static void reCombination(int idx, int cnt, int[] selected) {\n        if (cnt == r) {\n            totalCnt++;\n\n            int[] saveArr = selected.clone(); // 객체 복사 - 원본 배열과 별개의 주소값으로 새로운 객체 생성\n            res.add(saveArr);\n\n            return;\n        }\n\n        for (int i = idx; i < n; i++) {\n            selected[cnt] = arr[i];\n            reCombination(i, cnt + 1, selected);\n        }\n    }s\n```\n\n중복 조합은 조합 소스에서 index를 자기 자신은 가능하지만, 이전 값들을 다시 쓸 수 없게 구현하면 된다.\n\n# 전체 소스\n\n```java\npackage math;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\n\npublic class example {\n    static int arr[], n, r, totalCnt;\n    static boolean visited[];\n    static ArrayList<int[]> res;\n\n    static String[] commands = {\n            \"permutation\", \"rePermutation\", \"combination\", \"reCombination\"\n    };\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] nr = br.readLine().split(\" \");\n\n        n = stoi(nr[0]);\n        r = stoi(nr[1]);\n        arr = new int[n];\n\n        String[] input = br.readLine().split(\" \");\n        for (int i = 0; i < n; i++) {\n            arr[i] = stoi(input[i]);\n        }\n\n        for (String command : commands) {\n            run(command);\n        }\n    }\n\n    public static void run(String command) {\n        init();\n\n        switch (command) {\n            case \"permutation\":\n                permutation(0, new int[r]);\n                break;\n            case \"rePermutation\":\n                rePermutation(0, new int[r]);\n                break;\n            case \"combination\":\n                combination(0, 0, new int[r]);\n                break;\n            case \"reCombination\":\n                reCombination(0, 0, new int[r]);\n                break;\n        }\n\n        printResult(command);\n    }\n\n    public static void init() {\n        totalCnt = 0;\n        res = new ArrayList<>();\n        visited = new boolean[n];\n    }\n\n    // static int arr[], n, r, totalCnt / ArrayList<int[]> res; / boolean[] visited\n    public static void permutation(int cnt, int[] selected) {\n        if (cnt == r) {\n            totalCnt++;\n\n            int[] saveArr = selected.clone();\n            res.add(saveArr);\n\n            return;\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (visited[i]) {\n                continue;\n            }\n\n            visited[i] = true;\n            selected[cnt] = arr[i];\n            permutation(cnt + 1, selected);\n            visited[i] = false;\n        }\n    }\n\n    // static int arr[], n, r, totalCnt / ArrayList<int[]> res; / boolean[] visited\n    public static void rePermutation(int cnt, int[] selected) {\n        if (cnt == r) {\n            totalCnt++;\n\n            int[] saveArr = selected.clone();\n            res.add(saveArr);\n\n            return;\n        }\n\n        for (int i = 0; i < n; i++) {\n            selected[cnt] = arr[i];\n            rePermutation(cnt + 1, selected);\n        }\n    }\n\n    // static int arr[], n, r, totalCnt / ArrayList<int[]> res;\n    public static void combination(int idx, int cnt, int[] selected) {\n        if (cnt == r) {\n            totalCnt++;\n\n            int[] saveArr = selected.clone(); // 객체 복사 - 원본 배열과 별개의 주소값으로 새로운 객체 생성\n            res.add(saveArr);\n\n            return;\n        }\n\n        for (int i = idx; i < n; i++) {\n            selected[cnt] = arr[i];\n            combination(i + 1, cnt + 1, selected);\n        }\n    }\n\n    // static int arr[], n, r, totalCnt / ArrayList<int[]> res;\n    public static void reCombination(int idx, int cnt, int[] selected) {\n        if (cnt == r) {\n            totalCnt++;\n\n            int[] saveArr = selected.clone(); // 객체 복사 - 원본 배열과 별개의 주소값으로 새로운 객체 생성\n            res.add(saveArr);\n\n            return;\n        }\n\n        for (int i = idx; i < n; i++) {\n            selected[cnt] = arr[i];\n            reCombination(i, cnt + 1, selected);\n        }\n    }\n\n    public static void printResult(String command) {\n        System.out.print(command);\n\n        System.out.print(\"( \");\n        for (int n : arr) {\n            System.out.print(n + \" \");\n        }\n        System.out.println(\")\");\n        System.out.println(\"totalCount : \" + totalCnt);\n\n        for (int[] list : res) {\n            for (int item : list) {\n                System.out.print(item + \" \");\n            }\n            System.out.println();\n        }\n        System.out.println();\n    }\n\n    public static int stoi(String s) {\n        return Integer.parseInt(s);\n    }\n}\n\n```\n\n## 결과\n\n![](result.png)\n\n백준 N과 M ( 1 ~ 4 )문제가 순서대로 순열, 조합, 중복순열, 중복 조합 문제  \n(검증하기 좋다 ㅎㅎ)\n","excerpt":"n, m, arr을 받아 순열, 조합, 중복 순열, 중복 조합 전부 출력하는 형태로 구현 해보자 정리하고 백트래킹 문제 좀 풀어봐야 겠따 종류 정의 중복 순서 순열 n개의 원소 중 r개를 순서를 고려 해 나열 X O 중복 순열 n개의 원소 중 r개를…","fields":{"slug":"/permutation_2/"},"frontmatter":{"date":"Oct 31, 2022","title":"순열, 조합, 중복 순열, 중복 조합, 부분 집합","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n코딩 테스트 준비가 부족해서 유형별로 풀고 정리해보려고 한다.\n\n정렬, 그리디, 해시맵, 스택, BFS, DFS, 그래프 탐색 문제 풀이\n\n[빠킹독 공개 문제집](https://www.acmicpc.net/workbook/by/BaaaaaaaaaaarkingDog), [백준 단계별 문제](https://www.acmicpc.net/step) 여기 있는 문제들로 골랐다.\n\n# 정렬\n\n## 11656번\n\n![](11656.png)\n\nString 배열을 잘라서 접미사 배열을 만들어 주고 정렬하면 된다.\n\n```java\npackage sort;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class num11656 {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        String input = br.readLine();\n        String[] res = new String[input.length()];\n\n        for(int i=0; i<input.length(); i++){\n            res[i] = input.substring(i);\n        }\n\n        Arrays.sort(res);\n\n        for(String item : res){\n            System.out.println(item);\n        }\n\n    }\n}\n\n```\n\n## 10825번\n\n![](10825.png)\n\n사람마다 점수를 저장할 객체 생성, compareTo 함수를 문제에 주어진 조건에 맞게 구현하면 된다\n\n```java\npackage sort;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class num10825 {\n    static int N;\n    static ArrayList<Person> list = new ArrayList<>();\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        N = stoi(br.readLine());\n\n        for(int i=0; i<N; i++){\n            String[] input = br.readLine().split(\" \");\n\n            list.add(new Person(input[0], stoi(input[1]), stoi(input[2]), stoi(input[3])));\n        }\n\n        Collections.sort(list);\n\n        for(Person person : list){\n            System.out.println(person.name);\n        }\n    }\n\n    static class Person implements Comparable<Person> {\n        String name;\n        int kor, eng, math;\n        public Person(String name, int kor, int eng, int math) {\n            this.name = name;\n            this.kor = kor;\n            this.eng = eng;\n            this.math = math;\n        }\n\n        @Override\n        public int compareTo(Person o) {\n            // 국어 (내림차순)\n            if(this.kor > o.kor)\n                return -1;\n            else if(this.kor < o.kor)\n                return 1;\n\n            // 영어 (오름차순)\n            if(this.eng > o.eng)\n                return 1;\n            else if(this.eng < o.eng)\n                return -1;\n\n            // 수학 (내림차순)\n            if(this.math > o.math)\n                return -1;\n            else if(this.math < o.math)\n                return 1;\n\n            // 이름 (오름차순)\n            return this.name.compareTo(o.name);\n        }\n    }\n\n    public static int stoi(String s){\n        return Integer.parseInt(s);\n    }\n}\n\n```\n\n# 그리디\n\n> 매번 선택에서 지금 가장 최적인 답을 근시안적으로 택하는 알고리즘\n\n## 11501번\n\n![](11501.png)\n\n값을 뒤에서부터 확인하며 max값을 갱신\n\n1. max 값보다 크면 max값 갱신\n\n2. max 값보다 작으면 샀을 때 max - 현재 값 만큼 이익\n\n```java\npackage greedy;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class num11501 {\n    static int T, N;\n    static int[] list;\n    static long[] res;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        T = stoi(br.readLine());\n        res = new long[T];\n\n        for (int i = 0; i < T; i++) {\n            N = stoi(br.readLine());\n            String[] input = br.readLine().split(\" \");\n\n            list = new int[N];\n            int max = 0;\n\n            for (int j = 0; j < N; j++) {\n                list[j] = stoi(input[j]);\n            }\n\n            for (int j = 1; j <= N; j++) {\n                if (list[N - j] > max) {\n                    max = list[N - j];\n                } else {\n                    res[i] += (max - list[N - j]);\n                }\n            }\n        }\n\n        for (long item : res) {\n            System.out.println(item);\n        }\n    }\n\n    public static int stoi(String s) {\n        return Integer.parseInt(s);\n    }\n}\n\n```\n\n## 2170번\n\n![](2170.png)\n\n선을 그릴 때 조건을 나눠보면\n\n1. 다음 선이 이전 선에 포함되는 경우\n2. 다음 선이 이전 선과 일부분 포함되는 경우\n3. 다음 선이 이전 선과 포함되지 않는 경우\n\n3가지로 나눠진다.\n\n값을 입력받을 때 선의 시작 지점을 기준으로 오름차순인 우선순위 큐를 선언하고\n\n선을 하나씩 빼며 위 조건에 맞춰 선의 길이를 계속 더하면 된다.\n\n```java\npackage greedy;\n\nimport javax.sound.sampled.Line;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.PriorityQueue;\n\npublic class num2170 {\n    static int N, res = 0;\n    static PriorityQueue<Line> pq = new PriorityQueue<>();\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        N = stoi(br.readLine());\n\n        for(int i=0; i<N; i++){\n            String[] input = br.readLine().split(\" \");\n\n            pq.add(new Line(stoi(input[0]), stoi(input[1])));\n        }\n\n\n        // 초기값 설정\n        Line cur = pq.poll();\n        if (cur != null) {\n            res = cur.end - cur.start;\n        }\n\n        while(!pq.isEmpty()) {\n            Line next = pq.poll();\n\n            // 1. 선이 작은 경우 pass\n            if(next.end <= cur.end) {\n                continue;\n            }\n\n            // 2. 겹치는 경우\n            if(next.start <= cur.end) {\n                res += next.end - cur.end;\n            } else { // 3. 겹치는 영역이 없는 경우\n                res += next.end - next.start;\n            }\n\n            cur = next;\n        }\n\n        System.out.println(res);\n\n    }\n\n    static class Line implements Comparable<Line> {\n        int start, end;\n\n        public Line(int s, int e){\n            this.start = s;\n            this.end = e;\n        }\n\n        @Override\n        public int compareTo(Line o) {\n            return this.start - o.start;\n        }\n    }\n\n    public static int stoi(String s){\n        return Integer.parseInt(s);\n    }\n}\n\n```\n\n# 해시맵\n\n> key - value 형태의 자료구조, 탐색을 O(1)으로 줄여주기 위해 사용\n\n## 1351번\n\n![](1351.png)\n\ndp문제다. 문제에 주어진 대로 점화식을 재귀함수로 구현해주고\n\n메모제이션을 해시맵으로 저장해 사용하면 된다\n\n```java\npackage HashMap;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\n\npublic class num1351 {\n    static long n, p, q;\n    static HashMap<Long, Long> map = new HashMap<Long, Long>();\n\n    static long search(long n) {\n        if (n == 0)\n            return 1;\n\n        if (map.containsKey(n))\n            return map.get(n);\n\n        map.put(n, search(n / p) + search(n / q));\n\n        return map.get(n);\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        String[] input = br.readLine().split(\" \");\n\n        n = stol(input[0]);\n        p = stol(input[1]);\n        q = stol(input[2]);\n\n        System.out.println(search(n));\n    }\n\n    public static long stol(String s){\n        return Long.parseLong(s);\n    }\n}\n```\n\n## 16928번\n\n![](16928_1.png)\n![](16928_2.png)\n\n사다리, 뱀으로 이동하는 부분을 해시맵으로 저장하고\n\nbfs돌면서 탐색\n\n```java\npackage BFSDFS;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.LinkedList;\n\npublic class num16928 {\n    static int N, K, res = 0;\n    static HashMap<Integer, Integer> map = new HashMap<>();\n    static boolean[] visited = new boolean[101];\n    static LinkedList<int[]> q = new LinkedList<>();\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        String[] NK = br.readLine().split(\" \");\n\n        N = stoi(NK[0]);\n        K = stoi(NK[1]);\n\n        for (int i = 0; i < N + K; i++) {\n            String[] input = br.readLine().split(\" \");\n\n            int key = stoi(input[0]);\n            int value = stoi(input[1]);\n\n            map.put(key, value);\n        }\n\n        bfs();\n\n        System.out.println(res);\n    }\n\n    public static void bfs() {\n        q.add(new int[]{1, 0});\n        visited[1] = true;\n\n        while(!q.isEmpty()) {\n            int[] cur = q.poll();\n\n            if (cur[0] == 100) {\n                res = cur[1];\n                return;\n            }\n\n            for(int i=1; i<=6; i++){\n                int next = cur[0] + i;\n                if(next > 100) break;\n                if(visited[next]) continue;\n\n                if(map.containsKey(next)) {\n                    next = map.get(next);\n                    if(visited[next]) continue;\n                }\n\n                visited[next] = true;\n                q.add(new int[] {next, cur[1] + 1});\n            }\n        }\n    }\n\n    public static int stoi(String s) {\n        return Integer.parseInt(s);\n    }\n}\n```\n\n## 20166번\n\n![](20166_1.png)\n![](20166_2.png)\n![](20166_3.png)\n\n검사해야 할 문자들을 hashMap에 저장하고\n\ndfs로 만들 수 있는 문자열을 모두 만들어 확인\n\n보통 map의 밖으로 나가면 검사하지 않는데 이 문제는 map의 반대로 넘어가는 처리 필요\n\n쓸데없이 시간을 많이 썼는데 생각없이 hashMap에 저장된 값들을 그대로 출력하게 짜서 왜맞틀을 시전했다...\n\n입력받은 순서대로 출력할 수 있게 순서대로 배열을 저장시켜 출력한다.\n\n```java\npackage BFSDFS;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\n\npublic class num20166 {\n    static int N, M, K, fsLen = 0;\n    static String keys[];\n    static HashMap<String, Integer> favoriteStrings = new HashMap<>();\n    static String[][] map;\n    static int[] dx = {0, 1, 1, 1, 0, -1, -1, -1};\n    static int[] dy = {1, 1, 0, -1, -1, -1, 0, 1};\n\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        String[] NMK = br.readLine().split(\" \");\n        N = stoi(NMK[0]);\n        M = stoi(NMK[1]);\n        K = stoi(NMK[2]);\n\n        map = new String[N][M];\n        keys = new String[K];\n\n        for (int i = 0; i < N; i++) {\n            String[] input = br.readLine().split(\"\");\n            for (int j = 0; j < M; j++) {\n                map[i][j] = input[j];\n            }\n        }\n\n        for (int i = 0; i < K; i++) {\n            String inputString = br.readLine();\n            fsLen = Math.max(fsLen, inputString.length());\n            favoriteStrings.put(inputString, 0);\n            keys[i] = inputString;\n        }\n\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < M; j++) {\n                makeString(i, j, 1, map[i][j]);\n            }\n        }\n\n        for(String key : keys){\n            System.out.println(favoriteStrings.get(key));\n        }\n\n    }\n\n    public static void makeString(int x, int y, int depth, String item) {\n        if(favoriteStrings.containsKey(item)){\n            favoriteStrings.put(item, favoriteStrings.get(item) + 1);\n        }\n\n        // 종료 조건\n        if (depth == fsLen) {\n            return;\n        }\n\n        for (int i = 0; i < dx.length; i++) {\n            int cx = checkMapValue(dx[i] + x, N);\n            int cy = checkMapValue(dy[i] + y, M);\n\n            String cItem = item + map[cx][cy];\n\n            makeString(cx, cy, depth + 1, cItem);\n        }\n\n    }\n\n    public static int checkMapValue(int value, int checkValue) {\n        if(value >= checkValue) {\n            return 0;\n        }else if(value < 0) {\n            return checkValue - 1;\n        }\n\n        return value;\n    }\n\n\n    public static int stoi(String s) {\n        return Integer.parseInt(s);\n    }\n}\n\n```\n\n# 스택\n\n> 현재 값을 기준으로 과거 값을 처리하는 유형\n\n## 3986\n\n![](3986.png)\n\n문자 나눠서 같은 경우 스택에서 제거하고, 다른경우 스택에 추가해서\n\n스택이 비었는지 확인 후에 결과값에 추가\n\n```java\npackage stack;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Stack;\n\npublic class num3986 {\n    static int N, res;\n    static Stack<String> stack;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        N = stoi(br.readLine());\n\n        for(int i=0; i<N; i++){\n            String[] input = br.readLine().split(\"\");\n\n            stack = new Stack<String>();\n            for(int j=0; j<input.length; j++){\n                if(stack.empty()){\n                    stack.push(input[j]);\n                    continue;\n                }\n\n                if(stack.peek().equals(input[j]))\n                    stack.pop();\n                else\n                    stack.push(input[j]);\n            }\n\n            if(stack.empty())\n                res++;\n        }\n\n        System.out.println(res);\n    }\n\n    public static int stoi(String s){\n        return Integer.parseInt(s);\n    }\n}\n\n```\n\n## 2841\n\n![](2841_1.png)\n![](2841_2.png)\n\n라인별로 스택을 생성하고 누르고 있는 숫자를 스택에 저장한다\n\n1. stack.top > now 인 경우 -> 손가락 뗴야함 -> 값 제거, 결과 + 1\n2. stack.top < now 인 경우 -> 눌러야 함 -> 값 추가 , 결과 + 1\n3. stack.top == now 인 경우 -> pass\n\n로 케이스를 나눠 처리하면 된다.\n\n## 2493\n\n![](2493_1.png)\n![](2493_2.png)\n\nstack에 [높이, 인덱스]값을 추가하는데\n\n스택엔 **새로 추가한 탑의 높이보다 큰 탑**을 가지고 있으면 된다\n\n```java\npackage stack;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Stack;\n\npublic class num2493 {\n    static long N;\n    static Stack<Long[]> stack = new Stack<>();\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder sb = new StringBuilder();\n\n        N = stol(br.readLine());\n        String[] input = br.readLine().split(\" \");\n\n        for(int i=0; i<N; i++){\n            long item = stol(input[i]);\n\n            while(!stack.empty()){\n                if(stack.peek()[0] >= item) {\n                    sb.append(stack.peek()[1] + \" \");\n                    break;\n                }\n                stack.pop();\n            }\n\n            if(stack.isEmpty()) {\n                sb.append(\"0 \");\n            }\n            stack.push(new Long[] {item, (long) i + 1});\n        }\n\n        System.out.println(sb.toString());\n    }\n\n    public static long stol(String s){\n        return Long.parseLong(s);\n    }\n}\n\n```\n\n## 3015번\n\n![](3015_1.png)\n![](3015_2.png)\n\n풀이가 좀 어려웠다ㅜ\n\n값의 범위 때문에 long 형태를 사용하고\n\n값을 스택에 저장하는데 [길이, 횟수] 를 저장해야 한다 (길이가 같은 값을 처리하기 위해)\n\n값이 추가 되면서 이전 값들과 짝을 이룰 수 있는 지 확인 하는 형태로 반복문이 진행되는데\n\n케이스는 총 3개로 나눠 생각해야 한다\n\n1. **stack.top > now**인 경우  \n   -> stack의 top인 사람과 쌍을 지을 수 있다. (이전 값들은 가려져서 보이지 않음)\n2. **stack.top < now**인 경우  \n   -> 스택에 담겨 있을 필요 없는 값들 제거하며 값 증가\n3. **stack.top == now**인 경우  \n   -> 같은 키를 갖는 사람들과 모두 쌍을 지을 수 있어 같은 높이를 가진 **사람을 모두 더해주고**  \n   -> (스택에 값이 있으니) 자기 자신을 하나 추가해 스택에 값 추가\n\n2412251을 예시로 설명하면\n\n| 단계 | 추가 값 | stack        | res |\n| ---- | ------- | ------------ | --- |\n| 1    | 2       | <2,1>        | 0   |\n| 2    | 4       | <4,1>        | 1   |\n| 3    | 1       | <4,1>, <1,1> | 2   |\n| 4    | 2       | <4,1>, <2,1> | 4   |\n| 5    | 2       | <4,1>, <2,2> | 6   |\n| 6    | 5       | <5,1>        | 9   |\n| 7    | 1       | <5,1>, <1,1> | 10  |\n\n위 표와같이 진행되는데\n\n값 추가 시 result값이 먼저 계산되고 stack에 추가된다\n\n```java\npackage stack;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Stack;\n\npublic class num3015 {\n    static long N, res;\n    static Stack<long[]> stack = new Stack<>();\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        N = stol(br.readLine());\n\n        for(int i=0; i<N; i++){\n            long input = stol(br.readLine());\n            // 0 = 높이, 1 = 개수\n            long[] now = new long[]{input, 1};\n            long[] top;\n\n            // 스택에 담겨 있을 필요 없는 값들 제거하며 값 증가\n            while(!stack.empty() && stack.peek()[0] <= now[0]){\n                top = stack.pop();\n                res += top[1];\n\n                // 키가 같을 경우 같은 키를 가진사람과 모두 쌍을 지을 수 있음\n                if(top[0] == input){\n                    now[1] += top[1];\n                }\n            }\n\n            // 스택에 값이 있으면 현재 값과 매칭 가능\n            if(!stack.empty()) {\n                res++;\n            }\n\n            stack.push(now);\n        }\n\n        System.out.println(res);\n\n    }\n\n    public static long stol(String s){\n        return Long.parseLong(s);\n    }\n}\n\n```\n\n# DFS, BFS\n\n> DFS - 재귀, 스택 / BFS - 큐 으로 구현\n> 방문 처리 필요\n\n## 5427번\n\n![](5427_1.png)\n![](5427_2.png)\n\nQueue를 2개 사용해서 불, 사람을 이동 시킨다.\n\n```java\npackage BFSDFS;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class num5427 {\n    static int N, w, h, result;\n    static int[] dx = {1, -1, 0, 0}, dy = {0, 0, 1, -1};\n    static Queue<Position> personQueue;\n    static Queue<Position> fireQueue;\n    static String map[][], res[];\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        N = stoi(br.readLine());\n        res = new String[N];\n\n        for (int i = 0; i < N; i++) {\n            String[] wh = br.readLine().split(\" \");\n            w = stoi(wh[0]);\n            h = stoi(wh[1]);\n\n            // h : 행 / w : 열\n            map = new String[h][w];\n            personQueue = new LinkedList<>();\n            fireQueue = new LinkedList<>();\n\n            for (int j = 0; j < h; j++) {\n                String[] input = br.readLine().split(\"\");\n                for (int k = 0; k < w; k++) {\n                    if (input[k].equals(\"@\")) {\n                        personQueue.add(new Position(j, k));\n                    } else if (input[k].equals(\"*\")) {\n                        fireQueue.add(new Position(j, k));\n                    }\n\n                    map[j][k] = input[k];\n                }\n            }\n\n            result = 0;\n            bfs();\n\n            res[i] = result == 0 ? \"IMPOSSIBLE\" : Integer.toString(result);\n        }\n\n        for (String item : res) {\n            System.out.println(item);\n        }\n\n    }\n\n    public static void bfs() {\n        int cnt = 0;\n\n        while (!personQueue.isEmpty()) {\n            // 1. 먼저 불 전파\n            int fSize = fireQueue.size();\n\n            // 현재 q에 들어있는 것들 전파\n            for (int i = 0; i < fSize; i++) {\n                Position cur = fireQueue.poll();\n\n                for(int j=0; j<4; j++){\n                    int cx = cur.x + dx[j];\n                    int cy = cur.y + dy[j];\n\n                    if(checkValue(cx, cy)) {\n                        if(map[cx][cy].equals(\"@\") || map[cx][cy].equals(\".\")) {\n                            map[cx][cy] = (\"*\");\n                            fireQueue.add(new Position(cx, cy));\n                        }\n                    }\n                }\n            }\n\n            // 2. 사람 이동\n            int pSize = personQueue.size();\n\n            for(int i=0; i<pSize; i++){\n                Position cur = personQueue.poll();\n\n                for(int j=0; j<4; j++){\n                    int cx = cur.x + dx[j];\n                    int cy = cur.y + dy[j];\n\n                    if(!checkValue(cx, cy)) {\n                        result = cnt + 1;\n                        return;\n                    }\n\n                    if(checkValue(cx, cy)) {\n                        if(map[cx][cy].equals(\".\")) {\n                            map[cx][cy] = (\"@\");\n                            personQueue.add(new Position(cx, cy));\n                        }\n                    }\n                }\n            }\n            cnt++;\n        }\n    }\n\n\n    static boolean checkValue(int x, int y) {\n        return x >= 0 && y >= 0 && x < h && y < w;\n    }\n\n    public static class Position {\n        int x, y;\n\n        Position(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    public static int stoi(String s) {\n        return Integer.parseInt(s);\n    }\n}\n\n```\n\n## 2573번\n\n![](2573_1.png)\n![](2573_2.png)\n\n... 좀 지저분하게 짰는데 핵심은 **빙산의 덩어리를 먼저 계산**  \n-> 빙산 처리를 할 때 visited배열을 써서 기존에 빙산이 있던 곳은 0으로 계산하지 않게 처리\n\ncurHeight <= 0 을 curHeight < 0 처리해서 좀 오래걸렸다... ㅋㅋ;\n\n```java\npackage BFSDFS;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class num2573 {\n    static int N, M, map[][], res, time, part;\n    static int[] dx = {1, -1, 0, 0}, dy = {0, 0, -1, 1};\n    static boolean flag = false, visited[][];\n    static Queue<Point> q = new LinkedList<>();\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        String[] NM = br.readLine().split(\" \");\n\n        N = stoi(NM[0]);\n        M = stoi(NM[1]);\n        map = new int[N][M];\n\n        for (int i = 0; i < N; i++) {\n            String[] input = br.readLine().split(\" \");\n\n            for (int j = 0; j < M; j++) {\n                int item = stoi(input[j]);\n\n                if (item != 0) {\n                    q.add(new Point(i, j));\n                }\n\n                map[i][j] = item;\n            }\n        }\n\n        while (!q.isEmpty()) {\n            visited = new boolean[N][M];\n\n            // 빙산 개수\n            part = 0;\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < M; j++) {\n                    if (!visited[i][j] && map[i][j] > 0) {\n                        dfs(i, j);\n                        part++;\n                    }\n                }\n            }\n\n            if(part > 1){\n                flag = true;\n                break;\n            } else if(part == 0) {\n                break;\n            }\n\n            int size = q.size();\n            time++;\n            visited = new boolean[N][M];\n            // 빙산 처리\n            for (int i = 0; i < size; i++) {\n                Point cur = q.poll();\n                int curHeight = map[cur.x][cur.y];\n                int cnt = 0;\n                visited[cur.x][cur.y] = true;\n\n                for (int add = 0; add < 4; add++) {\n                    int cx = cur.x + dx[add];\n                    int cy = cur.y + dy[add];\n\n                    if (checkValue(cx, cy)) {\n                        if (!visited[cx][cy] && map[cx][cy] == 0) {\n                            cnt++;\n                        }\n                    }\n                }\n\n                curHeight -= cnt;\n\n                if (curHeight <= 0) {\n                    curHeight = 0;\n                } else {\n                    q.add(new Point(cur.x, cur.y));\n                }\n\n                map[cur.x][cur.y] = curHeight;\n            }\n        }\n\n\n        System.out.println(flag ? time : 0);\n    }\n\n    public static void dfs(int x, int y) {\n        visited[x][y] = true;\n\n\n        for (int i = 0; i < 4; i++) {\n            int cx = x + dx[i];\n            int cy = y + dy[i];\n\n            if (checkValue(cx, cy)) {\n                if (!visited[cx][cy] && map[cx][cy] != 0) {\n                    dfs(cx, cy);\n                }\n            }\n        }\n    }\n\n\n    public static boolean checkValue(int x, int y) {\n        return x >= 0 && y >= 0 && x < N && y < M;\n    }\n\n    public static class Point {\n        int x, y;\n\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n    }\n\n    public static int stoi(String s) {\n        return Integer.parseInt(s);\n    }\n}\n\n```\n\n## 9019번\n\n![](9019.png)\n\n문제에 주어진 1. 현재 숫자 2. command 대로 동작하는 클래스를 하나 만들어주고\n\nbfs값 탐색 후에 순서대로 출력\n\n```java\npackage BFSDFS;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class num9019 {\n    static int T;\n    static String[] res;\n    static String[] go = new String[]{\"D\", \"S\", \"L\", \"R\"};\n    static Queue<Register> q;\n    static boolean[] visit = new boolean[10000];\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        T = stoi(br.readLine());\n        res = new String[T];\n\n        for (int i = 0; i < T; i++) {\n            String[] AB = br.readLine().split(\" \");\n            int A = stoi(AB[0]);\n            int B = stoi(AB[1]);\n\n            q = new LinkedList<>();\n            visit = new boolean[10000];\n            search(A, B, i);\n        }\n\n        for (String item : res) {\n            System.out.println(item);\n        }\n    }\n\n    public static void search(int A, int B, int index) {\n        q.add(new Register(A, \"\"));\n\n        while (!q.isEmpty()) {\n            int size = q.size();\n\n            for (int si = 0; si < size; si++) {\n                Register cur = q.poll();\n                if (cur.num == B) {\n                    res[index] = cur.command;\n                    return;\n                }\n\n                for (int i = 0; i < 4; i++) {\n                    int cx = cur.run(go[i]);\n                    if (!visit[cx]) {\n                        q.add(new Register(cx, cur.command + go[i]));\n                        visit[cx] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    static class Register {\n        int num;\n        String command;\n\n        Register(int num, String command) {\n            this.num = num;\n            this.command = command;\n        }\n\n        int run (String run) {\n            if(run.equals(\"D\")){\n                return (num * 2) % 10000;\n            }else if(run.equals(\"S\")){\n                return num == 0 ? 9999 : num - 1;\n            }else if(run.equals(\"L\")){\n                return num % 1000 * 10 + num / 1000;\n            }else if(run.equals(\"R\")){\n                return num % 10 * 1000 + num / 10;\n            }\n            return 0;\n        }\n    }\n\n    public static int stoi(String s) {\n        return Integer.parseInt(s);\n    }\n}\n\n```\n\n# 그래프\n\n## 1939번\n\n![](1939.png)\n\n.... 오래 걸렸다\n\n실수한 부분은 2가지\n\n1. 별 생각 안하고 DFS로 탐색하는 방법으로 풀었는데 정점(N), 간선(M)값이 100000으로 O(V+E) 시간 초과 -> 이분 탐색으로 탐색이 가능한지 확인\n\n2. dfs시 visited배열을 재사용 하지 않고 false로 바꿔주면서 사용하니 메모리 초과 -> 인자값으로 넘겨줘 재사용\n\n추가로 다익스트라, 크루스칼 알고리즘으로 풀이가 가능한데 유형2 정리하면서 풀이 추가할 예정\n\n```java\npackage BFSDFS;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class num1939 {\n    static int N, M;\n    static long res = 0, max = 0;\n    static boolean visited[];\n    static ArrayList<ArrayList<Edge>> Vertex = new ArrayList<ArrayList<Edge>>();\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        String[] NM = br.readLine().split(\" \");\n\n        N = stoi(NM[0]);\n        M = stoi(NM[1]);\n\n        for (int i = 0; i <= N; i++) {\n            Vertex.add(new ArrayList<Edge>());\n        }\n        visited = new boolean[N + 1];\n\n        for (int i = 0; i < M; i++) {\n            String[] input = br.readLine().split(\" \");\n            int s = stoi(input[0]);\n            int e = stoi(input[1]);\n            long w = stol(input[2]);\n\n            Vertex.get(s).add(new Edge(s, e, w));\n            Vertex.get(e).add(new Edge(e, s, w));\n            max = Math.max(max, w);\n        }\n\n        String[] se = br.readLine().split(\" \");\n        int s = stoi(se[0]);\n        int e = stoi(se[1]);\n        long left = 0;\n        long right = max;\n\n        while (right >= left) {\n            long mid = (left + right) / 2;\n\n            visited = new boolean[N + 1];\n            if (dfs(s, e, mid, visited)) {\n                left = mid + 1;\n                res = Math.max(res, mid);\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        System.out.println(res);\n    }\n\n    public static boolean dfs(int s, int e, long mid, boolean[] visited) {\n        if (visited[s]) {\n            return false;\n        }\n        visited[s] = true;\n\n        if (s == e) {\n            return true;\n        }\n\n        for (Edge item : Vertex.get(s)) {\n            if (item.w >= mid) {\n                if (dfs(item.e, e, mid, visited)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public static class Edge {\n        int s, e;\n        long w;\n\n        Edge(int s, int e, long w) {\n            this.s = s;\n            this.e = e;\n            this.w = w;\n        }\n    }\n\n    public static long stol(String s) {\n        return Long.parseLong(s);\n    }\n\n    public static int stoi(String s) {\n        return Integer.parseInt(s);\n    }\n}\n\n```\n","excerpt":"코딩 테스트 준비가 부족해서 유형별로 풀고 정리해보려고 한다. 정렬, 그리디, 해시맵, 스택, BFS, DFS, 그래프 탐색 문제 풀이 빠킹독 공개 문제집, 백준 단계별 문제 여기 있는 문제들로 골랐다. 정렬 11656번  String 배열을 잘라서…","fields":{"slug":"/CodingTest1/"},"frontmatter":{"date":"Oct 30, 2022","title":"알고리즘 문제 풀이 (정렬, 그리디, 해시, 스택, BFS, DFS)","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# QueryDSL 이란?\n\n> **Querydsl**을 통해 생성되는 정적 Q-type 클래스를 이용해 쿼리를 생성하도록 도와주는 프레임 워크\n\n## JPQL vs Querydsl\n\n**타입 체크, 오류 잡아주는 시점**  \nJPQL - 실행 시점 오류  \nQuerydsl - 컴파일 시점 오류\n\n**파라미터 바인딩**  \nJPQL - 파라미터 바인딩 직접  \nQuerydsl - 파라미터 바인딩 자동 처리\n\n## build.gradle\n\nbuild.gradle에 queryDSL 설정 추가\n\n```\n# build.gradle\nbuildscript {\n  ext {\n    queryDslVersion = \"5.0.0\"\n  }\n}\n\nplugin {\n  ...\n  id \"com.ewerk.gradle.plugins.querydsl\" version \"1.0.10\"\n  ...\n}\n\ndependencies {\n  ...\n  implementation \"com.querydsl:querydsl-jpa:${queryDslVersion}\"\n  implementation \"com.querydsl:querydsl-apt:${queryDslVersion}\"\n  ...\n}\n\ndef querydslDir = \"$buildDir/generated/querydsl\"\n\nquerydsl {\n  jpa = true\n  querydslSourcesDir = querydslDir\n}\nsourceSets {\n  main.java.srcDir querydslDir\n}\ncompileQuerydsl{\n  options.annotationProcessorPath = configurations.querydsl\n}\nconfigurations {\n  compileOnly {\n    extendsFrom annotationProcessor\n  }\n  querydsl.extendsFrom compileClasspath\n}\n```\n\n```bash\n# queryDSL Q타입 생성 (git ignore 설정 필요)\n# build.gradle에 설정한 명령어\n./gradlew clean compileQuerydsl\n\n# Gradle 의존관계 확인\n./gradlew dependencies --configuration compileClasspath\n```\n\n**Querydsl 라이브러리**\n\n- querydsl-apt: Querydsl 관련 코드 생성 기능 제공\n- querydsl-jpa: querydsl 라이브러리\n\n# QueryDSL 활용\n\n## QueryDSL Bean 등록\n\nrepository 작성 시 JPA에 접근하기 위한 EntityManager와 QueryDSL을 사용하기 위한 JPAQueryFactory를 주입받아야 하는데\n\nEntityManager의 경우 Spring에 Bean으로 등록되어 있어 생성자 주입으로 주입이 가능\n\nqueryFactory도 생성자 주입으로 주입 받고 싶을 경우엔 SpringBoot에 Bean으로 등록시키고 생성자 생성시 주입받으면 된다.  \n(AppConfig를 만들어 적용)\n\n```java\n@Configuration\n@RequiredArgsConstructor\npublic class Appconfig {\n    private final EntityManager em;\n\n    @Bean\n    public JPAQueryFactory queryFactory() {\n        return new JPAQueryFactory(em);\n    }\n}\n```\n\n- JPA 접근 시 EntityManager 필요\n- JPAQueryFatory는 QueryDSl 쿼리 작성 클래스\n\n## 동시성 문제\n\n> 스프링은 여러 쓰레드에서 동시에 같은 EntityManager에 접근해도  \n> 트랜잭션 마다 별도의 영속성 컨텍스트 제공 -> **동시성 문제 x**\n\n## Qclass 인스턴스 사용 방법\n\n1. 별칭 직접 지정 -> 같은 테이블 조인 시\n2. 기본 인스턴스 사용 -> static import로 전역선언 후 사용\n\n```java\n//별칭 직접 지정\nQMember qMember = new QMember(\"m\");\n\n//기본 인스턴스 사용\nQMember qMember = QMember.member;\n\n// 전역 선언\nimport static study.querydsl.entity.QMember.*;\n```\n\n## 검색 조건 추가\n\n- .and(), .or() 메서드 체인으로 연결\n- JPQL이 제공하는 모든 검색 조건 제공\n- and vs eq -> eq 사용 - 동적 쿼리 만들 때 null 무시하게 코드 작성 가능\n\n<details>\n<summary><b>검색 조건 설정 (Toggle)</b></summary>\n\n| 표현                  | 결과                 |\n| --------------------- | -------------------- |\n| .eq(\"member\")         | username = 'member'  |\n| .ne(\"member\")         | username != 'member' |\n| .eq(\"member\").not()   | username != 'member' |\n| .isNotNull()          | is not null          |\n| .in(10, 20)           | in (10,20)           |\n| .notIn(10, 20)        | not in (10, 20)      |\n| .between(10,30)       | between 10, 30       |\n| .goe(30)              | >= 30                |\n| .gt(30)               | > 30                 |\n| .loe(30)              | <= 30                |\n| .lt(30)               | < 30                 |\n| .like(\"member%\")      | like 검색            |\n| .contains(\"member\")   | like ‘%member%’ 검색 |\n| .startsWith(\"member\") | like ‘member%’ 검색  |\n\n</details>\n\n## 결과 조회\n\n**fetch()** : 리스트 조회, 데이터 없으면 빈 리스트 반환\n\n**fetchOne()** : 단 건 조회\n\n- 결과가 없으면 : null\n- 결과가 둘 이상이면 : com.querydsl.core.NonUniqueResultException\n\n**fetchFirst()** : limit(1).fetchOne()\n\n**fetchResults, fetchCount** -> deprecated 되서 count용 쿼리 구현 후 사용\n\n## 정렬\n\n> groupby 사용\n\ndesc() , asc() : 일반 정렬\nnullsLast() , nullsFirst() : null 데이터 순서 부여\n\nSQL은 다중 정렬 시 왼쪽부터 순차 정렬\n\n```java\n.orderBy(member.age.desc(), member.username.asc().nullsLast())\n```\n\n## 집합\n\n7가지 집합 함수 사용 가능\n\n## 조인\n\n#### 기본 조인 (페치 조인 적용)\n\n- join은 leftJoin, rightJoin 모두 가능\n- join 이후에 on을 넣어 조건절 가능\n- 세타조인 또한 가능\n- **.on()** 절을 통해 **조인 대상을 필터링** 하거나 **동적인 조건 연관관계 없이 조인** 가능\n\n```java\nList<Member> resultQuerydsl = queryFactory\n                .selectFrom(user)\n                .join(member.team, team).fetchJoin() // fetch join 가능\n                .fetch();\n\nList<Member> result = queryFactory\n        .select(member)\n        .from(member, team)\n        .where(member.username.eq(team.name))\n        .fetch();\n\nList<Tuple> result = queryFactory\n        .select(member, team)\n        .from(member)\n        .leftJoin(team).on(member.username.eq(team.name))\n        .fetch();\n\n```\n\n## 서브 쿼리\n\n- QueryDSL에서 제공하는 **JPAExpressions** 클래스를 사용해 서브쿼리 사용 가능\n- alias가 중복되면 안되는 경우 Q-type 객체 생성해서 사용\n- case문 사용 시 **CaseBuilder** 클래스 사용\n- 상수 사용 시 **Expressions** 클래스 사용\n\n```java\n// 1. where절 서브쿼리\nQMember memberSub = new QMember(\"memberSub\");\nList<Member> result = queryFactory\n        .selectFrom(member)\n        .where(member.age.eq(\n                JPAExpressions\n                        .select(memberSub.age.max())\n                        .from(memberSub)\n        )).fetch();\n\n// 2. select절 서브쿼리\nList<Tuple> fetch = queryFactory\n        .select(member.username,\n                JPAExpressions\n                        .select(memberSub.age.avg())\n                        .from(memberSub)\n        ).from(member)\n        .fetch();\n\n// 3. case문\nList<String> result = queryFactory\n             .select(new CaseBuilder()\n                    .when(member.age.between(0, 20)).then(\"0~20살\")\n                    .when(member.age.between(21, 30)).then(\"21~30살\")\n                    .otherwise(\"기타\"))\n             .from(member)\n             .fetch();\n\n// 4. 상수 사용\nTuple result = queryFactory\n            .select(member.username, Expressions.constant(\"A\"))\n            .from(member)\n            .fetchFirst();\n```\n\n## 프로젝션\n\n- 간단한 몇 가지 프로퍼티들만 조회 할 경우엔 Q-type 객체의 프로퍼티를 넘겨주면 된다.\n- Dto를 사용해 select 할 경우엔 3가지 방법이 가능하다\n  - 프로퍼티 접근\n  - 필드 직접 접근\n  - 생성자 사용\n- 프로퍼티, 필드 접근 시 이름이 다를 땐 **ExpressionUtils.as(source,alias)**를 사용해 필드나 서브쿼리에 별칭을 적용한다.\n\n```java\n// 대상이 하나인 경우\nList<String> result = queryFactory\n        .select(member.username)\n        .from(member)\n        .fetch();\n\n// 대상이 여러개\nList<Tuple> result2 = queryFactory\n        .select(member.username, member.age)\n        .from(member)\n        .fetch();\n\n// --- DTO 사용\n// 1. Property 사용\n// bean으로 사용하면 getter, setter로 값을 넣어준다.\nList<MemberDto> result = queryFactory\n        .select(Projections.bean(MemberDto.class,\n                member.username,\n                member.age))\n        .from(member)\n        .fetch();\n\n// 2. field 직접 접근\nList<MemberDto> result = queryFactory\n        .select(Projections.fields(MemberDto.class,\n                member.username,\n                member.age))\n        .from(member)\n        .fetch();\n\n// 2.1 field 접근 시 별칭이 다를 때\nQMember memberSub = new QMember(\"memberSub\");\n\nList<UserDto> result = queryFactory\n        .select(Projections.fields(UserDto.class,\n                member.username.as(\"name\"),\n\n                // 서브 쿼리 사용 시, 이름이 없을 때 ExpressionUtils 사용\n                ExpressionUtils.as(\n                        select(memberSub.age.max())\n                                .from(memberSub), \"age\")\n        ))\n        .from(member)\n        .fetch();\n\n// 3. 생성자 사용\n List<MemberDto> result = queryFactory\n        .select(Projections.constructor(MemberDto.class,\n        member.username,\n        member.age))\n.from(member)\n.fetch();\n```\n\n추가로 Dto 클래스에 **@QueryProjection** 어노테이션을 추가해 Dto 전용 Q-type을 추가해  \n깔끔한 코드를 작성 가능한데 Dto 클래스 내부에 Querydsl 라이브러리 의존성이 생기기 때문에  \n확장성이나 유지보수 시 단점이 될 수 있다.\n\n```java\n@Data\n@NoArgsConstructor\npublic class UserDto {\n    private String name;\n    private int age;\n\n    @QueryProjection\n    public UserDto(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n\nList<UserDto> result = queryFactory\n        .select(new QUserDto(member.username, member.age))\n        .from(member)\n        .fetch();\n\n```\n\nTip!!\n\n- Query로 데이터 가져올 때 기본조건이나 limit 조건 있는게 좋음 (너무 많은 데이터 가져와서)\n\n## 동적 쿼리\n\n동적 쿼리를 처리할 땐 **BooleanBuilder**, **Where 다중 파라미터** 2가지 방법으로 처리가 가능하다.\n\n1. BooleanBuilder 사용\n\n```java\n\nList<Member> result = searchMember1(usernameParam, ageParam);\n\nprivate List<Member> searchMember1(String usernameCond, Integer ageCond) {\n    BooleanBuilder builder = new BooleanBuilder();\n    if (usernameCond != null) {\n        builder.and(member.username.eq(usernameCond));\n    }\n    if (ageCond != null) {\n        builder.and(member.age.eq(ageCond));\n    }\n    return queryFactory\n            .selectFrom(member)\n            .where(builder)\n            .fetch();\n}\n\n```\n\n2. Where 다중 파라미터 사용\n\n```java\nList<Member> result = searchMember2(usernameParam, ageParam);\n\nprivate List<Member> searchMember2(String usernameCond, Integer ageCond) {\n    return queryFactory\n            .selectFrom(member)\n            .where(usernameEq(usernameCond), ageEq(ageCond))\n            .fetch();\n}\n\nprivate BooleanExpression usernameEq(String usernameCond) {\n    return usernameCond != null ? member.username.eq(usernameCond) : null;\n}\n\nprivate BooleanExpression ageEq(Integer ageCond) {\n    return ageCond != null ? member.age.eq(ageCond) : null;\n}\n```\n\n## SQL 함수 사용\n\n- concat, coalesce, upper 와 같은 간단한 함수들은 Querydsl 에서 메소드로 지원\n- 자신이 사용하고 싶은 함수가 Querydsl 에 없는 경우는 stringTemplate()을 이용하여 쿼리를 작성 가능\n\n```java\nist<String> result = queryFactory\n\t\t.select(Expressions.stringTemplate(\n\t\t\t\t\"function('regexp_replace', {0}, {1}, {2})\",\n\t\t\t\tuser.username, \"user\", \"User_\"))\n\t\t.from(user)\n\t\t.fetch();\n```\n\n## 수정, 삭제 벌크 연산\n\n- 영속성 컨텍스트에 있는 엔티티를 무시하고 실행되기 때문에 배치 쿼리를 실행하고 나면 영속성 컨텍스트를 초기화 필요\n\n```java\nlong count = queryFactory\n              .update(member)\n              .set(member.username, \"비회원\")\n              .where(member.age,lt(28))\n              .execute();\nem.flush();\nem.clear();\n```\n\n## DataJPA와 함께 사용\n\nDataJPA 같은 경우 [실전 스프링 데이터 JPA](http://localhost:8000/JPA_4/) 에 정리해놔서\n\n코드로만 정리한다.\n\n```java\n// repository\npublic interface MemberRepository extends JpaRepository<Member, Long>, MemberRepositoryCustom {\n    List<Member> findByUsername(String username);\n}\n\n// Custom\npublic interface MemberRepositoryCustom {\n    List<MemberTeamDto> search(MemberSearchCondition condition);\n\n    Page<MemberTeamDto> searchPageSimple(MemberSearchCondition condition,\n                                         Pageable pageable);\n    Page<MemberTeamDto> searchPageComplex(MemberSearchCondition condition,\n                                          Pageable pageable);\n}\n\n// Impl\npublic class MemberRepositoryImpl implements MemberRepositoryCustom {\n\n    private final JPAQueryFactory queryFactory;\n\n    public MemberRepositoryImpl(EntityManager em) {\n        this.queryFactory = new JPAQueryFactory(em);\n    }\n\n    //회원명, 팀명, 나이(ageGoe, ageLoe)\n    @Override\n    public List<MemberTeamDto> search(MemberSearchCondition condition) {\n        return queryFactory\n                .select(new QMemberTeamDto(\n                        member.id,\n                        member.username,\n                        member.age,\n                        team.id,\n                        team.name))\n                .from(member)\n                .leftJoin(member.team, team)\n                .where(usernameEq(condition.getUsername()),\n                        teamNameEq(condition.getTeamName()),\n                        ageGoe(condition.getAgeGoe()),\n                        ageLoe(condition.getAgeLoe()))\n                .fetch();\n    }\n\n    private BooleanExpression usernameEq(String username) {\n        return isEmpty(username) ? null : member.username.eq(username);\n    }\n\n    private BooleanExpression teamNameEq(String teamName) {\n        return isEmpty(teamName) ? null : team.name.eq(teamName);\n    }\n\n    private BooleanExpression ageGoe(Integer ageGoe) {\n        return ageGoe == null ? null : member.age.goe(ageGoe);\n    }\n\n    private BooleanExpression ageLoe(Integer ageLoe) {\n        return ageLoe == null ? null : member.age.loe(ageLoe);\n    }\n\n    @Override\n    public Page<MemberTeamDto> searchPageSimple(MemberSearchCondition condition,\n                                                Pageable pageable) {\n        QueryResults<MemberTeamDto> results = queryFactory\n                .select(new QMemberTeamDto(\n                        member.id,\n                        member.username,\n                        member.age,\n                        team.id,\n                        team.name))\n                .from(member)\n                .leftJoin(member.team, team)\n                .where(usernameEq(condition.getUsername()),\n                        teamNameEq(condition.getTeamName()),\n                        ageGoe(condition.getAgeGoe()),\n                        ageLoe(condition.getAgeLoe()))\n                .offset(pageable.getOffset())\n                .limit(pageable.getPageSize())\n                .fetchResults();\n        List<MemberTeamDto> content = results.getResults();\n        long total = results.getTotal();\n        return new PageImpl<>(content, pageable, total);\n    }\n\n    /*\n     * 데이터 조회 쿼리와, 전체 카운트 쿼리를 분리\n     */\n    @Override\n    public Page<MemberTeamDto> searchPageComplex(MemberSearchCondition condition,\n                                                 Pageable pageable) {\n        List<MemberTeamDto> content = queryFactory\n                .select(new QMemberTeamDto(\n                        member.id,\n                        member.username,\n                        member.age,\n                        team.id,\n                        team.name))\n                .from(member)\n                .leftJoin(member.team, team)\n                .where(usernameEq(condition.getUsername()),\n                        teamNameEq(condition.getTeamName()),\n                        ageGoe(condition.getAgeGoe()),\n                        ageLoe(condition.getAgeLoe()))\n                .offset(pageable.getOffset())\n                .limit(pageable.getPageSize())\n                .fetch();\n\n//        long total = queryFactory\n//                .select(member)\n//                .from(member)\n//                .leftJoin(member.team, team)\n//                .where(usernameEq(condition.getUsername()),\n//                        teamNameEq(condition.getTeamName()),\n//                        ageGoe(condition.getAgeGoe()),\n//                        ageLoe(condition.getAgeLoe()))\n//                .fetchCount();\n\n//        return new PageImpl<>(content, pageable, total);\n\n        JPAQuery<Member> countQuery = queryFactory\n                .select(member)\n                .from(member)\n                .leftJoin(member.team, team)\n                .where(usernameEq(condition.getUsername()),\n                        teamNameEq(condition.getTeamName()),\n                        ageGoe(condition.getAgeGoe()),\n                        ageLoe(condition.getAgeLoe()));\n        return PageableExecutionUtils.getPage(content, pageable,\n                countQuery::fetchCount);\n    }\n}\n\n\n```\n\n# Reference\n\n- [실전! Querydsl](https://www.inflearn.com/course/Querydsl-%EC%8B%A4%EC%A0%84/dashboard)\n","excerpt":"QueryDSL 이란? Querydsl을 통해 생성되는 정적 Q-type 클래스를 이용해 쿼리를 생성하도록 도와주는 프레임 워크 JPQL vs Querydsl 타입 체크, 오류 잡아주는 시점 JPQL - 실행 시점 오류 Querydsl - 컴파일 시…","fields":{"slug":"/JPA_5/"},"frontmatter":{"date":"Oct 17, 2022","title":"Querydsl","tags":["JPA"],"update":"Feb 22, 2023"}}},{"node":{"rawMarkdownBody":"\n알고리즘 문제 푼지 오래된 것 같아 leetcode를 기웃기웃 해보니\n\n![](leetcodeCource.png)\n\n요런게 있다\n\nleetcode에 study plan을 정해서 매일 문제 풀어보려고 하는데\n\n![](leetcode28.png)\n\n28번 문제 보고 kmp 알고리즘 정리하던게 생각나서 정리한다 하핳....\n\n(28번은 그냥 java String 함수 indexOf써도 통과함)\n\n---\n\n# KMP 알고리즘 이란?\n\n> 접두사, 접미사를 활용(전처리)해 **공통되는 부분을 건너 뛰어** 모든 경우를 계산하지 않고  \n> **반복되는 연산을 줄여 매칭 문자열을 빠르게 계산하는 방법**\n\n일반적으로 문자열을 brute-force로 패턴 매칭을 할 경우에는 전부 순회하면서 확인하는 방식으로 동작해  \n시간 복잡도는 O(문자열 길이 \\* 패턴 길이) 가 된다\n\nKMP 알고리즘은 어디서부터 어디까지 일치했는지에 대한 정보(전처리)를 토대로 **다음 비교를 할 위치를 찾는 것**이 핵심 아이디어다.\n\n| 인덱스  | 0   | 1   | 2   | 3   | 4   | 5   | 6     | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  |\n| ------- | --- | --- | --- | --- | --- | --- | ----- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| origin  | a   | a   | b   | a   | a   | b   | b     | a   | a   | b   | a   | a   | b   | c   | b   | c   |\n| pattern | a   | a   | b   | a   | a   | b   | **c** |     |     |     |     |     |     |     |     |     |\n\n요렇게 불일치가 일어났을 때 다음 비교를\n\n| 인덱스  | 0   | 1   | 2   | 3   | 4   | 5   | 6     | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  |\n| ------- | --- | --- | --- | --- | --- | --- | ----- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| origin  | a   | a   | b   | a   | a   | b   | **b** | a   | a   | b   | a   | a   | b   | c   | b   | c   |\n| pattern |     |     |     | a   | a   | b   | **a** | a   | b   | c   |     |     |     |     |     |     |\n\n이렇게 수행이 된다.\n\nKMP 알고리즘을 이해하기 위해선 몇가지 개념을 이해해야 한다.\n\n접두사 : 단어 앞에 붙은 단어  \n접미사 : 단어 끝에 붙은 단어  \n실패 함수 : **문자열 일치 여부를 검사하다가, 불일치가 발생하면 어떤 조치를 취해야 하는지에 대한 함수**  \n--> **문자 매칭에 실패하기 직전 상황에서, 접두사와 접미사가 일치하는 최대 길이**\n\n라고 이해하면 된다\n\n아래 실패 함수의 예시를 확인해보자\n\norigin text : aabaabbaabaabcbc  \npattern : aabaabc\n\n일 때 먼저 pattern의 실패함수 pi 를 구하면\n\n| i   | N[i]    | 접두사이면서 접미사인 최대 문자열 | pi[i] |\n| --- | ------- | --------------------------------- | ----- |\n| 0   | a       | (없음)                            | 0     |\n| 1   | aa      | a                                 | 1     |\n| 2   | aab     | (없음)                            | 0     |\n| 3   | aaba    | a                                 | 1     |\n| 4   | aabaa   | aa                                | 2     |\n| 5   | aabaab  | aab                               | 3     |\n| 6   | aabaabc | (없음)                            | 0     |\n\n```text\nindex  0 1 2 3 4 5 6\n       a a b a a b c\npi[]   0 1 0 1 2 3 0\n```\n\n요런 형태로 pi[] 배열이 만들어 진다.\n\nkmp알고리즘을 다시 한번 살펴보면\n\n| 인덱스  | 0   | 1   | 2   | 3   | 4   | 5   | 6     | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  |\n| ------- | --- | --- | --- | --- | --- | --- | ----- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| origin  | a   | a   | b   | a   | a   | b   | b     | a   | a   | b   | a   | a   | b   | c   | b   | c   |\n| pattern | a   | a   | b   | a   | a   | b   | **c** |     |     |     |     |     |     |     |     |     |\n\n| 인덱스  | 0   | 1   | 2   | 3   | 4   | 5   | 6     | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  |\n| ------- | --- | --- | --- | --- | --- | --- | ----- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| origin  | a   | a   | b   | a   | a   | b   | **b** | a   | a   | b   | a   | a   | b   | c   | b   | c   |\n| pattern |     |     |     | a   | a   | b   | **a** | a   | b   | c   |     |     |     |     |     |     |\n\n이런 모양으로 이전 까지 공통된 부분(aab)를 건너 뛴 채 비교하는 형태가 된다.\n\n실제 소스에선 i = 6, j = 3을 카르키고 계속 진행되고,  \n값이 매칭 될 때마다 길이를 비교해 전체가 매칭되는지 확인한다\n\n자세한 설명은 소스를 보고 확인해보자\n\n# 1786번 문제\n\n![문제사진](kmpProblem1.PNG)\n![문제사진2](kmpProblem2.PNG)\n\n```java\npackage package33;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class num1786_finish {\nstatic int cnt;\nstatic ArrayList<Integer> result = new ArrayList<Integer>();\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        String origin = br.readLine();\n        String pattern = br.readLine();\n\n        KMP(origin, pattern);\n\n        System.out.println(cnt);\n        for (int i = 0; i < cnt; i++)\n            System.out.println(result.get(i));\n    }\n\n    // 대응 된 문자수 matched만 유지하면서 orgin 모두 순회\n    // 글자마다 matched 적절히 갱신\n    public static void KMP(String origin, String pattern) {\n        int N = origin.length(), M = pattern.length();\n\n        int[] pi = getPartialMatch(pattern);\n\n        // 현재 대응된 글자 수\n        int j = 0;\n\n        for(int i=0; i< N; i++){ // i = begin + matched\n            while(j > 0 && origin.charAt(i) != pattern.charAt(j)) {\n                j = pi[j - 1];\n            }\n\n            //글자 대응 될 경우\n            if(origin.charAt(i) == pattern.charAt(j)){\n                // 전체 대응 (pattern 길이 확인)\n                if(j == M - 1){\n                    ++cnt;\n                    result.add(i - j + 1);\n                    j = pi[j];\n                } else {\n                    j++;\n                }\n            }\n        }\n    }\n\n    // O(pattern 길이)\n    // 접두사, 접미사 일치 테이블 계산\n    public static int[] getPartialMatch(String pattern) {\n        // 초기화\n        int len = pattern.length();\n        int[] pi = new int[len];\n        int j = 0;\n\n        for (int i = 1; i < len; i++) {\n            // 맞는 위치가 나올 때 까지 j - 1칸의 공통 부분 위치로 이동\n            // j-1 까지 접두사와 접미사가 일치\n            while (j > 0 && pattern.charAt(i) != pattern.charAt(j)) {\n                j = pi[j - 1];\n            }\n\n            // 맞는 경우\n            if (pattern.charAt(i) == pattern.charAt(j))\n                // 공통 문자열의 길이는 j의 위치(배열의 index) + 1\n                pi[i] = ++j;\n        }\n\n        return pi;\n    }\n\n}\n\n```\n\n## 풀이 방법\n\n1. **접두사도 되고 접미사도 되는 문자열의 최대 길이**를 가진 실패 함수 배열 계산\n2. 구한 배열을 통해 **문자열 매칭을 탐색할 때 점프**를 해 계산\n\nKMP 함수부터 간략히 설명하면\n\ni는 원본 텍스트의 현재 비교위치, j는 패턴의 현재 비교위치를 나타내는 변수로\n\ni와 j가 **일치했을 때, 일치하지 않았을 때**를 나눠서 생각해야한다.\n\n**일치 했을 때**  \n -> **i, j를 한칸 씩 오른쪽으로 이동 시키면서 비교**\n\n**일치 하지 않았을 경우**  \n -> 이전까지 접두사와 접미사가 일치한 부분 부터 확인하기 위해 (공통된 부분은 건너 뛰고)  \n -> **pi[j-1]로 이동 후 비교**한다\n\n---\n\ngetPartialMatch함수는\n\nKMP함수와 동일하게 동작하는데\n\n**j는 접두사의 위치, i는 접미사의 위치**다\n\n0번째 인덱스는 문자가 1개이기 때문에 제외하고 시작하기 위해서\n\ni를 1부터 시작하고\n\n동일한 글자가 있는지 전부 비교해서\n\npi배열을 완성시킨 후에 반환한다\n\n| i   | N[i]    | 접두사이면서 접미사인 최대 문자열 | pi[i] |\n| --- | ------- | --------------------------------- | ----- |\n| 0   | a       | (없음)                            | 0     |\n| 1   | aa      | a                                 | 1     |\n| 2   | aab     | (없음)                            | 0     |\n| 3   | aaba    | a                                 | 1     |\n| 4   | aabaa   | aa                                | 2     |\n| 5   | aabaab  | aab                               | 3     |\n| 6   | aabaabc | (없음)                            | 0     |\n\n이 그림과 동일하게 값을 하나씩 넣으면서 동작해 pattern의 길이인 O(M) 만큼 돈다\n\n---\n\n# Reference\n\n[알고리즘 문제 해결전략 (20.1 ~ 20.2) - 종만북]()  \n[KMP 문자열 탐색 알고리즘이 동작하는 구체적인 원리 - injae Kim](https://injae-kim.github.io/dev/2020/07/23/all-about-kmp-algorithm.html)  \n[[알고리즘] 문자열 매칭 알고리즘 KMP (Java) - 그릿 속의 해빗](https://loosie.tistory.com/192)  \n[[알고리즘 정리] KMP, 문자열 패턴 매칭 알고리즘](https://devje8.tistory.com/24)\n[[알고리즘] KMP 알고리즘](https://baeharam.github.io/posts/algorithm/kmp/)\n\n<!-- Rabin-Karp 알고리즘이란 무엇인가?\n\n문자열 검색을 위해 해시 값 함수를 이용하고, 패턴 내의 문자들을 다 비교하는 대신에 패턴의 해시 값과 본문 안에 있는 하위 문자열의 해시 값만을 비교하는 알고리즘입니다. 비교에 대한 부담을 brute-force보다는 줄이지만 최악의 시간 복잡도는 brute-force 와 같은 O(M * N)입니다. 그러나 평균적으로는 선형에 가까운 시간 복잡도를 보이는 알고리즘입니다.\n\n\n\n\n\nBoyer-Moore 알고리즘이란 무엇인가?\n\n뒤에서부터 탐색을 하는 알고리즘으로 오른쪽 끝에 있는 문자가 불일치이고 문자가 패턴 내에 존재하지 않는 경우 패턴의 길이 만큼 이동할 수 있습니다. 빠를 것 같지만 시간 복잡도는 O(M * N)입니다.\n\n s-->\n\n```\n\n```\n","excerpt":"알고리즘 문제 푼지 오래된 것 같아 leetcode를 기웃기웃 해보니  요런게 있다 leetcode에 study plan을 정해서 매일 문제 풀어보려고 하는데  28번 문제 보고 kmp 알고리즘 정리하던게 생각나서 정리한다 하핳.... (28번은 그…","fields":{"slug":"/kmpAlgorithm/"},"frontmatter":{"date":"Oct 10, 2022","title":"KMP 알고리즘","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# 공통 인터페이스 설정\n\n@SpringBootApplication위치에 @EnableJpaRepositories설정  \n(스프링 부트 사용시 생략 가능)\n\nJpaRepository를 상속받아 인터페이스 JpaRepository내 구현된 메소드 사용 필요 시 확장  \n-> Generic - <엔티티 타입, 식별자 타입>\n\n```java\npublic interface TeamRepository extends JpaRepository<Team, Long> {\n}\n```\n\n# 쿼리 메소드\n\n## 메소드 이름으로 쿼리 생성\n\n> 스프링 데이터 JPA는 메소드 이름을 분석해서 JPQL을 생성하고 실행\n\n[메소드 이름 내에서 지원되는 키워드](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.query-creation)\n\n- 필드명이 바뀐 경우 메서드 이름도 함께 변경\n- 짧은 쿼리를 사용하는 경우 주로 사용\n- **식별하기 위한 내용(설명) 추가 가능** ex) findSliceMemberByAge\n\n## NamedQuery\n\n> 쿼리에 이름을 부여하고 호출하는 기능\n\n```java\n@Entity\n@NamedQuery(\n      name=\"Member.findByUsername\",\n      query=\"select m from Member m where m.username = :username\")\npublic class Member {\n  ...\n}\n```\n\n엔티티에 @NamedQuery로 작성한 SQL 가져와 사용\n\n```java\n@Query(name = \"Member.findByUsername\")\nList<Member> findByUsername(@Param(\"username\") String username);\n```\n\n- 스프링 데이터 JPA는 선언한 \"도메인 클래스 + .(점) + 메서드 이름\"으로 Named 쿼리를 찾아서 실행\n- 만약 실행할 Named 쿼리가 없으면 메서드 이름으로 쿼리 생성 전략 사용\n\n## @Query - 리파지토리 메소드에 쿼리 정의 파라미터 바인딩\n\n> NamedQuery 보단 @Query 사용해 리파지토리 메소드에 쿼리 직접 정의\n\n```java\n@Query(\"select m from Member m where m.username= :username and m.age = :age\")\nList<Member> findUser(@Param(\"username\") String username, @Param(\"age\") int age);\n\n// DTO로 직접 조회\n@Query(\n  \"select new study.datajpa.dto.MemberDto(m.id, m.username, t.name) \" +\n  \"from Member m join m.team t\")\nList<MemberDto> findMemberDto();\n```\n\n- JPA Named 쿼리처럼 **애플리케이션 실행 시점에 문법 오류를 발견** 가능\n- DTO로 직접 조회 시 new 명령어 사용\n- 파라미터 바인딩, 컬렉션 파라미터 바인딩 가능\n\n## 반환 타입\n\n> 유연한 반환 타입 지원\n\n[Spring Data JPA return type 문서](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repository-query-return-types)\n\n```java\n//컬렉션\nList<Member> findByUsername(String name);\n\n//단건\nMember findByUsername(String name);\n\n//단건 Optional\nOptional<Member> findByUsername(String name);\n```\n\n컬렉션\n\n- 결과 없음: 빈 컬렉션 반환\n\n단건 조회\n\n- 결과 없음: null 반환 -> 예외 발생 시 무시하고 null 반환\n- 결과가 2건 이상: javax.persistence.NonUniqueResultException 예외 발생\n\n## 페이징과 정렬\n\n페이징 객체\n\n- org.springframework.data.domain.**Pageable** : 패이징 기능 (내부에 Sort객체 포함)\n\n반환 타입\n\n- Page : count 쿼리 결과를 포함하는 페이징\n- Slice : count 쿼리 없이 다음 페이지만 확인 (limit + 1 조회)\n- List(자바 컬렉션) : count없이 결과만 반환\n\n```java\n// repository\nPage<Member> findPageByUsername(String name, Pageable pageable);\nSlice<Member> findSliceByUsername(String name, Pageable pageable);\nList<Member> findListByUsername(String name, Pageable pageable);\n```\n\ncount를 포함하는 경우 성능상 이슈 발생 가능 ex) join이 많을 경우  \n -> **@Query를 사용해 count 쿼리 분리 가능**\n\n```java\n// repository\n@Query(value = \"select m from Member m left join m.team t\",\n        countQuery = \"select count(m.username) from Member m\")\nPage<Member> findByAge(int age, Pageable pageable);\n```\n\n## 벌크성 수정 쿼리\n\n> @Modifying 어노테이션 추가, 영속성 컨텍스트 초기화(clearAutomatically true 옵션, em.clear())\n\n```java\n@Modifying(clearAutomatically = true)\n@Query(\"update Member m set m.age = m.age + 1 where m.age >= :age\")\nint bulkUpdateAgePlus(@Param(\"age\") int age);\n```\n\n1. 영속성 컨텍스트에 엔티티가 없는 상태에서 벌크 연산 먼저 실행\n2. 영속성 컨텍스트에 엔티티가 있으면 벌크 연산 직후 영속성 컨텍스트 초기화\n\n## @EntityGraph\n\n> 연관된 엔티티들을 SQL 한번에 조회하는 방법 -> **패치 조인** 사용\n> JPQL 없이 패치 조인\n\n```java\n// JPQL + 엔티티 그래프\n@EntityGraph(attributePaths = {\"team\"})\n@Query(\"select m from Member m\")\nList<Member> findMemberEntityGraph();\n\n// 메서드 이름에서 사용\n@EntityGraph(attributePaths = {\"team\"})\nList<Member> findByUsername(String username)\n```\n\n# JPA Hint\n\n> @QueryHints 어노테이션 사용해 readOnly 속성 사용\n\nJPA도 @Lock 어노테이션으로 트랜잭션 처리의 순차성을 보장하기 위해 DB Lock 지원\n\n관련된 내용은 추가로 정리 예정\n\n# 사용자 정의 인터페이스\n\n1. Custom interface 생성\n2. Custom interface 을 상속받은 사용자 정의 구현 클래스 생성\n3. 기존 Repository Interface에 Custom interface를 상속 받는다.\n\n사용자 정의 구현 클래스\n\n- **규칙: 리포지토리 인터페이스 이름 + Impl** ex) MemberRepositoryImpl\n- 2.x 버전부터는 **사용자 정의 인터페이스 명 + Impl** 지원 ex) MemberRepositoryCustomImpl\n- 스프링 데이터 JPA가 인식해서 스프링 빈으로 등록  \n  (따로 Bean 관련 어노테이션 붙이지 않아도 된다)\n\n다른 이름으로 적용하고 싶으면 설정 변경\n\n```java\n@EnableJpaRepositories(basePackages = \"study.datajpa.repository\",\n                           repositoryImplementationPostfix = \"Impl\")\n```\n\nCustom 기능은 확장하는 기능으로 관리의 복잡도가 높아질 수 있음  \n -> 레포지토리를 기능에 따라 분리해 작성\n\n핵심은\n\n1. 쿼리와 커맨드 분리\n2. 핵심 비즈니스 로직 / 아닌 부분 분리\n\n# Auditing\n\n> 엔티티 생성, 변경할 때 변경한 사람과 시간을 추적하는데 사용\n> 보통 **1) 등록일, 2)수정일 -기본 / 추가로 3)등록자, 4)수정자(로그인 한 세션정보 기반)**\n\n순수 JPA 사용, Spring JPA 사용 2가지 방법 존재\n\nSpring JPA 사용 방법\n\n1. @EnableJpaAuditing 어노테이션 **스프링 부트 설정 클래스에 적용**\n2. @EntityListeners(AuditingEntityListener.class) 어노테이션 **엔티티에 적용**\n3. 공통 매핑 정보 사용을 위한 @MappedSuperclass 어노테이션 **엔티티에 적용**\n\n관련 어노테이션\n\n```java\n@CreatedDate\n@LastModifiedDate\n@CreatedBy\n@LastModifiedBy\n```\n\n# Domain Class Converter\n\n> HTTP 파라미터로 넘어온 엔티티의 아이디로 엔티티 객체를 찾아서 바인딩\n\n```java\n@GetMapping(\"/members/{id}\")\npublic String findMember(@PathVariable(\"id\") Member member) {\n    return member.getUsername();\n}\n```\n\n도메인 클래스 컨버터로 엔티티를 파라미터로 받으면 **단순 조회용으로 사용**  \n-> **트랜잭션이 없는 범위에서 엔티티를 조회**하기 때문 (권장x)\n\n# 페이징, 정렬\n\n> Pageable객체를 파라미터로 받아 페이징, 정렬 기능 사용 가능\n\n- org.springframework.data.domain.PageRequest tkdyd\n- 사용 파라미터 : page(0부터 시작), size, sort\n\n## 설정 방법\n\n글로벌 설정 - 스프링 부트 설정\n\n```yml\n# Application.yml\ndata:\n  web:\n    pageable:\n      default-page-size: 10 # 기본 페이지 사이즈\n      max-page-size: 2000 # 최대 페이지 사이즈\n```\n\n개별 설정 - @PageableDefault 어노테이션 사용\n\n```java\n@RequestMapping(value = \"/members_page\", method = RequestMethod.GET)\npublic String list(@PageableDefault(size = 12, sort = \"username\",\n                    direction = Sort.Direction.DESC) Pageable pageable) {\n  ...\n}\n```\n\n### 멀티 페이징 시\n\n> 페이징 정보가 둘이상이면 접두사로 구분 -> @Qualifier에 접두사 추가\n\nex) /members?member_page=0&order_page=1\n\n```java\npublic String list (\n  @Qualifier(\"member\") Pageable memberPageable,\n  @Qualifier(\"order\") Pageable orderPageable,\n)\n\n```\n\n### Page 1부터 시작 시\n\n- 직접 클래스 만들어 변환 후 PageRequest 생성 -> 레포지토리에서 사용\n- 응답도 Page 대신 직접 만들어 제공\n\n# 스프링 데이터 JPA 구현체\n\n> org.springframework.data.jpa.repository.support.SimpleJpaRepository\n\n- 구현체를 살펴보면 class레벨에 @Repository, @Transactional(readOnly = true) 적용\n- save() 같은 경우 readOnly false (default)\n\n## readOnly\n\n> 기본값은 false 이며 true 로 세팅하는 경우 트랜잭션을 읽기 전용으로 변경\n\n- 읽기 전용 트랜잭션 내에서 INSERT, UPDATE, DELETE 작업을 해도 반영x\n- **성능 향상을 위해 사용**하거나 읽기 외 다른 동작 방지위해 사용\n\n### Dirty Checking 무시\n\n> 개발자가 임의로 UPDATE 쿼리를 사용하지 않아도 트랜잭션 커밋 시에 1차 캐시에 저장되어 있는 Entity 와 스냅샷을 비교해서 변경된 부분이 있으면 UPDATE 쿼리를 날려주는 기능\n\n-> readOnly=true 설정 시 스프링 프레임워크가 Hibernate의 FlushMode를 **MANUAL로 설정**  \n-> 플러시 할 때 일어나는 스냅샷 비교와 같은 무거운 로직 수행x\n\n# 새로운 엔티티 구분\n\nsave() 메서드는\n\n- 새로운 엔티티면 저장 - em.persist()\n- 새로운 엔티티가 아니면 병합 - em.merge()\n\n객체일 때 **null**로 판단  \n자바 기본 타입일 때 **0**으로 판단  \n -> 식별자 생성 전략이 @Id만 사용해 **직접 할당**할 때 문제 발생\n\n**Persistable 인터페이스 구현해 새로운 엔티티 판단**  \n -> 새로운 엔티티인지 확인하는 isNew 함수 구현\n-> @CreatedDate 조합하면 편리하게 확인 가능\n\n```java\n@Entity\n@EntityListeners(AuditingEntityListener.class)\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\npublic class Item implements Persistable {\n    @Id\n    private String id;\n\n    @CreatedDate\n    private LocalDateTime createdDate;\n\n    public Item(String id) {\n        this.id = id;\n    }\n\n\n    @Override\n    public Object getId() {\n        return id;\n    }\n\n    @Override\n    public boolean isNew() {\n        return createdDate == null;\n    }\n}\n\n```\n\n# Tip!!\n\n- gradle 의존관계 확인 command\n\n```sh\n./gradlew dependencies --configuration compileClasspath\n```\n\n@Inheritance -> 다형성을 위한 상속 (상속 관계 매핑)  \n@Embedded, @Embeddable -> 합성 (복합 값 타입 사용 시)  \n@MappedSuperclass -> 객체의 입장에서 공통 매핑 정보가 필요할 때 사용\n\n# Reference\n\n- [실전! 스프링 데이터 JPA](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%8D%B0%EC%9D%B4%ED%84%B0-JPA-%EC%8B%A4%EC%A0%84/dashboard)\n- [Spring data JPA Document](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/)\n","excerpt":"공통 인터페이스 설정 @SpringBootApplication위치에 @EnableJpaRepositories설정 (스프링 부트 사용시 생략 가능) JpaRepository를 상속받아 인터페이스 JpaRepository내 구현된 메소드 사용 필요 시 …","fields":{"slug":"/JPA_4/"},"frontmatter":{"date":"Sep 28, 2022","title":"실전 스프링 데이터 JPA","tags":["JPA"],"update":"Oct 11, 2022"}}},{"node":{"rawMarkdownBody":"\n# Entity Mapping\n\n양방향 매핑 설정\n\n> jackson라이브러리는 json생성 방법에 대해 모름 (무한 루프)\n\n1. 양방향 매핑관계 설정 시 한쪽에 **@JsonIgnore** 처리 해야 함  \n   -> 실제로 Property에 Null 할당하는 방식\n2. @JsonBackReference // 부모 클래스 , @JsonManagedReference // 자식 클래스\n   -> 순환참조 방어\n3. Entity 대신 DTO 사용\n\n## Entity 사용시 문제\n\n엔티티를 반환값에 직접 사용 할 경우 XtoOne 관계(LASY 로딩일 경우)에서 객체가 없기 때문에 하이버네이트가 프록시 객체 생성  \n -> Jackson 라이브러리가 값을 읽다 문제 발생\n\n해결 방법\n\nhibernate5Module 사용\n\n1. 강제 지연 로딩 설정\n2. 강제로 연관관계 객체를 초기화\n\n결론 : 엔티티를 외부로 노출하지 말고 **DTO 사용**\n(**내부 컬랙션도 전부 DTO**로 바꿔줘야 함 -> 바꿔주지 않으면 내부 스펙 노출)\n\n## DTO 사용 시 장점\n\n- Entity와 API 스펙 분리 가능\n- Entity가 변경될 경우 API 스펙 유지 가능\n\n# 성능 튜닝\n\n## 1. Entity를 DTO 변환 -> 패치 조인\n\n> XtoOne 관계 설정 시 N+1문제 발생\n\n=> 페치 조인(fetch join)을 사용해서 쿼리 1번에 조회\n\n```java\npublic List<Order> findAllWithMemberDelivery() {\n    return em.createQuery(\n        \"select o from Order o\" +\n                    \" join fetch o.member m\" +\n                    \" join fetch o.delivery d\", Order.class)\n        .getResultList();\n}\n```\n\n## 2. DTO 직접 조회\n\n=> select 절에 new를 사용해 JPQL 결과를 DTO로 즉시 변환\n\n복잡한 쿼리를 DTO로 뽑아야 할 때 QueryService or QueryRepository로 빼서 작성\n\n```java\npublic List<OrderQueryDto> findOrderDtos() {\n  return em.createQuery(\n    \"select new jpabook.jpashop.repositoryerQueryDto(o.id, m.name, o.orderDate, o.status,ddress) \" +\n      \"from Order o\" +\n      \" join o.member m\" +\n      \" join o.delivery d\", OrderQueryDto.class)\n    .getResultList();\n}\n```\n\n단점\n\n- 리포지토리 재사용성 떨어짐\n- API 스펙에 맞춘 코드가 리포지토리에 들어감\n\n### 성능 튜닝 권장 순서\n\n1. Entity -> DTO 변환\n2. fetch join으로 최적화 (대부분 성능 이슈 해결)\n3. DTO로 직접 조회\n4. JPA Native SQL or JDBC Template으로 SQL직접 사용\n\n## 컬렉션 조인 최적화\n\nOneToMany 인 경우 distinct와 fetch join을 사용해 최적화  \n -> 컬렉션은 페치 조인시 페이징이 불가능\n\nJPA의 distinct는 2가지 역할\n\n- SQL에 distinct 추가\n- 같은 엔티티가 조회되면 중복 제거\n\n## 컬렉션 엔티티 사용 시 페이징 처리\n\n### 1. 엔티티 직접 조회\n\n- ToOne 관계 모두 페치 조인, 컬렉션 지연조인\n- hibernate.default_batch_fetch_size 설정, @BatchSize 적용\n- 개별 @BatchSize 적용 시 XtoOne - 엔티티, XtoMany(Collection) - 컬렉션 필드\n\n### 2. DTO 직접 조회\n\n-> ToOne(N:1, 1:1) 관계 조회\n\n- ToMany(1:N) 관계 각각 별도로 처리 (개별 요소 마다 SQL로 데이터 가져와 객체에 추가)\n- IN 절을 활용해서 메모리에 미리 조회해서 최적화\n\n### 결론\n\n-> IN 절 활용하자\n\n## OSIV와 성능 최적화\n\n> Open Session In View: 하이버네이트\n\n1. true\n\n   - 최초 데이터베이스 커넥션 시작 시점부터 API 응답이 끝날 때 까지 영속성 컨텍스트와 데이터베이스 커넥션을 유지\n   - Filter Interceptor, Controller, View, Service, Repository\n\n2. off\n   - 트랜잭션을 종료할 때 영속성 컨텍스트를 닫고, 데이터베이스 커넥션도 반환\n   - Service, Repository\n   - 모든 지연로딩을 트랜잭션 안에서 처리\n     - @Transactional 어노테이션 가진 Service 계층에서 처리\n     - **핵심 비즈니스 로직**과 **화면이나 API맞춘 서비스** 부분을 분리하는게 좋다.\n\n# Tip!!\n\n- lombok 사용 시 Entity에 비해 DTO는 더 유연하게 사용  \n  (중요한 로직이 많이 들어가 있지 않음)\n\n- 비즈니스 로직 구성 시 쿼리와 커맨드를 분리 (CQS 패턴)\n\n  - Command : 내부에서 데이터 변경(사이드 이펜트), 값 반환x / Query : 데이터 변경x 값 반환o\n  - 쓰기(insert, update) / 읽기(select) 분리 가능\n  - [CQS(Command Query Separation) Pattern 이란? ](https://medium.com/@su_bak/cqs-command-query-separation-pattern-%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A1%E1%86%AB-f701eabf8754)\n\n- 캐시가 필요한 경우에는 **DTO를 캐시**\n\n# Reference\n\n- [실전! 스프링 부트와 JPA 활용2 API 개발과 성능 최적화](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-JPA-API%EA%B0%9C%EB%B0%9C-%EC%84%B1%EB%8A%A5%EC%B5%9C%EC%A0%81%ED%99%94)\n- [JPA에서 순환참조를 해결하는 방법 | @JsonIgnore, @JsonManagedReference, @JsonBackReference](https://binarycube.tistory.com/1)\n","excerpt":"Entity Mapping 양방향 매핑 설정 jackson라이브러리는 json생성 방법에 대해 모름 (무한 루프) 양방향 매핑관계 설정 시 한쪽에 @JsonIgnore 처리 해야 함 -> 실제로 Property에 Null 할당하는 방식 @JsonBa…","fields":{"slug":"/JPA_3/"},"frontmatter":{"date":"Sep 27, 2022","title":"실전! 스프링 부트와 JPA 활용2 - API 개발과 성능 최적화","tags":["JPA"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# 테이블, 엔티티 설계 시 주의사항\n\n- 다대다 관계 사용x -> 일대다, 다대일로 풀어서 사용\n- 외래키가 있는 곳을 연관관계의 주인으로 설정\n- getter는 가급적 열어두고 setter는 비즈니스 메서드를 별도로 작성해 변경지점이 명확히 설계\n- 값 타입 사용시 **Immutable** 하게 설계\n- 연관관계는 지연로딩 설정\n\n# 계층형 구조\n\n- Controller : 웹 계층\n- Service : 비즈니스 로직, 트랜잭션 처리\n- Repository : JPA 사용 계층\n- Domain : 엔티티가 모여있는 계층\n\n서비스, 리포지토리 계층 개발 -> 테스트 케이스 작성 후 검증 -> 웹 계층 적용\n\n# 어노테이션\n\nRepository 관련\n\n```java\n@Repository // 빈으로 등록, JPA 예외를 스프링 기반 예외로 변환\n@PersistenceUnit // 엔티티 매니저 팩토리(EntityManagerFactory) 주입\n@PersistenceContext // 엔티티 매니저(EntityManager) 주입\n// -> SpringBoot 사용 시 @Autowird지원\n// -> @RequiredArgsConstruct 사용해 생성자 주입 가능\n```\n\nService 관련\n\n```java\n@Service\n\n// 트랜잭션, 영속성 컨텍스트\n// 데이터의 변경이 없는 읽기 전용 메서드에 사용\n// 영속성 컨텍스트를 플러시 않아 약간의 성능 향상(읽기 전용에는 다 적용)\n@Transactional(readOnly=true)\n```\n\nTest 관련\n\n```java\n@RunWith(SpringRunner.class) // Junit4 스프링과 테스트 통합\n@ExtendWith(SpringExtension.class) // Junit5\n\n@SpringBootTest // 스프링 부트 띄우고 테스트 - @Autowired시 필요\n@Transactional // 테스트를 실행할 때마다 트랜잭션 시작 - 테스트 종료 시 롤백\n```\n\n# Pattern\n\n비즈니스 로직에 따른 패턴\n\n## 1. 도메인 모델 패턴\n\n- 엔티티가 비즈니스 로직을 가지고 객체지향 특성을 적극 활용\n- 서비스 계층은 단순히 엔티티에 필요한 요청만 위임\n- 엔티티에 대해 테스트 코드 작성 가능 (단위 테스트)\n\n## 2. 트랜잭션 스크립트 패턴\n\n- 일반적으로 사용하던 패턴\n- 서비스 계층에서 대부분의 비즈니스 로직 처리\n\n# Form 객체 vs 엔티티 직접 사용\n\n엔티티는 **핵심 비즈니스 로직**만 소유  \n-> 화면이나 API에 맞는 **폼 객체**나 **DTO**를 사용  \n-> API는 절대 엔티티 반환x -> 엔티티가 변경되면 스펙이 변경되기 때문-> DTO 사용\n\n# 변경 감지(dirty check)와 병합(Merge)\n\n> JPA는 플러시 할 때 변경 감지가 일어나 업데이트 해준다\n> -> 준영속 상태의 엔티티 변경시 문제 발생\n\n**준영속 엔티티란?**\n\n> 영속성 컨텍스트가 관리하지 않는 엔티티 -> 기존 식별자를 가지고 있는 엔티티\n\n해결 방법\n\n1. 변경 감지 기능 사용  \n   -> 영속성 컨텍스트에서 엔티티를 다시 조회한 후에 데이터 수정하는 방법\n\n2. 병합 사용  \n   -> 준영속 상태의 엔티티를 영속 상태로 변경할 때 사용하는 기능\n\n```java\nem.merge(item);\n```\n\n병합 동작 방식\n\n1. 준영속 엔티티의 식별자 값으로 영속 엔티티 조회\n2. 영속 엔티티의 값을 준영속 엔티티로 병합\n3. 트랜잭션 커밋 시점에 변경 감지 기능이 동작해 DB에 UPDATE\n\n=> 병합 사용 시 모든 필드를 변경, 데이터가 없으면 null로 업데이트\n\n## 결론\n\n엔티티 변경 시 **변경 감지를 사용**하는 것이 좋다  \n-> 트랜잭션이 있는 서비스 계층에서 영속 상태의 엔티티를 조회 -> 변경\n(트랜잭션 커밋 시점 변경 감지 실행)\n\n```java\n@PostMapping(value = \"/items/{itemId}/edit\")\npublic String updateItem(@ModelAttribute(\"form\") BookForm form) {\n  // 변경해야 하는 엔티티 값을 넘겨준다.\n  itemService.updateItem(form.getId(), form.getName(), form.getPrice());\n\n  return \"redirect:/items\";\n}\n\n@Service\n@Transactional(readOnly = true)\n@RequiredArgsConstructor\npublic class ItemService {\n  ...\n\n  @Transactional\n  public void updateItem(Long itemId, String name, int price, int stockQuantity) {\n    Item item = itemRepository.findOne(itemId);\n    item.setName(name);\n    item.setPrice(price);\n    item.setStockQuantity(stockQuantity);\n  }\n\n  ...\n}\n```\n\n# Tip!!\n\n- 테스트 코드 작성 시 스프링, DB없이 순수한 메서드만 단위테스트 하는게 좋다\n- @Test(expected = ...) -> junit5에서 사용법 변경 [Migrating from JUnit 4 to JUnit 5](https://www.baeldung.com/junit-5-migration) 참고\n- 동적 쿼리를 작성 할 때(ex - 검색 기능) JPQL로 구현하면 String 붙여줘서 문자열로 만들어줘야 함  \n  -> QueryDSL 사용\n\n## 값 검증\n\n- 값 검증은 implementation 'org.springframework.boot:spring-boot-starter-validation' 추가\n\n```java\n// @Valid 어노테이션 사용해 값 검증\n// @Valid 어노테이션 사용한 부분에 BindingResult 사용해주면 에러를 result값으로 생성\n// -> 화면에 노출 가능\npublic String create(@Valid MemberForm form, BindingResult result) {\n  ,,,\n }\n```\n\n# Reference\n\n- [실전! 스프링 부트와 JPA 활용1 - 김영한](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-JPA-%ED%99%9C%EC%9A%A9-1)\n- [[JUnit] 경고: Runner org.junit.internal.runners.ErrorReportingRunner](https://handr95.tistory.com/16)\n- [Migrating from JUnit 4 to JUnit 5](https://www.baeldung.com/junit-5-migration)\n","excerpt":"테이블, 엔티티 설계 시 주의사항 다대다 관계 사용x -> 일대다, 다대일로 풀어서 사용 외래키가 있는 곳을 연관관계의 주인으로 설정 getter는 가급적 열어두고 setter는 비즈니스 메서드를 별도로 작성해 변경지점이 명확히 설계 값 타입 사용시…","fields":{"slug":"/JPA_2/"},"frontmatter":{"date":"Sep 26, 2022","title":"실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발","tags":["JPA"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# JPA (JAVA Persistence API)\n\n> 자바 ORM 기술 표준\n\n## ORM(Object-relational mapping)\n\n> 프레임 워크가 중간에서 매핑\n\n- JPA는 APP과 JDBC 사이에서 동작\n- 패러다임의 불일치 해결\n\nJPA는 인터페이스 모음 -> Hibernate (구현체)\n\n## JPA 설정(Persistence.xml)\n\n> JPA 설정하기 위해선 **Persistence.xml**필요\n\n- /META_INF/persistence.xml위치\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<persistence version=\"2.2\"\n             xmlns=\"http://xmlns.jcp.org/xml/ns/persistence\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n             xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd\">\n    <persistence-unit name=\"hello\">\n        <properties>\n            <!-- 필수 속성 -->\n            <!-- 자바 접근 정보-->\n            <property name=\"javax.persistence.jdbc.driver\" value=\"org.h2.Driver\"/>\n            <property name=\"javax.persistence.jdbc.user\" value=\"sa\"/>\n            <property name=\"javax.persistence.jdbc.password\" value=\"\"/>\n            <property name=\"javax.persistence.jdbc.url\" value=\"jdbc:h2:tcp://localhost/~/test\"/>\n            <property name=\"hibernate.dialect\" value=\"org.hibernate.dialect.H2Dialect\"/>\n            <!-- 옵션 -->\n            <property name=\"hibernate.show_sql\" value=\"true\"/>\n            <property name=\"hibernate.format_sql\" value=\"true\"/>\n            <property name=\"hibernate.use_sql_comments\" value=\"true\"/>\n<!--            <property name=\"hibernate.hbm2ddl.auto\" value=\"create\" />-->\n        </properties>\n    </persistence-unit>\n</persistence>\n```\n\n- persistence-unit name으로 이름 지정\n- javax.persistence -> DB접근 정보\n- hibernate -> 하이버네이트 전용 속성\n- hibernate.dialect -> DB에 맞는 sql 문법 지정  \n  ex) MySQLDialect, OracleDialect, H2Dialect\n\n![](jpa.png)\n\n## 주의 사항\n\n- 엔티티 매니저 팩토리는 애플리케이션 전체에서 공유\n- 엔티티 매니저는 쓰레드간에 공유X (사용하고 버려야 한다)\n- JPA의 모든 데이터 변경은 트랜잭션 안에서 실행\n\n## JPQL\n\n> SQL을 추상화한 객체 지향 쿼리 언어\n\n특징\n\n- 객체를 중심으로 개발\n- 검색시 테이블이 아닌 엔티티 객체를 대상으로 검색\n- 모든 DB 데이터를 객체로 변환해서 검색하는 것은 불가능\n- 필요한 데이터를 DB에서 불러오려면 결국 검색 조건이 포함된 SQL 필요\n\n# 영속성\n\n- 객체와 관계형 데이터 베이스 매핑\n- 영속성 컨텍스트\n\n## 영속성 컨텍스트란?\n\n-> 엔티티를 영구 저장하는 환경  \n -> **DB와 App간에 중간 계층**\n\n장점\n\n- 1차 캐시\n- 동일성 보장\n- 트랜잭션을 지원하는 쓰기 지원\n- 변경 감지\n- **지연 로딩**\n\n## 플러시란?\n\n> 영속성 컨텍스트의 변경 내용을 DB에 반영 (영속성 컨텍스트를 비우지 않음)\n\n**플러시 과정**  \n변경 감지 -> 수정된 엔티티를 쓰기 지연 SQL 저장소에 등록  \n-> 쿼리를 데이터베이스에 전송\n\n### 영속성 컨텍스트를 플러시 하는 방법\n\n- em.flush() : 직접 호출\n- 트랜잭션 커밋 : 플러시 자동 호출\n- JPQL 쿼리 : 플러시 자동 호출\n\n## 준영속 상태\n\n> 영속 상태의 엔티티를 영속성 컨텍스트에서 분리\n\n- em.detach(entity) : 특정 엔티티만 준영속 상태로 전환\n- em.clear() : 초기화\n- em.close() : 종료\n\n# Entity Mapping\n\n## 기본 어노테이션\n\n| 어노테이션            | 설명                        |\n| --------------------- | --------------------------- |\n| @Entity @Table        | entity와 매핑할 테이블 지정 |\n| @Id                   | 데이터베이핑 PK와 매핑      |\n| @Column               | 필드와 컬럼 매핑            |\n| @ManyToOne @JoinColum | 연관관계 매핑               |\n\n## Column 어노테이션\n\n| 어노테이션  | 설명                                                                        |\n| ----------- | --------------------------------------------------------------------------- |\n| @Column     | 컬럼 매핑                                                                   |\n| @Temporal   | 날짜 타입 매핑                                                              |\n| @Enumerated | JAVA enum 타입 매핑 (String사용)                                            |\n| @Lob        | BLOB(byte[]), CLOB(String, char[]) 매핑                                     |\n| @Transient  | 특정 필드를 컬럼에 매핑하지 않음(메모리상에서만 임시로 값 보관하고 싶을 때) |\n\n## 기본키 매핑\n\n### 기본키 자동 생성 전략\n\n1. IDENTITY - 데이터 베이스에 위임\n2. SEQUENCE - 데이터베이스 시퀀스 오브젝트 사용 (Oracle, PostgreSQL, H2)\n3. TABLE - 키 생성용 테이블 사용\n\n```java\n@Id // 직접 할당\n\n// 자동 생성\n// AUTO : 사용하는 DB에 따라 자동 지정 (기본값)\n@GeneratedValue(strategy = GenerationType.AUTO)\n\n// SEQUENCE : 데이터베이스 시퀀스 오브젝트 사용\n@Entity\n@SequenceGenerator(\n  name = \"MEMBER_SEQ_GENERATOR\",\n  equenceName = \"MEMBER_SEQ\",    // 매핑할 데이터베이스 시퀀스 이름\n  initialValue = 1,\n  allocationSize = 1             // 시퀀스 한 번 호출에 증가하는 수(성능 최적화)\n)\npublic class Member {\n  @Id\n  @GeneratedValue(strategy = GenerationType.SEQUENCE, generator= \"MEMBER_SEQ_GENERATOR\")\n  private Long id;\n  ...\n\n// TABLE : 키 생성용 테이블 사용\n@TableGenerator(name = \"MEMBER_SEQ_GENERATOR\",\n                table = \"MY_SEQUENCES\",\n                pkColumnValue = \"MEMBER_SEQ\",\n                allocationSize = 1)\npublic class CLASSNAME {\n    @Id\n    @GeneratedValue(strategy = GenerationType.TABLE, generator = \"MEMBER_SEQ_GENERATOR\")\n    private Long id;\n    ...\n\n```\n\n<details>\n<summary><b>SequenceGenerator 설정 값 (Toggle)</b></summary>\n\n| 속성            | 설명                                                          | 기본              |\n| --------------- | ------------------------------------------------------------- | ----------------- |\n| name            | 식별자                                                        | 생성기 이름 필수  |\n| sequenceName    | 데이터베이스에 등록되어 있는 시퀀스 이름                      | hibernate_sequenc |\n| initialValue    | DDL 생성 시에만 사용됨, 시퀀스 DDL 생성 시 시작하는 수를 지정 | 1                 |\n| allocationSize  | 시퀀스 한 번 호출에 증가하는 수                               | 50                |\n| catalog, schema | 데이터베이스 catalog, schema 이름                             |                   |\n\n</details>\n\n<details>\n<summary><b>TableGenerator 설정 값 (Toggle)</b></summary>\n\n| 속성                   | 설명                                 | 기본                |\n| ---------------------- | ------------------------------------ | ------------------- |\n| name                   | 식별자 생성기 이름                   | 필수                |\n| table                  | 키생성 테이블명                      | hibernate_sequences |\n| pkColumnName           | 시퀀스 컬럼명                        | sequence_name       |\n| valueColumnNa          | 시퀀스 값 컬럼명                     | next_val            |\n| pkColumnValue          | 키로 사용할 값 이름                  | 엔티티 이름         |\n| initialValue           | 초기 값, 마지막으로 생성된 값이 기준 | 0                   |\n| allocationSize         | 시퀀스 한 번 호출에 증가하는 수      | 50                  |\n| catalog, schema        | 데이터베이스 catalog, schema 이름    |                     |\n| uniqueConstraints(DDL) | 유니크 제약 조건 지정                |                     |\n\n</details>\n\n권장하는 기본키 전략  \n -> Long형, 대체키, 기본 키 전략 // 비즈니스 로직 포함 x\n\n# 연관 관계 매핑\n\n## 고려 사항\n\n- 다중성\n- 단방향, 양방향\n- 연관관계 주인\n\n## 단방향, 양방향\n\n테이블 : **외래키 하나**로 연관관계를 관리\n객체 : 서로 다른 **단뱡향 관계 2개**\n\n한쪽만 참조하면 단방향\n양쪽 서로 참조시 양방향\n\n양방향 매핑 규칙\n\n- **외래키**가 있는 곳을 **연관관계 주인**으로 지정\n- 연관관계 주인 값이 변경 시 외래키를 변경\n- 연관관계 주인 -> 외래키 관리(**등록, 수정**)\n- 주인이 아닌 쪽은 **읽기**만 가능 -> mappedBy 속성으로 주인 지정\n\n주의할 점\n\n- 값 추가 시 양쪽 모두 값 입력 -> **연관관계 편의 메소드** 사용\n- 무한루프 주의\n  - lombok toString 사용 x\n  - Controller에서 Entity 직접 반환x -> DTO로 변환해 사용\n\n연관관계 편의 메소스\n\n- 주인 setter + 반대쪽 객체에 값 넣어주는 부분 추가\n- 새로운 함수로 작성해 setter함수와 구분\n- 필요 시 제약조건 검사 구문 추가\n- 한쪽에만 작성\n\n```java\n\n...\n\npublic void addMember(Member member) {\n  member.setTeam(this);\n  members.add(member);\n}\n\n...\n\n```\n\n### 정리\n\n- 테이블 설계 -> 연관관계 매핑은 단방향 매핑으로 완성 되어야 함\n- 양방향 매핑은 반대 방향으로 조회 기능을 위해 추가\n- JPQL에서 역방향 탐색할 일이 많음\n\n## 다중성\n\n연관관계 매핑을 위한 어노테이션\n\n```java\n@ManyToOne @JoinColumn(name = \"TEAM_ID\") // N : 1\n\n@OneToMany(mappedBy = \"team\") // 1 : N\n\n@OneToOne // 1 : 1\n\n@ManyToMany // N : M 사용x\n\n```\n\n- 보통 다대일 관계 사용 - 외래키가 있는 쪽이 연관관계 주인\n- 일대일 관계 - 외래키에 유니크 제약조건 추가\n\n### 일대일\n\n| 위치                     | 특징                                        | 장점                                                                          | 단점                                                         |\n| ------------------------ | ------------------------------------------- | ----------------------------------------------------------------------------- | ------------------------------------------------------------ |\n| 주(access가 많은) 테이블 | - 객체지향 개발자 선호 <br> - JPA 매핑 편리 | 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능                  | 값이 없으면 외래 키에 null 허용                              |\n| 대상 테이블              | - 전통적인 데이터베이스 개발자 선호         | 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지 | 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨 |\n\n<details>\n<summary><b>@ManyToOne, @OneToMany 설정 값 (Toggle)</b></summary>\n\n| 속성     | 설명                                               | 기본 값                                                   |\n| -------- | -------------------------------------------------- | --------------------------------------------------------- |\n| optional | false로 설정하면 연관된 엔티티가 항상 있어야 한다. | TRUE                                                      |\n| fetch    | 글로벌 페치 전략을 설정한다.                       | @ManyToOne=FetchType.EAGER <br> @OneToMany=FetchType.LAZY |\n| cascade  | 영속성 전이 기능을 사용한다                        | sequence_name                                             |\n\n </details>\n\n# 상속 관계 매핑\n\n객체는 상속을 지원하므로 모델링과 구현이 똑같지만, DB는 상속을 지원하지 않으므로 논리 모델을 물리 모델로 구현할 방법이 필요\n\n유사한 개념으로는 슈퍼타입 서브타입 관계 있어 JPA에서는 **상속 구조**를 **슈퍼타입 - 서브타입 관계에 매핑**\n\nDB의 **슈퍼타입 서브타입 논리 모델**을 **실제 물리 모델**로 구현하는 방법 3가지\n\n1. 각각의 테이블 -> 조인 전략\n2. 통합 테이블 -> 단일 테이블 전략\n3. 서브타입 테이블 -> 구현 클래스 마다 테이블 전략\n\n```java\n// JOINED: 조인 전략\n// SINGLE_TABLE: 단일 테이블 전략\n// TABLE_PER_CLASS: 구현 클래스마다 테이블 전략\n// 부모 클래스에 어노테이션 추가 + 자식 클래스에서 부모 클래스 상속\n@Inheritance(strategy=InheritanceType.XXX)\n\n// 부모 클래스에 선언\n// 하위 클래스를 구분하는 용도 (Default = DTYPE)\n@DiscriminatorColumn(name=“DTYPE”)\n\n// 자식 클래스에 선언\n// 엔티티를 저장할 때 슈퍼타입 구분 컬럼에 저장할 값 지정 (Default : 클래스 명)\n@DiscriminatorValue(“XXX”)\n```\n\n| 전략                         | 장점                                                                                | 단점                                                                                                                                                                  |\n| ---------------------------- | ----------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| 조인 전략                    | - 테이블 정규화 <br> - 외래 키 참조 무결성 제약조건 활용가능 <br> - 저장공간 효율화 | - 조회시 조인을 많이 사용, 성능 저하 <br> - 조회 쿼리가 복잡함 <br> - 데이터 저장시 INSERT SQL 2번 호출                                                               |\n| 단일 테이블 전략             | - 조인이 필요 없으므로 일반적으로 조회 성능이 빠름 <br> - 조회 쿼리가 단순함        | - 자식 엔티티가 매핑한 컬럼은 모두 null 허용 <br> - 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다. <br> - 상황에 따라서 조회 성능이 오히려 느려질 수 있다. |\n| 구현 클래스 마다 테이블 전략 | - 서브 타입을 명확하게 구분해서 처리할 때 효과적 <br> - not null 제약조건 사용 가능 | - 여러 자식 테이블을 함께 조회할 때 성능이 느림(UNION SQL 필요) <br> - 자식 테이블을 통합해서 쿼리하기 어려움                                                         |\n\n## 정리\n\n- 기본적으로는 **조인 전략** -> 중요, 복잡, 확장 가능성이 높은 경우\n- 심플하고 확장 가능성이 낮은 경우 -> **단일 테이블 전략**\n\n## @MappedSubperclass\n\n> 객체의 입장에서 공통 매핑 정보가 필요할 때 사용\n\n- 상속 받는 자식 클래스에 **매핑 정보만 제공**\n- 조회, 검색이 불가능\n\n# 프록시\n\n> 연관된 객체를 처음부터 DB에서 조회하는 것이 아닌 실제 사용하는 시점에 조회 가능 (가짜 객체)\n\nem.find() - DB를 통해서 실제 엔티티 객체를 조회하는 메서드\nem.getReference() - DB의 조회를 미루는 가짜(프록시) 엔티티 객체를 조회하는 메서드\n\n## 특징\n\n- 실제 클래스의 상속을 받아 만들어짐\n- 프록시 객체는 실제 객체의 참조값(주소)를 가지고 있음\n- 사용 시 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 된다  \n  (JPA 내부에서 알아서 처리해준다.)\n\n<details>\n<summary><b>@트랜잭션 범위 밖에서 프록시 객체를 조회 (준영속 상태) 문제</b></summary>\n\n초기화 문제 발생\n\n(하이버네이트는 org.hibernate.LazyInitializationException 예외)\n-> 해결책으로 Spring Boot에서 open-in-view 설정 true\n(영속성 컨텍스트(하이버네이트 세션)를 뷰 렌더링하는 시점까지 유지시키는 방법)\nhttps://kingbbode.tistory.com/27\n\n실전 JPA강의에 해당 내용 강의 듣고 추가 정리\n\n</details>\n\n## 즉시 로딩, 지연 로딩\n\n```java\n@ManyToOne(fetch = FetchType.LASY) // 지연 로딩\n@ManyToOne(fetch = FetchType.EAGER) // 즉시 로딩\n```\n\n연관관계를 설정한 엔티티 조회 시 프록시 객체로 가져온다\n\n즉시 로딩 사용 시 **N+1 문제** 발생 가능  \n[JPA N+1 문제 해결 방법 및 실무 적용 팁 - 삽질중인 개발자](https://programmer93.tistory.com/83)  \n[[Tecoble] JPA Pagination, 그리고 N + 1 문제 - Chasing Yesterday](https://xlffm3.github.io/spring%20data/jpa-pagination-nplusone/)\n[JPA N+1 발생원인과 해결방법 - Yun Blog](https://cheese10yun.github.io/jpa-nplus-1/)\n\n- 모든 연관관계에서 **지연 로딩 사용**\n- @ManyToOne, @OneToOne, @XXXToOne 어노테이션들은 기본이 즉시 로딩(EAGER)  \n  => LAZY로 명시적으로 설정해서 사용\n- **JPQL fetch 조인**, 엔티티 그래프 기능, Batch Size 사용\n\n## 영속성 전이(CASCADE)\n\n> 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속상태로 만들 때\n\n연관관계 주인이 아닌 자식 객체에 설정\n\n```java\n@OneToMany(mappedBy=\"parent\", cascade=CascadeType.PERSIST)\n```\n\n종류\n\n- ALL: 모두 적용\n- PERSIST: 영속\n- REMOVE: 삭제\n- MERGE: 병합\n- REFRESH: REFRESH\n- DETACH: DETACH\n\n## 고아 객체\n\n> 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제\n\n- ** 참조하는 곳이 하나**일 때 사용\n- 특정 엔티티가 개인 소유할 때 사용  \n  (@OneToOne, @OneToMany 일 경우)\n\n```java\n@OneToMany(CascadeType.ALL + orphanRemovel=true)\n```\n\n-> 두 옵션을 모두 활성화 하면 부모 엔티티를 통해서 자식의 생명 주기 관리 가능\n(도메인 주도 설계(DDD)의 Aggregate Root개념을 구현할 때 유용)\n\n# 값 타입\n\nJPA는 크게 **엔티티타입, 값 타입**으로 분류\n\n엔티티 타입 : @Entity 정의, 데이터가 변해도 식별자로 추적 가능\n값 타입 : 자바 기본 타입이나 객체, 식별자가 없어 추적 불가\n\n## 값 타입 종류\n\n생명주기를 엔티티에 의존\n\n### 1. 기본 값 타입\n\n- 값타입 공유 x -> 복사해 사용\n- 생명주기를 엔티티에 의존\n- 불변 객체로 만들어 사용\n\n### 2. 임베디드(복합 값) 타입\n\n- 새로운 값 타입을 정의할 수 있음\n- 재사용성, 높은 응집도\n- 해당 값 타입만 사용하는 메소드 만들 수 있음\n- 값이 null이면 매핑한 컬럼은 모두 null\n- 불변 객체로 만들어 사용해야 함\n  - setter 만들지 않으면 된다\n  - 값을 복사해 사용\n  - 값을 공유해 사용하기 위해선 **엔티티**를 만들어 사용\n\n```java\n@Embeddable // 값 타입을 정의하는 곳에 사용\n@Embedded // 값 타입을 사용하는 곳에 사용\n\n@AttributeOverrides // 한 엔티티에서 같은 값 타입을 사용하면 어노테이션 사용해서 재정의\n\n// 사용 예시\n@Embedded\n@AttributeOverrides({\n  @AttributeOverride(name=\"city\", column=@Column(name=\"COMPANY_CITY\")),\n  @AttributeOverride(name=\"street\", column=@Column(name=\"COMPANY_STREET\")),\n  @AttributeOverride(name=\"zipcode\", column=@Column(name=\"COMPANY_ZIPCODE\"))\n})\nAddress companyAddress;\n```\n\n### 3. 컬렉션 값 타입\n\n- 컬렉션을 저장하기 위한 별도의 테이블 필요\n- 일반 엔티티와 동일하게 지연로딩 사용 가능\n- 값 타입 컬렉션은 **영속성 전이 + 고아 객체 제거** 기능을 필수로 가짐\n\n**제약 사항**\n\n- 식별자 개념 없다.\n- 변경 시 추적이 어려움\n- 변경사항 발생 시, 값 타입 컬렉션에 있는 모든 값을 다시 저장\n- 값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본키 구성 - null x, 중복 저장x\n\n```java\n@ElementCollection // 컬렉션 값 타입 사용시 매핑\n\n@CollectionTable // 테이블 설정\n```\n\n실무에 적용 시 상황에 따라 **일대다 관계 고려**\n\n엔티티 vs 값 타입  \n-> **식별자 필요, 지속해서 값 추적** 필요 시 엔티티\n\n# 쿼리\n\n## 종류\n\n- JPQL\n- JPA Criteria\n- QueryDSL\n- 네이티브 SQL\n- JDBC API 직접사용, MyBatis, SpringJdbcTemplate 함께 사용  \n  -> 영속성 컨텍스트를 **적절한 시점에 강제로 플러시 필요**\n\n## JPQL문법\n\n- 엔티티 이름 사용(테이블 아님)\n- 별칭 필수\n\n### 반환 타입\n\n```java\n// 반환 타입이 명확할 경우\nTypedQuery<Member> query = em.createQuery(\"SELECT m FROM Member m\", Member.class);\n\n// 반환 타입이 명확하지 않을 경우\nQuery query = em.createQuery(\"SELECT m.username, m.age from Member m\");\n```\n\n### 결과 조회\n\n```java\nquery.getResultList()   // 결과가 하나 이상일 때 리스트 반환\nquery.getSingleResult() // 결과가 하나\n```\n\n### 파라미터 바인딩\n\n> 이름 , 위치 기준\n\n```java\n// SQL\nSELECT m FROM Member m where m.username=:username\n\nquery.setParameter(\"username\", usernameParam);\n```\n\n### 프로젝션\n\n> 프로젝션 대상으로 엔티티, 임베디드 타입, 스칼라 타입 가능\n\n### 페이징 API\n\n```java\nsetFirstResult(int startPoint) // 조회 시작 위치\nsetMaxResults(int maxResult)   // 조회할 데이터 수\n```\n\n### 서브 쿼리\n\n- SELECT, WHERE, HAVING 절에서 서브 쿼리 사용 가능\n- **FROM 절 서브쿼리는 사용 불가**\n\n### 경로 표현식\n\n```SQL\nselect m.username -> 상태 필드\nfrom Member m\n  join m.team t -> 단일 값 연관 필드\n  join m.orders o -> 컬렉션 값 연관 필드\nwhere t.name = '팀A'\n```\n\n상태 필드(state field) : 단순히 값을 저장하기 위한 필드 (ex: m.username)  \n연관 필드(association field) : 연관관계를 위한 필드\n\n> **묵시적 내부 조인** 발생\n\n- 단일 값 연관 필드 : @ManyToOne, @OneToOne, 대상이 엔티티(ex: m.team)\n- 컬렉션 값 연관 필드 : @OneToMany, @ManyToMany, 대상이 컬렉션(ex: m.orders)\n\n주의 사항\n\n- 컬렉션은 탐색의 끝, 명시적 조인을 통해 별칭을 얻어야 함\n- 묵시적 조인 사용 x -> **명시적 조인 사용**\n\n### 페치 조인\n\n> SQL 조인 종류가 아닌 **성능 최적화**를 위해 제공하는 기능으로 연관된 엔티티나 컬렉션을 **SQL 한 번에 함께 조회** (N+1 문제 해결책)\n\n```SQL\nselect m from Member m join fetch m.team\n\n->\nSELECT M.*, T.* FROM MEMBER M\nINNER JOIN TEAM T ON M.TEAM_ID=T.ID\n```\n\n**DISTINCT**\n\n1. SQL에 DISTINCT를 추가\n2. 애플리케이션에서 같은 식별자를 가진 엔티티 중복 제거\n\n**한계**\n\n- 패치 조인은 기본적으로 모든 연관 그래프 가지고 오는 개념\n- 패치 조인 대상에는 별칭을 줄 수 없다\n- 둘 이상의 컬렉션은 패치 조인 할 수 없다\n- 컬렉션을 패치 조인하면 페이징 **API를 사용할 수 없다.**\n\n### 다형성 쿼리\n\nType : 조회 대상을 특정 자식으로 한정\n\n```SQL\n-- [JPQL]\nselect i from Item i\nwhere type(i) IN (Book, Movie)\n\n-- [SQL]\nselect i from i\nwhere i.DTYPE in (‘B’, ‘M’)\n```\n\nTREAT : 상속 구조에서 부모 타입을 특정 자식 타입으로 다룰 때 사용\n\n```SQL\n-- [JPQL]\nselect i from Item i\nwhere treat(i as Book).auther = ‘kim’\n\n-- [SQL]\nselect i.* from Item i\nwhere i.DTYPE = ‘B’ and i.auther = ‘kim’\n```\n\n### Named 쿼리(정적 쿼리)\n\n> 미리 정의해서 이름을 부여해두고 사용하는 JPQL\n\n- 어노테이션, XML 정의\n- 어플리케이션 로딩 시점에 초기화 후 재사용, **쿼리 검증**\n\nTip!!\n\n- JPA에서 타입 비교시 instance of(객체 비교) 사용\n\n- 벌크 연산 수행 후 영속성 컨텍스트 초기화(em.clear()) 필수!\n\n- 다대다 연관관계 사용 x -> 일대다, 다대일로 관계를 풀어서 사용  \n  (보통 중간에 매핑 테이블 필요 ex - category - gategory_item - item)\n\n- @Entity 클래스는 @Entity나 @MappedSuperclass로 지정한 클래스만 상속할 수 있다.\n\n- Entity는 기본 생성자 필요 -> protect 레벨로 생성 (추가로 필요한 내용 정리 예정)\n\n```java\n@Entity\n@NoArgsconstructor(access = AccessLevel.PROTECTED)\npublic class Member {\n  ...\n}\n```\n\n# Reference\n\n- [자바 ORM 표준 JPA 프로그래밍 (기본편) - 김영한](https://www.inflearn.com/course/ORM-JPA-Basic)\n- [JPA - 프록시란?](https://ict-nroo.tistory.com/131)\n","excerpt":"JPA (JAVA Persistence API) 자바 ORM 기술 표준 ORM(Object-relational mapping) 프레임 워크가 중간에서 매핑 JPA는 APP과 JDBC 사이에서 동작 패러다임의 불일치 해결 JPA는 인터페이스 모음 ->…","fields":{"slug":"/JPA_1/"},"frontmatter":{"date":"Sep 18, 2022","title":"자바 ORM 표준 JPA 프로그래밍 (기본편)","tags":["JPA"],"update":"Oct 13, 2022"}}},{"node":{"rawMarkdownBody":"\n# Redux\n\n> 자바스크립트로 구동되는 어플리케이션에서 예측 가능한 상태관리를 도와주는 상태관리 라이브러리\n\n## State\n\n> state는 크게 3가지로 구분할 수 있다.\n\n| 구분                  | 설명                                                                   | 방법                     |\n| --------------------- | ---------------------------------------------------------------------- | ------------------------ |\n| Local State           | 하나의 컴포넌트에 영향을 미치는 상태                                   | useState(), useReducer() |\n| Cross-Component State | 여러개의 컴포넌트에 영향을 미치는 상태                                 | prop chains              |\n| Would Wide State      | 전체, 대부분의 컴포넌트에 영향을 미치는 상태 ex) authentication status | prop chains              |\n\n2, 3에 해당하는 경우 **React Context, Redux**를 사용해 해결한다.\n\nContext를 사용해 2,3번을 해결할 수 있지만 크게 2가지 단점이 존재\n\n**1. Complex Setup / Management**\n\n- 여러개의 ContextProvider컴포넌트가 생기면서 관리의 어려움\n- 여러개의 Provider Component를 생성해 복잡한 JSX구문\n\n**2. Performance**\n\n## 장점\n\n- 상태를 예측 가능하게 만듬\n- 테스트나 디버깅에 용이\n\n## 특징\n\n1. Single source of truth\n\n   > 애플리케이션의 모든 상태는 하나의 저장소 안에 하나의 객체 트리 구조로 저장\n\n2. State is read-only\n\n   > 상태는 읽기전용(불변) 데이터이며, 오직 액션만 상태를 변경할 수 있다\n\n3. 변화를 일으키는 함수, 리듀서는 순수 함수여야 한다\n   > 이전 상태와 액션을 받아 다음 상태를 반환하는 순수 함수\n\n순수함수: 반환(reture)값이 전달 인자(argument) 값에만 의존하는 함수\n\n=> 순수 함수, 사이드 이펙트 x, 비동기 코드x\n\n## 핵심 개념\n\n### Flux패턴\n\n> 단방향 데이터 흐름의 디자인 패턴\n\n```text\nAction -> Dispatch -> Store -> View(Component)\n```\n\nComponent에서 Dispatch함수를 통해 Action 발생  \n-> reducer함수에 정의된 로직에 따라 store에 state를 변경 후 view에 반영\n\n=> **애플리케이션의 구조와 상태를 심플하게 파악 가능**\n\n### 1. State\n\n> Redux API에서는 보통 저장소에 의해 관리되고 getState()에 의해 반환되는 하나의 상태값\n\n### 2. Store\n\n> 애플리케이션의 상태 값들을 내장하고 있다 (상태가 관리되는 하나의 공간)\n\n### 3. Action\n\n> 태를 변화시키려는 의도를 표현하는 객체\n\n어떤 형태의 액션이 행해질지 표시하는 **type 필드**를 가져야 한다\n\n### 4. Reducer\n\n> 상태를 변화시키는 로직이 담긴 함수. 현재 상태와 Action을 이용해 다음 상태를 만들어 낸다\n\n### 5. Dispatch\n\n> 액션이나 비동기 액션을 받는 함수\n\n[추가로 알아야 할 용어](https://ko.redux.js.org/understanding/thinking-in-redux/glossary/)\n\nreact-redux 사용 방법\n\n1. Action 선언 및 Reducer 함수 작성\n\n```React\nexport const INCREMENT = 'increment';\nexport const INCREASE = 'increase';\nexport const DECREMENT = 'decrement';\nexport const TOGGLE = 'toggle';\nconst initialState = { counter: 0, showCounter: true };\n\nconst counterReducer = (state = initialState, action) => {\n  if (action.type === 'increment') {\n    return {\n      ...state,\n      counter: state.counter + 1,\n    };\n  }\n\n  if (action.type === 'increase') {\n    return {\n      ...state,\n      counter: state.counter + action.amount,\n    };\n  }\n\n  if (action.type === 'decrement') {\n    return {\n      ...state,\n      counter: state.counter - 1,\n    };\n  }\n\n  if (action.type === 'toggle') {\n    return {\n      ...state,\n      showCounter: !state.showCounter,\n    };\n  }\n\n  return state;\n};\n\nconst store = createStore(counterReducer);\n```\n\n2. Provider 컴포넌트를 사용해 store 연동\n\n```React\nroot.render(\n    <Provider store={store}>\n        <App />\n    </Provider>,\n);\n```\n\n3. Store내부의 **State사용을 위한 useSelector**와 **액션을 실행 시킬 useDispatch** 사용\n4. Component에 이벤트 - 함수 트리거\n\n```React\nconst Counter = () => {\n    const dispatch = useDispatch();\n    const counter = useSelector((state) => state.counter);\n\n    const incrementHandler = () => {\n        dispatch({ type: 'increment' });\n    };\n   ...\n\n   return (\n      ...\n         <button onClick={incrementHandler}>Increment</button>\n      ...\n    );\n}\n\n```\n\n- reducer함수에서 반환값은 항상 새로운 객체를 반환 (기존 객체 변경x)\n\n### useDispatch()\n\n> 액션을 호출하는 함수\n\nuseDispatch객체를 dispatch로 선언 후, dispatch 변수를 활용하여 import로 가져온 액션 호출\n\n```React\n// store/index.js\nexport const itemActions = itemSlice.actions;\n\n// item.js\nimport { itemActions } from '../../store/cart-slice';\n\nconst item = (props) => {\n  const dispatch = useDispatch();\n\n  ...\n\n  const addItemHandler = () => {\n    dispatch(\n      itemActions.addItemToCart({\n        id,\n        title,\n        price\n      })\n    )\n  }\n}\n\n```\n\n### useSelector()\n\n> tore state에 데이터를 등록한 상태를 가져오기 위한 함수\n\n```javascript\nconst user = useSelector((state) => state.user);\n```\n\n비동기를 지원하는 [Redux-Saga](https://github.com/redux-saga/redux-saga), [React-query](https://tanstack.com/query/v4/docs/guides/important-defaults) (추가로 정리 할 예정)\n\n강의에선 redux-toolkit을 사용하고 비동기 처리를 위해 react-thunk를 사용해서 이 부분을 정리한다.\n\n## Redux-toolkit\n\n> Redux를 사용하기 쉽게 만든 개발도구\n\n### 1. configureStore()\n\n> redux의 createStore를 추상화한 store 생성하는 함수\n\nreducer, middleware, devTools, preloadedState, enchancer 정보 전달\n\n기본 미들웨어로 redux-thunk를 추가하고 개발 환경에서 리덕스 개발자 도구(Redux DevTools Extension)를 활성화\n\n```React\nconst store = configureStore({\n  reducer: {\n    counter: counterReducer,\n    auth: authReducer,\n  },\n  middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(logger),\n  devTools: process.env.NODE_ENV !== 'production',\n  preloadedState,\n  enhancers: [reduxBatch],\n});\n```\n\n**reducer**\n\n- 단일 함수를 전달해 루트 리듀서 사용, 슬라이스 리듀서들로 구성된 객체 전달해 생성 가능\n- reducer 내부에선 combineReducers 함수로\n\n**middleware**\n\n- 리덕스 미들웨어를 담는 배열\n- 사용자 지정 미들웨어와 기본값을 함께 사용하려면 콜백 표기법을 사용,\n- 사용 예) redux-logger, custom middleware, verified serialization\n\n![Redux Toolkit (리덕스 툴킷)은 정말 천덕꾸러기일까? - 화해 블로그](reduxMiddleware.png)\n\n**devTools**\n\n- 리덕스 개발자 도구 on/off\n\n**preloadedState**\n\n- store 초기값\n\n**enchaners**\n\n- 기본 : 배열 , 콜백 함수로 작성 시 미들웨어가 적용되는 순서보다 앞서서 추가 가능\n\n### 2. createReducer()\n\n> 상태 변화를 일으키는 리듀서 함수 생성하는 함수\n\n- 내부적으로 **immer** 라이브러리를 사용하여 불변 업데이트가 이루어지도록 한다\n- 액션 처리 시 **1) builder callback, 2) map object**\n- 타입스크립트와 호환성을 위해성 builder callback 표기법 선호\n\n자세한 사항은 [redux-toolkit document](https://redux-toolkit.js.org/usage/usage-guide) 참조\n\n### 3. createAction()\n\n> 리덕스는 일반적으로 **액션 타입 상수, 액션 생성자 함수**를 분리하여 선언  \n> -> createAction 함수를 사용해 하나로 결합해 추상화\n\n### 4. createslice()\n\n> 리듀서, 액션 생성자, 액션 타입 자동으로 생성\n\n```React\nconst cartState = {\n    ...\n};\n\nconst cartSlice = createSlice({\n    name: 'cart',\n    initialState: cartState,\n    reducers: {\n        addItemToCart(state, action) {\n            ...\n        },\n        removeItemFromCart(state, action) {\n            ...\n        },\n    },\n});\n\n// const { actions, reducer } = cartSlice\n// export const { addItemToCart } = actions\n\n// export default reducer\n\nexport const cartActions = cartSlice.actions;\nexport default cartSlice;\n\n```\n\nredux를 구현하기 위해선 **actionsTypes, actions, reducer** 가 필요해 구조 중심으로 나눠서 관리하는데 기능을 수정하기 위해선 전부 다른 폴더로 관리되는 파일을 수정해야 한다\n\ncreateSlice는 Ducks Pattern을 사용해 **구조 중심 -> 기능 중심**형태로 코드 작성을 돕는다.  \n[ducks-modular-redux - github](https://github.com/erikras/ducks-modular-redux)으로 가면 관련된 내용 확인할 수 있다.\n\n### Ducks Pattern\n\n> **기능 중심으로 관리 -> module이라 부른다.**\n\n해당 패턴은 4가지 규칙을 가지고 있다.\n\n- MUST export default a function called reducer()\n- MUST export its action creators as functions\n- MUST have action types in the form npm-module-or-app/reducer/- ACTION_TYPE\n- MAY export its action types as UPPER_SNAKE_CASE, if an external reducer needs to listen for them, or if it is a published reusable library\n\n잘 정리된 블로그가 있어서 링크로 남긴다\n[React Redux, Ducks Pattern 적용하기 - tlatjdgh3778](https://velog.io/@tlatjdgh3778/React-Redux-Ducks-Pattern-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0)\n\n# Side Effects and Async Tasks in Redux\n\n비동기 처리를 위해 2가지 방법 사용 가능하다\n\n## 1. Inside the components - useEffect()\n\n> Component 내에서 직접 fetch, axios 사용\n\n## 2. Inside the actions creators\n\n> 리덕스 툴킷을 통해 action creator 생성 -> 디스 패치 할 작업 크리에이터 생성(Thunk)\n\nThunk란?\n\n> 다른 작업이 완료될 떄 까지 작업을 지연시키는 함수\n\nthunk로 action creator를 생성한다.  \n(Redux Toolkit을 사용 할 경우 기본적으로 thunk 추가 한다.)\n\nhttps://github.com/reduxjs/redux-thunk\n\n```Javascript\n\n```\n\n# React Route\n\n## 라우팅이란?\n\n> 사용자가 요청한 URL에 따라 알맞는 페이지 노출\n\n## React-Router\n\n가장 최신버전인 v6로 진행\n\n1. 패키지 관리 툴로 react-router-dom 설치\n\n```bash\nnpm install react-router-dom@5\n```\n\n2. 프로젝트에 적용\n\n```React\nimport ReactDOM from \"react-dom/client\";\nimport { BrowserRouter } from \"react-router-dom\";\n\nimport \"./index.css\";\nimport App from \"./App\";\n\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\nroot.render(\n  <BrowserRouter>\n    <App />\n  </BrowserRouter>\n);\n```\n\nApp 컴포넌트를 BrowserRouter로 감싸준다. (App 컴포넌트 내부에서도 적용 가능)\n\n3. Routers, Route 컴포넌트로 경로와 컴포넌트 설정\n\nRoute 컴포넌트 사용 방법\n\n```React\n<Route path=\"주소\" element={컴포넌트 JSX 요소} />\n```\n\n```React\n// App.js\nimport { Route, Routes } from \"react-router-dom\";\n\nimport Welcome from \"./pages/Welcome\";\nimport Products from \"./pages/Products\";\n\nconst App = () => {\n  return (\n    <Routes>\n      <Route path=\"/welcome\" element={<Welcome />} />\n      <Route path=\"/products\" element={<Products />} />\n    </Routes>\n  );\n};\n\nexport default App;\n```\n\n- Route 컴포넌트를 사용하기 위해선 Routes 컴포넌트로 감싸줘야 한다.\n- 경로 뒤에 \"/welcome/*\" 처럼 *추가 시 남은 전체 패턴에 대해 라우팅 가능  \n  (맨 끝에서만 사용 가능 - [react router 공식 문서](https://reactrouter.com/en/6.4.5/upgrading/v5#note-on-route-path-patterns))\n\n## Link 컴포넌트\n\n> 페이지를 새로 불러오는 것을 막고 History API를 통해 브라우저 주소의 경로만 바꾸는 기능을 가진 컴포넌트  \n> (a 태그 사용)\n\n사용 방법\n\n```React\n<Link to=\"경로\">{text}</Link>\n```\n\n## NavLink 컴포넌트\n\n> 링크에서 사용하는 경로가 현재 라우트 경로와 일치하는 경우 특정 css를 적용하는 컴포넌트\n\n사용 방법\n\n```React\n<NavLink\n  className={(navData) => console.log(navData)}\n  //   className={(navData) => (navData.isActive ? classes.active : \"\")}\n  to=\"welcome\"\n>\nWelcome\n</NavLink>\n```\n\nclassName은 isActive, isPending 2개의 값이 넘어온다\n\n- isActive가 true일 때 -> 유저가 NavLink의 URL 안에 있을 때\n- isPending가 true일 때 -> active가 막 되려고 할 때, 즉 데이터가 로딩되고 있을 때\n\n## URL 파라미터와 쿼리 스트링\n\nURL 파라미터 : 주소 경로에 값을 넣는 형태  \n -> useParams() Hook을 이용해 객체 형태로 값 조회\n\n쿼리 스트링 : ? 문자열 이후에 key=value 형태의 값  \n -> useLocation(), useSearchParams() Hook을 이용해 값 조회\n\n```React\n// Parent Component\n<Route path=\"/products/:productId\" element={<ProductDetail />} />\n\n// child Component\nconst ProductDetail = () => {\n    const params = useParams();\n    const location = useLocation();\n    const [searchParams, setSearchParams] = useSearchParams();\n\n    console.log(params);\n    console.log(location);\n    console.log(searchParams.get('name'));\n    console.log(searchParams.get('name2'));\n\n    return (\n        <section>\n            <h1>Product Detail</h1>\n            <p>{params.productId}</p>\n        </section>\n    );\n};\n\nexport default ProductDetail;\n```\n\n[useSearchParams 공식 문서](https://reactrouter.com/en/main/hooks/use-search-params)\n\n## 내부 중첩 route\n\n1. 부모 컴포넌트에서 \\* wildcart를 사용해 해당 패턴에 대한 라우팅 설정\n\n2. 자식 컴포넌트에서 Route 태그 추가\n\n```React\n// parent\n<Route path=\"/welcome/*\" element={<Welcome />} />\n\n// child\nconst Welcome = () => {\n    return (\n        <section>\n            <h1>The Welcome Page</h1>\n            <Routes>\n                <Route path=\"new-user\" element={<p>Welcome, new user!</p>} />\n            </Routes>\n        </section>\n    );\n};\n```\n\n## Redirect\n\n> Navigate Component 사용\n\n사용 방법\n\n```React\n<Route path=\"/\" element={<Navigate to=\"/welcome\" />} />\n```\n\n## useNavigate\n\n> 다른 페이지로 이동할 때 사용하는 Hook\n\n```React\nconst Layout = () => {\n  const navigate = useNavigate();\n\n  const goBack = () => {\n    // 이전 페이지로 이동\n    navigate(-1);\n  };\n\n  const goMain = () => {\n    // main 경로로 이동\n    navigate('/main');\n  };\n\n  const goMainReplace = () => {\n    navigate('/main', {replace: true});\n  }\n\n  return (\n    <div>\n      ...\n    </div>\n  );\n};\n\nexport default Layout;\n```\n\n다른 페이지로 이동 시 replace 옵션을 true 설정 할 경우 리다이렉션이 된다.  \n(리다이렉트가 되면 브라우저 내 페이지 기록에 남기지 않는다.)\n\n## Navigate Guard\n\n> v5에선 Prompt 컴포넌트를 사용해 페이지 이동을 막고, 제어할 수 있다.\n\n현재 v6에선 기능이 동작되지 않고 구현 중이므로 구현해서 사용해야 한다\n\n[[V6] [Feature] Getting usePrompt and useBlocker back in the router #8139](https://github.com/remix-run/react-router/issues/8139)  \n[Block user navigation with React Router v6 - Tadas Goberis](https://dev.to/tadasgo/block-user-navigation-with-react-router-v6-417f)\n\n이에 관련된 내용\n\n# React LazyLoading\n\nReact앱을 화면에 렌더링 하기 위해선 필요한 코드를 다운받아 화면에 노출시키는데 앱의 크기가 커지면 다운로드 할 파일이 커져 페이지 노출하는데 시간이 걸린다.\n\nReact는 코드를 분할해 화면상 보이는 페이지만 로드할 수 있게 **지연로딩(lazy-loading)**을 지원한다.\n\n1. 컴포넌트를 React.lazy()로 동적 import 한다.\n\n2. Suspense컴포넌트로 lazy컴포넌트를 감싸준다.\n\n```React\nconst NotFound = React.lazy(() => import('./pages/NotFound'));\n\nfunction App() {\n  return(\n    <Layout>\n      <Suspense\n          fallback={\n              <div className=\"centered\">\n                  <LoadingSpinner />\n              </div>\n          }\n      >\n        ...\n        <Route path=\"*\">\n            <NotFound />\n        </Route>\n      </Suspense>\n    </Layout>\n  )\n}\n```\n\n# React Animation\n\n리액트 컴포넌트에 애니메이션 적용 시 오픈 할 땐 문제가 되지 않지만\n제거 시, 컴포넌트가 바로 삭제되기 때문에 추가 라이브러리 필요\n\n-> react-transition-group (368, 370, 373듣고 간단히 정리)\n\nreact-transition-group은 dom에서 요소를 제거하거나 추가할 때 있어 시간과 관련 된 것들을 제공\n\nreact-motion, react-move, react-router-transition -> 애니메이션 적용 시 고려\n\n# Testing\n\n## Jest\n\n> 자바스크립트 테스트 프레임워크\n> -> 유닛 테스트, 스냅샷 비교, mocking, coverage 기능 제공\n\n### Global Variable\n\n> Jest는 테스트 파일에서 사용하는 메서드와 객체를 전역환경에 배치 (expect, jest, test ...)\n\n명시적으로 가져 올 경우\n\n```javascript\nimport { expect, jest, test } from '@jest/globals';\n```\n\n[더 많은 글로벌 변수 확인(jest 공식 문서)](https://jestjs.io/docs/api)\n\n#### 1. test\n\n> test 할 때 사용하는 메소드, **it** 메소드 동일한 기능\n\n```javascript\n// test(name, fn, timeout)\ntest('name', () => {});\n\n// it(name, fn, timeout)\nit('name', () => {});\n```\n\n#### 2. describe\n\n> 여러개의 테스트 그룹화\n\n```javascript\ndescribe('group', () => {\n  test('test1', () => {\n    ...\n  });\n\n  test('test2', () => {\n    ...\n  });\n});\n```\n\n#### 3. expect\n\n> 테스트 시 항목의 유효성 검사할 수 있는 matcher 함수 제공\n\n#### 4. jest 객체\n\n> 몇가지 유틸리티 함수를 가지는데 대표적으로 fn함수 (Mock데이터 생성)\n\n[matchers 함수 예시](https://jestjs.io/docs/expect)\n\n## React testing library\n\n> React UI Component test 하는데 사용 (가상 DOM 제공)\n\n```javascript\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport '@testing-library/jest-dom';\nimport Fetch from './fetch';\n\ntest('loads and displays greeting', async () => {\n  // ARRANGE\n  render(<Fetch url=\"/greeting\" />);\n\n  // ACT\n  await userEvent.click(screen.getByText('Load Greeting'));\n  await screen.findByRole('heading');\n\n  // ASSERT\n  expect(screen.getByRole('heading')).toHaveTextContent('hello there');\n  expect(screen.getByRole('button')).toBeDisabled();\n});\n```\n\n### 1. render 객체\n\n> 테스트를 위해 특정 컴포넌트를 jsdom에 렌더링\n\n### 2. Query - screen 객체\n\n> 렌더링 된 DOM 노드에 접근해 엘리먼트를 가져오는 메서드\n\n메서드 네이밍\n\n```javascript\n{쿼리 타입}{다수의 타겟 탐색 시 - all 추가}{타겟 유형}\n// ex)\ngetAllByRole\n\n```\n\n- 쿼리 타입 : get(동기적), find(비동기적 / 프로미스 반환)\n- 타겟 유형 : ex) ByRole, ByText ...\n\n### 3. Action - userEvent객체\n\n> 얻어온 타겟을 이용해 이벤트 실행\n\nex) click\n\n## Tips!!\n\n### 1. UI 테스트 시 서버 요청 x -> 요청에 따른 결과값으로 컴포넌트 동작 테스트 코드 작성 o\n\n> 요청하는 코드를 재사용x (서버 부하) -> Mock 데이터를 생성해서 테스트 한다.\n\n### 2. React Custom Hook\n\n> custom hook 테스트를 간단하게 해준다\n\n[react-hooks-testing-library - Github](https://github.com/testing-library/react-hooks-testing-library)  \n[react-hooks-testing-library - 공식문서](https://react-hooks-testing-library.com/)\n\n# Reference\n\n- [Udemy - React 완벽 가이드 with Redux, Next.js, TypeScript](https://www.udemy.com/course/best-react/learn/lecture/28517643#overview)\n- [3가지 원칙 - redux doc](https://ko.redux.js.org/understanding/thinking-in-redux/three-principles)\n- [Style Guide: Best Practices - redux doc](https://ko.redux.js.org/style-guide/)\n- [용어집 - redux doc](https://ko.redux.js.org/understanding/thinking-in-redux/glossary/)\n- [usage-guide - Redux-toolkit doc](https://redux-toolkit.js.org/usage/usage-guide)\n- [Redux Toolkit (리덕스 툴킷)은 정말 천덕꾸러기일까? - 화해 블로그](http://blog.hwahae.co.kr/all/tech/tech-tech/6946/)\n- [React Redux, Ducks Pattern 적용하기 - tlatjdgh3778](https://velog.io/@tlatjdgh3778/React-Redux-Ducks-Pattern-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0x)\n- [벨로퍼트와 함께하는 모던 리액트](https://react.vlpt.us/redux-middleware/05-redux-thunk-with-promise.html)\n- [React Router 공식 문서 ](https://reactrouter.com/en/main)\n- [코드 분할 - react 공식 문서](https://ko.reactjs.org/docs/code-splitting.html)\n- [jest 공식 문서](https://jestjs.io/docs/expect)\n- [React testing library 공식 문서](https://testing-library.com/docs/)\n","excerpt":"Redux 자바스크립트로 구동되는 어플리케이션에서 예측 가능한 상태관리를 도와주는 상태관리 라이브러리 State state는 크게 3가지로 구분할 수 있다. 구분 설명 방법 Local State 하나의 컴포넌트에 영향을 미치는 상태 useState(…","fields":{"slug":"/reactStudy_3/"},"frontmatter":{"date":"Sep 05, 2022","title":"React Redux, Routing","tags":["React"],"update":"Jan 07, 2023"}}},{"node":{"rawMarkdownBody":"\n작성중.......\n\n자바스크립트 특징에 대해 정리해보자\n\n## 배열 vs 객체\n\n### 배열\n\n- 순서가 있는 값, 순서는 인덱스로 구성\n\n- 값들은 요소(element)라고 부르며, 각각의 요소들은 쉼표(comma)로 구분\n\n- \\[ \\] 을 통해 배열 생성\n\n### 객체\n\n- 키와 값(key-value pair) 형태\n\n- 속성(Property)을 가지고, 한 쌍당 구분은 쉼표(comma)\n\n- \\{ \\}로 객체 생성\n\n## Prototype\n\n> 부모 역할을 담당하는 객체 - 자바스크립트의 모든 객체는 부모 역할을 담당하는 객체와 연결되어 있다.\n\n- 자바스크립트는 **프로토타입 기반 객체지향 프로그래밍 언어**\n- 객체 생성 시 <!--TODO:-->\n\n<!--TODO:-->\n\n## scope\n\n### 블록 레벨 스코프(Block-level scope)\n\n> 모든 코드 블록 내에서 선언된 변수는 코드 블록 내에서만 유효하며 코드 블록 외부에서는 참조할 수 없다.\n\n### 함수 레벨 스코프(Function-level scope)\n\n> 함수 내에서 선언된 변수는 함수 내에서만 유효하며 함수 외부에서는 참조할 수 없다.\n\n- 전역 변수, 지역 변수 중복되는 경우 지역 변수 우선\n- 선언하지 않고 변수 사용시 전역변수 처럼 동작 -> **암묵적 연역**이라 함\n- 전역 변수 사용을 억제하기 위해서 **즉시 실행 함수**로 만들어 사용\n\n### Hoisting\n\n> var 선언문이나 function 선언문 등을 해당 스코프의 선두로 옮긴 것처럼 동작하는 특성\n\n변수 할당은  \n선언(실행 컨텍스트에 변수 객체 등록) -> 초기화(공간을 메모리에 확보)  \n-> 할당(undefined로 초기화 된 변수에 실제 값 할당) 순으로 이뤄지는데\n\nvar 선언문은 이 과정이 한번에 일어난다\n\n**let**키워드는 선언 단계와 초기화 단계가 분리되어 진행 -> **블록 레벨 스코프 지원**\n\n### Lexical Scope(Enviroment)\n\n> 렉시컬 스코프는 함수를 어디서 호출하는지가 아니라 어디에 선언하였는지에 따라 결정된다.\n\n```javascript\nvar a = 1;\n\nfunction afn() {\n  var a = 10;\n  bfn();\n}\n\nfunction bfn() {\n  console.log(a);\n}\n\nafn(); // 10\nbfn(); // 10\n```\n\n## Closure\n\n> 함수 + 함수를 둘러싼 환경(Lexical environment)\n\n## Exports & Imports\n\n![](exportImport.png)\n보통 분리시킨 코드를 사진과 같이 크게 2가지 방법으로 가져온다.\n\n1. default 키워드 사용\n\n2. named export - {}로 작은 단위로 불러오는게 가능하다.\n\n```Javascript\nimport * as Canvas from './modules/canvas.js';\\\n```\n\n전체를 불러올 땐\n\n1. \\* 키워드 사용\n2. as 키워드를 통해 별칭 지정을 해 import할 수 있다.\n\n## Class\n\n```Javascript\n\nclass Person {\n  construct() {\n    gender = 'female';   // Property\n  }\n\n  printGender () {  // Method\n    console.log(this.gender);\n  }\n}\n\nclass SangHyeok extends Person {\n  constructor() {\n    super();\n    this.name = 'SangHyeok';\n    this.gender = 'male'\n  }\n  printName() {  // Method\n    console.log(this.name);\n  }\n}\n\nconst person = new Person();\nperson.printMyName();\nperson.printGender();\n\n// output:\n// \"SangHyeok\"\n// \"male\"\n\n// es6 style\n\nclass Person {\n  gender = 'female';   // Property\n  printGender = () => {  // Method\n    console.log(this.gender);\n  }\n}\n\nclass SangHyeok extends Person {\n  name = 'SangHyeok';\n  gender = 'male'\n\n  printName = () => {  // Method\n    console.log(this.name);\n  }\n}\n\nconst person = new Person();\nperson.printMyName();\nperson.printGender();\n\n// output:\n// \"SangHyeok\"\n// \"male\"\n```\n\n## Rest/Spread Operators\n\n> 객체 리터럴을 분해하고 병합하는데 편리한 기능 제공\n\nRest Parameter : 매개변수 내 사용 시 나머지 배열 값들을 받을 수 있음\nSpread Parameter : 대상을 개별 요소로 분리 (대상이 이터러블 해야 함)\n\n## 구조분해할당(Destructuring)\n\n> 구조화된 배열 또는 객체를 비구조화하여 개별적인 변수에 할당 (값을 추출하여 변수에 할당하거나 반환할 때 유용)\n\n### 배열\n\n```javascript\nconst today = new Date();\nconst formattedDate = today.toISOString().substring(0, 10);\nconst [year, month, day] = formattedDate.split('-');\n\nconsole.log([year, month, day]);\n\n// output\n// [\"2022\", \"07\", \"25\"]\n```\n\n### 객체\n\n```javascript\nconst users = [\n  {\n    name: 'Han',\n    address: {\n      city: 'Seoul',\n    },\n    phone: '010-1111-1111',\n  },\n  {\n    name: 'Sang',\n    address: {\n      city: 'Ansan',\n    },\n    phone: '010-2222-2222',\n  },\n];\n\nconst {\n  address: { city },\n} = users[0];\nconst { phone } = users[0];\n\nconsole.log(phone);\nconsole.log(city);\n\nconst admin = users.filter(({ name }) => name == 'Han');\n\nconsole.log(admin);\n\n// output\n/**\n\"010-1111-1111\"\n\"Seoul\"\n[[object Object] {\n  address: [object Object] {\n    city: \"Seoul\"\n  },\n  name: \"Han\",\n  phone: \"010-1111-1111\"\n}]\n */\n```\n\n이런식으로 원하는 값들을 뽑아와 변수에 할당해 읽기 편한 코드를 작성할 수 있다.\n\n## 원시 자료형와 자료 참조형\n\n원시 자료형 할당 시 **값**이 담기고 (6가지 자료형)\n참조 자료형 할당 시 **주소**가 담긴다 (배열, 객체, 함수)\n\n```javascript\nconst getUser = {\n  name: 'Han',\n};\n\nconst user1 = getUser;\n\nconst user2 = {\n  ...getUser,\n};\n\ngetUser.name = 'hahahaha';\n\nconsole.log(user1.name);\nconsole.log(user2.name);\n```\n\n리액트에서 객체의 값을 사용 시, spread연산자로 값을 **복사**해 사용해야 한다.\n\n## this\n\n## strict mode\n\n> 자바스크립트 문법을 엄격히 적용하여 기존에는 무시되던 오류를 발생시킬 가능성이 높거나 자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적인 에러를 발생 시킴\n\n전역, 함수단위 strict mode 적용은 피하는게 좋다  \n**->strict mode는 즉시실행함수로 감싼 스크립트 단위로 적용할 때 활용**\n\neslint같은 자바스크립트 문법에서 에러를 표시해주는 도구를 사용하는게 좋다\n\n## Arrow Function\n\n> 함수를 선언하는 방법\n\n```Javascript\nconst func = () => {\n\n}\n```\n\n### **this로 인해 생긴 문제 해결**\n\n> 화살표 함수의 this는 언제나 상위 스코프의 this를 가르킨다. -> Lexical this\n\n자바스크립트는 함수를 선언할 때 this에 바인딩 할 객체가 정적으로 결정 x\n**함수를 호출할 때 함수가 어떻게 호출되었는지에 따라 동적으로 결정된다.**\n\n<!--TODO:-->\n\n```javascript\n\n```\n\n## Iterator protocol이란?\n\n> value들의 sequence를 만드는 표준 방법\n\ndone (boolean) : iterator에 return값이 있으면 value값으로 지정  \nvalue : iterator으로 반환되는 모든 자바스크립트 값 (done이 true일 경우 생략 가능)\n\n```javascript\nfunction makeIterator(array) {\n  var nextIndex = 0;\n\n  return {\n    next: function () {\n      return nextIndex < array.length ? { value: array[nextIndex++], done: false } : { done: true };\n    },\n  };\n}\n\nvar it = makeIterator(['yo', 'ya']);\n\nconsole.log(it.next().value); // 'yo'\nconsole.log(it.next().value); // 'ya'\nconsole.log(it.next().done); // true\n```\n\n## Generator란?\n\n<!--TODO:-->\n\n## 비동기 처리\n\n자바스크립트는 특정 코드의 연산이 끝날 때까지 코드의 실행을 멈추지 않고 다음 코드를 먼저 실행\n-> 일정 시간이 지난 후 순차적으로 실행해야 하는 부분에서 문제가 발생할 수 있다\n\n이러한 문제는 콜백함수로 해결할 수 있으나 코드의 가독성 면에서 좋지 않다\n\n### Promise\n\n```javascript\nconst promise = new Promise((resolve, reject) => {\n  if (true)) {  // 성공\n    resolve('result');\n  }\n  else { // 실패\n    reject('failure reason');\n  }\n}).then(() => {\n  // 다음 동작\n}).catch(() => {\n  // 에러처리\n});\n```\n\n<!--TODO: 설명 추가-->\n\n이런 형식으로 콜백 함수를 사용하는 방법보다는 가독성이 좋지만 then... 지옥에 빠질 수 있다.\n\n### Generator 활용\n\n<!--TODO:-->\n\n### async, await\n\n```javascript\nlet play = async () => {\n  // try - catch 에러 처리\n  try {\n    var user = await ajaxUser();\n    if (user.id === 1) {\n      ...\n    }\n  } catch (error) {\n    console.log(error);\n  }\n};\n```\n\n## 유사 배열 객체 vs 배열\n\n- 유사 배열 객체 : key가 숫자, length값을 가지고 있는 객체\n  - 배열 함수, for-of, 비구조화 할당, 전개 연산자(...) 사용 불가 -> **객체가 이터러블 하지 않기 때문**\n  - ex) 문자열(String), 함수의 매개변수 객체(arguments), 각종 DOM객체(HTML Collection, NodeList)\n  - 유사 배열 객체는 Array.prototype.slice.call()로 배열로 만들 수 있다.\n  - The iterator protocol로 구현 가능 (iterable한 객체로 만들기)\n\n## foreach, for ...in, for ...of\n\n---\n\n# Library\n\n## immutable.js\n\n<!-- TODO -->\n\n## lodash.js\n\n<!-- TODO -->\n\n1. empty\n\n---\n\n# Javascript Inner Function\n\n## bind()\n\n> 호출될 때 this 키워드가 제공된 값으로 설정되는 새로운 함수를 반환한다.\n\n```javascript\nbind(thisArg, arg1, ... , argN)\n```\n\n1. thisArg : this가 가리킬 객체를 지정\n2. arg1, ... , argN : 함수에 전달할 인자 값\n   thisArg는 전달하지 않고 null을 사용할 수도 있다.\n\n<!-- TODO -->\n\n<!--https://bigtop.tistory.com/69-->\n<!--https://tocomo.tistory.com/26-->\n<!--https://velog.io/@won-developer/JS%EC%9D%98-%EB%B0%B0%EC%97%B4-%EB%82%B4%EC%9E%A5%ED%95%A8%EC%88%98%EB%93%A4-->\n\n---\n\n# Tip!!\n\n## 빈값, null 체크\n\nnull, undefined, NaN, \"\", 0, false 체크 시 not 연산자로 체크\n\n```Javascript\nlet result = \"\";\n\nif(!result){\n  console.log('error');\n}\n```\n\n## indexOf, include\n\nindexOf는 index를 활용할 때 사용\nincludes는 return해 true/false 처리할 때 사용\n\n---\n\n유용한 라이브러리 사용법과 개발하면서 자주 활용되는 javascript inner 함수는.... 추후에 추가로 정리 해보자... 하핳ㅎ...\n\n# Reference\n\n- [negabaro's Blog](https://negabaro.github.io/archive/js-isEmpty)\n- [Iteration_protocols](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Iteration_protocols)\n- [Javascript : Prototype vs Class](https://medium.com/@parsyval/javascript-prototype-vs-class-a7015d5473b)\n- [poiemaweb](https://poiemaweb.com/)\n- [Object prototypes - mdn](https://developer.mozilla.org/ko/docs/Learn/JavaScript/Objects/Object_prototypes)\n- [자바스크립트의 스코프와 클로저 - NHN](https://meetup.toast.com/posts/86)\n- [자바스크립트 async와 await - 캡틴 판교](https://joshua1988.github.io/web-development/javascript/js-async-await/)\n- [ES6의 제너레이터를 사용한 비동기 프로그래밍](https://meetup.toast.com/posts/73)\n- [Async-await는 어떻게 구현하는가 - Haegul Pyun](https://medium.com/@la.place/async-await%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94%EA%B0%80-fa08a3157647)\n","excerpt":"작성중....... 자바스크립트 특징에 대해 정리해보자 배열 vs 객체 배열 순서가 있는 값, 순서는 인덱스로 구성 값들은 요소(element)라고 부르며, 각각의 요소들은 쉼표(comma)로 구분 [ ] 을 통해 배열 생성 객체 키와 값(key-v…","fields":{"slug":"/frontTips_2/"},"frontmatter":{"date":"Aug 30, 2022","title":"Javascript","tags":["Javascript"],"update":"Dec 28, 2022"}}},{"node":{"rawMarkdownBody":"\n이번 포스팅에선 리액트 어플리케이션을 만들기 위해 사용하는 중요한 Hooks와 Http 요청에 대해 정리한다.\n\n---\n\n# Side Effects(Refs) & More Hooks\n\n## Side Effects\n\n> 함수가 실행되면서 함수 외부에 존재하는 값이나 상태를 변경시키는 등의 행위  \n> (비동기로 처리되어야 하는 부수적인 효과)\n\nex) 브라우저 스토리지에 값 저장, 타이머, 백엔드 서버에 HTTP 요청 등\n\n## UseEffect()\n\n> Side Effect 처리를 위해 필요\n\n```javascript\nuseEffect(() => {}, [dependencies]);\n```\n\n```text\nuseEffect함수는 2개의 매개 변수를 받음\n1. 콜백함수,\n2. 값이 변할 경우 콜백함수를 실행시키고 싶은 변수\n -> 빈 배열이면 Component가 처음 마운트 되고 렌더링 될 때만 실행\n -> 콜백함수 내부에서 사용하는 모든 변수는 배열에 추가되어야 한다\n```\n\n- 첫번째 인자인 callback의 return 값으로 함수 반환 -> **cleanUp 함수**\n- clean up 함수는 1번째 인자값으로 받은 함수(사이드 이펙트 함수)가 실행되기 전에 실행  \n  (최초 실행시 동작x)\n- useEffect로 작성된 함수는 Promise객체를 반환 하면 에러  \n  -> 함수를 따로 만들어 사용\n\n### Debouncing\n\n> 연이어 호출되는 함수들 중 마지막 함수(또는 제일 처음)만 호출되도록 하는 것\n\n```javascript\nuseEffect(() => {\n  const identifier = setTimeout(() => {\n    setFormIsValid(enteredEmail.includes('@') && enteredPassword.trim().length > 6);\n  }, 500);\n\n  // cleanUp 함수\n  return () => {\n    clearTimeout(identifier);\n  };\n}, [enteredEmail, enteredPassword]);\n```\n\nex) Form 태그 하위 요소 입력값 검증, AJAX 요청\n\n### Throttling\n\n> 마지막 함수가 호출된 후 일정 시간이 지나기 전에 다시 호출되지 않도록 하는 것\n\nex) scroll 동작 시\n\nTip!!\n\n- Debouncing, Throttling -> lodash 활용 가능\n\n## useReducer()\n\n> 복잡한 state를 관리할 때 사용\n> 다른 state기반으로 한 state를 업데이트 할 때 사용 (하나의 state로 병합)\n\n일반적인 경우, 데이타 변경이 잦은 경우 -> useState사용\n\n```javascript\nconst [state, dispatchFn] = useReducer(reducerFn, initialState, initFn);\n```\n\n```\n첫번째 인자 reducer 함수\n두번째 인자 initial State\n세번째 인자 초기 state를 계산하는 함수\n\nreducer함수는\n첫번째 인자 - 현재 상태\n두번째 인자 - 액션 객체 를 파라미터로 받아와 새로운 상태를 반환해주는 함수 반환\n\n보통 dispatch함수의 액션 Type은 대문자로 명칭을 정해준다.\n```\n\n## Context API\n\n> 어떤 컴포넌트에서라도 직접 다른 컴포넌트에 전달할 수 있게 해준다.\n> props chain을 없앨 수 있음\n\n앱 전체나 여러 컴포넌트에 영향을 주는 state 관리에 적합\n(자주 바뀌는 경우 적합하지 않음)\n\n```React\nimport React from 'react';\n\nconst AuthContext = React.createContext({\n  iosLoggedIn: false,\n});\n\nexport default AuthContext;\n```\n\nReact.createContext로 반환되는 값은 컴포넌트나 컴포넌트를 포함한 객체\n\n만든 컴포넌트를 전역적인 위치에서 감싸준다.\n\n```React\n// App.js\nfunction App() {\n  // ...\n\n  return (\n    <AuthContext.Provider\n      value={{\n        isLoggedIn: isLoggedIn,\n      }}\n    >\n    <Header>\n    <Main>\n    </AuthContext.Provider>\n  );\n}\n```\n\n값을 받아오는 방법은 2가지\n\nConsumer , react hooks 사용\n\n1. 사용하는 곳에서 Consumer 컴포넌트로 감싸 값을 가져옴\n\n```React\nconst Main = (props) => {\n    return (\n        <AuthContext.Consumer>\n            {(ctx) => {\n                return (\n                    {ctx.isLoggedIn && (\n                        <li>\n                            <a href=\"/\">Users</a>\n                        </li>\n                    )}\n                );\n            }}\n        </AuthContext.Consumer>\n    );\n};\n```\n\n2. useContext()\n\n```React\nconst Main = (props) => {\n    const ctx = useContext(AuthContext);\n\n    return (\n        {ctx.isLoggedIn && (\n            <li>\n                <a href=\"/\">Users</a>\n            </li>\n        )}\n    );\n};\n```\n\nstate, state를 수정하는 로직을 모아서 사용 가능\n\n```React\n// auth-context.js\nimport React, { useState, useEffect } from 'react';\n\n// 선언을 해주면 IDE 자동 완성 가능\nconst AuthContext = React.createContext({\n    iosLoggedIn: false,\n    onLogout: () => {},\n    onLogin: () => {},\n});\n\nexport const AuthContextProvider = (props) => {\n    const [isLoggedIn, setIsLoggedIn] = useState(false);\n\n    useEffect(() => {\n        const storedUserLoggedInInformation = localStorage.getItem('isLoggedIn');\n\n        if (storedUserLoggedInInformation === true) {\n            setIsLoggedIn(true);\n        }\n    }, []);\n\n    const logoutHandler = () => {\n        localStorage.setItem('isLoggedIn', true);\n        setIsLoggedIn(false);\n    };\n\n    const loginHandler = () => {\n        localStorage.removeItem('isLoggedIn');\n        setIsLoggedIn(true);\n    };\n\n    return (\n        <AuthContext.Provider value={{ isLoggedIn: isLoggedIn, onLogout: logoutHandler, onLogin: loginHandler }}>\n            {props.children}\n        </AuthContext.Provider>\n    );\n};\n\nexport default AuthContext;\n\n\n// index.js\nroot.render(\n    <AuthContextProvider>\n        <App />\n    </AuthContextProvider>,\n);\n\n// App.js\nimport React, { useContext } from 'react';\n\nfunction App() {\n    const ctx = useContext(AuthContext);\n\n    return (\n        <React.Fragment>\n            <MainHeader onLogout={ctx.onlogout} />\n            <main>\n                {!ctx.isLoggedIn && <Login />}\n                {ctx.isLoggedIn && <Home />}\n            </main>\n        </React.Fragment>\n    );\n}\n\nexport default App;\n```\n\n## Rules of Hooks\n\n1. 리액트 훅을 호출 시 1) 컴포넌트 함수, 2) 커스텀 훅에서만 사용\n2. 리액트 훅은 최상위 부분에서 호출\n\n![](reactHooksRules.png)\n\n## Forward Refs\n\nReact.forwardRef\n\n> 부모 컴포넌트에서 하위 컴포넌트로 ref전달\n\nuseImperativeHandle\n\n> ref를 사용하는 부모 측에서 커스터마이징된 메서드를 사용 가능\n\nex) focusing, scrolling\n\n```javascript\nuseImperativeHandle(ref, createHandle, [deps]);\n```\n\nref : 프로퍼티를 부여할 ref\ncreateHandle : 객체를 리턴하는 함수. 해당 객체에 추가하고 싶은 프로퍼티를 정의\n\n```React\n// Login.js\nconst login = (props) => {\n    const emailInputRef = useRef();\n    const passwordInputRef = useRef();\n    ...\n\n    const submitHandler = (event) => {\n        event.preventDefault();\n\n        if (formIsValid) {\n            authCtx.onLogin(emailState.value, passwordState.value);\n        } else if (!emailIsValid) {\n            emailInputRef.current.focus();\n        } else {\n            passwordInputRef.current.focus();\n        }\n    };\n\nreturn (\n        <form onSubmit={submitHandler}>\n            <Input\n                ref={emailInputRef}\n                id=\"email\"\n                label=\"E-Mail\"\n                type=\"email\"\n                isValid={emailIsValid}\n                value={emailState.value}\n                onChange={emailChangeHandler}\n                onBlur={validateEmailHandler}\n            />\n            <Input\n                ref={passwordInputRef}\n                id=\"password\"\n                label=\"Password\"\n                type=\"password\"\n                isValid={passwordIsValid}\n                value={passwordState.value}\n                onChange={passwordChangeHandler}\n                onBlur={validatePasswordHandler}\n            />\n            <div className={classes.actions}>\n                <Button type=\"submit\" className={classesbtn}>\n                    Login\n                </Button>\n            </div>\n        </form>\n    );\n\n}\n\n// input.js\n// React.forwardRef 메서드로 감싸줌\nconst Input = React.forwardRef((props, ref) => {\n    const inputRef = useRef();\n\n    const activate = () => {\n        inputRef.current.focus();\n    };\n\n    // 1) ref객체 , 2) 기능 트리거 될 함수 객체 리턴하는 익명 함수\n    useImperativeHandle(ref, () => {\n        return {\n            focus: activate,\n        };\n    });\n\n    return (\n        <div className={`${classes.control} ${props.isValid === false ? classes.invalid : ''}`}>\n            <label htmlFor={props.id}>{props.label}</label>\n            <input\n                ref={inputRef}\n                type={props.type}\n                id={props.id}\n                value={props.value}\n                onChange={props.onChange}\n                onBlur={props.onBlur}\n            />\n        </div>\n    );\n});\n```\n\n# React memoization\n\nComponent의 props, state, 부모 컴포넌트 렌더링에 따라 다시 실행 되는데 성능상의 이슈로 인해 리렌더가 일어나지 않도록 최적화 해주는 방법\n\nReact에서 컴포넌트가 렌더링 하는 규칙에는 크게 3가지\n\n1. state/props 변경 시\n2. forceUpdate() 실행 시\n3. 부모 컴포넌트가 렌더링 되었을 때\n\n## React.Memo()\n\n> 같은 props를 받을 때 같은 결과를 렌더링한다면 React.memo를 사용하여 불필요한 컴포넌트 렌더링을 방지\n\n다음 렌더링이 일어날 때 props가 같은 경우 성능향상\n\n```React\n// 1\nconst Header = React.memo(() => {\n  return ()\n})\n\n// 2\nexport default React.memo(Header);\n\n```\n\n- 컴포넌트를 감싸서 사용\n- 비교 방식을 커스텀하고 싶으면 두번째 인자로 **비교하는 함수 추가**\n\nReact.memo()를 사용하지 말아야 할 때\n\n- 렌더링 될 때 props가 다른 경우가 대부분인 컴포넌트일 경우  \n  -> 메모제이션 기법의 이점을 얻기\n- 클래스 기반의 컴포넌트 일 경우\n  -> **PureComponent**, shouldComponentUpdate() 메서드를 구현해 사용하는 것이 적절\n\n## useMemo()\n\n> 함수에 의해 나온 결과값을 메모리에 저장해서 컴포넌트가 반복적으로 렌더링 되어도 이미 가져온 결과값을 메모리에서 꺼내와 재사용 (값을 반환)\n\nReact.memo가 props, state에 의해 re-render를 관리한다면  \nuseMemo는 함수의 결과 값을 memoizing하여 연산을 관리한다\n\n```React\n  const sortedList = useMemo(() => {\n    return items.sort((a, b) => a - b);\n  }, [items]);\n  console.log(\"DemoList RUNNING\");\n```\n\n## useCallback()\n\n> 특정 함수를 새로 만들지 않고 재사용하고 싶을때 사용 (함수를 반환)\n\n```React\nconst changeTitleHandler = useCallback(() => {\n    setListTitle('New Title');\n}, []);\n```\n\ndependency 배열에는 useEffect와 동일하게 어떤값이 변경되면 다시 생성할지에 대한 값들이 들어감\n\nuseEffect내부에 함수를 사용할 경우, 디펜던시 배열에 함수를 추가하면 무한 루프가 발생  \n-> 즉, useCallback 함수는 useEffect내부에서 사용하는 함수를 useCallback으로 감싸 동일한 객체를 사용할 수 있도록 사용\n\nuseCallback(fn, deps)은 useMemo(() => fn, deps)와 같음\n\n## useState, useReducer\n\n> 컴포넌트가 초기화 될 때만 갱신된다.\n\n성능 측정은 Dev tools Profiling 탭을 통해 가능하다.\n\n# Class Component\n\nFunction Component : 일반 컴포넌트와 달리 state, 라이플 사이클 기능 제거  \n -> 일반 클래스형 함수보다 빠르다\n\nReact life cycle은 [React document](https://ko.reactjs.org/docs/react-component.html) 참고\n\n| function                               | state                  | 기능                             |\n| -------------------------------------- | ---------------------- | -------------------------------- |\n| useEffect(..., [])                     | componentDidMount()    | 초기화 될 때마다 실행            |\n| useEffect(..., [someValue])            | ComponentDidUpdate()   | State가 없데이트 될 때 마다 실행 |\n| useEffect(() => r{eturn () => {}}, []) | componentWillUnmount() | 컴포넌트가 실행되기 전에 실행    |\n\n대체적으로 함수형으로 작성한게 this. 구문도 없애주고 깔끔한 코드를 작성할 수 있게 해주지만 에러를 잡아주는 부분은 클래스 컴포넌트로만 잡아줄 수 있다.\n\n## Error boundary\n\n```React\n// ErrorBoundary.js\nimport { Component } from 'react';\n\nclass ErrorBoundary extends Component {\n  constructor() {\n    super();\n    this.state = { hasError: false };\n  }\n\n  componentDidCatch(error) {\n    console.log(error);\n    this.setState({ hasError: true });\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <p>에러 발생</p>;\n    }\n    return this.props.children;\n  }\n}\n\nexport default ErrorBoundary;\n```\n\n이런 식으로 componentDidCatch를 사용하는 ErrorBoundary 컴포넌트를 만들어 탐지하고 싶은 컴포넌트에 감싸서 사용한다\n\n# Forms, Http Request & Custom Hooks\n\n## Http Request\n\nReact에서 Http 요청을 하기 위한 2가지 방법\n\n1. axios\n2. fetch\n\n비동기 처리를 위해 async, await 구문을 사용한다.\n\n## Custom Hooksre\n\n> 로직 재사용(공유)을 위해 Hook 만들어 사용\n\n- 함수의 이름은 **use**로 시작한다.\n- Custom Hook을 통해 만들어진 상태는 각각의 컴포넌트마다 따로 상태 관리\n\n```React\n// use-Https.js\nimport { useCallback, useState } from 'react';\n\nconst useHttp = () => {\n    const [isLoading, setIsLoading] = useState(false);\n    const [error, setError] = useState(null);\n\n    // 1) 어떤 종류의 요청이든 가능하게\n    // 2) 어떤 데이터 변환도 가능하게\n    // 3) 로딩과 에러 상태 관리\n    const sendRequest = useCallback(async (requestConfig, applyData) => {\n        setIsLoading(true);\n        setError(null);\n        try {\n            const response = await fetch(requestConfig.url, {\n                method: requestConfig.method ? requestConfig.method : 'GET',\n                headers: requestConfig.headers ? requestConfig.headers : {},\n                body: requestConfig.body ? JSON.stringify(requestConfig.body) : null,\n            });\n\n            if (!response.ok) {\n                throw new Error('Request failed!');\n            }\n\n            const data = await response.json();\n\n            // 2번째 인자로 받은 request 요청 후 처리 함수 실행\n            applyData(data);\n        } catch (err) {\n            setError(err.message || 'Something went wrong!');\n        }\n        setIsLoading(false);\n    }, []);\n\n    return {\n        isLoading,\n        error,\n        sendRequest,\n    };\n};\n\nexport default useHttp;\n\n// other Component\nconst [tasks, setTasks] = useState([]);\n\nconst { isLoading, error, sendRequest: fetchTasks } = useHttp();\n\nuseEffect(() => {\n    const transformTasks = (tasksObj) => {\n        const loadedTasks = [];\n\n        for (const taskKey in tasksObj) {\n            loadedTasks.push({ id: taskKey, text: tasksObj[taskKey]text });\n        }\n\n        setTasks(loadedTasks);\n    };\n\n    fetchTasks({ url: url }, transformTasks);\n}, []);\n\n```\n\n## Form\n\n사용자의 입력값을 검증하는 방법 3가지\n\n| 동작                 | 장점                                              | 단점                                |\n| -------------------- | ------------------------------------------------- | ----------------------------------- |\n| Form 요청을 제출     | 불필요한 알림을 줄일 수 있다                      | 사용자에게 알리는 시점이 늦다       |\n| Input 포커스 해제    | 폼 데이터를 제출하기 전에 사용자에게 알릴 수 있다 | 포커스를 잃었을 때만 동작           |\n| 사용자의 키 입력마다 | 빠른 피드백 가능                                  | 사용자의 입력을 전부 받기 전에 알림 |\n\n비즈니스 요구사항에 따라 적절히 조합해 값 검증\n\n# Tip!!\n\n태그의 속성들을 객체로 만들어 속성값을 한번에 넘겨서 사용하면 깔끔한 코드 작성 가능\n\n```React\n// Component\nreturn = (\n    ...\n\n    <Input\n        label=\"Amount\"\n        input={{\n            id: 'amount_' + props.id,\n            type: 'number',\n            min: '1',\n            max: '5',\n            step: '1',\n            defaultValue: '1',\n        }}\n    />\n\n    ...\n)\n// input.js\nconst Input = (props) => {\n    return (\n        <div>\n            <label htmlFor={props.input.id}>{props.label}</label>\n            <input {...props.input} />\n        </div>\n    );\n};\n\nexport default Input;\n\n\n```\n\nreducer 함수 작성 시 배열값을 추가할 때 concat으로 값을 추가하면 새로운 객체로 값을 생성해서 이전 상태를 바꾸지 않고 처리 가능\n\n---\n\nReact는 함수 내 상태를 업데이트하는 여러개의 함수가 있어도\n**하나의 동기화 프로세스에서 같이 실행**한다\n\n# Reference\n\n- [Udemy - React 완벽 가이드 with Redux, Next.js, TypeScript](https://www.udemy.com/course/best-react/learn/lecture/28517643#overview)\n- [React.memo() 현명하게 사용하기 - TOAST UI](https://ui.toast.com/weekly-pick/ko_20190731)\n- [[React] useImperativeHandle의 장점](https://developer-alle.tistory.com/372)\n","excerpt":"이번 포스팅에선 리액트 어플리케이션을 만들기 위해 사용하는 중요한 Hooks와 Http 요청에 대해 정리한다. Side Effects(Refs) & More Hooks Side Effects 함수가 실행되면서 함수 외부에 존재하는 값이나 상태를 변경…","fields":{"slug":"/reactStudy_2/"},"frontmatter":{"date":"Aug 24, 2022","title":"React Hooks & Http Request","tags":["React"],"update":"Aug 31, 2022"}}},{"node":{"rawMarkdownBody":"\n- ctrl + enter : generate\n- cmd + b : 코드 구현부로 이동\n- ctrl + shift + f : 전체 검색\n- ctrl + shift + r : 전체 변경\n\n코드 작성\n\n- option + cmd + v : 해당 라인에 변수 추가\n- command + shift + t : 테스트 코드 작성\n- \"iter\" + tab : foreach문 생성\n- shift + F6 : 이름 변경\n- option + cmd + n : : 인라인 변수\n\n이동\n\n- cmd + e : 파일 이동\n- option + F12 : terminal 이동\n- cmd + 4 : run 창\n- cmd + b : 부모 클래스로 이동\n\n![인텔리제이 맥 치트키](mac_inteiij_key_map)\n","excerpt":"ctrl + enter : generate cmd + b : 코드 구현부로 이동 ctrl + shift + f : 전체 검색 ctrl + shift + r : 전체 변경 코드 작성 option + cmd + v : 해당 라인에 변수 추가 comman…","fields":{"slug":"/IntelliJShortCut/"},"frontmatter":{"date":"Aug 22, 2022","title":"IntelliJ 단축키","tags":["IntelliJ"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# 웹 어플리케이션\n\n## 웹 서버\n\n- 정적 리소스 제공 (HTML, CSS, JS, 이미지, 영상)\n\n## 웹 어플리케이션 서버 (WAS)\n\n- 쓰레드 풀 - 필요한 쓰레드 보관, 관리 (Tomcat 최대 200개 기본 설정)\n- 멀티 쓰레드 지원\n- 멀티 쓰레드 환경이기 때문에 싱클톤 객체(Servlet, Bean) 주의해서 사용\n\n## 서블릿\n\n> HTTP 요청 메시지를 편리하게 사용 할 수 있도록 **HTTP 요청 메세지 파싱**\n\n- 서블릿 객체는 싱글톤으로 관리\n- 공유 변수 사용 주의\n- 동시 요청을 위한 멀티 쓰레드 처리 지원\n\n## 멀티 쓰레드\n\n- 쓰레드 풀에서 쓰레드를 꺼내서 사용 후 반납\n- 미리 생성되어 있어 비용 절약, 응답시간 빠름\n- 생성 가능한 쓰레드의 최대치가 있음, 기존 요청 안전하게 처리 가능\n- 성능 테스트 - 아파치 ab, 제이미터, nGrinder\n\n# Servlet\n\n```java\n// 임시 저장소 기능\nrequest.setAttribute(name, value);\nrequest.getAttribute(name);\n\n// 세션 관리\nrequest.getSession(create: true);\n\n```\n\n## Request\n\n### Get, Post(Form데이터)\n\n조회 메서드\n\n```java\n// HttpServletRequest request\n\nString username = request.getParameter(\"username\");               //단일 파라미터 조회\nEnumeration<String> parameterNames = request.getParameterNames(); //파라미터 이름들 모두 조회\nMap<String, String[]> parameterMap = request.getParameterMap();   //파라미터를 Map 으로 조회\nString[] usernames = request.getParameterValues(\"username\");      //복수 파라미터 조회\n```\n\nPOST HTML Form 형식은 헤더에 content-type application/x-www-form-urlencoded 이 포함\n\n### HTTP body\n\n- InputStream 사용해 Byte 단위로 읽을 수 있음\n- json데이터를 읽기위해 **jackson**사용\n\n```java\nServletInputStream inputStream = request.getInputStream();\nString messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);\n\nJsonData data= objectMapper.readValue(messageBody, JsonData.class);\n```\n\n## Response\n\n> 반환 형태를 지정해 응답할 수 있음\n\n```java\n// Header 설정\nresponse.setHeader(\"content-type\", \"application/json\");\n// Encoding type 설정\nresponse.setCharacterEncoding(\"utf-8\");\n\nJsonData data = new JsonData();\ndata.setUsername(\"kim\");\ndata.setAge(20);\n\nString result = objectMapper.writeValueAsString(data);\nresponse.getWriter().write(result);\n```\n\n# MVC\n\n- DB에서 값을 꺼내올 때 **동시성 문제**로 인해 실무에선 ConcurrentHashMap, AtomicLong 사용을 고려\n\n## FrontController Pattern\n\n> 클라이언트 요청들을 처리하는 서블릿을 두고 요청에 맞는 컨트롤러를 찾아 호출 -> 공통 처리 가능\n\n## DispatcherServlet\n\n![dispatcherServlet](dispatcherServlet.PNG)\n\n### 1. 핸들러\n\n> 웹 요청을 실제로 처리하는 객체\n\n### 2. 어댑터\n\n> 핸들러마다 각각 그 핸들러를 처리하는 객체\n\n### 3. 핸들러 매핑\n\n> 요청 URI과 알맞는 핸들러 객체를 Dispatcher Servlet에 리턴\n\n### 4. 핸들러 어댑터\n\n> 핸들러 객체를 가지고 어댑터를 찾는 과정  \n> 2개 이상의 인터페이스에 스펙이 맞지 않을 때, 중간에 이 스펙을 맞도록 변환해주는 역할을 하는 객체\n\n### 핸들러와 어댑터가 필요한 이유\n\n- 핸들러 어댑터는 다양한 요청에 맞춰 ModelAndView객체로 응답  \n  ex) 리턴 타입 변경, 매개변수 변경\n- 다양한 형태의 핸들러 처리를 위해 ex) Controller Interface, @Controller 처리를 위한 핸들러 어댑터 필요\n- 비즈니스 개발 로직에만 집중하여 편하게 원하는 형태로 컨트롤러를 정의 가능\n\n## RequestMapping\n\n우선순위가 가장 높은 핸들러 매핑, 어댑터  \n -> RequestMappingHandlerMapping, RequestMappingAdaptorMapping\n\n```java\n@Controller     // Spring bean에 등록\n@RequestMapping // 요청 정보 매핑\n```\n\n- @RequestMapping은 클래스 레벨, 메서드 데벨로 나눠서 분리, 조합 가능\n\n```java\n@RequestMapping(\"/map/\"); // 클래스 레벨\n@RequestMapping(\"kr\");    // 메서드 레벨 -> /map/kr\n```\n\n**-> @GetMapping, @PostMapping** 으로 활용 가능!\n\n# Log\n\n사용 방법\n\n```java\nprivate Logger log = LoggerFactory.getLogger(getClass());\n@Slf4j // Lombok 사용 가능\n\nlog.trace(\"{}\", data); // 로그 출력 레벨에 따라 실행 x\n```\n\n# Spring MVC HTTP 요청, 응답 처리\n\n## HTTP 메서드 매핑\n\n```java\n@RestController // HTTP Message Body에 바로 입력\n@Controller     // 반환 값이 'String'이면 뷰이름으로 인식, 뷰를 찾고 렌더링\n@RequestMapping // method 속성으로 HTTP 메서드를 지정하지 않으면 HTTP 메서드와 무관하게 호출\n\n@GetMapping({path})       // 축약 가능\n@GetMapping(value = {path})\n@PostMapping({path})\n@PutMapping({path})\n@DeleteMapping({path})\n@PatchMapping({path})\n```\n\n## PathVariable(경로 변수)\n\n```java\n@GetMapping(\"/mapping/users/{id}/name/{name}\")\npublic String mappingPath(@PathVariable String id, @PathVariable String name) {\n    return \"ok\";\n}\n```\n\n리소스 경로 내 변수 사용 가능\n\n## 조건 매핑\n\n> HTTP 메서드를 매핑해주는 어노테이션에 파라미터 추가해 조건 매핑 가능\n\n```java\n@PostMapping(value = \"/api\", produces = \"text/html\")\n```\n\n| 조건     | 내용              | 형식                                        |\n| -------- | ----------------- | ------------------------------------------- |\n| params   | 파마미터          | params = \"mode=debug\"                       |\n| headers  | 특정 헤더         | headers = \"mode=debug\"                      |\n| produces | Acept 헤더        | produces = MediaType.APPLICATION_JSON_VALUE |\n| consumes | Content-Type 헤더 | consumes = MediaType.TEXT_HTML_VALUE        |\n\n## @RequestParam\n\n> url이 매핑 된 함수의 인자값으로 @RequestParam 추가\n\n```java\n@RequestMapping(\"/users\")\npublic String requestParam(\n  @RequestParam(\"username\") String username,\n  @RequestParam String phone,\n  int age,\n  @requestParam(required = true, defaultValue = \"aaa@aaa.com\") String email\n  // @RequestParam Map<String, Object> paramMap\n){\n  ...\n}\n```\n\n- 파라미터 이름이 변수 이름과 같으면 () 생략 가능\n- String, int 등 단순 타입이면 @RequestParam 생략 가능\n- 생략할 경우 required=false적용\n- Map, MultiValueMap으로 parameter를 한번에 받을 수 있음\n\n## @ModelAttribute\n\n> 요청 파라미터를 받아 객체 생성 (Model 객체에 자동으로 들어간다)\n\n- 생략 가능 (기본 단순 타입 제외한 값이 입력값인 경우 자동 적용)\n- 객체 프로퍼티 찾음 -> setter호출 해 입력값 바인딩\n- BindException 처리 필요\n\n## Text 데이터 처리\n\n```java\n@PostMapping(\"/request\")\npublic HttpEntity<String> requestBody(HttpEntity<String> httpEntity) {\n// public HttpEntity<String> requestBody(@RequestBody String httpbody) {\n  ...\n}\n```\n\n### HttpEntity\n\n- HTTP header, body 정보 조회\n- 요청 파라미터 조회 기능 관계 x (@RequestParam, @ModelAttribute)\n\n### RequestEntity\n\n> HttpMethod, url 정보 추가\n\n### ResponseEntity\n\n> HTTP 상태코드 설정 가능(조건문에 따라 분기처리)\n\n- @RequestBody, @ResponseBody 어노테이션으로도 제공\n- @RequestBody 파라미터에, @ResponseBody는 Mapping 되는 곳 or 클래스에 어노테이션 달아줌\n- @RestController or @ResponsesBody를 클래스 레벨 적용시 해당 컨트롤러의 response에 모두 적용\n- HttpEntity -> 요청 값 받는 Json에는 사용 가능 (Form 사용 불가능)\n\n**Form, HTTP Message Body 데이터를 읽을 때**\n\n- 요청 파라미터 조회 : @RequestParam, @ModelAttribute\n- HTTP 메시지 바디 조회 : @RequestBody\n\n## Json 데이터 처리\n\n처리 방법\n\n1. Json 데이터는 **Jackson 라이브러리 objectMapper**로 객체를 변환해 사용\n2. HttpEntity, @RequestBody 사용\n\n```java\n@PostMapping(\"/request\")\n// public HelloData requestBodyJson(HttpEntity<HelloData> httpEntity) {\npublic HelloData requestBodyJson(@RequestBody HelloData data) {\n  ...\n}\n```\n\n**@RequestBody생략 불가** -> @ModelAttribute이 적용 됨  \nHttp Body가 아닌 요청 파라미터 처리(Form처리)\n\n## Response응답\n\n> 응답시에는 ResponseEntity(HttpEntity), @ResponseBody 사용\n\n```java\n@GetMapping(\"/ResponseEntity\")\npublic ResponseEntity<String> ResponseEntityApi() {\n    return new ResponseEntity<>(\"ok\", HttpStatus.OK);\n}\n\n@ResponseStatus(HttpStatus.OK)\n@ResponseBody\n@GetMapping(\"/ModelAttribute\")\npublic Data ModelAttributeApi() {\n  ...\n}\n```\n\n**조건문에 따라 상태값을 다르게 리턴하려면 ResponseEntity사용**\n\n## Http Message Converter\n\n> 메세지 컨버터가 **클래스 타입, 미디어 타입**을 읽고 처리 방법 선택\n\n요청 : @RequestBody, HttpEntity(RequestEntity)\n응답 : @ResponseBody, HttpEntity(ResponseEntity)\n\n## Mapping Handler Adaptor\n\n![ArgumentResolver](ArgumentResolver.PNG)\n\n- RequestMapping하는 어노테이션에 구현되어 있음\n- Argument Resolver는 요청 시 보낸 데이터 처리\n\n- @RequestBody, HttpEntity에 한에서 HTTP 메세지 컨버터로 Body데이터 처리\n\n## Redirect\n\n> RedirectAttributes 객체 사용 (매개변수로 받는다)\n\n```java\n@PostMapping(\"/api\")\npublic String addItem(Item item, RedirectAttributes redirectAttributes) {\n    Item savedItem = itemRepository.save(item);\n\n    redirectAttributes.addAttribute(\"itemId\", savedItem.getId());\n    redirectAttributes.addAttribute(\"status\", true);\n\n    // pathVarible해주고 나머진 쿼리 파라미터 처리\n    return \"redirect:/basic/items/{itemId}\";\n}\n```\n\n기능 : URL 인코딩, pathVarible, 쿼리 파라미터 처리\n\n## Thymeleaf\n\n> 순수 HTML을 그대로 유지하면서 뷰 템플릿 사용 가능 (네츄럴 템플릿)\n\n[Thymeleaf 튜토리얼](https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html)\n\n사용 선언\n\n```html\n<html xmlns:th=\"http://www.thymeleaf.org\"></html>\n```\n\n@{/...} 형식을 사용하면 Thymeleaf가 context path 추가\nex) WAS안에 여러 애플리케이션 배포 시\n\n```java\n@{/basic/items}\n```\n\n# Tip!\n\n요청 데이터 종류 : 1) Get쿼리 파라미터, 2) Post - HTML Form, 3) HTTP message body\n\n응답 데이터 종류 : 1) 정적 리소스, 2) 뷰 템플릿, HTTP Message Body\n\napplication.properties - logging.level.org.apache.coyote.http11=debug  \n -> http 요청 메세지 확인 가능 (부하가 있어 개발 할 때만)\n\nredirect vs forward  \n-> 리다이렉트는 실제 클라이언트(웹 브라우저)에 응답이 나갔다가, 클라이언트가 redirect 경로로 다시 요청  \n(클라이언트가 인지할 수 있고, URL 경로도 실제로 변경)  \n -> 포워드는 서버 내부에서 일어나는 호출이기 때문에 클라이언트가 전혀 인지x\n\nMultiValueMap\n\n> 하나의 키에 여러 값을 받을 수 있다. (HTTP header, 쿼리 파라미터 같이 하나의 키에 여러 값을 받을 때 사용)\n\n```java\nMultiValueMap<String, String> map = new LinkedMultiValueMap();\nmap.add(\"key\", \"value1\");\nmap.add(\"key\", \"value2\");\n\n//[value1,value2]\nList<String> values = map.get(\"key\");\n```\n\n- 코드 짜면서 중복 vs 명확성 중 고민이면 명확성을 따르는게 좋다\n\n# Reference\n\n- [인프런]김영한 스프링 MVC 1 강의\n","excerpt":"웹 어플리케이션 웹 서버 정적 리소스 제공 (HTML, CSS, JS, 이미지, 영상) 웹 어플리케이션 서버 (WAS) 쓰레드 풀 - 필요한 쓰레드 보관, 관리 (Tomcat 최대 200개 기본 설정) 멀티 쓰레드 지원 멀티 쓰레드 환경이기 때문에 …","fields":{"slug":"/SpringStudy_3/"},"frontmatter":{"date":"Aug 18, 2022","title":"스프링 MVC 1 강의 정리 - 김영한","tags":["Spring"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n이번 포스팅에서는 리액트의 핵심원리에 대해 정리!!\n\n---\n\n리액트는 **사용자 인터페이스를 구축하는 자바스크립트 라이브러리**\n\n# 왜 리액트를 사용하는가\n\nJavascript는 브라우저 내 DOM조작, 이를 통해 화면을 랜더링한다.\n\n리액트는 컴포넌트 기반의 UI 라이브러리로 자바스크립트를 유용하게 이용할 수 있게 도와준다.\n\n리액트는 응용프로그램을 작은 컴포넌트로 분리, 조합해서 사용(선언형 방식)  \n-> 유지보수와 관리 향상\n**복잡한 사용자 인터페이스를 구축하기에 용이하다**\n\n## Routing\n\n> 서드 파티 라이브러리 설치 (React-router)\n\n# Components & Building UIs\n\n> 코드를 Component단위로 분리해 관리하면 **재사용성**, **가독성** 향상\n\n## react vs reactDOM\n\n- react : UI라이브러리\n- reactDOM : 웹사이트에 출력을 도와주는 모델\n\n- React 주요 특징 중 하나는 Virtual DOM을 사용\n\n- DOM(Document Object Model) 이란?\n  > 객체로 문서 구조를 표현하는 방법으로 XML이나 HTML로 작성한다. 웹 브라우저는 DOM을 활용하여 자바스크립트와 css적용\n\n**=> ReactDOM은 브라우저에 대한 리액트 어댑터**\n\n### 페이지가 리로드 되는 과정\n\n1.  데이터를 업데이트하면 전체 UI를 Virtual DOM에 리랜더링 한다.\n2.  이전 Virtual DOM에 있던 내용과 비교\n3.  바뀐 부분만 실제 DOM에 적용\n\n### 주요 특징\n\n- 리액트는 단방향 데이터 플로우를 가지고 있다.\n- 데이터는 항상 일정한 장소에 위치하고, 그 장소에서만 변경 가능!\n- 선언적 접근 방법(state정의 -> 상태 처리)\n- reactDOM은 컴포넌트를 출력(Render)하고, Component는 항상 render, return 해야 함\n- react app은 하나의 component만 rendering (App Component)\n\npublic/index.html <- 여기에 src/index.js 가 붙여주는 방식  \n => Single Page Application\n\n**Tip!**\n\n- import시 js파일은 확장자 생략 가능, css파일은 생략 불가능\n\n### JSX(JavaScript XML)\n\n- return으로 반환되는 Component / JSX는 반드시 root요소를 가진다.\n- css 이름을 적용할 때 - classname으로 이름 지정\n\n### React Naming\n\n- 소문자로 시작하는 요소는 내장된 html요소 -> **Component는 대문자로 시작**\n\n## Components\n\n- 자바스크립트 표현식 작성 시 JSX내부에서 {}로 감싸면 된다.\n- 부모 컴포넌트로 부터 자식 컴포넌트로 값을 전달시 props로 사용\n- 여러개의 컴포넌트를 하나의 컴포넌트로 조합해 사용 -> **합성(Composition)**\n- **Wrapper Component** - 여러 컴포넌트를 감싸는 방식\n- **props.children** 자식 엘리먼트를 출력에 전달 가능\n\n# Working with Events, state & props\n\n- 리액트는 모든 기본 이벤트를 **on으로 시작하는 props**로 나타낸다\n- 모든 이벤트 핸들러는 props값으로 **함수 필요**\n- 이벤트는 모두 DOM 기본 동작에 기반\n- [react 이벤트 종류](https://ko.reactjs.org/docs/events.html)\n\n### onChange vs onInput\n\n> onChange은 모든 입력 입력타입에 같은 이벤트 사용 가능\n\n## State\n\n> 리액트는 원하는 state 설정 => state에 맞게 화면 rendering\n\n- State는 컴포넌트 객체 별로 나뉘어져서 따로 관리된다.\n\n### useState\n\n```javascript\n// useState에서 반환되는 값 1) 상태명, 2) 1에서 정한 상태를 변경하는 함수\nconst [name, setName] = useState(props.name);\n```\n\n### State Update\n\n> 이전 상태에 따라 상태를 업데이트 할 때 아래 처럼 callback 함수로 구현\n\n```javascript\nconst titleChangeHandler = (event) => {\n  setUserInput((prevState) => {\n    return { ...prevState, title: event.target.value };\n  });\n};\n```\n\n## Lifting State Up\n\n> props로 함수를 넘겨 전달 (자식 -> 부모 컴포넌트로 값 전달)\n\n## stateless component\n\n> 데이터 출력만을 위한 컴포넌트(해당 컴포넌트에서 관리하는 state 없음)\n\n# Working with Dynamic Contents\n\nreact 컴포넌트 별로 key값을 지정할 수 있음  \n-> 이렇게 지정하면 업데이트 할 때 특정 위치에 정확히 삽입 가능  \n-> key가 없으면 값을 추가하는 위치를 정확히 인지하지 못해서 rerendering이 일어남 -> 성능상 이슈  \n-> 목록 리스트가 존재하면 key값을 주는게 좋다\n\n## Rendering List\n\n> array 객체의 map함수 이용 동적으로 contents 추가\n\n```javascript\nconst itemfilter = props.items.filter((item) => {\n  return item.date.getFullYear().toString() === selectedDate;\n});\n\n...\n\nreturn (\n  <div>\n    {\n      itemfilter.map((item) => <ExpenseItem key={item.id} title={item.title} amount={item.amount} date={item.date} />);\n    }\n  </div>\n)\n```\n\nfilter함수를 추가해 조건에 따라 contents 반환 할 수 있다.\n\n## Conditional Content\n\n> {} 안에 3항 연산자를 사용해 조견별 component 출력이 가능하다\n\n# Styling Components\n\nComponent에 스타일을 적용하는 방법은 4가지\n\n## 1) 인라인 요소로 css 추가\n\nhtml태그의 style속성을 동적으로 줘서 css변경 가능\n\n```javascript\nlet barFillHeight = '20%';\n\n<div className=\"bar\" style={{ height: barFillHeight, backgroundColor: 'red' }}></div>;\n```\n\n위 방식대로 style을 주면 **인라인 방식**이라 코드 가독성이 떨어짐\n\n## 2) .css파일로 분리\n\n**className을 동적으로 변경**해서 css 적용 가능  \n-> 같은 class name을 사용하는 경우 문제\n\n## 3) Styled Components\n\n> 서드 파티 라이브러리, 고유한 범위를 가진 스타일로 미리 스타일이 지정된 컴포넌트로 지정 가능\n\n```javascript\nconst FormControl = styled.div`\n  margin: 0.5rem 0;\n  & label {\n    font-weight: bold;\n    display: block;\n    margin-bottom: 0.5rem;\n    color: ${(props) => (props.invalid ? 'red' : 'black')};\n  }s\n`;\n```\n\n- styled를 import해 객체를 만들어 사능\n- HTML의 모든 태그가 정의되어 있음\n- props를 전달해 동적으로 변환 가능\n- 미디어 쿼리 적용 가능\n\n## 4) CSS Module\n\nreact css module 사용\n\n```javascript\nimport styles from \"./Button.module.css\";\n\n...\n\nconst Button = (props) => {\n  return (\n    <button type={props.type} className={styles.button} onClick={props.onClick}>\n      {props.children}\n    </button>\n  );\n};\n\n```\n\n- **컴포넌트 이름*클래스 이름*해시 값**으로 동적으로 클래스명이 생긴다.\n\n[babel-plugin-react-css-modules](https://github.com/gajus/babel-plugin-react-css-modules)\n\n# Fragments, Portals & Refs\n\n## Fragments\n\n> 리액트는 HTML태그를 트리 구조로 생성하기 때문에 루트 태그가 반드시 필요\n\n빈 div태그로 감싸는 방법 -> 많은 태그들이 생기면서 성능상에도 좋지 않을 수 있음  \n **=> <React.Fragment>** 사용\n\n- 1. Wrapper 태그 생성\n\n```javascript\nconst Wrapper = (props) => {\n  return props.chilren;\n};\n```\n\n- 2. React.Fragment 사용 - 빈 Wrapper 렌더링\n\n```javascript\n<React.Fragment>\n\n</React.Fragment>\n\n<>\n\n</>\n```\n\n## Portals & Refs\n\n### Portals\n\n> 메인 DOM 외부에 앨리먼트 일부를 그리기 위한 기능\n> (앨리먼트를 다른 돔으로 옮겨 CSS 상속 구조에 영향 받지 않음)\n\nex) 모달, 사이드 드로워\n\n```javascript\nimport ReactDOM from \"react-dom\";\n\n...\nreturn\n<React.Fargment>\n  // createPortal 함수 사용\n  // 1. 렌더링 되는 리액트 노드 (JSX 주의)\n  // 2. 렌더링 되어야 하는 실제 DOM 컨테이너 (실제 HTML DOM요소 - Browser API 사용)\n  ReactDOM.createPortal(<Backdrop />, document.getElementById('backdrop-root'))\n</React.Fargment>\n```\n\n### Refs\n\n> 다른 DOM요소에 접근해 사용 가능\n\ninput같은 경우 키 입력마다 state를 변경하는 것은 비 효율적  \n**-> useRef사용**\n\n```javascript\nconst inputData = useRef();\n```\n\n- 모든 훅과 마찬가지로 함수형 컴포넌트에만 사용 가능\n- 사용하고 싶은 태그로 가서 ref 속성 추가\n- 어떤 HTML요소라도 하나에 연결 가능\n- 반환값으로 **객체 전달** -> {변수}.current.value 값 사용\n- **입력된 값을 초기화** 하고 싶은 경우 유용\n\n#### Refs값을 재설정 하는 방법\n\n1. Ref 변수를 직접 변경\n\n2. stateHandler함수로 state 변경\n\n> 단순히 값을 변경하는 것으로 **Ref 변수를 직접 변경하는 것을 추천**\n\n#### 제어 컴포넌트 vs 비제어 컴포넌트\n\n> React에 의해 값이 제어되는 입력 폼 엘리먼트 “제어 컴포넌트 (controlled component)“ ex) input, textarea, select\n\n```javascript\n// 제어 가능한 컴포넌트 -> 항상 최신값으로 유지\n<input type=\"text\" value={title || ''} onChange={titleChangeHandler} />\n// 비 제어 컴포넌트 -> 필드에서 값을 트리거해 값 사용\n<input id=\"age\" type=\"number\" ref={ageInputRef} />\n```\n\n제어 가능한 컴포넌트 -> 항상 최신값으로 유지  \n비 제어 컴포넌트 -> 필드에서 값을 트리거해 값 사용\n\n| 기능                         | 제어 컴포넌트 | 비제어 컴포넌트 |\n| ---------------------------- | ------------- | --------------- |\n| 일회성 정보 제출             | O             | O               |\n| 제출 시 값 검증              | O             | O               |\n| 실시간 필드 값 검사          | O             | X               |\n| 조건부로 제출 버튼 비 활성화 | O             | X               |\n| 실시간 입력 형식 적용        | O             | X               |\n| 동적 입력                    | O             | X               |\n\n# Tip!!\n\n## npm error 날 경우\n\n```bash\n$ npm cache clean --force\n$ rm -rf node_modules package-lock.json\n$ npm install\n```\n\n## 객체에 Number 저장\n\n간혹가다 숫자로 객체를 생성하려다가 문자열로 생성되는 경우가 있는데  \n+를 붙여줘 형변환이 일어나게 저장하면 문제 해결 가능\n\n```javascript\nconst data = {\n  name : name,\n  age : +age\n  date : date\n}\n```\n\n## 함수에 언더스코어(\\_)를 붙여서 만듬\n\n-> 이유는, 리액트는 자체 기능이 많기 때문에 리액트 자체기능과 구분하기 위해서\n\n# Reference\n\n- [Udemy - React 완벽 가이드 with Redux, Next.js, TypeScript](https://www.udemy.com/course/best-react/learn/lecture/28517643#overview)\n- [React: 제어 컴포넌트와 비제어 컴포넌트의 차이점](https://velog.io/@yukyung/React-제어-컴포넌트와-비제어-컴포넌트의-차이점-톺아보기)\n- [Controlled and uncontrolled form inputs in React don't have to be complicated](https://goshacmd.com/controlled-vs-uncontrolled-inputs-react/)\n- [https://dev.to/dylanju/useref-3j37](https://dev.to/dylanju/useref-3j37)\n","excerpt":"이번 포스팅에서는 리액트의 핵심원리에 대해 정리!! 리액트는 사용자 인터페이스를 구축하는 자바스크립트 라이브러리 왜 리액트를 사용하는가 Javascript는 브라우저 내 DOM조작, 이를 통해 화면을 랜더링한다. 리액트는 컴포넌트 기반의 UI 라이브…","fields":{"slug":"/reactStudy_1/"},"frontmatter":{"date":"Aug 15, 2022","title":"React 핵심 기능","tags":["React"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n- 열린 포트 PID 찾을 때\n\n```bash\nsudo lsof -PiTCP -sTCP:LISTEN\n```\n\n- 프로세스 죽일 때\n\n```bash\nsudo kill -9 {port}\n```\n\n- mac 8080 사용중인 프로세스 죽이기\n\n```bash\nkill $(lsof -t -i:8080)\n```\n","excerpt":"열린 포트 PID 찾을 때 프로세스 죽일 때 mac 8080 사용중인 프로세스 죽이기","fields":{"slug":"/linuxCommand/"},"frontmatter":{"date":"Aug 14, 2022","title":"많이 사용하는 리눅스 명령어","tags":["JPA"],"update":"Nov 20, 2022"}}},{"node":{"rawMarkdownBody":"\n# JAR vs WAR\n\n> JAVA jar툴을 이용해 생성된 압축 파일이며 **어플리케이션을 배포하고 동작시킬 수 있도록 관련된 파일(리소스, 설정파일)을 패키징**\n\n## JAR(Java Archive)\n\n- JAVA 어플리케이션이 동작할 수 있도록 자바 프로젝트를 압축한 파일\n- Class (JAVA리소스, 속성 파일), 라이브러리 파일을 포함(ZIP 파일 포맷으로 압축)\n- **JRE(JAVA Runtime Environment)만 있어도 실행 가능**\n- (BOOT-INF, META-INF, org) // 원하는 구조로 JAR 파일 구성 가능\n- 내장 서버 사용에 최적화\n- 명령줄에서 JAR실행 가능\n\n## WAR(Web Application Archive) .\n\n- 웹 관련 자원을 포함함 (JSP, Servlet, JAR, Class, XML, HTML, Javascript)\n- 실행시켜주기 위해서 웹서버(WEB) 또는 웹컨테이너(WAS)가 필요\n- **외부 WAS사용하는 경우 사용**\n- **JAR파일의 일종**으로 웹 애플리케이션 전체를 패키징 하기 위한 JAR 파일\n- 외장 서버 사용에 최적화\n- (WEB-INF, META-INF, org)\n\n**Sprinag boot 표준 JAR**\n\n# Reference\n\n- [java-jar-war-packaging - BAELDUNG](https://www.baeldung.com/java-jar-war-packaging)\n- [Springboot docs](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#appendix.executable-jar)\n","excerpt":"JAR vs WAR JAVA jar툴을 이용해 생성된 압축 파일이며 어플리케이션을 배포하고 동작시킬 수 있도록 관련된 파일(리소스, 설정파일)을 패키징 JAR(Java Archive) JAVA 어플리케이션이 동작할 수 있도록 자바 프로젝트를 압축한 …","fields":{"slug":"/JARWAR/"},"frontmatter":{"date":"Jul 13, 2022","title":"JAR vs WAR","tags":["Spring"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# Spring\n\n> 스프링의 가장 큰 핵심은 **좋은 객체지향 어플리케이션 개발**에 도움\n\n## 1. 객체 지향 설계\n\n### 역할(인터페이스)과 책임(구현체) 분리\n\n- 구현체를 **실행 시점에 유연하게 변경가능**  \n  => 클라이언트 변경 없이 서버 구현기능 변경\n- 의존관계 주입(DI), 제어의 역전(IoC)\n\n### 좋은 객체지향 설계의 5가지 원칙\n\n#### SRP: 단일 책임 원칙(single responsibility principle)\n\n- 한 클래스는 하나의 책임\n- **변경 / 변경이 있을 때 파급효과가 적어야 함**\n\n#### OCP: 개방-폐쇄 원칙 (Open/closed principle)\n\n- 역할과 책임 분리\n- 인터페이스를 구현한 클래스(구현체)로 기능 구현\n- 객체 생성, 연관관계 생성, 설정자가 필요\n\n#### LSP: 리스코프 치환 원칙 (Liskov substitution principle)\n\n- 컴파일에 성공하는 것을 넘어서 기능까지 만족해야 한다.\n\n#### ISP: 인터페이스 분리 원칙 (Interface segregation principle)\n\n- 특정 클라이언트를 위한 여러개의 인터페이스가 범용 인터페이스 보다 낫다\n\n#### DIP: 의존관계 역전 원칙 (Dependency inversion principle)\n\n- 추상화에 의존해야하고 구체화에는 의존하면 안된다\n- (Interface 에만 의존해야 한다.)\n\n## 관심사 분리\n\n구현 객체에서 직접 추상화된 객체 의존을 선택하게 되면 DIP에 위반된다.  \n -> **구현 객체와 추상화된 객체를 연결하는 설정 클래스**로 관리한다. -> AppConfig  \n => 이렇게 하면 **구성 영역**과 **사용 영역**으로 분리하는 효과를 가진다.\n\n## 2. IoC, DI, Container\n\n### 제어의 역전 (IoC)\n\n> 프로그램이 **객체의 생성**관리\n\n### DI\n\n> 실행 시점(런타임)에 외부에서 구현 객체를 생성해 의존관계 설정  \n>  -> **동적으로 객체 의존관계 변경 가능**\n\n### 프레임워크 vs 라이브러리\n\n- 프레임워크 : 프로그램이 코드 제어 및 실행\n- 라이브러리 : 내가 작성한 코드가 제어의 흐름 담당\n\n### DI Container\n\n> 객체 생성, 관리, 의존관계 연결\n\n## 3. Container, Bean\n\n### **ApplicationContext** 스프링 컨테이너(Interface)\n\n```java\nAnnotationConfigApplicationContext ac =\n  new AnnotationConfigApplicationContext(AppConfig.class) // 매개변수로 구성 정보 지정\n```\n\n- XMl / Annotation 기반으로 스프링 컨테이너 생성 가능\n- 스프링 컨테이너를 생성할 땐 **구성 정보**를 지정해줘야 한다\n- Bean은 key-value형태로 저장이되고, **항상 다른 이름을 사용**해야 한다.\n- MessageSource(국제화), EnviromentCapable(로컬, 개발, 운영 구분)\n- ApplicationEventPublisher(이벤트 발행, 구독 모델 지원)\n- ResourceLoader(파일, 클래스패스 리소스 조회)\n\n### **bean 조회**\n\n> 빈을 조회할 때 부모타입으로 조회하면, **자식 타입도 함께 조회**\n\n```Java\nString[] beanDefinitionNames = ac.getBeanDefinitionNames(); // 모든 빈 조회\n\nfor (String beanDefinitionName : beanDefinitionNames) {\n  BeanDefinition beanDefinition = ac.getBeanDefinition(beanDefinitionName);\n  // ROLE_APPLICATION : 사용자 정의 빈\n  // ROLE_INFRASTRUCTURE : 스프링 내부 빈\n  if (beanDefinition.getRole() == BeanDefinition.ROLE_APPLICATION) {\n    Object bean = ac.getBean(beanDefinitionName);  // 빈 이름으로 빈 객체 조회\n    // ac.getBean(빈이름, 타입)                    // 빈 이름과 타입으로 빈 객체(인스턴스)를 조회\n    System.out.println(\"name=\" + beanDefinitionName +\n    \" object=\" + bean);\n  }\n}\n```\n\n**BeanFactory**\n\n- 스프링 컨테이너 최상위 인터페이스\n- 빈 관리, 조회하는 역할\n- getBean제공\n\n## 스프링 빈 설정 메타 정보 - BeanDefinition\n\n> 역할 / 구현 개념 분리 => **스프링 컨테이너는 이 메타 정보를 기반으로 빈 생성**\n\n<details>\n<summary><b>BeanDefinition 정보 (Toggle)</b></summary>\n<div markdown=\"1\">       \nBeanClassName: 생성할 빈의 클래스 명(자바 설정 처럼 팩토리 역할의 빈을 사용하면 없음)</br>\nfactoryBeanName: 팩토리 역할의 빈을 사용할 경우 이름, 예) appConfig </br> \nfactoryMethodName: 빈을 생성할 팩토리 메서드 지정, 예) memberService  </br>\nScope: 싱글톤(기본값)  </br>\nlazyInit: 스프링 컨테이너를 생성할 때 빈을 생성하는 것이 아니라, 실제 빈을 사용할 때 까지 최대한 생성을 지연처리 하는지 여부  </br>\nInitMethodName: 빈을 생성하고, 의존관계를 적용한 뒤에 호출되는 초기화 메서드 명  </br>\nDestroyMethodName: 빈의 생명주기가 끝나서 제거하기 직전에 호출되는 메서드 명 Constructor arguments, Properties: 의존관계 주입에서 사용한다.  </br>\n - (자바 설정 처럼 팩토리 역할의 빈을 사용하면 없음)  </br>\n</div>\n</details>\n\n스프링이 **다양한 형태의 설정 정보를 추상화해서 사용**\n\n## 4. Singleton Container\n\n> 클래스 객체가 1개만 생기는 디자인 패턴\n\n-> **private 생성자를 사용해 임의로 new키워드 사용 방지**\n\n대부분 싱클톤패턴을 사용한다.  \n(HTTP Request LifeCycle, HTTP Session LifeCycle에 Bean LifeCycle 맞추는 경우같이 아주 특별한 경우에만 싱글톤을 사용하지 않음)\n\n싱글톤 객체를 **생성, 관리**하는 기능을 **싱글톤 레지스트리**라 한다\n\n### Singleton 방식 주의점!!\n\n> 여러 클라이언트가 같은 객체를 공유하기 때문에 **상태를 유지하게** 설계하면 안된다.\n\n- 특정 클라이언트에 **의존적인 필드**가 있으면 안된다.\n- 값을 **변경할 수 있는 필드**가 있으면 안된다.\n- 가급적 **읽기만 가능하게**\n- 필드 대신에 자바에서 **공유할 수 없는 지역변수, 파라미터, ThreadLocal** 등을 사용\n- 스프링 빈 항상 **무상태(stateless)**로 설계\n\n### Configuration 어노테이션\n\n> Configuration 어노테이션은 빈의 **싱글톤을 보장**해준다.\n> (Bean만 사용해도 등록은 되지만, 싱글톤x)\n\n## 5. Component Scan\n\n> 설정 정보가 없어도 자동으로 Bean 등록 -> **Autowired** 어노테이션으로 의존성 주입\n\nComponent Scan은 @Component가 붙은 모든 클래스를 빈으로 등록\n\n- 기본 전략 : 기본이름은 클래스 명을 사용하되 **맨 앞글자만 소문자로 사용**  \n  ex) UserImpl 클래스 -> userImpl\n- 직접 지정 : 지정하고 싶은 이름을 @Component 매개변수에 등록\n\n### ComponentScan 옵션\n\n- basePackages : 패키지로 시작위치 지정\n- basePackageClasses : 클래스 위치로 지정\n- includeFilters : 추가 지정\n- excludeFilters : 제외할 대상 지정\n\n### 부가기능이 있는 어노테이션\n\n@Controller : 스프링 MVC 컨트롤러  \n@Repository : 데이터 접근 계층 인식 - 데이터 계층 예외 -> 스프링 예외로 변환  \n@Configuration : 스프링 설정 정보 인식 / 싱글톤 유지  \n@Service : 특별한 처리 x - 개발자들이 비즈니스 로직 구분하기 위한 용도\n\n<details>\n<summary><b>FilterType 정보 (Toggle)</b></summary>\n\nANNOTATION: 기본값, 애노테이션 인식 ex) org.example.SomeAnnotation</br>\nASSIGNABLE*TYPE: 지정한 타입과 자식 타입 인식 ex) org.example.SomeClass</br>\nASPECTJ: AspectJ 패턴 사용 </br>\nex) org.example..\\_Service+ </br>\nREGEX: 정규 표현식 </br>\nex) org\\.example\\.Default.* </br>\nCUSTOM: TypeFilter 이라는 인터페이스를 구현해서 처리 ex) org.example.MyTypeFilter </br>\n\n```java\n  includeFilters = @Filter(type = FilterType.ANNOTATION, classes = MyIncludeComponent.class)\n```\n\n</details>\n\n## 6. 의존 관계\n\n### 의존관계 주입\n\n#### 1. 생성자 주입\n\n> 생성자 호출 시점에 한번 호출, **불변, 필수**\n\n#### 2. 수정자 주입 (setter)\n\n> **선택, 변경** 가능성이 있는 의존관계에서 사용\n\n#### 3. 필드 주입\n\n#### 4. 일반 메서드 주입\n\n### 옵션 처리\n\n> Bean이 없어도 동작해야 할 때\n\n@Autowired(required=false) : 자동 주입할 대상이 없으면 수정자 메서드 호출 안됨  \n@Nullable : null  \nOptional<> : Optional.empty\n\n### 생성자 주입의 장점\n\n- 대부분 의존관계는 애플리케이션 종료시까지 변경이 없음.\n- 객체를 불변하게 설정해, 개발자가 실수로 객체를 변경할 경우 방지\n\n**Tip!!**\n\n- 생성자가 하나만 있으면 @Autowired 생략 가능\n- Lombok 라이브러리 @RequiredArgsConstructor 사용 -> final붙은 필드 모아서 생성자 자동 생성\n\n```java\n@Controller\n@RequestMapping(\"/items\")\n@RequiredArgsConstructor\npublic class BasicItemController {\n\n  private final ItemRepository itemRepository;\n\n  // 생략 가능\n  // @Autowired\n  // public BasicItemController(ItemRepository itemRepository) {\n  //     this.itemRepository = itemRepository;\n  // }\n}\n```\n\n### 조회 대상 빈이 2개 이상일 경우 해결 방법\n\n#### 1) @Autowired 필드 명 매칭\n\n> Autowired 타입 매칭 시도 -> 여러빈 있을 경우 -> 필드이름 -> 파라미터 이름 순으로 추가 매칭\n\n#### 2) @Quilifier -> @Quilifier끼리 매칭 -> 빈 이름 매칭\n\n```java\n@Component\n@Qualifier(\"{부르고 싶은 구분자}\")\npublic class RateDiscountPolicy implements DiscountPolicy {\n  ...\n}\n```\n\n```java\n@Autowired\npublic OrderServiceImpl(MemberRepository memberRepository,\n  @Qualifier(\"{부르고 싶은 구분자}\") DiscountPolicy discountPolicy) {\n  this.memberRepository = memberRepository;\n  this.discountPolicy = discountPolicy;\n}\n```\n\n1. @Qualifier 매칭\n2. 빈 이름 매칭\n3. NoSuchBeanDefinitionException 예외 발생\n\n#### 3) @Primary\n\nex) 메인 DB Connection / 서브 DB Connection -> 이런 경우 코드 가독성 향상 가능!\n\n**@Qualifier > @Primary 순으로 적용된다.**\n\n#### Tip!!\n\nQualifier는 문자라 컴파일 시 타입 체크가 안됨 -> **어노테이션**을 사용해 조금 더 깔끔하게 코드 관리 가능!\n\n### 모든 빈을 조회할 경우\n\n> 전략 패턴 매우 쉽게 구현 가능\n\n```java\n@Test\nvoid findAllBean() {\n  ApplicationContext ac = new AnnotationConfigApplicationContext(AutoAppConfig.class, DiscountService.class);\n  DiscountService discountService = ac.getBean(DiscountService.class);\n\n  Member member = new Member(1L, \"userA\", Grade.VIP);\n\n  int discountPrice = discountService.discount(member, 10000, \"fixDiscountPolicy\");\n\n  assertThat(discountService).isInstanceOf(DiscountService.class);\n  assertThat(discountPrice).isEqualTo(1000);\n}\n\nstatic class DiscountService {\n  private final Map<String, DiscountPolicy> policyMap;\n\n  public DiscountService(Map<String, DiscountPolicy> policyMap){\n      this.policyMap = policyMap;\n  }\n\n  public int discount(Member member, int price, String discountCode) {\n      DiscountPolicy discountPolicy = policyMap.get(discountCode);\n      return discountPolicy.discount(member, price);\n  }\n}\n```\n\n### 자동 주입 빈 vs 수동 주입 빈\n\n업무 로직 빈 : 비즈니스 요구 사항  \n기술 지원 빈 : 공통 관심사(AOP), DB연결, 로그 처리\n\n기술 지원 빈은 **수가 적고, 어플리케이션에 광범위하게 영향**을 준다.  \n-> **수동 빈으로 명확하게 들어내는 것이 좋다.**  \n(스프링 부트가 자동으로 등록하는 빈 제외)\n\n스프링 다형성을 활용할 때 (전략 패턴)  \n -> 한번에 설정 정보를 보기 위해 수동 빈이 보기 좋을때 있다.\n\n## 7. Bean LifeCycle Callback\n\n> 어플리케이션을 시작 시점, 종료시점에 **초기화 및 종료** 작업이 필요한 경우  \n>  ex) DB Connection pool, Network Socket\n\n빈은 간단히 보면\n객체 생성 -> 의존관계 주입\n을 가진다.\n\n**스프링 빈 이벤트 라이프 사이클**  \n스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입 -> **초기화 콜백** -> 사용 -> **소멸전 콜백** -> 스프링 종료\n\n간단한 경우 생성자에서 초기화해주는게 좋지만, 유지보수 관점에서 보면 **생성과 초기화는 분리하는게 좋다.**\n\n크게 3가지 방법으로 빈 생명주기 콜백 지원\n\n1. 인터페이스(InitializingBean, DisposableBean)\n2. 설정 정보에 초기화 메서드, 종료 메서드 지정\n3. @PostConstruct, @PreDestroy 어노테이션\n\n2,3 번 방법 사용 -> 스프링 빈이 스프링 코드에 의존하지 않는다.\n\n### 설정 정보에 초기화 메서드, 종료 메서드 지정\n\n```java\n@Configuration\nstatic class LifeCycleConfig {\n    @Bean(initMethod = \"init\", destroyMethod = \"close\") // 초기화, 종료 메서드 지정\n    public NetworkClient networkClient() {\n      NetworkClient networkClient = new NetworkClient();\n      networkClient.setUrl(\"http://hello-spring.dev\");\n      return networkClient;\n    }\n}\n```\n\n- 메서드 이름 자유롭게 줄 수 있다.\n- **코드 고칠 수 없는 외부 라이브러리** 초기화, 종료 메서드 적용\n- destroyMethod 에 값을 지정해주지 않으면 close, shutdown같은 이름의 종료 메서드 추론하여 동작\n  => 사용하지 않으려면 destroyMethod=\"\" 같이 빈 공백 지정해서 사용\n\n### @PostConstruct, @PreDestroy\n\n> 초기화 및 종료 하고싶은 메서드에 어노테이션을 단다.\n\n- 외부라이브러리 사용 불가능\n\n일반적인 경우엔 @PostConstruct, @PreDestroy사용 / 외부 라이브러리 경우 @Bean 사용\n\n## 8. Bean scope\n\n> 빈이 존재할 수 있는 범위\n\n- Singleton : 기본 스코프, 스프링 컨테이너 시작 ~ 종료까지 유지되는 스코프 (기본)\n- Prototype : 빈의 생성, 의존관계 주입까지만 관여\n\nPrototype Bean 의존 관계 주입, 초기화까지 처리 -> 빈 관리 책임은 클라이언트에 있다.  \n(@PostConstruct, @PreDestroy같은 종료메서드 호출되지 않는다.) .\n\n### Singleton, Prototype 같이 쓸 경우 문제점\n\n> getBean을 통해 Bean을 주입하면 스프링 컨테이너에 종속적인 코드가 되서 새로운 빈이 생기지 않음\n\nDL(의존관계 조회(탐색)) -> **ObjectProvider** (ObjectFactory 상속) .\n\n- 스트림 처리같은 편의 기능 제공, 별도의 라이브러리 필요x\n\n- 웹관련 스코프\n  - request : 웹 요청 ~ 종료\n  - session : 웹 세션이 생성 ~ 종료\n  - application : 서블릿 컨텍스트와 같은 범위로 유지되는 스코프\n  - websocket : 웹 소켓과 동일한 생명주기를 가지는 스코프\n\n### Tip!!\n\n- Spring-boot-web을 사용하면 AnnotationConfigServletWebServerApplicationContext 기반으로 애플리케이션 구동\n\nrequest scope 가진 빈 -> 실제 고객 요청이 와야 생성\n\n### 해결 방법 1)\n\n> ObjectProvider 사용\\*\\* -> bean생성을 getObject를 실행하는 시점까지 생성 지연\n\n### 해결 방법 2)\n\n> 프록시 사용\n\n```java\n@Scope(value = \"request\", proxyMode = ScopedProxyMode.TARGET_CLASS)\n```\n\nScope에 proxy설정을 하면 컨테이너는 **CGLIB** 라이브러리를 사용해 **프록시 객체 생성**  \n -> 진짜 빈을 요청하는 위임 로직 **(객체 조회를 필요 시점까지 지연 처리가 핵심)**  \n -> 실제 싱글톤 객체와 다르게 동작하기 때문에 주의해서 사용!\n\n# Test Tip!!\n\n- Assertions 객체는 상단에 선언하고 사용하는게 좋다.\n","excerpt":"Spring 스프링의 가장 큰 핵심은 좋은 객체지향 어플리케이션 개발에 도움 1. 객체 지향 설계 역할(인터페이스)과 책임(구현체) 분리 구현체를 실행 시점에 유연하게 변경가능 => 클라이언트 변경 없이 서버 구현기능 변경 의존관계 주입(DI), 제…","fields":{"slug":"/SpringStudy_2/"},"frontmatter":{"date":"Mar 01, 2022","title":"스프링 핵심 원리 강의 정리 - 김영한","tags":["Spring"],"update":"May 01, 2022"}}},{"node":{"rawMarkdownBody":"\n# Spring\n\n**Maven / Gradle** - 프로젝트 의존성 관리 도구\n\nController에서 리턴 값으로 문자를 반환 시 viewResolver 화면을 찾아서 처리한다.\n\n**resources:templates/ +{ViewName}+ .html**  \n해당 경로를 기본적으로 읽는다.\n\n## build\n\n```markdown\n1. .gradlew build\n2. cd build/libs\n3. jar파일 실행\n```\n\n## API\n\n> @RequestBody 어노테이션 사용\n\n- viewResolver 대신 HttpMessageConverter 동작\n- 기본 문자 처리 : StringHttpMessageConverter\n- 기본 객체 처리 : MappingJackson2HttpMessageConverter  \n  ++ 응답을 위한 여러 HttpMessageConverter가 포함되어 있다.\n\n1. HTTP Header\n2. 서버의 반환 정보\n   => HttpMessageConverter가 선택된다.\n\n## 일반적인 웹 어플리케이션 구조\n\n```text\n컨트롤러 -> 서비스 -> 레포지토리 -> db\n            도메인\n```\n\nController : MVC 컨트롤러  \nService : 비즈니스 로직  \nRepository : DB접근, 도메인 객체 저장 및 관리  \nDomain : 비즈니스 도메인 객체\n\n## 테스트 케이스 작성\n\n> Junit\n\n## DI(의존성 주입)\n\n> Service에서 직접 객체를 선언해 사용하지 않고 외부에서 객체를 만들어 전달해 사용\n\n- 컴포넌트 스캔과 자동 의존관계 설정 -> 스프링 부트 어노테이션  \n  ex) Controller, Repository, Service, Autowired\n\n```\n@Autowired를 통한 DI는 helloConroller , memberService 등과 같이\n스프링이 관리하는 객체에서만 동작한다.\n```\n\n- Bean객체는 Singleton으로 관리\n- DI에는 필드 주입, setter 주입(수정자를 통한 주입), 생성자 주입 3가지 방법  \n  (의존관계가 실행중에 동적으로 변하는 경우는 거의 없으므로 생성자 주입을 권장한다.)\n- 정형화 되지 않거나, **상황에 따라 구현 클래스 변경**하는 경우 설정(@Configuration)을 통해 스프링 빈 등록\n\n**생성자 주입**\n\n```Java\n@Controller\npublic class MemberController {\n    private final MemberService memberService;\n\n    @Autowired\n    public MemberController(MemberService memberService) {\n        this.memberService = memberService;\n    }\n}\n```\n\n## 생성자 주입의 장점\n\n- 의존관계 설정이 되지 않으면 객체 생성 불가  \n   -> **컴파일 타임에 인지 가능, NPE(Null Point Exception) 방지**\n- 필드 final 변수로 사용  \n   -> **런타임에 객체 불변성 보장**\n- 테스트 코드작성 용이  \n   -> **스프링에서 순환참조 확인가능**\n\n## H2\n\nh2 설치 하면 처음엔 파일을 읽는데 서버로 읽게 경로를 수정해준다.  \njdbc:h2:tcp://localhost/~/test\n\n## Test\n\n- Test 코드 작성 시, 편의에 따라 필드주입 사용 (의존관계가 별로 중요하지 않을 경우)\n- **@Transaction** : DB Transaction을 시작하고 롤백해줘서 DB에 영향을 주지 않는다.\n- **@SpringBootTest** : Spring Container, Test 함께 실행\n\n# 스프링 DB 접근 기술\n\n## 1. 순수 Jdpc\n\n## 2. JdbcTemplate\n\n- 순수 Jdpc를 Template Method패턴으로 반복코드 제거 (sql은 직접 작성)\n\n## 3. JPA\n\n- 반복 코드 제거 (SQL까지) -> 개발 생산성 향상\n- SQL과 데이터 중심의 설계 -> 객체 중심의 설계로 패러다임을 전환\n\n## 사용\n\n- dependency, application.properties 추가\n\n### application.properties\n\n```markdown\nshow-sql : JPA가 생성하는 SQL을 출력한다.\nddl-auto : 테이블을 자동으로 생성하는 기능 제공\n-> none / create(entity정보를 바탕으로 테이블 생성)\n```\n\n# AOP(Aspect Oriented Programming)\n\n- 특정 로직을 공통적으로 적용해야 하는 경우  \n  ex) 시간 체크\n- 공통 관심 사항 vs 핵심 관심 사항 분리\n\n# Tip!!\n\n## IntelliJ\n\n- Preferences - gradle 에서 Build and run 옵션 Intellij로 변경하면 빨라진다.\n\n## Spring\n\n1. null 반환 대신 Optional로 감싸서 반환해라  \n   -> **클라이언트에서 해당 값 사용**,  \n   -> Optional 함수 사용 가능 // ifPresent\n\n2. 동시성 문제 때문에 long, map 대신 다른 변수 사용한다.\n\n3. Test 전체 실행 시, 순서 보장이 안된다.  \n   -> Test case를 작성 시 **순서에 영향 받지 않아야 한다.**  \n   -> **@AfterEach**, **@BeforeEach** : Test가 끝날 때 마다 실행시켜주는 Call back method\n\n4. Service naming -> 비즈니스 로직에 맞게  \n   Repository naming -> 조금 더 개발자스럽게\n\n5. HashMap 대신 실무에서는 동시성 문제가 고려해 **ConcurrentHashMap, AtomicLong** 사용 고려\n\n## 문제 상황 해결\n\n애플리 케이션을 실행시켜 주면 중간에 이상한 로그들이 보였는데\n![](debug.PNG)\n\nspring-boot-starter로 프로젝트는 dependency들을 해결하기 위해 많은 class를 가지고 있으며,  \n이를 자동으로 해결해 주는 것을 autoconfiguration이라고 한다.\n\nstarter에서 classpath내의 class들을 훑으며 프로젝트에 필요한 클래스 등을 판별하는데,  \n프로젝트에 필요한 클래스라면 matched를, 프로젝트에 필요 없는 클래스라면 did not match  \n알려주는 로그  \n(문제 x)\n","excerpt":"Spring Maven / Gradle - 프로젝트 의존성 관리 도구 Controller에서 리턴 값으로 문자를 반환 시 viewResolver 화면을 찾아서 처리한다. resources:templates/ +{ViewName}+ .html 해당 경…","fields":{"slug":"/SpringStudy_1/"},"frontmatter":{"date":"Feb 02, 2022","title":"스프링 입문 강의 정리 - 김영한","tags":["Spring"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 브라우저 객체란?\n\n---\n\n> 브라우저에 내장된 객체 - 계층형 구조\n\n![](local1.PNG)\n\n가장 상위에는 window 객체가 있으며  \n하위 객체로는 document, screen, location, history, navigator 5개의 객체가 있다.\n\n## Location 객체\n\n---\n\n> 사용자 브라우저와 관련된 속성과 메서드를 제공하는 객체\n\n**주소 표시줄에 있는 부분을 가져올 수 있다.**\n\n기능 개발을 하다보면 URL에 따라 분기 처리를 해야 하는 경우가 있는데  \n이 때 **location객체**를 사용하면 유용하다.\n\n| 프로퍼티 | 설명                               | 예시                                            |\n| -------- | ---------------------------------- | ----------------------------------------------- |\n| hash     | 주소값에 붙어있는 anchor값 반환    | #haha                                           |\n| host     | URL의 도메인과 포트 반환           | www.example.com:8080                            |\n| hostname | URL의 도메인 반환                  | www.example.com                                 |\n| href     | URL 반환                           | http://www.example.com:8080/search?q=devmo#test |\n| orgin    | 프로토콜 + URL의 도메인 + 포트     | http://www.example.com:8080                     |\n| pathname | URL 경로 반환                      | /search                                         |\n| protocol | 프로토콜 반환                      | http                                            |\n| search   | Query String (URL에 붙은 매개변수) | ?t=20210727                                     |\n\n요렇게 주소 표시줄의 정보를 가지고와 화면 분기처리를 할 수 있다!!!\n\n주의할 점으로 프로퍼티에 따라 포함되는 값이 다르니 주의하며 사용해야 한다\n","excerpt":"브라우저 객체란? 브라우저에 내장된 객체 - 계층형 구조  가장 상위에는 window 객체가 있으며 하위 객체로는 document, screen, location, history, navigator 5개의 객체가 있다. Location 객체 사용자 …","fields":{"slug":"/frontTips_1/"},"frontmatter":{"date":"Aug 08, 2021","title":"Location 객체 정리","tags":["Javascript"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# Rsync(Remote sync)\n---\n> 파일과 디렉토리를 로컬 및 원격으로 동기화(복사) 하는데 사용\n\n## 특징\n---\n\n- 네트워크 대역폭을 최소화하는 델타 인코딩 알고리즘을 사용해 변경이 일어난 부분만 전송  \n  -> **빠르고 효율적으로 동기화 가능!**  \n- 설치\n```bash\n$ yum install rsync # CentOS\n$ apt-get install rsync # Ubuntu\n```\n\n- [rsync 홈페이지](https://rsync.samba.org/documentation.html)\n\n## 장점\n---\n\n- Cli툴로 쉘스크립트 프로그램 개발 가능 (cron으로 활용 가능)\n- 데이터를 압축하여 송/수신하기 때문에 빠르고 효율적\n- **link, 파일 소유자, 권한등 파일의 부가 정보를 함께 복사가능**\n- remote 업데이트를 이용하여 차이가 있는 파일만 복사한다. \n\n## 동기화 알고리즘\n---\n\n### 1. 파일 전송결정\n> 파일의 크기와 수정시간을 비교하는 것으로 파일을 전송할지 말지 결정한다.\n\n파일의 크기와 수정시간을 비교하는 것을, 아주 작은 cpu자원을 소모하지만 실수가 발생할 수 있다\n -> **checksum** 옵션 사용\n\n### 2. 전송할 파일 부분 결정\n\n1) 파일을 고정크기를 가지는 청크(Chunk)로 나눈다음에 checksum을 계산한다.\n2) 다를 경우 해당부분 chunk만 복사한다\n\nchunk파일의 체크섬을 비교하는 방식은 파일의 앞부분이 수정되서 정보가 밀리면 모든 청크와 checksum이 밀릴 것이다.\n -> **Rolling hash** 사용!\n\n#### 참고자료\n[위키트리](https://en.wikipedia.org/wiki/Rolling_hash)  \n[Quora답변](https://www.quora.com/What-is-a-rolling-hash-and-when-is-it-useful)  \n\n## 옵션\n---\n\n```\n-v : 진행 상황을 상세하게 보여줌\n-r : 지정한 디렉토리의 하위 디렉토리까지 재귀적으로 실행\n-l : 소프트 링크 보존\n-H : 하드 링크 보존\n-h : -human-readable 읽을 수 있는 형식으로 출력 번호를 출력합니다.\n-p : 버전 속성 보존\n-o : 소유 속성 보존(루트)\n-g : 그룹 속성 보존\n-t : 타임스탬프 보존\n-D : 디바이스 파일 보존(루트)\n-z : 데이터 압축 전송\n-b : 낡은 파일은 ~가 붙음\n-u : 추가된 파일만 전송 새 파일은 갱신하지 않음\n-a : 아카이브 모드. rlptgoD를 자동 지정\n-c : 서버와 클라이언트의 파일 크기를 세밀히 체크\n-e ssh(rsh) : 전송 암호화\n\n--stats : 결과를 보고\n--delete : 서버에 없는 파일은 클라이언트에서도 삭제\n# 데이터 백업시 사용하지 않는 것이 좋다.\n--progress : 전송시 진행상황을 보여줌\n--existing : 추가된 파일은 전송하지 않고 갱신된 파일만 전송\n--exclude=PATTERN : 패턴에 제외할 파일, 디렉토리 유형을 써주면 동기화하지 않는다.\n```\n\n\n## Rsync 사용 예시\n---\n\n### 기본 사용법\n```bash\n$ rsync [option] [source] [destination]\n```\n\n### 1. 로컬로 디렉토리 복사 또는 동기화\n> rsync -zvh\n\n![](local1.PNG)\n![](local2.PNG)\n\n\n### 2. 로컬로 파일 복사 또는 동기화\n> rsync -zavh\n\n### 3. 원격으로 파일 복사 또는 동기화\n> 원격 Pull\n```bash\n$ rsync {options}  <User_Name>@<Remote-Host>:<Source-File-Dir>  <Destination>\n```\n> 원격 Push\n```bash\n$ rsync  <Options>  <Source-Files-Dir>   <User_Name>@<Remote-Host>:<Destination>\n```\n\n[17가지 예제 - linuxtechi.com](https://www.linuxtechi.com/rsync-command-examples-linux/)\n\n# Reference\n---\n\n[rsync - 용훈님 블로그](https://m.blog.naver.com/PostView.nhn?blogId=asdf2017&logNo=221491533057&proxyReferer=https:%2F%2Fwww.google.com%2F)  \n[Rsync 10가지 사용 예제들](https://www.joinc.co.kr/w/Site/Tip/Rsync)  \n[TWpower's Tech Blog](https://twpower.github.io/153-copy-file-or-directory-using-rsync-command)  ","excerpt":"Rsync(Remote sync) 파일과 디렉토리를 로컬 및 원격으로 동기화(복사) 하는데 사용 특징 네트워크 대역폭을 최소화하는 델타 인코딩 알고리즘을 사용해 변경이 일어난 부분만 전송 -> 빠르고 효율적으로 동기화 가능!   설치 rsync 홈페…","fields":{"slug":"/Rsync/"},"frontmatter":{"date":"May 05, 2021","title":"Rsync 정리","tags":["Rsync"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n개발 프로젝트를 진행하면 코드를 관리하기 위해  \n보통 **코드베이스**, **코드리뷰**, **배포방법**에 대해 고민한다.오늘은 코드베이스를 정리해보자\n\n# 코드베이스란?\n---\n > 특정 시스템, 어플리케이션, 컴포넌트 따위를 빌드할 때 사용되는 소스코드의 전체집합, 그것을 담은 저장소 \n\n가장 대중적으로 많이 쓰이는 도구는 **git, svn**이 있다.\n\n보통 git을 가장 많이 사용하고 추가로 개발을 하며\n\nbranch를 어떻게 관리할지 고민하는데\n\ngit-flow, github-flow, gitlab-flow 브랜치 전략이 가장 대중적인 방법이다.\n\n## 1. Git-flow\n\n![](gitflow.png)\n\ngit-flow를 설명할 때 가장 많이 보이는 그림이다.  \n\n사진을 보면 5개의 브랜치가 있는데 브랜치를 정리해보면\n\n```\nmaster : 배포할 수 있는 브랜치\ndevelop : 개발 브랜치\nfeature : 기능별 개발 브랜치\nhotfixes : 버그를 수정하는 브랜치\nrelease : 배포 전 테스트를 통해 버그를 찾아내는 브랜치\n```\n\n진행과정을 살펴보면\n```\n1. 기능 개발을 위해 feature 브랜치를 생성 후 작업\n2. develop 브랜치에 merge\n3. 배포 전 테스트를 위해 release 브랜치 생성\n4. 테스트 완료 시, 배포를 위해 master 브랜치로 merge 후 태그를 달고 배포\n+ master branch에서 버그 발생 시, hotfix 브랜치 생성 \n  -> hotfix에서 작업한 내용은 master와 develop에 merge된다.\n```\n\n## 2. Github-flow\n---\n> 자동화 개념이 들어가 있는게 핵심!\n\n![](github-flow.PNG)\n\n가장 쉽고, 접하기 쉬운 브랜치 전략이라고 생각한다.   \n(혼자 개발할 때는 pull request가 없지만 ㅋ)\n\ngithub flow는 master 브랜치가 핵심이다. \n\nmaster 브랜치는 **항상 최신 상태, 안정적인 상태이다.**\n\ngithub flow를 잘 사용하기 위한 몇가지 특징을 정리해보면\n\n- 커밋 메세지를 명확히 작성한다.\n- pull request, role은 엄격해야한다.\n- CI가 필수!\n\n## 3. Gitlab-flow\n---\n\n![](gitlab-flow.PNG)\n\ngit-flow와 github flow의 중간버전 느낌이다.\n\nproduction 브랜치가 있는데 이 브랜치는 배포를 위한 브랜치이다.\n\n음... 더 알아 볼수록 짬뽕 시킨 것 같으므로 요런게 있다는 것만 알고 넘어가자 ㅋ\n\n# 정리\n---\n\n3가지 브랜치 전략을 알아보았는데 \n\n세가지 모두 효율적인 소스 관리, 좋은 배포를 위한 고민이다.\n\n어쨋든 가장 중요한건 **개발팀 상황에 맞게 구성원과 전략을 세우는 것**으로 정리하고 글을 마친다. \n\n# 잡담\n\n혼자 개발하고, 친구들이랑 공모전 준비할 땐 이런 문제를 딱히 고민하지 않았는데  \n회사에서 직접 버그를 수정하고, 간단한 기능개발 하며   \n협업 방법과 코드로 대화하는 것에 대해 계속 고민하게 된다.\n\n# Reference\n[git flow 참고 자료](https://nvie.com/posts/a-successful-git-branching-model/)  \n[github flow 참고 자료(공식 홈페이지)](https://guides.github.com/introduction/flow/)  \n[gitlab flow 참고 자료(공식 홈페이지)](https://about.gitlab.com/topics/version-control/what-is-gitlab-flow/)  ","excerpt":"개발 프로젝트를 진행하면 코드를 관리하기 위해 보통 코드베이스, 코드리뷰, 배포방법에 대해 고민한다.오늘은 코드베이스를 정리해보자 코드베이스란? 특정 시스템, 어플리케이션, 컴포넌트 따위를 빌드할 때 사용되는 소스코드의 전체집합, 그것을 담은 저장소…","fields":{"slug":"/gitflow/"},"frontmatter":{"date":"Apr 20, 2021","title":"git branch 전략","tags":["git"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\nGit 명령어 정리\n\n# Git, Git flow 명령어\n\n### Git commit \n\n```bash\n$ git commit -m \"{commit message}\"\n```\n\n### Git Branch 생성 및 checkout\n\n```bash\n$ git checkout -b \n```\n\n### Git Branch 삭제\n\n```bash\n$ git branch -d {브런치 명}\n```\n\n### Git Branch 확인\n\n```bash\n$ git branch\n\n$ git branch -v\n```\n\n### Git Branch 상태 확인\n\n```bash\n$ git branch --merged\n```\n > 이미 Merge한 브랜치 목록을 확인한다.\n\n### Git log 확인\n\n```bash\n$ git log --oneline --graph\n```\n\n### 태그 목록 조회\n```bash\n$ git tag -l\n````\n\n### 태그 checkout\n```bash\ngit checkout tags/<tag_name>\n```\n\n### 태그 checkout\n```bash\ngit checkout tags/<tag_name> -b <branch_name>>\n```\n\n\n\n추가로 기억해야 할 명령어는 계속 정리할 예정이다.\n\n[Git Tips!](https://github.com/mingrammer/git-tips#20%EA%B0%9C-%EB%82%B4%EC%99%B8%EC%9D%98-%EB%AA%85%EB%A0%B9%EC%96%B4%EB%A1%9C-git-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0)\n","excerpt":"Git 명령어 정리 Git, Git flow 명령어 Git commit Git Branch 생성 및 checkout Git Branch 삭제 Git Branch 확인 Git Branch 상태 확인 이미 Merge한 브랜치 목록을 확인한다. Git l…","fields":{"slug":"/gitCommand/"},"frontmatter":{"date":"Apr 20, 2021","title":"git flow 및 git cli 명령어 정리","tags":["git"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n\ncodeigniter3를 공부해보자\n\n# codeigniter3\n\n# 1. CI 동작\n\n![data flow image](dataFlow.PNG)\n\n1. index.php CI가 동작하기 위한 기반 리소스 초기화\n2. Router 모듈 동작 결정\n   2.1) 캐시 파일 존재 -> 캐시 파일 전송\n3. Security 모듈이 Controller로 이동하기 전에 필터링\n4. Controller 사용자 요청 처리\n5. View 모듈 렌더링 -> 전송 (캐시 추가)\n\n## CI URL\n\n새그먼트 기반 URL 사용\n\n```\nexample.com/news/article/my_article\n{호스트 주소}/{호출될 Controller}/{클래스 안의 호출될 Function}/{변수}\n```\n\n<!-- TODO : nginx index.php 제거 방법 -->\n\n# 2. MVC\n\n1. Model : 데이터구조 표현, 모델 클래스는 데이터 함수 포함\n2. View : 사용자에게 보여질 화면\n3. Controller : Model과 View사이 동작\n\n![](phpMVCpattrenEx.gif)\n\n<!-- TODO : 파일 구조 설명 -->\n\n## Controller\n> URL과 상호작용하는 클래스 파일\n\n#### 특징\n - 클래스 명은 항상 **대문자로 시작**\n\n### 추가로 알아야 될 사항\n\n#### 1. Controller에 나오는 _의 의미\n> Controller에서 _를 함수 이름 앞에 작성하면 **Routing**되지 않는다. (private한 메소드가 된다.)\n\n\n#### 2. $this, self, -> 차이\n<!-- TODO : 정리해야 한다. -->\n\n[참고 블로그](https://m.blog.naver.com/PostView.nhn?blogId=vefe&logNo=221454883593&proxyReferer=https:%2F%2Fwww.google.com%2F)\n\n#### 3. _remap() 함수\n> 함수요청 재매핑\n\n\n```php\npublic function _remap($method, $params = array()) {\n   $method = 'process_'.$method;\n   if (method_exists($this, $method)) {\n      return call_user_func_array(array($this, $method), $params);\n   }\n   show_404();\n}\n```\n\n\n**컨트롤러가 _remap()함수 가지고 있으면 무조건 호출된다**\n\n#### 4. _output() 함수\n> \n\n<!-- TODO : VIEW, Output 클래스 내용 정리하고 다시보자 -->\n\n**추가로 알아야 될 사항은 내용은 내용을 조금 더 추가 할 예정이다.**\n\n## Route\n> application/config/routes.php에 작성\n<!-- TODO : 생활코딩 강의 -> ref문서 정리 -->\n\n## View\n> 화면에 출력되는 부분\n\n## Model\n> Model은 데이터를 가져오는 로직을 메소드로 정의, Controller를 통해 사용된다.\n\n### 데이터 베이스 설정\n\n> Application/config/database.php 파일을 수정\n\n파일 속성\n```\nhostname : 데이터베이스 서버의 주소 (localhost는 PHP와 같은 머신을 의미)\nusername : 데이터베이스 사용자의 이름\npassword : 데이터베이스 비밀번호\ndatabase : 데이터베이스 명\ndbdriver : 데이터베이스의 종류로 지원되는 드라이브의 목록은 system/database/drivers 디렉토리명을 참고한다.\n```\n\n### 데이터 베이스 라이브러리 로드\n\nPHP에서 MySQL을 사용하기 위해 mysqli를 설치한다\n\n```bash\n$ sudo apt-get install php-mysqli\n```\n\n데이터 베이스 라이브러리 로드 방법은 2가지가 있다.\n\n```\n1. application/config/autoload.php 파일의 $autoload['libraries'] 배열에 'database'를 추가한다. \n2. controller 내에서 $this->load->database()를 호출한다.\n```\n\n### Model 파일 생성 규칙\n - **application/models/{모델 명_model}.php** 형식으로 생성\n - 파일은 **CI_Model 클래스 상속**\n - 클래스 명은 **대문자로 시작**\n\n### Model load\n\n1. Model load\n> $this->load->model('소문자로된 모델 클래스 명');  \n\nex)\n```\n$this->load->model('topic_model');\n```\n\n1. Model call\n> 모델 클래스 명 -> 메소드 명\n\nex)\n```\n$topics = $this -> topic_model -> gets();\n```\n\n### Model 내 쿼리 사용\n> $this->db 이용!\n\n- 사용 예제 \n  \n```php\n$query - $this->db->query('SELECT name, title, email FROM my_table')\n\nforeach($query->result() as $row) {\n   echo $row->title;\n   echo $row->name;\n   echo $row->email;\n}\n\necho 'Total Results: ' . $query->num_rows();\n```\n\n#### 결과 불러오기\n> **객체 배열 리턴**한다.\n\n1. 다중 결과(객체)\n   - result()\n2. 다중 결과(배열)\n   - result_array()\n3. 단일 결과(객체)\n   - row()\n4. 단일 결과(배열)\n   - row_array()\n\n<!-- TODO : 표준 입력 예제, 쿼리 빌더 -->\n<!-- http://www.ciboard.co.kr/user_guide/kr/database/examples.html#standard-insert -->\n\n<!-- TODO : Active Record vs JPA 비교 -->\n\n## Tip!!\n\n```bash\nif (!-e $request_filename ) {\n\trewrite ^(.*)$ /index.php last;\n}\n```\nfile이 존재하지 않으면, index.php로 이동\n\n### ?> 닫는 태그를 생략하는 경우\n\nPHP 구문은 기본적으로 \n```php\n<?php\n  ...\n?>\n```\n위와 같이 구성된다. 문장의 종료는 반드시 **세미 콜론**이 찍혀야 한다.\n\n하지만 php코드를 보면 닫는 코드인 ?> 을 생략한 구문이 있다. 이상하게 코드는 잘 동작한다.\n\n그 이유를 알아보면 순수 PHP코드로만 이루어진 코드는 닫는 태그를 생략하는 것이 더 유리하다고 한다.\n\n왜냐하면 닫는 태그인 ?> 앞 뒤에 공백이나 Enter가 실수로 들어가는 경우가 많기 때문이다.\n\n이런 상황에는 의도하지 않은 에러가 날 수 있고, 디버깅 하기 힘듬\n\n하지만 **HTML 코드와 같이 사용할 경우에는 반드시 사용해야 한다.**\n\n\n# 3. Library, Helper\n\n## Helper\n> 자주 사용하는 로직을 재활용 할 수 있게 만드는 Library\n\n**Library vs Helper**  \n> Helper : 일반적인 함수로 만들어짐 / Library : 객체로 만들어짐\n\n1. 기본적인 로드 방법\n```php\n$this->load->helper('헬퍼 이름')\n```\n\n2. 복수의 헬퍼를 로드하기 위한 방법\n```php\n$this->load->helper(array('헬퍼1의 이름', '헬퍼2의 이름'));\n```\n\n## Tip!!\n헬퍼는 보통 직접적으로 스크립트를 실행하는 경우가 많이 없으므로\n\n```php\n<?php if (! defined('BASEPATH')) exit('No Direct script access allowed');\n```\n구문을 상단에 최상단에 추가하여 스크립트의 실행을 막는다.\n\n## Library\n> 웹개발에서 자주 사용되는 로직을 내장(Core) 라이브러리로 제공하고 있다.\n\n# 4. CI Config\n> 필요에 따라 Application 동작 방법을 변경한다.\n> Application/config/ 디렉토리 아래에 위치\n\n**Tip!!**\n개발환경과 실서비스 환경과 설정을 다르게 위해 index.php의\n```php\ndefine('ENVIRONMENT', 'development');\n```\n두 번째 인자값을 development, testing / production 으로 바꿀 수 있지만\n**dev.php를 하나 더 만들어서 접속 경로를 다르게 하는 방법도 있음**\n\n```\ndevelopment : 개발 환경에서 사용한다. 모든 에러가 출력된다. \ntesting, production : 테스팅이나 실서비스 환경에서 사용된다. 에러가 출력되지 않는다. \n```\n\n## 1. config.php\n> CI에 필요한 기본적인 설정파일 / CI가 동작하는 방식에 대한 다양한 설정 값이 저장되어 있음.\n\n파일을 보면 쿠키, 세션, 보안, 캐시파일/로그파일 저장 위치 같은 것을 확인할 수 있다.\n\n## 2. database.php\n> database에 필요한 설정파일\n\n## 3. autoload.php\n> Helper, Library같은 리소스들을 자동 로드 -> 편의성 증대 / 성능 감소 주의\n\n## 4. hooks.php\n> 사용자가 Core의 기본 실행 흐름을 설정 가능 (자신만의 로직 추가 가능 / config.php에서 설정 해야지 사용 가능)\n\n## 설정 정보 사용\n> config 라이브러리와 config.php 파일은 자동 로딩하기 때문에 별도 작업 필요 없음\n\n```php\n$this->config->item('base_url');\n```\n\n### 사용자 정의 설정\n> $config 배열에 값 추가, 파일을 통한 설정 값 추가 가능(로딩 절차 필요)\n\n```php\n$this->load->config('hsh');\n// file을 통한 설정 load \n$this->config->item('hsh');\n// item 메소드는 설정이 없으면 false 리턴\n```\n\n## 5. CI debugging / log\n\napplication/config/config.php에 보면\n\n```php\n$config['log_threshold'] = 0;\n```\n구문 수정을 통해 log수준을 설정할 수 있다.\n\n```\n0 = 로깅을 비활성화\n1 = 에러로그만 기록\n2 = 디버그 로그도 기록 \n3 = 정보 로그도 기록\n4 = 모든 메시지를 기록\n```\n\ncontroller에서 아래와 같이 사용하면 원하는 log메세지를 추가 할 수 있다.\n\n```php\n// debug 메세지 추가\nlog_message('debug', 'topic 초기화');\n\n// error 메세지 추가\nlog_message('error', 'topic의 값이 없습니다');       \n```\n\n## 6. 파일 처리\n> Upload 클래스의 doupload가 핵심 메소드\n\n현재 다니고 있는 회사에선 file upload는 **Fine-Uploader**를 사용하고  \n**CKEditor**를 사용해서 HTML 코드 없이 글을 작성하는 기능을 구현했다.\n\n## 7. Core 확장\n> CI는 코어 상속, Hook방법을 통해 Core기능 \n\n\n\n\n<!-- ## 8. 세션 / 비밀번호 암호화\n\n## 9. CRI 프로그램\n\n## 10. Queue / Cron\n\n## 11. Caching -->\n\n<!-- \n[쿠키와 세션](https://opentutorials.org/course/62/240\n[Session](https://opentutorials.org/course/697/398)\n[회원가입 & 비밀번호 암호화](https://opentutorials.org/course/697/4278)\n[리다이렉션과 로그인 개선](https://opentutorials.org/course/697/4129)\n[이메일 전송 & 라이브러리 장]()\n[CLI](https://opentutorials.org/course/697/4282)\n[Queue & cron](https://opentutorials.org/course/697/4130)\n[Caching](https://opentutorials.org/course/697/3839)\n -->\n\n## 경로에 index.php 없애기\n\n1. application/config/config.php\n\n```php\n$config['index_page'] = '';\n```\nindex.php를 찾아서 빈 값으로 설정한다\n\n2. index.php가 존재하는 폴더에 .htaccess파일을 추가한다.\n(Permisson은 755로 설정한다.)\n\n**.htaccess 파일**\n```\n<IfModule mod_rewrite.c>\n    RewriteEngine On\n    RewriteCond %{REQUEST_FILENAME} !-f\n    RewriteCond %{REQUEST_FILENAME} !-d\n    RewriteRule ^(.*)$ index.php/$1 [L]\n</IfModule>\n```","excerpt":"codeigniter3를 공부해보자 codeigniter3 1. CI 동작  index.php CI가 동작하기 위한 기반 리소스 초기화 Router 모듈 동작 결정\n2.1) 캐시 파일 존재 -> 캐시 파일 전송 Security 모듈이 Controll…","fields":{"slug":"/phpNginxCI_4/"},"frontmatter":{"date":"Mar 01, 2021","title":"Codeigniter 학습","tags":["Codeigniter"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# 1. SQLite .명령어 정리\n> SQLITE의 특징은 명령어 앞에 마침표(.)를 붙인다.\n\n파일 접속\n```bash\n$ sqlite3 {파일명}\n```\n\n파일 접속 종료\n```bash\n> .quit\n> .exit\n```\n\n테이블 확인\n```bash\n> .tables\n```\n\n테이블 구조 확인\n```bash\n> .schema access_log\n```\n\n헤더(컬럼 명) 함께 출력\n```bash\n> .header on\n```\n\n라인별로 나눠 출력\n```bash\n> .mode line\n```\n\n컬럼별로 나눠 출력\n```bash\n> .mode column\n```\n\n추가 기능 확인\n```bash\n> .help\n```\n\n# 2. 파일 I/0\n> sqlite3는 쿼리 결과를 표준 출력으로 보낸다.\n - \".output\", \".once\" 명령어를 사용하여 변경 가능\n\n\n1) .OUTPUT 명령어 \n > .output에 인수로 파일명 넣으면 해당 파일에 기록 (.output을 사용하면 표준 출력 상태로 되돌아간다)\n\n2) .import 명령어를 사용해 csv데이터를 sqlite 테이블로 가져올 수 있다.\n```bash\nsqlite> .import C:/CVS/aaa.csv aaa\n```\n\n**주의할 점**\n - SQLite3은 기본적으로 UTF-8형식 / 윈도우 엑셀은 CP949형식","excerpt":"1. SQLite .명령어 정리 SQLITE의 특징은 명령어 앞에 마침표(.)를 붙인다. 파일 접속 파일 접속 종료 테이블 확인 테이블 구조 확인 헤더(컬럼 명) 함께 출력 라인별로 나눠 출력 컬럼별로 나눠 출력 추가 기능 확인 2. 파일 I/0 s…","fields":{"slug":"/SQLite/"},"frontmatter":{"date":"Feb 26, 2021","title":"SQLite","tags":["SQLite"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\nphp 문법을 간략히 정리해보자\n\n# 1. 변수\n\nPHP는 아래와 같은 자료형을 사용할 수 있다\n문자열 String  \n정수형 Integer  \n실수형 Float  \n논리형 Boolean  \n배열 Array  \n객체형 Object  \n널 NULL  \n리소스 Resource  \n\n아래의 방법으로 변수의 자료형을 알아내거나, 자료형을 변경할 수 있다.\n\n```php\n// 변수 자료형 알아내기 \nvar_dump({변수 이름});\necho gettype({변수 이름});\n\n// 변수 자료형 변경\nsettype({변수이름},'{자료형}');\n```\n\nPHP의 특징으로 동적으로 변수명 설정이 가능하다.\n\n```php\n<?php\n$title = 'subject';\n$$title = 'PHP tutorial';\necho $subject;\n?>\n```\n\n아래의 구문을 실행하면 실행값이\n```\nPHP tutorial\n```\n이 나온다.\n\n\\$\\$가 두번 표시되어 있는데, $title 의 값으로 변수가 생성된 것을 의미한다.\n\n\n# 2. 연관배열\n\n두번째 특징으로 연관배열이 있다.\n\n## 연관배열\n> 배열의 키 값으로 숫자와 문자 모두 사용\n\n예제를 보면 \n\n값 할당 및 출력 구문\n```php\n<?php\n$grades = array('egoing'=>10, 'k8805'=>6, 'sorialgi'=>80);\n$grades = array('egoing'=>10, 'k8805'=>6, 'sorialgi'=>80);\nforeach($grades as $key => $value){\n    echo \"key: {$key} value:{$value}<br />\";\n}\n?>\n```\n\n결과값\n```php\nkey : sorialgi  value : 80\nkey : k8805     value : 6\nkey : egoing    value : 10  \n```\n\n키값 형태로 사용한다.\n\n# 3. File load\n\n## require, import \n\nphp에는 **1. require** , **2. import** 두가지 방법으로 file호출 가능  \n뒤에 \\_once를 붙여 include\\_once 처럼 사용하면 파일을 로드할 때 단 한번만 로드하면 된다는 의미\n\n기능상 차이는 없는데 error 표시가 다르다.  \n\nrequire가 더 높은 에러 수준으로 error를 알리고, 코드의 실행을 중단시킨다.  \n\n\n**1) 파일 복사**\n> copy(\\$file, \\$newfile)\n\n**2) 파일 삭제**\n> unlink('file.txt');\n\n**3) 파일 읽기**\n> file_get_contents($file);\n\n**4) 파일 저장**\n> file_put_contents($file, 'coding everybody');\n\n**5) file etc**\n> is\\_readable, is\\_writable, file_exists 같은 함수를 통해 파일 확인이 가능하다\n\n**6) 디렉토리**\n```php\n// directory 읽기\n$dir    = './';\n$files1 = scandir($dir);\n\n// directory 만들기\nmkdir(\"1/2/3/4\", 0700, true);\n```\n\n# 4. Class\n\n클래스 선언 및 인스턴스 생성\n```php\nclass MyObject{\n  function __contruct($fname){\n    $this->filename = $fname;\n  }\n}\n\n$obj = new MyObject('file1');\n```\n\nClass내 함수 사용\n```php\nprint_r($obj->func());\n```\n\n# 5. 접근 제어자\n> private, public 키워드를 사용해서 접근을 제어할 수 있다.\n\n# 6. 상속\n> extends 키워드를 사용해 클래스를 상속할 수 있다.\n\n**Tip!!**  \n클래스 안에 static 키워드를 추가한 변수를 만들어주면 모든 인스턴스가 공유하는 변수를 만들어줄 수 있다.\n\n```php\nclass car{\n  private static $count = 0;\n  private $name;\n  function __construct($name){\n    $this->name = $name;\n    self::$count = self::$count+1;\n  }\n}\n```\n\n### 클래스 접근\n\n부모 클래스를 접근할 때는 parent(parent::) 연산자를 사용한다.\n자신의 클래스를 접근할 때는 self(self::) 연산자를 사용한다.\n\n**\\::는 new 지시자로 class를 미리 객체화 시켜놓지 않고 사용하는 시점에서 객체가 생성되고 지정된 메소드가 실행되도록 하는 접근자이다.**\n\n\n# 7. Namespace, use\n> Namespace : 동일한 이름을 가진 class가 존재할 때 구분하여 사용하기 위한 이름\n> use : 키워드를 통해 불러올 수 있다.\n\nJava에서 package와 import 같은 개념이다. \n\n[PSR](https://www.php-fig.org/psr/psr-4/)에서는 아래와 같은 방식으로 사용하는 것을 권장한다\n> \\<NamespaceName>(\\<SubNamespaceNames>)*\\<ClassName>\n\n사용법은\n```php\n<?php\n// 파일명 : greeting_en_ns.php\n\nnamespace language\\en;\nclass Hi{\n  function welcome(){\n      return 'Hello world';\n  }\n}\n```\n상단에 namespace 를 명시해준다.\n\n사용할 땐\n```php\n<?php\nrequire_once 'greeting_en_ns.php';\nuse \\greeting\\en\\Hi as hien\nnew HiEn();\n?>\n```\n\n불러와서 사용해주면 된다.\n\n# 8. 인터페이스\n\n```php\ninterface myInterface{\n  public function promiseMethod(array $param):int;\n}\n```\n\n# 9. abstract\n> 하위 클래스가 반드시 오버라이드하게 강제한다.\n\n강제하고 싶은 메소드 앞에 abstract 키워드를 붙여주면 된다.\n\n# 10. 컴포저\n> PHP의 Package Manager\n\ncomposer.json파일로 관리\n\n[packagist](https://packagist.org/)를 들어가보면 PHP Repository를 검색할 수 있다.\n\nCI3의 composer.json\n\n![](ciComposer.PNG)\n\n추가로 ci는 composer를 사용하려면 config/config.php 부분에 아래 구문을 수정 해야한다.\n\n```php\n$config['composer_autoload'] = '/vendor/autoload.php';\n```\n\n---\n\n위 내용을 바탕으로 간단하게 CI3 + Nginx로 띄운 서버에 id, password 입력 폼을 만들고 정규식으로 값들을 체크하는 코드를 작성해보았다.\n\ncontroller 소스다.\n![](1.PNG)\n\nview 소스다.\n![](2.PNG)\n\n/playground\n![](4.PNG)\n\n/playground/go 로 이동한 결과\n![](3.PNG)\n\n끗","excerpt":"php 문법을 간략히 정리해보자 1. 변수 PHP는 아래와 같은 자료형을 사용할 수 있다\n문자열 String 정수형 Integer 실수형 Float 논리형 Boolean 배열 Array 객체형 Object 널 NULL 리소스 Resource   아래…","fields":{"slug":"/phpNginxCI_3/"},"frontmatter":{"date":"Feb 25, 2021","title":"PHP 기본 문법 정리","tags":["PHP"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"# Nginx\n\n## CGI(Common Gateway Interface) 란?\n> 웹서버와 외부 프로그램(C, PHP, Python 등) 사이에서 정보를 주고받는 방법과 규약\n\n**이 표준에 맞춰 만들어진 것이 CGI 스크립트이다.**\n\n![](cgipic.PNG)\n\n### 관련 용어\n - Web Server : 웹 클라이언트에게 콘텐츠를 제공하는 서버\n - WAS : 서버 단에서 Application을 동작할 수 있도록 지원\n\n### 장점\n - 언어, 플랫폼에 독립적\n - 매우 단순하고 다른 서버 사이드 프로그래밍 언어에 비해 쉽게 수행\n - 라이브러리가 풍부하다\n - 가볍다\n\n### 단점\n - 느리다(요청이 올 때 마다 DB connection을 새로 열어야 한다)\n<!-- TODO : 확인해보자 -->\n - HTTP 요청마다 **새로운 프로세스를 만들어** 서버 메모리를 사용한다 (Fork로 구현되어 있음)\n - 데이터가 메모리에 캐시될 수 없다.\n\n### 추가\n[RPC 3875-1.4 항목](https://tools.ietf.org/html/rfc3875#section-1.4)\n```\n1. CGI 프로그램을 호출하는 WEB 서버 역할\n  1) 전송 단계에서의 인증 및 보안\n  2) CGI 프로그램의 선택\n  3) CGI Request 로 변환\n  4) CGI Response에서의 변환\n2. 호출 프로그램의 지정 방법 (URI)\n3. WEB 서버에서 CGI Request의 해석 방법 (경로 및 프로토콜)\n4. WEB 서버에서 CGI Response에 대한 반환 방법 (경로 및 프로토콜)\n```\n\n## FastCGI란?\n> 하나의 큰 프로세스로 동작한다. 이 프로세스가 계속해서 새로운 요청(Request) 처리(CGI 단점 해결)\n\n![](fastcgip.PNG)\n\n대부분의 웹서버 **(Nginx, IIS, Apache)** 가 FastCGI를 제공한다.\n\n## PHP-FPM(Fast Process Manager)\n> PHP를 FastCGI 모드로 동작하게 해준다.\n\n\n## 1. 역할\n1. 정적 파일을 처리하는 **HTTP 서버**로서의 역할\n\n![](webserver.PNG)\n\n2. 응용 프로그램 서버에 요청을 보내는 **리버스 프록시** 역할\n\n![](reverseProxy.PNG)\n\n프록시는, **클라이언트와 서버 통신 사이에서 통신을 대신!! 해주는 서버를 의미한다.**\n\n### 리버스 프록시란?\n > 클라이언트가 서버에 요청하면, 프록시 서버가 배후 서버(응용프로그램 서버)로부터 데이터를 가져옴\n\n추가로 포워드 프록시는 클라이언트 앞단에서\n**보안을 위해 사용을 제한할 목적**\n\n리버스 프록시는 서버의 앞단에서 요청을 처리  \n**좀 더 안전하게 Request, Response를 관리**\n\n### 리버스 프록시를 쓰는 이유\n > 1. **프록시 서버를 둠으로써 요청을 배분하는 역할**  \n > 2. cli가 직접 App 서버에 요청하면 프로세스 1개가 응답대기 상태가 되어서 요청에 대한 버퍼링이 생긴다  \n > 3. 보안상 이점! -> WAS는 대부분 DB서버와 연결되어 있으므로 WS - WAS가 통신을 통해 클라이언트에게 제공하는 방식\n\n추가로 스위치(로드밸런서)로써 역할도 가능하다.\n> 프로세스 응답 대기를 막고, 요청을 배분하는 역할 \n### Event-driven 방식\n\nThread 기반은 하나의 커넥션당 하나의 쓰레드를 사용\n\nEvent-driven 방식은 Event Handler를 통해 비동기 방식으로 처리해 먼저 처리되는 것부터 로직이 진행된다.\n\n![](threadp.PNG)\n\n![](eventp.PNG)\n\n## 2. 파일 구조\n\n5개 폴더 및 파일을 알아보고 넘어가겠다.\n\n```\nconf.d : nginx.conf에서 불러들일 수 있는 파일을 저장\nfastcgi.conf : FastCGI 환경설정 파일\nnginx.conf : 접속자 수, 동작 프로세스 수 등 퍼포먼스에 관한 설정들\nsites-available : 비활성화된 사이트들의 설정 파일들이 위치한다.\nsites-enabled : 활성화된 사이트들의 설정 파일들이 위치한다. \n```\n\n사실 기본 설정이 이렇다는 거고, 폴더명 같은 경우는 상황에 따라 변경이 가능하다. \n\n## 3. 변수\n\n#### $arg_{PARAMETER}\n> URI의 파라미터 변수의 이름 의미\n#### $host\n> 현재 요청의 호스트 명\n\n#### $uri\n> 현재 요청의 URI (호스트명과 파라미터는 제외된다.)\n\n#### $args\n> URL의 질의 문자열\n\n#### $binary_remote_addr\n> 바이너리 형식의 클라이언트 주소\n\n#### $body_bytes_sent\n> 전송된 바디의 바이트 수\n\n#### $content_length\n> HTTP 요청헤더의 Content-length\n\n#### $content_type\n> HTTP 요청헤더의 Content-type\n\n#### $document_root\n> 현재 요청의 document root 값\n\n#### $http_HEADER\n> HTTP 헤더의 값을 소문자로 한 값(-는 _로 변환된다.)\n\n#### \\$server\\_name / \\$server\\_port / \\$server\\_protocol\n> 각각 name, port, protocol을 의미한다.\n\n#### cookie_{쿠키이름}\n> 해당 쿠키의 값을 얻을 수 있다.\n## 4. 설정\n\n**설정 수정 시 원본을 복사해 보관해 두는 습관 가지자!**\n\n### 설정 파일\n\n설정파일은 크게 4가지로 나뉜다.\n1. nginx.conf : 메인 설정 파일\n2. fcgi.conf : FastCGI 환경 설정파일\n3. sites-enabled : 활성화된 사이트들의 설정 파일 위치\n4. sites-available : 비활성화된 사이트들의 설정 파일 위치\n\n\n두개의 파일을 보며 Nginx 설정에 대해 확인해보자\n> /etc/nginx/nginx.conf  \n> /etc/nginx/sites-available/default\n\n#### /etc/nginx/nginx.conf\n```\nuser www-data;\nworker_processes auto;\npid /run/nginx.pid;\n\nevents {\n        worker_connections 768;\n        # multi_accept on; #기본값:off\n}\n\nhttp {\n        sendfile on;\n        tcp_nopush on;\n        tcp_nodelay on;\n        keepalive_timeout 10; #기본값:75\n        types_hash_max_size 2048;\n        server_tokens off;\n\n        server_names_hash_bucket_size 64; #기본값:32\n        server_names_hash_max_size 2048; #기본값:512\n        # server_name_in_redirect off;\n\n        include /etc/nginx/mime.types;\n        default_type application/octet-stream;\n\n        access_log off; log_not_found off;\n        error_log /var/log/nginx/error.log warn;\n\n        include /etc/nginx/conf.d/*.conf;\n        include /etc/nginx/sites-enabled/*;\n}\n\n```\nnginx.conf 파일은 접속자 수, 동작 프로세스 수 등 퍼포먼스에 대한 기본적인 설정 항목을 포함한다.\n\n크게 3가지 항목으로 나뉜다.\n\n#### 1. 최상단 (Core 모듈)\n\nuser : Nginx 프로세스(워커 프로세스)가 실행되는 권한\n - nginx는 master process, worker process로 동작한다.\n - 실질적으로 **worker process가 실직적인 웹서버 역할** 수행\n - root로 설정되어 있을 경우, 워커 프로세스를 root 권한으로 동작  \n   -> 악의적인 사용자가 제어하게 된다면 보안상 위험  \n   -> 보통 **www-data, www, nginx**와 같이 계정이 하는 일에 대한 대표성 있는 이름 사용  \n    - (default 값 - ubuntu : www-data, 기타 nobody )  \n   -> 이 계정들은 일반 유저의 권한으로 쉘에 접속 할 수 없어야 안전하다.  \n    - ubuntu 에서 계정 생성방법  \n```bash\n$ useradd --shell /usr/sbin/nologin www-data\n```\n\nworker_processes : Nginx 프로세스 실행 가능 수\n - auto일 경우도 있지만, 명시적으로 서버의 코어 수 만큼 할당하는 것이 보통 (더 높게도 가능)\n\npid : Nginx 마스터 프로세스 정보\n\n\n#### 2. events\n주로 네트워크의 동작 방법과 관련된 설정값을 가진다. \n\nworker_connections : 몇개의 접속을 동시에 처리할 것인가\n - worker_processes * worker_connections = **처리 할 수 있는 커넥션의 양**\n - Tip!!\n   - 여러 자료와 퍼포먼스 테스트를 하며 값을 조정해야 한다.\n\n#### 3. http\n> server, location의 루트 블록이라 할 수 있고, 여기서 설정된 값들은 하위 블록들이 상속한다.  \n> http 블록은 여러개를 사용할 수 있지만 관리상의 이유로 한번 사용하는 것이 좋다.\n\n - keepalive_timeout : 클라이언트에서 커넥션을 유지하는 시간을 의미\n - servers token : Nginx 버전 숨길 수 있는 기능 (주석을 제거해 보안 이슈를 방지하는 것이 좋다.)\n - server_names_hash_max_size, server_names_hash_bucket_size : 호스트의 도메인 이름에 대한 공간(너무 낮으면 에러 발생 가능)\n - **log관련 설정**은 각 **호스트 마다 배분**하는 것이 관리하기 편하므로 http block에선 off로 처리한다.\n\n\n#### etc\n - **include 옵션** : 별도의 파일에 설정을 기록해서 설정의 그룹핑, 재활용성을 높이는 방법\n - ex) 리버스 프록시를 각 도메인에 설정한다고 했을 때 헤더 처리 옵션등을 conf.d에 넣어두고 불러온다. (nginx.conf 설정 파일이 깔끔해짐)\n   - 리버스 프록시란? : \n\n#### 4. server / location\n/etc/nginx/sites-available/default에 server, location 블록이 작성되어 있다.\n\nserver 블록 : 하나의 웹사이트를 선언하는데 사용 (가상 호스팅 개념)\nlocation 블록 : server 블록 안에 등장하며 특정 URL을 처리한다.\n\n```\nserver {\n    listen       80;\n    server_name  localhost;\n \n    root   /usr/share/nginx/html;\n    location / {\n        index  index.html index.htm index.php;\n    }\n \n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    location ~ \\.php$ {\n        fastcgi_pass   unix:/var/run/php5-fpm.sock;\n        fastcgi_index  index.php;\n        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;\n        include        fastcgi_params;\n    }\n}\n```\nlocation 블록을 상세히 살펴보면\n\n1. fastcgi_pass : \n2. fastcgi_param : \n\n**설정 파일을 변경하면 nginx에 반영해야 하는데, reload 명령을 이용한다**\n\n## 추가!!\n\n- 보통 가상 호스트 설정 파일의 경우 sites-available 디렉토리 아래 위치  \n- sites-enabled 디렉토리에 심볼릭 링크를 걸어주면서 nginx에서 사용하게 설정\n- 에러 같은 경우 중요한 오류 이외에는 로그로 남기지 않게 설정해서 로그로 인해 디스크 엑세스를 하지 않게 설정한다!\n\n**conf파일 구성은 상황마다 다르다.**\n\n### 로그 파일 위치\n> /var/log/nginx\n\n## Upstream Module\n> NGINX를 일종의 LoadBalancer(부하분산, 속도개선)로 이용할 수 있게 해주는 모듈\n\n- conf파일의 upstream블록을 통해 사용한다. \n- was를 의미하고, nginx는 downstream에 해당한다고 할 수 있다.\n\n**형식**\n```\nupstream 이름 {\n    [ip_hash;]\n    server host 주소:포트 [옵션];\n    .....\n}\n```\n\n**예제**\n```\nupstream backend {\n    ip_hash;\n    server 192.168.125.142:9000 weight=3;\n    server 192.168.125.143:9000;\n    server 192.168.125.144:9000 max_fails=5 fail_timeout=30s;\n    server unix:/var/run/php5-fpm.sock backup;\n}\n```\n\n**옵션**\n```\nip_hash : 같은 방문자로부터 도착한 요청은 항상 같은 업스트림 서버가 처리하게 설정\nweight=n : 업스트림 서버의 비중(2 -> 2배 더 자주 사용)\nmax_fails=n : n으로 지정한 횟수만큼 실패가 일어나면 서버가 죽은 것으로 간주한다.\nfail_timeout=n : max_fails가 지정된 상태에서 이 값이 설정만큼 서버가 응답하지 않으면 죽은 것으로 간주한다.\ndown : 해당 서버를 사용하지 않게 지정한다. ip_hash; 지시어가 설정된 상태에서만 유효하다.\nbackup : 모든 서버가 동작하지 않을 때 backup으로 표시된 서버가 사용되고 그 전까지는 사용되지 않는다.\n```\n\n다음 사진과 같이 사용한다.\n![](upstream.PNG)\n\n## 재작성(rewrite)\n> rewrite 모듈을 통해 URL 재작성\n\n예제\n```\nlocation ~ /tutorials/javascript.html {\n    rewrite ^ http://opentutorials.org/course/48;\n}\n```\n\n리다이렉션을 디버깅 하기 위해선 **error_log 지시자를 server나 location블록 아래에 위치!!**\n\n```\nserver {\n    server_name opentutorials.org\n    error_log /var/log/opentutorials.org.error debug;\n    location ~ /.php$ {\n        error_log /var/log/opentutorials.org.php.error debug;\n    }\n}\n```\n\n위와 같이 사용하면 error log는 debug수준에서 출력 -> 에러 출력 debug레벨 사용\n\nwww를 제거하는 예제\n```\nif ($host ~* ^www\\.(.*)){\n    set $host_without_www $1;\n    rewrite ^/(.*)$ $scheme://$host_without_www/$1 permanent;\n}\n```","excerpt":"Nginx CGI(Common Gateway Interface) 란? 웹서버와 외부 프로그램(C, PHP, Python 등) 사이에서 정보를 주고받는 방법과 규약 이 표준에 맞춰 만들어진 것이 CGI 스크립트이다.  관련 용어 Web Server :…","fields":{"slug":"/nginx/"},"frontmatter":{"date":"Feb 24, 2021","title":"Nginx 학습","tags":["Nginx"],"update":"Mar 01, 2021"}}},{"node":{"rawMarkdownBody":"\n# #!/bin/bash를 왜 쓸까\n\nbash파일은 주석을 #으로 단다.\n\nbash스크립트 파일 문제 풀면서 별 생각없이 #!/bin/bash 부분이 그냥 표시해주는 부분인 줄 알았는데\n\n\\#!/bin/bash를 꼭 달아줘야 한다고 한다.\n\n\"#!\"는 **Shebang**이라고 부르고, 실행 가능한 쉘 스크립트라는 것을 나타내는 특별한 표시자이다.  \n\n\"#!\" 뒤에 나오는 것은 경로명으로, 스크립트에 들어있는 명령어를 해석할 위치를 나타낸다.  \n**정확히 Full PATH로 작성해야한다.**  \n\n이 명령어 해석기가 주석은 무시하면서 스크립트의 첫번째 줄부터 명령어를 실행시킨다.\n\n\n## 쉘 스크립트의 구조\n\n\n```bash\n#!인터프리터(Interpreter)\n\n#\n# 주석(Comment)\n#\n\n함수명() {\n  명령\n  ...\n}\n\n명령1.. (Command)\n명령2..\n명령3..\n\n흐름제어 (Flow Control)\n\n함수 호출\n```","excerpt":"#!/bin/bash를 왜 쓸까 bash파일은 주석을 #으로 단다. bash스크립트 파일 문제 풀면서 별 생각없이 #!/bin/bash 부분이 그냥 표시해주는 부분인 줄 알았는데 #!/bin/bash를 꼭 달아줘야 한다고 한다. \"#!\"는 Sheba…","fields":{"slug":"/whyBash/"},"frontmatter":{"date":"Feb 23, 2021","title":"쉘 스크립트 첫 줄에 [#!/bin/bash]를 쓰는 이유","tags":["Linux"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\nbash 20문제 풀이\n\n## 풀이\n\n1. 현재 자기신의 pc(linux기준)의 cpu모델명, Os 종류 및 버전, kernel 버전을 출력하시오.\n\n```bash\ncat /proc/cpuinfo | egrep  'model name'\ncat /etc/issue\nuname -r\n```\n\n2. 매주 일요일, 새벽4시 30분과 낮12시 30분에, /tmp/* 를 삭제하는 crontab \n예) * * * * * 실행문\n\n```bash\ncat <(crontab -l) <(echo \"30 4,12 * * * rm /tmp/*\") | crontab\ncrontab -l\n```\n\n3. 정수인자 2개를 받아 인자 개수 검증 후 4칙연산별 함수를 구현하여 결과값을 모두 \n\n```bash\nfunction add(){\n\tlet value=$1+$2\n\techo \"$1 + $2 : ${value}\"\n}\n\nfunction minus(){\n\tlet value=$1-$2\n\techo \"$1 - $2 : ${value}\"\n}\n\nfunction multiply(){\n\tlet value=$1*$2\n\techo \"$1 * $2 : ${value}\"\n}\n\nfunction divide(){\n\tlet value=$1/$2\n\techo \"$1 / $2 : ${value}\"\n}\n\nadd $1 $2\nminus $1 $2\nmultiply $1 $2\ndivide $1 $2\n```\n\n4. 2초마다 현재시간을 출력하는 스크립트를 작성하세요.\n\n(3번 실행되도록 작성)\n\n```bash\nnumber=0\n\nwhile [ $number -le 2 ]\ndo\n\tdate\n\t((number++))\n\tsleep 2\ndone\n```\n\n5. 첨부파일 lastlog를 이용하여 한번도 로그인한 적 없는 사용자를 삭제하는 명령어를 문자열로 아래와 같이 출력.\n\n```bash\nwhile read A B C D E F G H I\ndo\n\tif [[ \"$B\" =~ \"**Never\" ]]; then\n\t\techo \"userdel -r \" $A\n\tfi\ndone < lastlog\n```\n\n6. 첨부파일 lastlog를 이용하여 로그인한 적 없는 사용자를 제외하고 년 월 일 시간 사용자계정 순서로 아래와 같이 출력 i\n\n```bash\nwhile read A B C D E F G H I\ndo\n\tif [[ \"$B\" =~ \"pts\" ]]; then\n\t\techo ${I:0:-1} $E $F $G $A\n\tfi\ndone < lastlog\n```\n\n7. 첨부파일 lastlog를 이용하여 ntp와 firenwo user 라인사이에 ‘end of system user’라인 삽입.\n\n```bash\nsed -i'' -r -e \"/ntp/a\\end of system user\" lastlog\ncat lastlog\n```\n\n8. 첨부파일 checkpassword를 이용하여 09:59:57부터 10:21:45까지의 라인만 출력\n\n```bash\ncat checkpassword | awk '/[9]:59:5[7-9]/'\ncat checkpassword | awk '/[10]:[0-1][0-9]:[0-5][0-9]/'\ncat checkpassword | awk '/[10]:2[0-1]:[0-3][0-9]/'\ncat checkpassword | awk '/[10]:21:4[0-5]/'\n```\n\n9.  첨부파일 checkpassword를 이용하여 121.156.118.254를 pop3.mailplug.co.kr로, 14.36.253.67는 office.ip.wiro.kr로 치환하여 출력\n\n```bash\ncat checkpassword | sed 's/121.156.118.254/pop3.mailplug.co.kr/g' | sed 's/14.36.253.67/office.ip.wiro.kr/g' checkpassword\n```\n\n10. 첨부파일 maillog를 이용하여 root@ma10.mailplug.co.kr에서 수신된 메일의 수를 출력\n\n```bash\nindex=0\n\nwhile read line\ndo\n\tif [[ \"$line\" =~ \"from <root@ma10.mailplug.co.kr>\" ]]; then\n\t\tlet value=$index+1\n\t\tindex=$value\n\tfi\ndone < maillog\n\necho $index\n```\n\n11. 첨부파일 maillog를 이용하여 시간별 총 용량만 아래와 같이 출력(bytes)\n\n```bash\nwhile read time byte\ndo\n\techo \"$time $byte\"\ndone < maillog | grep bytes | awk '{print $3\":\"$11}' | awk -F \":\" '{arr[$1]+=$4} END { for (i in arr) {print i \"\\t\" arr[i]}}' | sort | awk '{ if($1~\"(0[0-9])\") {sub(/0/,\"\")} print $1 \"시\\t\" $2}'\n```\n\n12. 첨부파일 conf를 이용하여 ; 로된 주석라인과 공백라인을 제외한 라인 출력\n\n```bash\ncat conf | egrep -v ^[[:space:]]*$ | grep -v \";\"\n```\n\n13. ps 명령어를 이용하여 pid값이 낮은순에서 높은순으로 정렬하여 출력\n\n```bash\nps -ef --sort=+pid \n```\n\n14. 첨부파일 nginx를 이용하여 접근을 한 국가별 카운트와 국가명 출력.\n\n```bash\nwhile read A B C D E F line\ndo\n\tgeoiplookup $F >> ip\ndone < nginx\n\ngrep '' ip | awk '{print $1,$2,$3,$4,$5,$6,$7}' | sort | uniq -c > 14result\ncat 14result\nrm ip\n```\n\n15. 첨부파일 nginx를 이용하여 3번 이상 접근한 국가별 카운트와 국가명 출력\n\n```bash\ncat 14result | awk '{if ($1>3) {print $0}}'\n```\n\n16. 반복문을 이용하여 1M의 용량을 가진 파일부터 10M까지의 총 10개 파일 생성(1M씩 증가)\n\n```bash\nfor time in {01..10}\ndo\n\ttruncate -s ${time}M ./${time}file\ndone\n\nfind ./ -name \"*file\"\n```\n\n17. 16번에서 생성한 파일 중 5M이상의 파일의 생성시간을 2017년 12월 31일로 변경\n\n```bash\nfind ./ -type f -size +5M -exec touch -t \"201712310000\" {} \\;\n```\n\n18. 17번에서 만든 파일 중 2017년 12월 31일 이후에 만들어진 파일을 찾아 해당파일명.new로 변경\n\n```bash\nfind -type f -newermt '2017-12-31' | grep file | xargs rename 's/file/file.new/'\n```\n\n19. 아래 그림을 test.c 파일로 작성 후 result.exe란 파일로 컴파일하여 실행하고 출력값을 test.txt로 저장\n\n```bash\ngcc -o result test.c\n./result > test.txt\necho \"test.txt 파일 내용\"\ncat test.txt\n```\n\n20. 121.156.118.15서버의 오픈 된 포트를 확인 후 해당 포트로 통신이 가능한지 모니터링하는 스크립트를 작성\n\n```bash\nwhile :\ndo\n\tnmap -sT 121.156.118.15\n\tsleep 5\ndone\n```\n\n모든 bash 파일 실행\n\nresult.bash\n```bash\nfor i in {1..19}\ndo\n\tbash $i.bash 5 5\n\techo \" \"\ndone\nrm 01file.new 02file.new 03file.new 04file.new 05file.new 06file 07file 08file 09file 10file\n\nbash 20.bash\n```\n\n## 배운 부분\n\n2번\n - 매주 일요일 부분을 빠트림\n\n6번\n - Window와 Linux는 개행 방식이 다르다.\n\n|window|Unix(Linux 및 Mac)|\n|------|-------|\n| \\r\\n | \\n |\n\n**vscode같은 곳에서 연결해서 사용한다면 관련된 설정 해줘야 한다.**\n\n17번\n - 문제를 보면 5M이상임. -size +4M으로 작성해야 한다.\n\n주의할점\n - dd 명령어 사용 시 input / output에 주의해라!\n - chown 명령어 사용 시 -R 옵션 줄 때 ./* 같이 경로를 정확히 사용 (/ 이렇게 주면 큰일난다.)\n\n중요한 명령어와 개념\n - find, ls, du, awk, sed, free, chown, chmod, 리눅스 권한부분은 상당히 중요!","excerpt":"bash 20문제 풀이 풀이 현재 자기신의 pc(linux기준)의 cpu모델명, Os 종류 및 버전, kernel 버전을 출력하시오. 매주 일요일, 새벽4시 30분과 낮12시 30분에, /tmp/* 를 삭제하는 crontab \n예) * * * * *…","fields":{"slug":"/bashMission/"},"frontmatter":{"date":"Feb 23, 2021","title":"bash 문제 풀이","tags":["Linux"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n리눅스 자주쓰는 명령어와 중요 개념 정리한다.\n\n# 1. find\n\n> find [path] [Option] [expression] : 파일이나 디렉터리를 찾고 싶을 때 사용하는 명령어\n\n**Tip!!**\n\n- 옵션을 통해 다양한 경우의 상황으로 찾기 가능\n- 시간 옵션 뒤에 부여해야 하는 숫자 tip!!\n  ![linux time 옵션](./findTimeOption.PNG)\n\n## 옵션\n\n```\n -name : 파일이나 디렉토리 이름\n -iname : 대소문자 구분 없이 이름으로 검색\n -user : 사용자 이름\n -group : 그룹 이름\n -uid : uid로 검색\n -gid : gid로 검색\n -perm : 권한으로 검색\n -type : 파일 유형으로 검색\n    (d : 디렉토리, f : 파일, l : 링크, s : 소켓)\n -atime n : 파일에 접근한 시간(파일을 Open할 때 마다 갱신된다)\n -ctime n : inode의 값(파일 속성, 권한, 크기 등)으로 검색\n -mtime n : 파일이 수정되었을 때 기준으로 검색\n   * time부분을 min으로 사용하면 분으로 검색\n   * 추가로 Suffix를 붙여 정확한 시간 지정 가능\n -empty : 빈 파일 찾기\n -exec : 명령 내릴 수 있는 옵션 / 결과 값 {}, \\;로 끝내야 한다.\n -size n : n블록 길이의 파일\n -inum n : inode\n -maxdepth n : 파일 계층 depth의 최대값 설정\n -mindepth n : 파일 계층 depth의 최소값 설정\n -prune : 값을 찾으면 하위 디렉토리에 들어가서 찾지 않음\n -newer : 뒤에 적힌 파일보다 최근에 변경된 파일 찾음\n```\n\n## 사용 예제\n\n```bash\n# 수정된지 100일이 지난 파일 목록 출력\n$ find -mtime +100\n\n# php 디렉토리 파일 중, 오늘 생성한 디렉토리를 삭제하시오\n$ find ~/php/* -ctime 0 -type d -exec rm -r {} \\;\n\n# 연결되지 않은 심볼릭 링크 찾는 방법\n$ find -L . -type l\n\n# 현재 디렉토리에서 test로 시작하는 디렉토리만 찾아 삭제\n$ rm -r `find -name 'test*' -type d`\n\n```\n\n**Tip!!**\n\n- 명령어에서 `(backtick)사용 : 스크립트 내에서 명령어를 실행할 경우 이용\n- 2>/dev/null : 명령어 뒤에 추가로 달아주면 권한 없는건 화면에 출력되지 않는다.\n\n# 2. grep\n\n> grep [option] [pattern] [file_name] : 특정 문자열을 파일에서 찾아주는 명령어\n\n- pattren에는 정규 표현식 메타 문자가 들어간다.\n\n**Tip!!**\n\n- egrep\n- egrep은 grep의 확장판\n- grep이 하나의 문자열을 찾는 것 과는 달리, 여러 개의 문자열을 동시에 찾기 가능\n- grep에서 활용할 수 있는 메타문자 이외에 추가 정규 표현식 메타문자 사용 가능\n\n+: +앞의 정규표현식이 1회 이상 나타남  \n?: ?앞의 정규표현식이 0회 또는 1회 나타남  \n|: 문자열간의 OR연산자  \n(): 정규표현식을 둘러쌈\n\n## 옵션\n\n```\n -b : 검색 결과의 각 행 앞에 블록번호 표시\n -c : 찾아낸 행의 총 개수 출력\n -i : 대소문자 구분 x\n -l : 대소문자 구분 o\n -n : 파일 내에서 행 번호를 함께 출력\n -s : 에러 메세지 외에 표시 x\n -G : 기본 정규식으로 검색\n```\n\n## 사용 예제\n\n```bash\n# 'm'으로 시작하는 모든 파일에서 'hamster'를 포함하는 모든 행을 찾으시오\n$ grep -n hamster m*\n\n# grep을 사용하여 마침표로 시작되는 줄을 찾으시오\n$ grep ^\\. {찾을 파일 / 디렉토리 명}\n\n# NW나 EA가 포함된 행을 출력한다\n$ egrep 'NW|EA' {file 명}\n\n# 숫자 3이 한 번 이상 등장하는 행 출력\n$ egrep '3+' {file 명}\n\n```\n\n# 3. awk\n\n> awk [옵션]\n> 문서에서 패턴을 검사해 원하는 값 얻는다.\n\n```\n$ awk {-f 파일명} {-F 필드 구분자} {\"패턴\"} {처리할 파일명}\n```\n\n- pattern 생략 시 **모든 레코드 적용**\n- action 생략 시 **print 적용**\n- pattern과 action에 작성되는 awk program 코드에는 표현식, 변수, 함수 사용 가능\n\n## 옵션\n\n```\n-F : 필드 구분 문자 지정\n-f : awk program 파일 경로 지정\n-v : awk program에서 사용될 특정 variable값 지정\n```\n\n## 사용 예제\n\n```bash\n# pattern 생략\n$ awk '{print}' ./file.txt\n\n# action 생략\n$ awk '/p/' ./file.txt\n\n# 레코드의 길이가 10 이상인 경우, 세 번째($3), 네 번째($4), 다섯 번째($5) 필드를 출력\n$ awk 'length($0) > 10 { print $3, $4, $5} ' {파일 이름}\n\n\n```\n\n# 4. Redirection\n\n> 명령의 결과를 모니터로 출력하지 않고, 파일로 저장할 수 있다. (리다이렉션을 사용해 출력, 입력 방향 지정 가능)\n\n표준 입출력(Standard I/O)\n\n| 구분      | 파일 디스크럽터 |\n| --------- | --------------- |\n| 표준 입력 | 0               |\n| 표준 출력 | 1               |\n| 표준 에러 | 2               |\n\n| 기호 | 기능             |\n| ---- | ---------------- |\n| >/>> | 출력 방향 재지정 |\n| </<< | 입력 방향 재지정 |\n| >    | 덮어 쓴다.       |\n| >>   | 추가된다.        |\n\n# 5. vi\n\n- 텍스트 편집기\n- 3가지 모드가 있다.\n  - 입력(내용입력), 명령(편집기능), 콜론(열기, 저장, 추가기능 수행)\n\n## 문자열 치환\n\n> : [범위] / [매칭 문자열] / [치환문자열] / [행범위]\n\n**Tip!!**\n\n- gg : 최상단으로 커서 옮김\n- 0 : 현재 줄 맨 앞\n- $ : 현재 줄 맨 뒤\n- dd : 라인 삭제\n- u : 복구\n- p : 붙여 넣기\n- yy : 라인 복사\n- :wq : 저장 후 종료\n- .vimrc 파일에 환경설정 가능!\n\n# 6. sed(stream deitor)\n\n> 필터링과 텍스트를 변환하는 스트림 편집기\n\n## 주요기능\n\n```bash\n# 1. 치환\n# addrass를 address로 바꾼다.\n$ sed 's/addrass/address/' {파일이름}\n\n# tab문자를 enter로 변환\n$ sed 's/\\t/\\ /' {파일이름}\n\n# 2. 삭제\n# 처음 1줄, 2줄을 지운다.\n\n# 공백라인을 삭제하는 명령\n$ sed '/^$/d {파일 이름}\n\n```\n\n[jhnyang님 블로그](https://jhnyang.tistory.com/287)\n\n# 7. ls\n\n> 현재 폴더의 하위 디렉토리의 리스트 출력\n\n## 옵션\n\n# 8. 사용자 권한 (chmod, chown)\n\n리눅스는 사용자 및 그룹에 기반하여 액세스를 허가하거나 금지한다.\n\n## chown\n\n> 파일의 소유권 바꾸기 위해 사용\n\n```bash\nchown [OPTION]... [OWNER][:[GROUP]] FILE...\n```\n\n## chmod\n\n> 파일이나 디렉토리의 모드를 변경\n\n```bash\n$ chmod {옵션} {권한} {파일}\n```\n\n# 9. tty\n\n- 로그인 한 모든 세션은 각각 고유의 tty를 가지고 있다.\n- 입력과 출력을 처리한다.\n\n```bash\n$ tty\n\n/dev/pts/0\n```\n\n# 10. alias\n\n> 사용자가 원하는 명령어를 추가하기 위한 명령어\n\n사용 예제\n\n```\n$ alias la='ls -a'\n$ alias lf='ls -F'\n$ alias lr='ls -R'\n$ alias ri='rm -i'\n$ alias mi='mv -i'\n```\n\n- alias를 입력하면 입력 된 alias를 확인할 수 있다.\n- ~/.bashrc에 정의하면 쉘이 시작할 때 자동으로 정의된다.\n\n# 11. history\n\n> 커맨드 이력 관리 명령어\n\n- ~/.bash_history 에 저장\n\n히스토리 관련 환경변수\n\n```\nHISTFILE : command 저장 파일\nHISTFILESIZE : 히스토리 파일 최대 크기\nHISTSIZE : 히스토리에 저장 가능한 최대 명령어 개수\n```\n\n**Tip!!**\n\n- history -w {파일 이름}: 별도의 파일로 저장\n- !! : 바로 직전 커맨드 실행\n- !n : history n 번째에 저장된 명령어 실행\n- !{string} : string으로 시작하는 가장 최근 실행한 커맨드 찾아 실행\n- :p : :p를 붙여서 실행 시 커맨드만 출력\n\n# 12. jobs / 포그라운드 백그라운드\n\n- jobs : 현재 쉘에서 작업 중지된 상태나 백그라운드로 진행되는 작업 표시\n- bg : 백그라운드 프로세스 확인\n- & : 프로세스를 백그라운드로 실행\n\n# 13. ps\n\n> 현재 실행중인 프로세스 목록과 상태를 보여준다.\n\n# 14. 심볼릭 링크, 하드 링크\n\n> 하나의 파일에 두개의 이름 사용하게 링크를 연결\n\n사용하는 경우\n\n- 매우 긴 파일명이 있을 때\n- 경로를 입력하지 않고 파일명만 입력해 사용할 때\n\n* 서버(nginx)가 바라보는 경로설정 같은 경우에도 사용한다.\n\n## 차이점\n\n| 하드 링크                      | 심볼릭 링크                          |\n| ------------------------------ | ------------------------------------ |\n| 파일에만 링크 가능             | 파일 또는 디렉토리에 링크 할 수 있음 |\n| 존재하지 않는 파일 링크 불가능 | 존재하지 않는 파일에 대해 링크 가능  |\n| 같은 파일 시스템에서만 가능    | 다른 파일 시스템에서 가능            |\n\n# 15. du / df\n\n## du\n\n> 디렉토리 사용량 확인\n\n### 옵션\n\n```\n-a : 모든 파일들의 기본정보를 보여준다.\n-b : 표시단위를 기본 KB 대신 Byte로 한다.\n-k : 표시단위를 KB 단위로 한다.\n-h : 파일들의 용량단위가 보기좋게 정리되어 보여준다.\n-c : 모든 파일들의 디스크 사용정보를 보여주고 나서 합계를 보여준다.\n-s : 총 사용량만 표시\n-x : 체크하는 경로안에 다른 시스템이 있으면 생략\n```\n\n## df\n\n> 디스크의 사용가능한 용량 확인\n\n# 16. dd\n\n> 파일을 변환하고 복사하는 명령어\n\n```\n$ dd if={입력} of={출력} bs={바이트} count={반복}\n\nibs = bytes     #한번에 bytes 바이트씩 읽는다.\nobs = bytes     #한번에 bytes 바이트씩 쓴다.\nskip = n        #n*ibs 바이트만큼 무시하고 읽는다.\nseek = n        #n*obs 바이트만큼 무시하고 쓴다.\n```\n\n# 17. cat\n\n> cat {옵션} 파일명\n\n파일 내용 출력\n\n# 18. cron\n\n> unix 운영체제에서 어떤 작업을 특정 시간에 실행시키기 위한 데몬\n\ncron 작업을 설정하는 파일을 crontab이라고 부른다.\n\n형식\n\n```\n* * * * * {명령어}\n\n분/시/일/월/요일\n```\n\n추가 기호\n\n```\n , : 복수개의 시간 지정\n * : 모든 시간 지정\n - : 시간의 범위 지정\n / : 시간 간격을 지정\n```\n\n크론 조회\n\n```bash\n$ crontab -l\n```\n\n크론 접근 권한 설정은 관련된 파일로 명시해준다.\n\n- /etc/cron.allow\n- /etc/cron.deny\n- /etc/con.d/cron.deny\n\n# 19. cut\n\n> cut {option} {file}\n\n파일에서 필드 추출, 필드는 구분자로 구분 가능\n\n옵션\n\n```\n -c : 잘라낼 곳의 위치 지정. (콤마나 하이픈으로 범위 설정 가능)\n -f : 잘라낼 필드 설정\n -d : 필드 구분 문자 지정\n```\n\n# 20. tar / gzip\n\ntar : gzip 명령이 포함된 압축 툴\ngzip : 파일 압축 명령어\n\n# 21. wc\n\n> wc {옵션} {파일}\n> 각각의 파일에 대한 줄(line), 단어(word), 문자(char), 바이트(byte) 수를 알려준다.\n\n## 옵션\n\n```\n-c : byte 수를 알려준다.\n-m : 문자 수를 알려준다.\n-l : 줄 수를 알려준다.\n-L : 가장 긴 줄의 길이를 알려준다.\n```\n\n# 22. Tree\n\ntree 명령어는 기본적으로 존재하는 명령어가 아니므로 apt이나 yum을 이용해 설치한다.\n\n```bash\n$ tree --help\n```\n\n명령어로 트리의 옵션을 볼 수 있다.\n![tree 옵션](./treeOption.PNG)\n\ntree 명령어의 실행 화면이다.\n\n![tree 실행 화면](./treeResult.PNG)\n","excerpt":"리눅스 자주쓰는 명령어와 중요 개념 정리한다. 1. find find path Option expression : 파일이나 디렉터리를 찾고 싶을 때 사용하는 명령어 Tip!! 옵션을 통해 다양한 경우의 상황으로 찾기 가능 시간 옵션 뒤에 부여해야 하…","fields":{"slug":"/linuxStudy/"},"frontmatter":{"date":"Feb 22, 2021","title":"Linux Study","tags":["Linux"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n1.소유자가 george이고 그룹이 others일때 data파일의 소유자와 그룹을 동시에 변경하시오.\n\n```bash\n$ chown georage:others data\n```\n\n2.현재 로그인한 사용자의 목록에서 2016­01­07에 접속한 사용자를 출력하시오.\n\n```bash\n$ who | grep '2016-01-07'\n```\n\n3.접근권한이 755인 data 디렉토리를 생성하시오(명령어 1개 이용).\n\n```bash\n$ mkdir -m 755 data\n```\n\n4.현재 디렉토리에서 링크파일만 찾는 lnfind란 alias를 생성하시오.\n\n```bash\n$ alias lnfind='find ./ -type l'\n```\n\n5.현재 디렉토리에서 24시간 내에 수정된 파일을 찾으시오.\n\n```bash\n$ find ./ -mtime -1\n```\n\n6.현재 디렉토리에서 test로 시작하는 디렉토리만 찾아 삭제하시오.\n\n```bash\n$ rm -r `find -name 'test*' -type d`\n```\n\n7.ssh를 이용하여 kumquat란 서버에 /test2란 디렉토리를 생성하시오.\n\n```bash\n$ ssh root@kumquat mkdir /test2\n```\n\n8.test1과 test2의 내용을 비교하는 명령어를 작성하시오.\n\n```bash\n$ diff test1 test2\n```\n\n9.test1 test2 test3을 리다이렉트를 이용하여 test4의 파일로 합치시오.\n\n```bash\n$ cat test1 test2 test3 > test4\n```\n\n10.test5 파일의 마지막 10개의 행을 출력하시오.\n\n```bash\n$ tail test5\n```\n\n11./etc/group과 /etc/passwd에서 root가 있는 라인의 개수를 출력하시오.\n\n```bash\n$ grep -c 'root' /etc/group/* /etc/etc/password/*\n```\n\n12.test6파일에서 시작문자가 a, 마지막 문자가 z로 끝나는 문장을 출력하시오.\n\n```bash\n$ grep -E '^a.*z$' test 6\n```\n\n13.test6파일에서 mail이 나오는 행과 plug가 나오는 행 사이의 모든 행을 출력하시오.\n\n```bash\n$ sed -e '/mail/, /plug/' test6\n```\n\n14.test7파일을 gzip으로 압축하시오.\n\n```bash\n$ gzip test7\n```\n\n15.test8파일의 가장 긴 줄의 길이를 출력하시오.\n\n```bash\n$ wc -L test8\n```\n\n16.vi ex에서 10행부터 파일의 끝까지를 test9로 저장하시오.\n\n```bash\n:10,$ w test9\n```\n\n17.vi ex에서 help 또는 Help라는 단어를 모두 HELP로 변경하시오.\n\n```bash\n:%s/[Hh]elp/HELP/g\n```\n\n18.dd를 사용하여 블록사이즈가 2바이트이고 10블록으로 null(/dev/zero)문자로 채워진 test10파일을 생성하시오.\n\n```bash\n$ dd if=/dev/zero of=test10 bs=2 count=10\n```\n\n19.test11파일의 3번째 필드를 기준으로 정렬하시오.\n\n```bash\n$ sort -k 3 test11\n```\n\n20.test12파일을 역순으로 정렬하고 중복되는 라인을 제거하고 출력하시오.\n\n```bash\n$ sort -ur test12\n```\n\n21.월요일마다 새벽 4시 30분에 /bin/date를 실행하는 cron문을 작성하시오.\n\n```bash\n$ 30 4 * * 1 /bin/date\n```\n\n22.최근에 사용한 명령 20개를 출력하시오.\n\n```bash\n$ history 20\n```\n\n23.cut명령어로 test14파일의 \"_\"를 구분자로 지정하여 두번째 필드를 출력하시오.\n\n```bash\n$ cut -d\"_\" -f2\n```\n\n24.touch명령어를 이용하여 test15파일을 2016년 1월 1일로 변경하시오.\n\n```bash\n$ touch -t 201601010000 test15\n```\n\n25.nginx프로세스에 대한 정보를 출력하시오.\n\n```bash\n$ ps -ef | grep nginx\n```\n\n26.2342의 pid를 가진 프로세스를 종료하시오.\n\n```bash\n$ kill -9 2342\n```\n\n27.ls를 백그라운드로 동작시키시오.\n\n```bash\n$ ls &\n```\n\n28.백그라운듸 작업목록을 출력하시오.\n\n```bash\n$ jobs\n```\n\n29.test16의 파일을 test.tar로 압축하시오.\n\n```bash\n$ tar -cvf test.tar test16\n```\n\n30.일정한 크기를 가진 여러 개의 작은 파일로 분할하는 명령어를 이용하여 test17파일을 20행씩 분할하시오.\n\n```bash\n$ split -l 20 test17\n```\n\n31.memory의 상세정보를 볼수있는 파일의 위치를 작성하시오.\n\n```bash\n$ which free\n\n=> /usr/bin/free\n```\n\n32.명령어의 위치를 찾을 수 있는 명령어를 작성하시오.\n\n```bash\n$ which\n$ whereis\n```\n\n33.60초동안 대기하는 명령어를 작성하시오.\n\n```bash\n$ sleep 60\n```\n\n34./dev/sda5를 /mnt에 마운트하는 명령어를 작성하시오.\n\n```bash\n$ mount /dev/sda5 /mnt\n```\n\n35.작업 중인 터미널창이 종료 되더라도 실행 중인 프로세스를 백그라운드 프로세스로 계속 작업할 수 있도록 하는 명령어를 작성하시오.\n\n```bash\n$ nohup {실행}&\n```\n\n\n36.apt­get 명령이 패키지 관련 정보를 확인하기 위해 참조하는 파일의 위치를 작성하시오.\n\n```bash\n$ /etc/apt/sources.list\n```\n\n37.yum을 이용하여 nginx 패키지를 제거하는 명령어를 작성하시오.\n\n```bash\n$ yum remove nginx\n```\n\n38.커널에 로드되어 있는 모듈을 확인하는 명령어를 작성하시오.\n\n```bash\n$ lsmod\n```\n\n39.현재 파일시스템들의 사용량을 MB단위로 출력하시오.\n\n```bash\n$ df -m\n```\n\n40./home/test18읠 디렉토리의 사용량을 KB단위로 출력하시오.\n\n```bash\n$ du -k ./home/test18\n```\n\n41.awk를 이용하여 test19파일의 필드 개수를 출력하시오.\n\n```bash\n$ awk '{print NF}' test19\n```\n\n42.awk를 이용하여 test20파일의 \"_\"를 구분자로 하는 첫번째와 세번째 필드를 출력하시오.\n\n```bash\n$ awk -F_ '{print $1, $3}' test20\n```\n\n43.cat nofile의 표준에러를 표준출력으로 리다이렉트하시오.\n\n```bash\n$ awk -F_ '{print $1, $3}' test19\n```\n\n44.basename /home/mkel/bin/test.sh 의 결과값을 작성하시오.\n\n```bash\n$ test.sh\n```\n\n45.test21의 계정의 로그인 쉘을 sh로 변경하시오.\n\n```bash\n$ vi /etc/passwd\n\ntest21의 7번째 필드 값을 sh로 변경\n```\n\n46.시스템을 부팅 시 자동으로 마운트되게 하기 위해 설정해야 하는 파일의 위치를 작성하시오.\n\n```bash\n/etc/fstab\n```\n\n47.호스트끼리 메일 메시지를 주고받기 위한 간단하고 확장성이 있는 프롤토콜은 무엇인가?\n\n```bash\n$ SMTP(Simple Mail Transfer Protocol) 프로토콜\n```\n\n48.mailplug.co.kr의 DNS 질의를 할 수 있는 명령어를 작성하시오.\n\n```bash\n$ nslookup mailplug.co.kr\n```\n\n49.listen되고 있는 포트의 네트워크 정보상태를 출력하시오.\n\n```bash\n$ netstat -tnlp\n```\n\n50.bash에서 2MB보다 큰 파일을 만들지 못하게 하는 명령어를 작성하시오.\n\n```bash\n$ ulimit -f 2000\n```\n\n","excerpt":"1.소유자가 george이고 그룹이 others일때 data파일의 소유자와 그룹을 동시에 변경하시오. 2.현재 로그인한 사용자의 목록에서 2016­01­07에 접속한 사용자를 출력하시오. 3.접근권한이 755인 data 디렉토리를 생성하시오(명령어 …","fields":{"slug":"/linuxProblem2/"},"frontmatter":{"date":"Feb 21, 2021","title":"Linux 문제 풀이2","tags":["Linux"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n1. 수정된지 100일이 지난 파일 목록을 출력하시오. (명령어 : find)\n\n```bash\n$ find -mtime +100\n```\n\n2. (a)에서 (b)의 결과를 얻으시오 (명령어: ll)\n![](2번.PNG)\n\n```bash\n$ ll -rt\n```\n\n3. 명령어가 저장되는 history 파일의 경로는 어디인가\n\n```bash\n$ ~/.bash_history\n```\n\n4. 저장된 히스토리를 파일명 ‘myhistory.log’ 으로 저장하시오\n\n```bash\n$ history > myhistory.log\n```\n\n5. 아래 디렉토리의 소유자/그룹을 하위 디렉토리, 파일까지 전부 nobody 로 변경하시오. (명령어:chown)\n![](5번.PNG)\n\n```bash\n$ chown -R nobody:nobody ./*\n```\n\n6. temp 디렉토리의 파일 중, 하루가 지난 파일을 삭제하시오 (명령어: find)\n\n```bash\n$ find /temp -ctime +0 -type f -exec rm -f {} \\;\n```\n\n7. screen 명령어를 사용하여, 서버와의 연결이 비정상종료되더라도, session은 유지한 채 작업을 할 수 있다. 이\n때 단축키를 사용하여 screen에서 빠져 나오시오.\n\n```bash\nCTRL + a + d\n```\n\n8. 자신이 사용하고 있는 tty를 출력하시오.\n\n```bash\ntty\n```\n\n9. 아래 그림과 같이 단계적인 디렉토리를 한번에 생성하시오.\n![](9번.PNG)\n\n```bash\nmkdir -p 1/2/3/4\n```\n\n10. grep 명령어의 위치를 출력하시오.\n\n```bash\n$ which grep\n\n$ whereis grep\n```\n\n11. 상위디렉토리로 이동하는 ‘cd..’ 를 ‘pd’로 정의하시오. (alias)\n\n```bash\nalias pd='cd..'\n``` \n\n12. 이전에 친 ‘vi mytest’ 명령어를 다시 출력하는 방법은 무엇인가.\n\n```bash\n$ !!\n\n$ !{history에 명령어 번호}\n```\n\n13. 아래 출력결과를 현재 경로 내에 result.txt 파일로 저장하시오.\n![](13번.PNG)\n\n```bash\n$ ll > result.txt\n```\n\n14. 5개의 백그라운드(background) 작업 중, 3번 작업을 포그라운드(foreground)로 가져오시오.\n\n```bash\n$ fg %3\n```\n\n15. 이름 ‘vi’ 프로세스를 찾아 종료시키시오. (‘vi’ 프로세스 id는 9140으로 가정한다.)\n\n```bash\n$ ps -ef | grep vi\n\n$ kill 9140\n```\n\n16. (a)에서 (b)의 결과를 얻으시오 (명령어: ll)\n![](16번.PNG)\n\n```bash\n$ ll -d\n```\n\n17. ‘test.txt’ 파일에서 상단 10줄을 읽어 오류만 ‘error.txt’ 에 저장하시오.\n\n```bash\n$ head test.txt 2> error.txt\n```\n\n18. ‘test.txt’ 파일에 ‘link_test’ 이름으로 심볼릭 링크를 생성하시오.\n\n```bash\n$ ln -s test.txt link_test\n```\n\n19. (a)에서 (b)의 결과를 얻으시오 (명령어: du)\n![](19번.PNG)\n\n```bash\n$ du -ah\n``` \n\n20.  현재 디렉토리의 모든 파일에서 ‘mail’ 이라는 패턴이 들어간 파일의 이름을 출력하라. (명령어 : grep)\n\n```bash\n$ grep -l 'mail' *\n```\n\n1.  ‘m’으로 시작하는 모든 파일에서 ‘hamster’ 를 포함하는 모든 행을 찾으시오.(명령어 : grep)\n\n```bash\n$ grep -n hamster m*\n```\n\n22. 현재 디렉토리 내의 ‘test.txt’ 파일에서 ‘:’ 구분자를 이용하여 3번째 필드를 출력하라 (명령어 : awk)\n\n```bash\n$ awk -F: '{ print $3 }' test.txt\n```\n\n23. 현재 디렉토리 내의 ‘test.txt’ 파일에서 1행에서 3행까지 출력하라. (명령어 : sed)\n\n```bash\n$ sed -n '1,3p' test.txt\n```\n\n24. vi 에디터의 탭간격을 4로 설정하시오. (vi 에디터를 실행시켰다고 가정)\n \n```bash\n:set sts=4\n```\n\n25. 다음 vi 화면에서 ‘if’를 ‘testif’ 로 한번에 변경하시오.\n![](25번.PNG)\n\n```bash\n:%s/if/testif/g\n``` \n\n1.  실행중인 터미널의 사이즈를 구하시오.\n\n```bash\n$ stty size\n```\n\n27. 로그인 하고 있는 모든 사용자를 출력하시오.\n\n```bash\n$ who\n```\n\n28. 현재 서버의 메모리와 캐시사용량을 mb 단위로 출력하시오.\n\n```bash\n$ free -m\n```\n\n29. 현재 디렉토리에 linuxwr.txt라는 파일을 만드는 alias를 작성하시오. (alias명 : linuxtest)\n \n```bash\n$ alias linux=\"touch linuxwr.txt\"\n```\n\n30. 포그라운드(foreground)로 실행중인 프로세스를 일시 중지하는 단축키는 무엇인가.\n \n```bash\nCTRL + Z\n```\n\n31.  아래 리스트에서 ‘6자리 단어이자, 대소문자 구분없이 ‘y’ 가 포함되는’ 단어의 개수를 출력하라.\n(명령어:more)\n![](31번.PNG)\n\n```bash\nmore list | grep -w '......' | -ic 'y'\n```\n\n32. ‘diff -u b a’ 명령어를 이용하여 아래와 같은 결과를 도출하였다. 결과값을 가지고 a파일을 만드시오.\n![](32번.PNG)\n\n```bash\ndiff -u b a > a\n```\n\n33. 당일 오후 1시로 알람을 지정한 뒤, 프로세스를 죽이시오 (PID는 9140으로 가정한다.)\n \n```bash\nkill -14 9999 | at 13:00\n```\n\n34.  10G의 더미파일(빈파일)을 만들고자 한다. 흰색을 채우시오. (파일명은 ‘mailplug’로 지정한다.)\n![](34번.PNG)\n\n```bash\n$ dd if=/dev/zero of=파일명 bs=1GB count=10\n```\n\n35. 시그널 이름 중 ‘SIGQUIT’ 는 몇 번에 해당하는가?  \n\n```\na. 19 b.17 c.15 d.3 e.1\n```\n\n```bash\n3\n``` \n\n36.  csh 에서 로그아웃할 때 백그라운드 프로세스들을 자동으로 죽일 때, 어느 파일을 참조하는가?\n```\na. .logout b. .bash_history c. .bashrc d. .bash_logout e. hamster\n```\n\n정답 : a\n\n```bash\n$ ~/logout\n```\n\n37.  grep 을 사용하여 마침표로 시작되는 줄을 찾으시오.\n\n```bash\n$ grep ^\\. {찾을 파일/디렉토리 명}\n```\n\n38. 디렉토리 내에서 가장 새로운 파일의 이름을 출력하는 방법은 무엇인가 (명령어: ls)\n\n```bash\n$ ls -t1 | head -1\n```\n\n39. 연결되지 않은 심볼릭 링크 찾아내는 방법은 무엇인가 (명령어: find)\n\n```bash\n$ find -L . -type l\n```\n\n40. ‘rm’ 명령어 사용시, 바로 삭제시키지 않고 한번 더 물어본 후 삭제시키고자 할 때 사용하는 옵션은?\n\n```bash\n$ rm -l file\n```\n\n41. ‘cat’ 명령어 옵션 중, ‘tab과 행바꿈 문자를 제외한 제어 문자를 ^ 형태로 출력해 주는’ 옵션은?\n\n```bash\n$ cat -v file\n```\n\n42. 0.0.0.0 에서 999.999.999.999 까지 표현할 수 있는 정규표현식을 작성하시오.\n\n```bash\n$ [0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\n```\n\n43. ‘egrep’ 명령어를 이용하여 ‘testfile’ 내 ‘숫자 3이 한 번 이상 등장하는 행을 출력하시오’.\n\n```bash\n$ egrep '3+' testfile\n```\n\n44. 디렉토리 구조는 아래와 같다. a.py 를 vi 편집기로 연 후, 빠져 나오지 않은 채, b.py 로 전환하시오.\n (cf. a.py 파일을 연 후, :q 명령은 내리지 않는다.)  \n\n![](44번.PNG)\n\n```bash\n:e b.py\n```\n\n45. 파일의 제일 앞부분에 있는 100개의 문자를 삭제하시오 (명령어 : dd)\n\n```bash\ndd if={input file이름} of={output file이름} ibs=1 slip100 conv=cotrunc\n```\n\n46. ‘test.log’ 파일을 정렬하여, 동일 디렉토리 내 ‘result.log’ 에 작성하시오. (명령어 : sort)\n\n```bash\n$ sort -o result.log test.log\n```\n\n47. 백그라운드로 실행중인 프로세스나 현재 중지된 프로세스 목록을 PID와 같이 출력하라.\n\n```bash\n$ jobs -l\n```\n\n48. 현재 등록된 crontab에 등록된 작업을 출력하시오\n\n```bash\n$ crontab -l\n```\n\n49. 아래 crontab 에 대해 맞는 설명은?\n![](49번.PNG)\n\n```\n a. 새벽 4시부터 낮12까지 30분 간격으로 로그파일 삭제.\n b. 매주 일요일, 새벽4시 30분과 낮12시 30분에, 로그파일 삭제.\n c. 매월 4일, 12일에 매시간 30분에 로그파일 삭제\n d. 새벽4시와 낮 12시, 30분에 로그파일 삭제\n e. 매월 30일 새벽4시와 낮12시에 로그파일 삭제\n```\n\n정답 : d\n```bash\n매일 4시 30분 12시 30분에 홈디렉토리의 모든 로그파일 삭제\n```\n\n1.   vi 편집기내에서 문서 최상단으로 커서를 위치시키는 명령어는?\n\n```bash\ngg\n\n1G\n```\n","excerpt":"수정된지 100일이 지난 파일 목록을 출력하시오. (명령어 : find) (a)에서 (b)의 결과를 얻으시오 (명령어: ll)\n 명령어가 저장되는 history 파일의 경로는 어디인가 저장된 히스토리를 파일명 ‘myhistory.log’ 으로 저장하…","fields":{"slug":"/linuxProblem1/"},"frontmatter":{"date":"Feb 20, 2021","title":"Linux 문제 풀이1","tags":["Linux"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# 위상 정렬\n> 싸이클이 없는 방향 그래프의 모든 노드를 **방향성에 거스르지 않도록 순서대로 나열**\n\n**Tip!!**\n1. 그래프에서 **방문 조건이 주어질 때 사용!!**\n2. 시간 복잡도 **O(V+E)**이다.\n   (모든 노드를 확인하면서, 해당 노드에서 출발하는 간선을 차례대로 제거하기 때문)\n\n## 구현 방법\n\n### 1. DFS 활용\n\n```\n1. DFS 실행\n2. DFS가 끝날 때 스택에 삽입\n\n```\n\n### 2. BFS와 In-degree 활용\n\n```\n1. 모든 간선을 읽으며 InDegree 테이블을 채운다.\n2. Indegree가 0인 정점을 모두 큐에 넣는다.\n3. 큐의 Front에 있는 정점을 가져와 위상정렬 결과에 추가한다.\n4. 해당 정점으로부터 연결된 모든 정점의 Indegree값을 1 감소 시킨다.\n   이 때 Indegree가 0이면 그 정점을 큐에 추가\n5. 큐게 빌 때까지 3,4번을 반복\n```\n\n**Tip!!**\n - **루프가 V번 돌기전에 큐가 비면** 위상정렬이 **불가능**\n - **큐의 크기가 2이상인 경우가 생기면** 위상정렬 **결과가 2개 이상**\n\n## 백준 2623 - 음악 프로그램\n\n---\n\n![2623pb1](2623pb1.PNG)  \n![2623pb2](2623pb2.PNG)  \n\n---\n\n### 풀이\n---\n\n간선을 입력받을 때 슬라이딩 윈도우 방식을 사용한다. \n\nBFS / Indegree를 활용해 위상정렬\n\n---\n\n```java\npackage TopologySort;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class num2623 {\n\tstatic int N, M;\n\tstatic int[] indegree;\n\tstatic Queue<Integer> q = new LinkedList<Integer>();\n\tstatic ArrayList<Edge>[] edge;\n\tstatic int[] result;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st;\n\t\tst = new StringTokenizer(br.readLine());\n\t\t\n\t\tN = stoi(st.nextToken());\n\t\tM = stoi(st.nextToken());\n\t\t\n\t\tindegree = new int[N+1];\n\t\tresult = new int[N+1];\n\t\tedge = new ArrayList[N+1];\n\t\t\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tedge[i] = new ArrayList<Edge>();\n\t\t}\n\t\t\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tint testCase = stoi(st.nextToken());\n\t\t\tif(testCase==0) continue;\n\t\t\t\n\t\t\tint prev = stoi(st.nextToken());\n\t\t\tfor(int j=1; j<testCase; j++) {\n\t\t\t\tint now = stoi(st.nextToken());\n\t\t\t\tindegree[now]++;\n\t\t\t\tedge[prev].add(new Edge(prev, now));\n\t\t\t\tprev = now;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=1; i<=N; i++)\n\t\t\tif(indegree[i]==0) q.add(i);\n\t\t\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tif(q.isEmpty()) {\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint now = q.poll();\n\t\t\tresult[i] = now;\n\t\t\tfor(Edge e : edge[now]) {\n\t\t\t\tindegree[e.e]--;\n\t\t\t\tif(indegree[e.e]==0)\n\t\t\t\t\tq.add(e.e);\n\t\t\t}\n\t\t}\n\t\tfor(int num : result) {\n\t\t\tSystem.out.println(num);\n\t\t}\n\t\t\n\t}\n\tstatic class Edge{\n\t\tint s, e;\n\t\tEdge(int s, int e){\n\t\t\tthis.s = s;\n\t\t\tthis.e = e;\n\t\t}\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\n}\n\n```\n\n## 백준 1516 - 게임 개발\n\n---\n\n![1516pb1](1516pb1.PNG)  \n![1516pb2](1516pb2.PNG)  \n\n---\n\n### 풀이\n---\n\n이 전 문제와 비슷한데 출력을 비용으로 해준다.\n -> result배열에 간선의 값을 더해준다.\n\n---\n\n```java\npackage TopologySort;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class num1516 {\n\tstatic int N, M;\n\tstatic int[] indegree, result, weight;\n\tstatic Queue<Integer> q = new LinkedList<Integer>();\n\tstatic ArrayList<Edge>[] edge;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\t\n\t\tN = stoi(st.nextToken());\n\t\t\n\t\tindegree = new int[N+1];\n\t\tresult = new int[N+1];\n\t\tedge = new ArrayList[N+1];\n\t\tweight = new int[N+1];\n\t\t\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tedge[i] = new ArrayList<Edge>();\n\t\t}\n\t\t\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tweight[i] = stoi(st.nextToken());\n\t\t\twhile(true) {\n\t\t\t\tint prev = stoi(st.nextToken());\n\t\t\t\tif(prev == -1) break;\n\t\t\t\tindegree[i]++;\n\t\t\t\tedge[prev].add(new Edge(prev, i));\n\t\t\t}\n\t\t\tif(indegree[i] == 0){\n\t            result[i] = weight[i];\n\t            q.add(i);\n\t        }\n\t\t}\n\t\t\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tif(q.isEmpty()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint now = q.poll();\n\t\t\t\n\t\t\tfor(Edge next : edge[now]) {\n\t\t\t\tresult[next.e] = Math.max(result[next.e], result[now]+weight[next.e]);\n\t\t\t\tindegree[next.e]--;\n\t\t\t\tif(indegree[next.e]==0)\n\t\t\t\t\tq.add(next.e);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=1; i<=N; i++)\n\t\t\tSystem.out.println(result[i]);\n\t\t\n\t}\n\tstatic class Edge{\n\t\tint s, e;\n\t\tEdge(int s, int e){\n\t\t\tthis.s = s;\n\t\t\tthis.e = e;\n\t\t}\n\t}\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\n}\n\n```\n\n## 백준 2252 - 줄 세우기\n\n---\n\n![2252pb1](2252pb1.PNG)  \n![2252pb2](2252pb2.PNG)  \n\n---\n\n### 풀이\n---\n\n2623번과 거의 동일하다\n\n---\n\n```java\npackage package34;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class num2252 {\n\tstatic int N, M;\n\tstatic int[] indegree,result;\n\tstatic ArrayList<Edge>[] edge;\n\tstatic Queue<Integer> q = new LinkedList<Integer>();\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tString[] NM = br.readLine().split(\" \");\n\t\t\n\t\tN = stoi(NM[0]);\n\t\tM = stoi(NM[1]);\n\t\tindegree = new int[N+1];\n\t\tresult = new int[N+1];\n\t\tedge = new ArrayList[N+1];\n\t\t\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tedge[i] = new ArrayList<Edge>();\n\t\t}\n\t\t\n\t\tfor(int i=1; i<=M; i++) {\n\t\t\tString[] edgeData = br.readLine().split(\" \");\n\t\t\tint s = stoi(edgeData[0]);\n\t\t\tint e = stoi(edgeData[1]);\n\t\t\t\n\t\t\tedge[s].add(new Edge(s, e));\n\t\t\tindegree[e]++;\n\t\t}\n\t\t\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tif(indegree[i] == 0) q.add(i);\n\t\t}\n\t\t\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tif(q.isEmpty()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint temp = q.poll();\n\t\t\tresult[i] = temp;\n\t\t\tfor(Edge e : edge[temp]) {\n\t\t\t\tindegree[e.e]--;\n\t\t\t\tif(indegree[e.e] == 0)\n\t\t\t\t\tq.add(e.e);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tSystem.out.print(result[i] + \" \");\n\t\t}\n\t\t\n\t}\n\t\n\tstatic class Edge{\n\t\tint s, e;\n\t\tEdge(int s, int e){\n\t\t\tthis.s = s;\n\t\t\tthis.e = e;\n\t\t}\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n\n```\n\n## 백준 3665 - 최종 순위\n\n---\n\n![3665pb1](3665pb1.PNG)  \n![3665pb2](3665pb2.PNG)  \n\n---\n\n### 풀이\n---\n\n일단 문제가 이해가 안되서\n\n[stack07142님 블로그](https://stack07142.tistory.com/223)를 참고했다.\n\n1. 그래프를 인접 행렬로 구현한다.  \n2. 바뀐 순위에 따라 간선과 indegree를 갱신한다.  \n3. 위상 정렬을 한다.  \n   3-1. **정상일 경우**에 1등 팀 부터 순서대로 출력  \n   3-2. **확실한 순위를 찾을 수 없다면** \"?\"출력  \n   3-2. **사이클이 생겨** 순위를 정할 수 없는 경우   \"IMPOSSIBLE\"출력  \n\n어렵당...\n\n---\n\n```java\npackage package34;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class num3665 {\n    static final int NONE = 0;\n    static final int IMPOSSIBLE = 1;\n    static final int NOT_DETERMINED = 2;\n\n    static int T, N, M;\n    static int[] indegree, result, prev;\n    static Queue<Integer> q = new LinkedList<Integer>();\n    static int[][] graph;\n    \n    public static void main(String[] args) throws IOException {\n\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder sb = new StringBuilder();\n\n        T = stoi(br.readLine());\n\n        for(int i=0; i<T; i++){\n            N = stoi(br.readLine());\n\n            indegree = new int[N + 1];\n            result = new int[N+1];\n            prev = new int[N+1];\n            graph = new int[N+1][N+1];\n\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            for (int j=0; j < N; j++) \n                prev[j] = stoi(st.nextToken());\n            \n\n            for (int j = 0; j < N; j++) {\n                for (int k = j + 1; k < N; k++) {\n                    graph[prev[j]][prev[k]] = 1;\n                    indegree[prev[k]]++;\n                }\n            }\n\n            M = stoi(br.readLine());\n\n            for (int j=0; j<M; j++) {\n\n                st = new StringTokenizer(br.readLine());\n\n                int a = stoi(st.nextToken());\n                int b = stoi(st.nextToken());\n\n                if (graph[a][b] == 1) {\n                    graph[a][b] = 0;\n                    graph[b][a] = 1;\n\n                    indegree[a]++;\n                    indegree[b]--;\n                } else {\n                \tgraph[a][b] = 1;\n                    graph[b][a] = 0;\n                    \n                    indegree[b]++;\n                    indegree[a]--;\n                }\n            }\n            \n            for (int j=1; j<=N; j++) {\n                if (indegree[j] == 0) {\n                    q.add(j);\n                }\n            }\n\n            int ans = NONE;\n            for (int j=1; j<=N; j++) {\n                if (q.isEmpty()) {\n                    ans = IMPOSSIBLE;\n                    break;\n                }\n                if (q.size() > 1) {\n                    ans = NOT_DETERMINED;\n                    break;\n                }\n\n                int u = q.poll();\n                result[j] = u;\n\n                for (int k=1; k<=N; k++) {\n                    if (graph[u][k] == 1) {\n                        indegree[k]--;\n                        if (indegree[k] == 0) q.add(k);\n                    }\n                }\n            }\n            \n            if (ans == NONE) {\n                for (int j=1; j<=N; j++)sb.append(result[j] + \" \");\n                sb.append(\"\\n\");\n            } else if (ans == IMPOSSIBLE) sb.append(\"IMPOSSIBLE\\n\");\n            else if (ans == NOT_DETERMINED) sb.append(\"?\\n\");\n        }\n        System.out.println(sb);\n    }\n    \n    public static int stoi(String string) {\n    \treturn Integer.parseInt(string);\n    }\n}\n```\n\n## 백준 1005 - ACM Craft\n\n---\n\n![1005pb1](1005pb1.PNG)  \n![1005pb2](1005pb2.PNG)  \n![1005pb3](1005pb3.PNG)  \n![1005pb4](1005pb4.PNG)  \n![1005pb5](1005pb5.PNG)  \n\n---\n\n### 풀이\n---\n\n1516문제와 비슷하다.\n\n---\n\n```java\npackage package34;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class num1005 {\n\tstatic int T, N, K;\n    static int[] result, indegree, weight;\n\tstatic ArrayList<Edge>[] edge;\n\tstatic Queue<Integer> q = new LinkedList<Integer>();\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuilder sb = new StringBuilder();\n\t\tStringTokenizer st;\n\t\t\n\t\tT = stoi(br.readLine());\n\t\t\n\t\twhile(T-- >0) {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tN = stoi(st.nextToken());\n\t\t\tK = stoi(st.nextToken());\n\t\t\t\n\t\t\tresult = new int[N+1];\n\t\t\tindegree = new int[N+1];\n\t\t\tweight = new int[N+1];\n\t\t\tedge = new ArrayList[N+1];\n\t\t\t\n\t\t\tfor(int i=1; i<=N; i++) {\n\t\t\t\tedge[i] = new ArrayList<Edge>();\n\t\t\t}\n\t\t\t\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tfor(int i=1; i<=N; i++) {\n\t\t\t\tweight[i] = stoi(st.nextToken());\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=1; i<=K; i++) {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\tint s = stoi(st.nextToken());\n\t\t\t\tint e = stoi(st.nextToken());\n\t\t\t\t\n\t\t\t\tedge[s].add(new Edge(s,e));\n\t\t\t\tindegree[e]++;\n\t\t\t}\n\t        for(int i=1; i<=N; i++) {\n\t            result[i] = weight[i];\n\t \n\t            if(indegree[i] == 0)\n\t                q.offer(i);\n\t        }\n\t        \n\t\t\tfor(int i=1; i<=N; i++) {\n\t\t\t\tif(q.isEmpty()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint now = q.poll();\n\t\t\t\tfor(Edge next : edge[now]) {\n\t\t\t\t\t// 요기 중요함 둘 중 큰거 들어감\n\t\t\t\t\tresult[next.e] = Math.max(result[next.e], result[now]+weight[next.e]);\n\t\t\t\t\tindegree[next.e]--;\n\t\t\t\t\tif(indegree[next.e]==0)\n\t\t\t\t\t\tq.add(next.e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint num = stoi(br.readLine());\n\t\t\tsb.append(result[num]+\"\\n\");\n\t\t}\n\t\tSystem.out.println(sb);\n\t\t\n\t}\n\t\n\tstatic class Edge{\n\t\tint s, e;\n\t\tEdge(int s, int e){\n\t\t\tthis.s = s;\n\t\t\tthis.e = e;\n\t\t}\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\t\n}\n```\n\n## 백준 1766 - 문제집\n\n---\n\n![1766pb1](1766pb1.PNG)  \n![1766pb1](1766pb2.PNG)  \n\n---\n\n### 풀이\n---\n\n문제를 보면 **가능한 쉬운 문제부터 풀어야 한다.** 라는 조건이 있다.  \n -> 이 조건은 Queue대신 PriorityQueue를 사용해 minheap에 저장하면 쉽게 구현 가능하다.\n\n---\n\n```java\npackage package34;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class num1766 {\n\tstatic int N, M;\n\tstatic int[] indegree,result;\n\tstatic ArrayList<Edge>[] edge;\n\tstatic PriorityQueue<Integer> q = new PriorityQueue<Integer>();\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tString[] NM = br.readLine().split(\" \");\n\t\t\n\t\tN = stoi(NM[0]);\n\t\tM = stoi(NM[1]);\n\t\tindegree = new int[N+1];\n\t\tresult = new int[N+1];\n\t\tedge = new ArrayList[N+1];\n\t\t\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tedge[i] = new ArrayList<Edge>();\n\t\t}\n\t\t\n\t\tfor(int i=1; i<=M; i++) {\n\t\t\tString[] edgeData = br.readLine().split(\" \");\n\t\t\tint s = stoi(edgeData[0]);\n\t\t\tint e = stoi(edgeData[1]);\n\t\t\t\n\t\t\tedge[s].add(new Edge(s, e));\n\t\t\tindegree[e]++;\n\t\t}\n\t\t\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tif(indegree[i] == 0) q.add(i);\n\t\t}\n\t\t\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tif(q.isEmpty()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint temp = q.poll();\n\t\t\tresult[i] = temp;\n\t\t\tfor(Edge e : edge[temp]) {\n\t\t\t\tindegree[e.e]--;\n\t\t\t\tif(indegree[e.e] == 0)\n\t\t\t\t\tq.add(e.e);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tSystem.out.print(result[i] + \" \");\n\t\t}\n\t\t\n\t}\n\t\n\tstatic class Edge{\n\t\tint s, e;\n\t\tEdge(int s, int e){\n\t\t\tthis.s = s;\n\t\t\tthis.e = e;\n\t\t}\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n```\n\n---\n\n끗\n\n\n# Reference\n\n[[그래프]위상 정렬 - JuticeHui님 블로그](https://justicehui.github.io/easy-algorithm/2018/03/24/TopologicalSort/)   \n[갓킹독님 블로그](https://blog.encrypted.gg/910?category=773649)   \n[라이님 블로그](https://m.blog.naver.com/kks227/220800013823)  \n","excerpt":"위상 정렬 싸이클이 없는 방향 그래프의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열 Tip!! 그래프에서 방문 조건이 주어질 때 사용!! 시간 복잡도 O(V+E)이다.\n(모든 노드를 확인하면서, 해당 노드에서 출발하는 간선을 차례대로 제거하기…","fields":{"slug":"/topologicalSort/"},"frontmatter":{"date":"Feb 09, 2021","title":"위상정렬 정리","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n<!-- TODO: https://devje8.tistory.com/22?category=930768 추가로 정리하자-->\n\n# 신장 트리(Spnning Tree)\n\n> 하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프\n\n# 최소 신장 트리(Minimum Spanning Tree)\n\n> 트리의 간선마다 가중치가 있을 때, **간선의 가중치 합이 최소**인 트리\n\n신장 트리의 최소비용을 구하는 크루스칼 알고리즘, 프림 알고리즘 2가지 알고리즘에 대해 정리한다.\n\n## 크루스칼 알고리즘\n\n---\n\n> 간선 선택 기반의 알고리즘으로, 탐욕적인 방법을 이용, 간선을 하나씩 선택해서 MST를 찾는 알고리즘입니다.\n\n### 특징\n\n---\n\n1. 그리디 알고리즘의 일종 -> 작은 간선부터 훑기 때문에\n2. 시간 복잡도 : **O(ElogE)**  \n   -> 가중치 별로 정렬 : O(ElogE) + 정점이 같은 컴포넌트에 속해있는지 확인 : 약 O(1) = **O(ElogE)**\n\n### 구현 방법\n\n---\n\n```\n1. 간선을 비용에 따라 오름차순으로 정리하고, 정점을 초기화한다\n2. 간선을 하나씩 확인하며 간선이 싸이클을 발생시키지 않으면 간선을 포함시킨다.\n3. 간선을 V-1개 뽑았을 때, 이루는 그래프가 MST이다.\n```\n\n## 백준 1197 - 최소 스패닝 트리\n\n---\n\n![1197pb1](1197pb1.PNG)\n![1197pb2.PNG](1197pb2.PNG)\n\n---\n\n### 풀이\n\n---\n\n1. 간선 클래스를 만들어 우선순위 큐로 저장한다.\n2. union find를 사용해 싸이클 검사와 거리를 더해준다.\n\n---\n\n```java\npackage package29;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\n\npublic class num1197 {\n\tstatic int V, E, result=0, cnt=0;\n\tstatic int[] parent;\n\tstatic PriorityQueue<Edge> pq = new PriorityQueue<Edge>();\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString[] VE = br.readLine().split(\" \");\n\t\tV = stoi(VE[0]);\n\t\tE = stoi(VE[1]);\n\n\t\tparent = new int[V+1];\n\n\t\tfor(int i=0; i<V+1; i++) {\n            parent[i] = i;\n        }\n\n\t    for(int i=0; i<E; i++) {\n\t    \tStringTokenizer st = new StringTokenizer(br.readLine());\n\t    \tpq.add(new Edge(stoi(st.nextToken()),stoi(st.nextToken()),stoi(st.nextToken())));\n\t    }\n\n\t    for(int i=0; i<E; i++) {\n\t    \tEdge temp = pq.poll();\n\n\t    \tint a = temp.s;\n\t    \tint b = temp.e;\n\t    \tif(!union(a, b))\n\t    \t\tcontinue;\n\t    \tresult+= temp.w;\n\t    \tcnt++;\n\t    \tif(cnt == V-1)\n\t    \t\tbreak;\n\t    }\n\t    System.out.println(result);\n\t}\n\n\tstatic class Edge implements Comparable<Edge>{\n\t\tint s, e, w;\n\t\tEdge(int s, int e, int w){\n\t\t\tthis.s = s;\n\t\t\tthis.e = e;\n\t\t\tthis.w = w;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\treturn o.w >= this.w ? -1: 1;\n\t\t}\n\t}\n\n\tpublic static int find_parent(int num) {\n\t\tif(parent[num] != num)\n\t\t\treturn parent[num] = find_parent(parent[num]);\n\t\treturn parent[num];\n\t}\n\n\tpublic static boolean union(int a, int b) {\n\t\ta = find_parent(a);\n\t\tb = find_parent(b);\n\n\t\tif(a==b) {\n\t\t\treturn false;\n\t\t}\n\t\telse if(a < b)\n\t\t\tparent[b] = a;\n\t\telse\n\t\t\tparent[a] = b;\n\t\treturn true;\n\t}\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\n}\n\n```\n\n## 백준 4386 - 별자리 만들기\n\n---\n\n![4386pb1](4386pb1.PNG)\n![4386pb2](4386pb2.PNG)\n\n---\n\n### 풀이\n\n---\n\n정점의 x좌표와 y좌표를 저장할 수 있는 클래스를 만들어 사용했다.\n\n위의 문제는 가중치가 주어졌지만, 4386번문제는 가중치를 두 점사이 거리로 계산해서 넣어야 한다.\n\n---\n\n```java\npackage package29;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\n\npublic class num4386 {\n\tstatic int N, cnt=0;\n\tstatic double result = 0;\n\tstatic int[] parent;\n\tstatic PriorityQueue<Edge> pq = new PriorityQueue<Edge>();\n\tstatic Vertex[] v;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tN = stoi(br.readLine());\n\n\t\tparent = new int[N+1];\n\t\tv = new Vertex[N+1];\n\t\tfor(int i=1; i<=N+1; i++) {\n            parent[i] = i;\n        }\n\n\t    for(int i=1; i<=N; i++) {\n\t    \tStringTokenizer st = new StringTokenizer(br.readLine(),\" \");\n\t    \tv[i] = new Vertex(stod(st.nextToken()), stod(st.nextToken()));\n\t    }\n\n\t    for(int i=1; i<=N; i++) {\n\t    \tfor(int j=i+1; j<=N; j++) {\n\t    \t\tpq.add(new Edge(i, j, getDistance(v[i].x, v[j].x, v[i].y, v[j].y)));\n\t    \t}\n\t    }\n\n\t    for(int i=0; i<pq.size(); i++) {\n\t    \tEdge temp = pq.poll();\n\n\t    \tint a = temp.s;\n\t    \tint b = temp.e;\n\t    \tif(!union(a, b))\n\t    \t\tcontinue;\n\t    \tresult+= temp.w;\n\t    \tcnt++;\n\t    \tif(cnt == N-1)\n\t    \t\tbreak;\n\t    }\n\t    System.out.println(String.format(\"%.2f\", result));\n\t}\n\n\tstatic class Vertex{\n\t\tdouble x, y;\n\t\tVertex(double x, double y){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tstatic class Edge implements Comparable<Edge>{\n\t\tint s, e;\n\t\tdouble w;\n\t\tEdge(int s, int e, double w){\n\t\t\tthis.s = s;\n\t\t\tthis.e = e;\n\t\t\tthis.w = w;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\treturn o.w >= this.w ? -1: 1;\n\t\t}\n\t}\n\n\tpublic static int find_parent(int num) {\n\t\tif(parent[num] != num)\n\t\t\treturn parent[num] = find_parent(parent[num]);\n\t\treturn parent[num];\n\t}\n\n\tpublic static boolean union(int a, int b) {\n\t\ta = find_parent(a);\n\t\tb = find_parent(b);\n\n\t\tif(a==b) {\n\t\t\treturn false;\n\t\t}\n\t\telse if(a < b)\n\t\t\tparent[b] = a;\n\t\telse\n\t\t\tparent[a] = b;\n\t\treturn true;\n\t}\n\n\tpublic static double getDistance(double x1, double x2, double y1, double y2) {\n\t\treturn Math.sqrt(Math.pow(Math.abs(x1 - x2), 2) + Math.pow(Math.abs(y1 - y2), 2));\n\t}\n\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\n\tpublic static double stod(String string) {\n\t\treturn Double.parseDouble(string);\n\t}\n\n}\n\n\n```\n\n## 백준 1647 - 도시 분할 계획\n\n---\n\n![1647pb1](1647pb1.PNG)\n![1647pb2](1647pb2.PNG)\n\n---\n\n### 풀이\n\n---\n\n도시를 2개로 나눈다고 했으니 크루스칼 알고리즘이 끝나는 조건을 N-2로 작성해야 한다.\n\n---\n\n```java\npackage MST;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\n\npublic class num1647 {\n\tstatic int N, M, result=0, cnt=0;\n\tstatic int[] parent;\n\tstatic PriorityQueue<Edge> pq = new PriorityQueue<Edge>();\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st;\n\n\t\tst = new StringTokenizer(br.readLine());\n\t\tN = stoi(st.nextToken());\n\t\tM = stoi(st.nextToken());\n\n\t\tparent = new int[N+1];\n\t\tfor(int i=1; i<=N; i++) {\n            parent[i] = i;\n        }\n\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tint s = stoi(st.nextToken()), e = stoi(st.nextToken()), w = stoi(st.nextToken());\n\t\t\tpq.add(new Edge(s,e,w));\n\t\t}\n\n\t\twhile(!pq.isEmpty()) {\n\t\t\tEdge temp = pq.poll();\n\n\t\t\tint a = temp.s;\n\t\t\tint b = temp.e;\n\t\t\tif(!union(a, b))\n\t\t\t\tcontinue;\n\t\t\tresult += temp.w;\n\t\t\tcnt++;\n\t\t\tif(cnt == N-2)\n\t\t\t\tbreak;\n\t\t}\n\t\tSystem.out.println(result);\n\t}\n\n\tstatic class Edge implements Comparable<Edge> {\n\t\tint s, e, w;\n\t\tEdge(int s, int e, int w) {\n\t\t\tthis.s = s;\n\t\t\tthis.e = e;\n\t\t\tthis.w = w;\n\t\t}\n\n\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\treturn o.w >= this.w ? -1 : 1;\n\t\t}\n\t}\n\n\tpublic static int find_parent(int num) {\n\t\tif(parent[num] != num)\n\t\t\treturn parent[num] = find_parent(parent[num]);\n\t\treturn parent[num];\n\t}\n\n\tpublic static boolean union(int a, int b) {\n\t\ta = find_parent(a);\n\t\tb = find_parent(b);\n\n\t\tif(a==b)\n\t\t\treturn false;\n\t\tif(a < b)\n\t\t\tparent[b] = a;\n\t\telse\n\t\t\tparent[a] = b;\n\t\treturn true;\n\t}\n\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\n}\n\n```\n\n## 백준 1774 - 우주신과의 교감\n\n---\n\n![1774pb1](1774pb1.PNG)\n![1774pb2](1774pb2.PNG)\n\n---\n\n### 풀이\n\n---\n\n일반적인 최소 스패닝 트리 문제다. 1197번과 풀이가 동일하다.\n\n---\n\n```java\npackage package29;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.PriorityQueue;\n\npublic class num1774 {\n\tstatic int N, M, cnt = 0;\n\tstatic PriorityQueue<Edge> pq = new PriorityQueue<Edge>();\n\tstatic int[] parent;\n\tstatic Node[] arr;\n\tstatic double minLen = 0;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString[] NM = br.readLine().split(\" \");\n\n\t\tN = stoi(NM[0]);\n\t\tM = stoi(NM[1]);\n\t\tNode[] arr = new Node[N+1];\n\t\tparent = new int[N+1];\n\n\t\tfor(int i=1; i<=N; i++) {\n            parent[i] = i;\n        }\n\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tString[] XY = br.readLine().split(\" \");\n\t\t\tarr[i] = new Node(stoi(XY[0]), stoi(XY[1]));\n\t\t}\n\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tString[] se = br.readLine().split(\" \");\n\t\t\tint s = stoi(se[0]);\n\t\t\tint e = stoi(se[1]);\n\t\t\tunion(s, e);\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = i + 1; j <= N; j++) {\n\t\t\t\tpq.add(new Edge(i, j, getDistance(arr[i].x, arr[j].x, arr[i].y, arr[j].y)));\n\t\t\t}\n\t\t}\n\n\t    for(int i=0; i<pq.size(); i++) {\n\t    \tEdge temp = pq.poll();\n\n\t    \tint a = temp.s;\n\t    \tint b = temp.e;\n\t    \tif(!union(a, b))\n\t    \t\tcontinue;\n\t    \tminLen+= temp.w;\n\t    }\n\t    System.out.println(String.format(\"%.2f\", minLen));\n\n\t}\n\tstatic class Edge implements Comparable<Edge>{\n\t\tint s, e;\n\t\tdouble w;\n\t\tEdge(int s, int e, double w){\n\t\t\tthis.s = s;\n\t\t\tthis.e = e;\n\t\t\tthis.w = w;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\treturn o.w >= this.w ? -1: 1;\n\t\t}\n\t}\n\n\tpublic static double getDistance(double x1, double x2, double y1, double y2) {\n\t\treturn Math.sqrt(Math.pow(Math.abs(x1 - x2), 2) + Math.pow(Math.abs(y1 - y2), 2));\n\t}\n\n\tpublic static int find_parent(int num) {\n\t\tif(parent[num] != num)\n\t\t\treturn parent[num] = find_parent(parent[num]);\n\t\treturn parent[num];\n\t}\n\n\tpublic static boolean union(int a, int b) {\n\t\ta = find_parent(a);\n\t\tb = find_parent(b);\n\n\t\tif(a==b) {\n\t\t\treturn false;\n\t\t}\n\t\telse if(a < b)\n\t\t\tparent[b] = a;\n\t\telse\n\t\t\tparent[a] = b;\n\t\treturn true;\n\t}\n\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\n\tstatic class Node{\n\t\tdouble x, y;\n\t\tNode(double x, double y){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n}\n```\n\n## 백준 2887 - 행성 터널\n\n---\n\n![2887pb1](2887pb1.PNG)\n![2887pb2](2887pb2.PNG)\n\n---\n\n### 풀이\n\n---\n\n이 문제가 어려웠다.\n\nN의 개수가 상당히 커서 모든 간선을 추가하면 시간 초과가 나온다.\n\n간선 비용은 문제에 주어진대로 Min(x좌표 차이, y좌표 차이, z좌표 차이)이다.\n\n행성을 연결할 때 드는 비용을 x, y, z을 각각 오름차순으로 정렬하고\n\n인접한 좌표의 비용을 PriorityQueue에 넣는다.\n\n그 뒤 크루스칼 알고리즘을 통해 답을 구한다.\n\n---\n\n```java\npackage package29;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class num2887 {\n\tstatic int N;\n\tstatic Vertex[] vertexs;\n\tstatic PriorityQueue<Edge> pq = new PriorityQueue<Edge>(new Comparator<Edge>() {\n\t\t@Override\n\t\tpublic int compare(Edge o1,Edge o2) {\n\t\t\treturn (o1.w-o2.w);\n\t\t}\n\t});\n\tstatic int[] parent;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tN = Integer.parseInt(br.readLine());\n\t\tvertexs = new Vertex[N];\n\n\t\tStringTokenizer st;\n\t\tfor (int i = 0; i < N ; i++) {\n\t\t\tst = new StringTokenizer(br.readLine().trim(), \" \");\n\t\t\tint X = stoi(st.nextToken());\n\t\t\tint Y = stoi(st.nextToken());\n\t\t\tint Z = stoi(st.nextToken());\n\t\t\tvertexs[i] = new Vertex(X, Y, Z, i);\n\t\t}\n\n\t\tArrays.sort(vertexs,new Comparator<Vertex>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Vertex o1, Vertex o2) {\n\t\t\t\treturn Integer.compare(o1.x, o2.x);\n\t\t\t}\n\t\t});\n\t\tfor (int i = 1; i <N ; i++) {\n\t\t\tpq.add(new Edge(vertexs[i-1].id, vertexs[i].id, Math.abs(vertexs[i].x-vertexs[i-1].x)));\n\t\t}\n\n\t\tArrays.sort(vertexs,new Comparator<Vertex>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Vertex o1, Vertex o2) {\n\t\t\t\treturn Integer.compare(o1.y, o2.y);\n\t\t\t}\n\t\t});\n\t\tfor (int i = 1; i <N ; i++) {\n\t\t\tpq.add(new Edge(vertexs[i-1].id, vertexs[i].id, Math.abs(vertexs[i].y-vertexs[i-1].y)));\n\t\t}\n\n\t\tArrays.sort(vertexs,new Comparator<Vertex>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Vertex o1, Vertex o2) {\n\t\t\t\treturn Integer.compare(o1.z, o2.z);\n\t\t\t}\n\t\t});\n\t\tfor (int i = 1; i <N ; i++) {\n\t\t\tpq.add(new Edge(vertexs[i-1].id, vertexs[i].id, Math.abs(vertexs[i].z-vertexs[i-1].z)));\n\t\t}\n\n\n\t\tparent = new int[N+1];\n\t\tfor (int i = 1; i <= N ; i++)\n\t\t\tparent[i] = i;\n\t\tlong result=0;\n\n\t\twhile(!pq.isEmpty()) {\n\t\t\tEdge tmp = pq.poll();\n\t\t\tif(find_parent(tmp.s)!=find_parent(tmp.e)) {\n\t\t\t\tresult +=tmp.w;\n\t\t\t\tunion(tmp.s,tmp.e);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(result);\n\t}\n\n\tstatic class Vertex {\n\t\tint x, y, z, id;\n\t\tVertex(int x, int y, int z, int id) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t\tthis.id = id;\n\t\t}\n\t}\n\n\tstatic class Edge {\n\t\tint s, e, w;\n\t\tEdge(int s, int e, int w) {\n\t\t\tthis.s = s;\n\t\t\tthis.e = e;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tpublic static int find_parent(int num) {\n\t\tif(parent[num] != num)\n\t\t\treturn parent[num] = find_parent(parent[num]);\n\t\treturn parent[num];\n\t}\n\n\tpublic static boolean union(int a, int b) {\n\t\ta = find_parent(a);\n\t\tb = find_parent(b);\n\n\t\tif(a==b) {\n\t\t\treturn false;\n\t\t}\n\t\telse if(a < b)\n\t\t\tparent[b] = a;\n\t\telse\n\t\t\tparent[a] = b;\n\t\treturn true;\n\t}\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n\n\n```\n\n## 백준 17472 - 다리 만들기2\n\n---\n\n![17472pb1](17472pb1.PNG)\n![17472pb2](17472pb2.PNG)\n![17472pb3](17472pb3.PNG)\n![17472pb4](17472pb4.PNG)\n![17472pb5](17472pb5.PNG)\n![17472pb6](17472pb6.PNG)\n\n---\n\n### 풀이\n\n---\n\n이전 문제들을 모두 풀어봤으면 어렵진 않은데 삽질을 많이했다.\n\n내가 실수한 부분은 2가지였다.\n\n```\n1. dfs로 체크하는데 자기 자신을 바꾸지 않음\n2. for(int i=0; i<pq.size(); i++) 이런식으로 사용\n```\n\n어떤 친절하신 분이 반례를 정리해놔서 참고했다.\n\n[반례모음 - promise12mee](https://www.acmicpc.net/board/view/63536)\n\n---\n\n```java\npackage package29;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.PriorityQueue;\n\n\npublic class num17472 {\n\tstatic int N, M, landCount=0, result = 0, cnt=0;\n\tstatic int[] parent;\n\tstatic int[][] map;\n\tstatic int[] dx = new int[]{0,0,1,-1};\n\tstatic int[] dy = new int[]{1,-1,0,0};\n\tstatic PriorityQueue<Edge> pq = new PriorityQueue<Edge>();\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString[] NM = br.readLine().split(\" \");\n\n\t\tN = stoi(NM[0]);\n\t\tM = stoi(NM[1]);\n\t\tmap = new int[N][M];\n\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tString[] mapData = br.readLine().split(\" \");\n\t\t\tfor(int j=0; j<M; j++) {\n\t\t\t\tmap[i][j] = stoi(mapData[j]);\n\t\t\t}\n\t\t}\n\n\t\tcheckLand();\n\n\t\tparent = new int[landCount+1];\n\t\tfor(int i=0; i<=landCount; i++) {\n\t\t\tparent[i] = i;\n\t\t}\n\n        for(int i=0; i<N; i++) {\n            for(int j=0; j<M; j++) {\n                if(map[i][j] != 0) {\n                    makeBridge(i, j, map[i][j]);\n                }\n            }\n        }\n\n        int size = pq.size();\n\t    for(int i=0; i<size; i++) {\n\t    \tEdge temp = pq.poll();\n\t    \tint a = temp.s;\n\t    \tint b = temp.e;\n\t    \tif(!union(a, b))\n\t    \t\tcontinue;\n\t    \tunion(temp.s, temp.e);\n\t    \tresult+= temp.w;\n\t    \tcnt++;\n\t    }\n\t    if(result == 0 || cnt != landCount-1) {\n            System.out.println(-1);\n        } else {\n            System.out.println(result);\n        }\n\t}\n\n\tstatic void makeBridge(int x, int y, int landNum) {\n        int newX = x;\n        int newY = y;\n\t\tint length = 0;\n\n        for(int i=0; i<4; i++) {\n            while(true) {\n                newX = newX + dx[i];\n                newY = newY + dy[i];\n\n                if(isPossibleIndex(newX, newY)) {\n                    if(map[newX][newY] == landNum) {\n                        length = 0;\n                        newX = x;\n                        newY = y;\n                        break;\n                    } else if(map[newX][newY] == 0){\n                        length++;\n                    } else {\n                        if(length > 1) {\n                        \tpq.add(new Edge(landNum, map[newX][newY], length));\n                        }\n                        length = 0;\n                        newX = x;\n                        newY = y;\n                        break;\n                    }\n                } else {\n                    length = 0;\n                    newX = x;\n                    newY = y;\n                    break;\n                }\n            }\n        }\n\t}\n\n\tstatic class Edge implements Comparable<Edge>{\n\t\tint s, e, w;\n\t\tEdge(int s, int e, int w){\n\t\t\tthis.s = s;\n\t\t\tthis.e = e;\n\t\t\tthis.w = w;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\treturn o.w >= this.w ? -1 : 1;\n\t\t}\n\t}\n\n\tpublic static int find_parent(int num) {\n\t\tif(parent[num] != num)\n\t\t\treturn parent[num] = find_parent(parent[num]);\n\t\treturn parent[num];\n\t}\n\n\tpublic static boolean union(int a, int b) {\n\t\ta = find_parent(a);\n\t\tb = find_parent(b);\n\n\t\tif(a==b) {\n\t\t\treturn false;\n\t\t}\n\t\telse if(a < b)\n\t\t\tparent[b] = a;\n\t\telse\n\t\t\tparent[a] = b;\n\t\treturn true;\n\t}\n\n\tpublic static void checkLand() {\n\t\tboolean[][] visited = new boolean[N][M];\n\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tfor(int j=0; j<M; j++) {\n\t\t\t\tif(map[i][j] != 0 && !visited[i][j]) {\n\t\t\t\t\tlandCount++;\n\t\t\t\t\tdfs(i, j, visited);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic static void dfs(int x, int y, boolean[][] visited) {\n\t\tmap[x][y] = landCount;\n\t\tfor(int i=0; i<4; i++) {\n\t\t\tint newX = x + dx[i];\n\t\t\tint newY = y + dy[i];\n\t\t\tif(isPossibleIndex(newX, newY) && !visited[newX][newY] && map[newX][newY] != 0) {\n\t\t\t\tvisited[x + dx[i]][y + dy[i]] = true;\n\t\t\t\tmap[newX][newY] = landCount;\n\t\t\t\tdfs(x + dx[i], y + dy[i], visited);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static boolean isPossibleIndex(int x, int y) {\n\t\treturn x >= 0 && y >= 0 && x < N && y < M ? true : false;\n\t}\n\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n\n```\n\n## 프림 알고리즘\n\n---\n\n> 정점 선택 기반의 알고리즘으로, 하나의 정점에서 연결된 간선들 중에 최소 간선 비용을 가진 정점을 하나씩 선택하면서 MST를 찾는 알고리즘\n\n### 구현 방법\n\n---\n\n```\n1. 임의의 정점 하나를 선택해서 시작\n2. 선택한 정점과 인접하는 정점들 중에 최소비용의 간선을 가지는 정점을 선택\n3. 모든 정점이 선택될 때 까지 반복\n\n```\n\n---\n\n## 주절주절\n\n크루스칼 알고리즘과 프림 알고리즘에 대해 알아보았다. 대부분 최소 신장 트리문제는 크루스칼 알고리즘을 통해 대부분 해결 가능하기 때문에 백준 단계별 문제에 있는 MST문제는 모두 크루스칼 알고리즘을 사용해서 문제를 풀었다.\n\n# Reference\n\n이것이 취업을 위한 코딩테스트다 - 나동빈  \n[라이님 블로그](https://m.blog.naver.com/kks227/220799105543)  \n[갓킹독님 블로그](https://blog.encrypted.gg/915?category=773649)  \n[주남2님 블로그](https://ju-nam2.tistory.com/112)  \n[두 점 사이의 거리, 좌표평면위의 두 점 사이의 거리](https://mathbang.net/408)  \n[Java - 반올림해서 소수점 n번째 자리까지 출력 - chacha님 블로그](https://codechacha.com/ko/java-round-a-number-to-decimal-point/)\n","excerpt":"신장 트리(Spnning Tree) 하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프 최소 신장 트리(Minimum Spanning Tree) 트리의 간선마다 가중치가 있을 때, 간선의 가중치 합이 최소인 트리 신장…","fields":{"slug":"/MST/"},"frontmatter":{"date":"Feb 04, 2021","title":"최소 신장 트리 정리","tags":["Algorithm"],"update":"Feb 08, 2021"}}},{"node":{"rawMarkdownBody":"\n# 슬라이딩 윈도우\n\n투포인터 알고리즘과 비슷하지만 슬라이딩 윈도우는 **어느 순간에도 그 구간의 넓이가 동일하다**  \n -> 사용하지 않는 값을 삭제하거나 갱신하는 기법이다.\n## 백준 2096번 - 내려가기\n---\n\n![2096pb1](2096pb1.PNG)\n![2096pb2](2096pb2.PNG)\n\n---\n\n### 풀이\n---\n\n이 문제는 슬라이딩 윈도우 + DP문제다. \n\n문제를 보면 메모리 제한이 있다.\n\n계단의 최대값과 최솟값을 저장하는데 이전의 값들만 저장하고 있으면 된다.\n\n---\n\n```java\npackage slidingWindow;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class num2096 {\n\tstatic int N, MAX, MIN;\n\tstatic int[] tempMaxDp, tempMinDp, maxDp, minDp;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tN = stoi(br.readLine());\n\t\ttempMaxDp = new int[3]; tempMinDp = new int[3]; maxDp = new int[3]; minDp = new int[3];\n\t\t\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tString[] step = br.readLine().split(\" \");\n\t\t\tfor(int j=0; j<3; j++) {\n\t\t\t\ttempMinDp[j] = tempMaxDp[j] = stoi(step[j]);\n\t\t\t\ttempMaxDp[j] += Math.max(maxDp[1] , j == 1 ? Math.max(maxDp[0], maxDp[2]) : maxDp[j]);\n\t\t\t\ttempMinDp[j] += Math.min(minDp[1] , j == 1 ? Math.min(minDp[0], minDp[2]) : minDp[j]);\n\t\t\t\tMAX = j==0 ? tempMaxDp[j] : MAX > tempMaxDp[j] ? MAX : tempMaxDp[j];\n\t\t\t\tMIN = j==0 ? tempMinDp[j] : MIN < tempMinDp[j] ? MIN : tempMinDp[j];\n\t\t\t}\n\t\t\tarrayCopy(maxDp, tempMaxDp);\n\t\t\tarrayCopy(minDp, tempMinDp);\n\t\t\t\n\t\t}\n\t\tSystem.out.println(MAX + \" \" + MIN);\n\t}\n\t\n\tpublic static void arrayCopy(int[] to, int[] from) {\n\t\tfor(int i=0; i<3; i++) {\n\t\t\tto[i] = from[i];\n\t\t}\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\n}\n\n```\n\n\n## 백준 11003번 - 최솟값 찾기\n---\n\n![11003번](11003pb1.PNG)\n![11003번](11003pb2.PNG)\n\n---\n\n### 풀이\n---\n\n문제를 보면 범위가 심상치 않다.....ㅋㅋㅋ\n\n문제가 좀 어려워서 노트로 작성하면서 정리했다.\n\n![11003번sol](11003sol.PNG)\n\n---\n\n```java\npackage slidingWindow;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class num11003 {\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        Deque<Integer> deque = new LinkedList<>();\n        StringTokenizer st = new StringTokenizer(br.readLine(), \" \");\n        \n        int N = stoi(st.nextToken());\n        int L = stoi(st.nextToken());\n        \n        int[] arr = new int[N];\n        st = new StringTokenizer(br.readLine(), \" \");\n        \n        \n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < N; i++) {\n        \tarr[i] = stoi(st.nextToken());\n            if (!deque.isEmpty() && deque.getFirst() <= i - L) {\n            \tdeque.removeFirst();\n            }\n            while (!deque.isEmpty() && arr[deque.getLast()] > arr[i]) {\n            \tdeque.removeLast();\n            }\n            deque.addLast(i);\n            sb.append(arr[deque.peekFirst()] + \" \");\n        }\n        bw.write(sb.toString());\n\t\tbw.flush();\n\t\tbw.close();\n    }\n    \n    public static int stoi(String string) {\n    \treturn Integer.parseInt(string);\n    }\n}\n```\n\n## 백준 3078번 - 좋은 친구\n---\n\n![3078pb1](3078pb1.PNG)\n![3078pb2](3078pb2.PNG)\n\n### 풀이\n---\n\n이전 문제를 풀었다면 어렵지 않게 풀 수 있다.\n\ncnt범위 때문에 long으로 설정해야 한다.\n\ncnt 때문에 책상 부술뻔.... 후.....하...후...하...\n\n---\n\n```java\npackage slidingWindow;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\npublic class num3078 {\n\tstatic int N, K;\n\tstatic long cnt=0;\n\tstatic Queue[] qarr;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tN = stoi(st.nextToken());\n\t\tK = stoi(st.nextToken());\n\t\t\n\t\tqarr = new Queue[21];\n\t\tfor(int i=0; i<=20; i++) {\n\t\t\tqarr[i] = new LinkedList<Integer>();\n\t\t}\n\t\t\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tint nowLen = br.readLine().length();\n\t\t\t\n\t\t\tif(qarr[nowLen].isEmpty()) {\n\t\t\t\tqarr[nowLen].offer(i);\n\t\t\t}else {\n\t\t\t\twhile ((i - (int) qarr[nowLen].peek()) > K) {\n\t\t\t\t\tqarr[nowLen].poll();\n\t\t\t\t\tif (qarr[nowLen].isEmpty()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcnt += qarr[nowLen].size();\n\t\t\t\tqarr[nowLen].offer(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(cnt);\n\t}\n\t\n\tstatic int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\n}\n\n```\n\n# Reference\n[라이님 블로그](https://m.blog.naver.com/kks227/220795165570)","excerpt":"슬라이딩 윈도우 투포인터 알고리즘과 비슷하지만 슬라이딩 윈도우는 어느 순간에도 그 구간의 넓이가 동일하다  -> 사용하지 않는 값을 삭제하거나 갱신하는 기법이다. 백준 2096번 - 내려가기 \n 풀이 이 문제는 슬라이딩 윈도우 + DP문제다.  문제…","fields":{"slug":"/slidingWindow/"},"frontmatter":{"date":"Feb 03, 2021","title":"슬라이딩 윈도우 정리","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# 구간합 배열\n> 전처리를 통해 모든 부분합을 O(1)으로 구할 수 있는 방법\n\n\n```\n1. 원래 배열 이외에 pSum배열을 추가로 하나 만들어 준다. \n2. pSum[x] 배열에는 앞에서 부터 x개 원소의 합을 저장한다.\n  -> pSum[i+1] = pSum[i] + A[i]\n\n```\n\n## 백준 11659 - 구간 합 구하기4\n\n---\n\n![11659](11659pb1.PNG)\n\n---\n\n### 풀이\n\npSum[i+1] - pSum[j]를 해주면 된다.\n\n---\n\n```java\npackage sumOfInterval;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class num11659 {\n\tstatic int N, M;\n\tstatic int[] arr, pSum;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuilder sb = new StringBuilder();\n\t\tString[] NM = br.readLine().split(\" \");\n\t\t\n\t\tN = stoi(NM[0]);\n\t\tM = stoi(NM[1]);\n\t\t\n\t\tarr = new int[N];\n\t\tpSum = new int[N+1];\n\t\t\n\t\tString[] arrData = br.readLine().split(\" \");\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tarr[i] = stoi(arrData[i]);\n\t\t\tpSum[i+1] = arr[i] + pSum[i];\n\t\t}\n\t\t\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tString[] AB = br.readLine().split(\" \");\n\t\t\tint a = stoi(AB[0])-1;\n\t\t\tint b = stoi(AB[1])-1;\n\t\t\t\n\t\t\tsb.append(pSum[b+1] - pSum[a] + \"\\n\");\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n\n```\n\n## 백준 11660 - 구간 합 구하기5\n\n---\n\n![11660](11660pb1.PNG)\n![11660](11660pb2.PNG)\n![11660](11660pb3.PNG)\n\n---\n\n### 풀이\n\n이전 문제와 비슷한데 2차원 배열을 사용해 pSum을 저장한다.\n\n빼줄 때 범위 설정에 주의한다.\n\n---\n\n```java\npackage sumOfInterval;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class num11660 {\n\tstatic int N, M, x1, x2, y1, y2;\n\tstatic int[][] map, pSum;\n\t\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuilder sb = new StringBuilder();\n\t\t\n\t\tString[] NM = br.readLine().split(\" \");\n\t\tN = stoi(NM[0]);\n\t\tM = stoi(NM[1]);\n\t\tmap = new int[N+1][N+1];\n\t\tpSum = new int[N+2][N+2];\n\t\t\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tString[] row = br.readLine().split(\" \");\n\t\t\tfor(int j=0; j<N; j++) {\n\t\t\t\tmap[i][j] = stoi(row[j]);\n\t\t\t\tpSum[i+1][j+1] = pSum[i+1][j] + pSum[i][j+1] - pSum[i][j] + map[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=1; i<=M; i++) {\n\t\t\tString[] point = br.readLine().split(\" \");\n\t\t\tx1 = stoi(point[0]);\n\t\t\ty1 = stoi(point[1]);\n\t\t\tx2 = stoi(point[2]);\n\t\t\ty2 = stoi(point[3]);\n\t\t\t\n\t\t\tsb.append(pSum[x2][y2] - pSum[x1-1][y2] - pSum[x2][y1-1] + pSum[x1-1][y1-1] + \"\\n\");\n\t\t}\n\t\t\n\t\tSystem.out.println(sb.toString());\n\t\t\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n\n```\n\n## 백준 10211 - Maximum Subarray\n\n---\n\n![10211](10211pb1.PNG)\n![10211](10211pb2.PNG)\n\n---\n\n### 풀이\n---\n```\n1\n2\n-7 5\n```\n\n별 생각 없이 풀다가 위 CASE에 걸리는 걸 알았다.\n\n**전까지 합이 음수고, 새롭게 들어온 값이 양수라면 새롭게 들어온 값부터 더해준 값이 최대값이다.**\n\n위 문장에 대한 처리를 해야한다.\n\n---\n\n```java\npackage sumOfInterval;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class num10211 {\n\tstatic int N, X, MAX;\n\tstatic int[] arr, pSum;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuilder sb = new StringBuilder();\n\t\t\n\t\tN = stoi(br.readLine());\n\t\t\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tMAX = Integer.MIN_VALUE;\n\t\t\tX = stoi(br.readLine());\n\t\t\tString[] arrData = br.readLine().split(\" \");\n\t\t\tarr = new int[X];\n\t\t\tpSum = new int[X+1];\n\t\t\t\n\t\t\tfor(int j=0; j<X; j++) {\n\t\t\t\tarr[j] = stoi(arrData[j]);\n\t\t\t\tpSum[j+1] = Math.max(pSum[j], 0) + arr[j];\n\t\t\t\tMAX = MAX > pSum[j+1] ? MAX : pSum[j+1];\n\t\t\t}\n\t\t\tsb.append(MAX+\"\\n\");\n\t\t}\n\t\t\n\t\tSystem.out.println(sb.toString());\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n\n```\n\n## 백준 10986 - 나머지 합\n\n---\n\n![10986](10986pb1.PNG)\n![10986](10986pb2.PNG)\n\n---\n\n### 풀이\n\n이 문제는 발상의 전환이 필요하다.\n\npSum[j] % M 와 pSum[i] % M 나머지가 같으면 나누어 떨어지는 구간이다.  \n -> M으로 나눴을 때 나머지를 저장하는 누적합 배열을 만든다.  \n -> 나머지의 개수를 저장하는 배열을 하나 더 만들어서 나머지에 대한 개수를 저장한다.  \n -> 나머지의 순서에 상관없이 2개씩 뽑는 개수를 모두 더한다.   \n\n---\n\n```java\npackage sumOfInterval;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class num10986 {\n\tstatic long N, M, ans;\n\tstatic long[] cnt, pSum;\n\tstatic final int MAX = 1000000 + 1;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tString[] NM = br.readLine().split(\" \");\n\t\t\n\t\tN = stol(NM[0]);\n\t\tM = stol(NM[1]);\n\t\tcnt = new long[(int)M];\n\t\tpSum = new long[(int)N+1];\n\t\t\n\t\tString[] arrData = br.readLine().split(\" \");\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tlong num = stol(arrData[i-1]);\n\t\t\tpSum[i] = (pSum[i - 1] + num) % M;\n\t\t\tcnt[(int) pSum[i]]++;\n\t\t\tif(pSum[i] == 0) ans++;\n\t\t}\n\t\t\n\t\tfor(int i = 0 ; i < M ; ++i) {\n\t\t\tans += cnt[i] * (cnt[i] - 1) / 2;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\tpublic static long stol(String string) {\n\t\treturn Long.parseLong(string);\n\t}\n\n}\n\n```\n\n# Reference\n[라이님 블로그](https://m.blog.naver.com/kks227/220787178657)  ","excerpt":"구간합 배열 전처리를 통해 모든 부분합을 O(1)으로 구할 수 있는 방법 백준 11659 - 구간 합 구하기4  풀이 pSumi+1 - pSumj를 해주면 된다. 백준 11660 - 구간 합 구하기5 \n\n 풀이 이전 문제와 비슷한데 2차원 배열을 사…","fields":{"slug":"/prefixSum/"},"frontmatter":{"date":"Feb 02, 2021","title":"구간합(Prefix Sum) 배열","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# 투 포인터 알고리즘\n---\n\n> 리스트에 순차적으로 접근해야 할 때 2개의 점의 위치를 기록하면서 처리하는 알고리즘을 의미한다.  \n\n -> **2개의 점을 무조건 증가시키는 방향으로 변화하면서 횟수 계산**\n\nTip!!  \n -> 연속된 값을 이용해 풀어나가는 문제에 한정적으로 사용해야 한다.\n (정렬을 통해 연속성을 줄 수 있다.)\n\n## 백준 2470 - 두 용액\n---\n\n![2470pb1](2470pb1.PNG)\n![2470pb2](2470pb2.PNG)\n\n---\n소스를 간략히 설명해보면\n\n1. end점을 마지막, start점을 처음값을 가르키게 설정한다.\n\n2. 입력받은 값을 정렬\n\n3. sum값이 0보다 크면 end점의 index를 -1해주고, 0보다 작으면 start값을 +1해준다.\n   (두 점이 가운데로 모이면서 진행된다.)\n\n---\n\n```java\npackage package25;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class num2470 {\n\tstatic int N, s = 0, e, sum = 0, min = Integer.MAX_VALUE;\n\tstatic int[] arr, result;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tN = stoi(br.readLine());\n\t\te = N-1;\n\t\tarr = new int[N];\n\t\tresult = new int[2];\n\t\t\n\t\tString[] inputData = br.readLine().split(\" \");\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tarr[i] = stoi(inputData[i]);\n\t\t}\n\t\tArrays.sort(arr);\n\t\t\n\t\tgetResult();\n\t\t\n\t\tSystem.out.println(result[0] + \" \" + result[1]);\n\t}\n\t\n\tpublic static void getResult() {\n\t\twhile(s < e) {\n\t\t\tsum = arr[s] + arr[e];\n\t\t\tif(min > Math.abs(sum)) {\n\t\t\t\tmin = Math.abs(sum);\n\t\t\t\tresult[0] = arr[s];\n\t\t\t\tresult[1] = arr[e];\n\t\t\t}\n\t\t\tif(sum > 0) e--;\n\t\t\telse s++;\n\t\t}\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n\n```\n\n## 백준 1806 - 부분 합\n---\n\n![1806pb1](1806pb1.PNG)\n![1806pb2](1806pb2.PNG)\n\n---\n\n연속 된 수들의 부분합이니 정렬 할 필요는 없다.\n\n입력받은 S값 보다 작으면 end점을 늘려주고 S값 보다 크면 S점을 늘려준다.\n\n---\n\n```java\npackage package25;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class num1806 {\n\tstatic int INF = Integer.MAX_VALUE;\n\tstatic int N, S, result=INF, sum = 0, s = 0, e = 0;\n\tstatic int[] arr;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tString[] NS = br.readLine().split(\" \");\n\t\tN = stoi(NS[0]);\n\t\tS = stoi(NS[1]);\n\t\tarr = new int[N];\n\t\t\n\t\tString[] inputArr = br.readLine().split(\" \");\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tarr[i] = stoi(inputArr[i]);\n\t\t}\n\t\t\n\t\tcalcCount();\n\t\t\n\t\tresult = result == INF ? 0 : result;\n\t\tSystem.out.println(result);\n\t}\n\t\n\tpublic static void calcCount() {\n\t\twhile(true) {\n\t\t\tif(sum >= S) {\n\t\t\t\tsum-=arr[s++];\n\t\t\t\tresult = Math.min(result, (e-s)+1);\n\t\t\t}else if(e == N) break;\n\t\t\telse sum+=arr[e++];\n\t\t}\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n\n```\n\n## 백준 1450 - 냅색 문제\n\n이 문제가 어려웠다.\n\n이 친구는 **Meet in the 알고리즘**을 사용한다.\n\n### Meet in the 알고리즘이란?\n\n> 구간을 반으로 나눈다.\n\n범위를 2개로 나누면  \n -> O(2^n)의 시간복잡도가 O(2^(N/2)) 시간으로 줄어든다.\n\n---\n\n![1450pb1](1450pb1.PNG)\n![1450pb2](1450pb2.PNG)\n\n---\n\n앞쪽과 뒤쪽으로 범위를 나눈다. 양쪽 구간에서 가능한 모든 합을 구해다 정렬하고 \n\n한쪽 값들을 순회하면서 다른 구간를 탐색하면서 모든 합을 확인하고 C값보다 작거나 같은 값이 몇개인지 이분 탐색을 사용해 찾는다.\n\n배열의 index값을 사용하기 때문에 count계산할 때 +1을 해주거나, 입력 받을 때 배열값을 장난쳐놔야 한다.\n\n---\n\n```java\npackage package25;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class num1450 {\n\tstatic int N, C, count =0, index;\n\tstatic int[] arr;\n\tstatic ArrayList<Integer> left, right;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tString[] NC = br.readLine().split(\" \");\n\t\tN = stoi(NC[0]);\n\t\tC = stoi(NC[1]);\n\t\tarr = new int[N];\n\t\t\n\t\tString[] arrData = br.readLine().split(\" \");\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tarr[i] = stoi(arrData[i]);\n\t\t}\n\t\t\n\t\tleft = new ArrayList<Integer>();\n\t\tright = new ArrayList<Integer>();\n\t\t\n\t\tcalcPart(0,N/2,0,left);\n\t\tcalcPart(N/2+1,N-1,0,right);\n\t\t\n\t\tCollections.sort(right);\n\t\t\n\t\tfor (int i = 0; i < left.size(); i++) {\n            index = 0;\n            binarySearch(0, right.size() - 1, left.get(i));\n            count += index +1;\n\t\t}\n\t\t\n\t\tSystem.out.println(count);\n\t}\n\t\n    static void binarySearch(int start, int end, int val) {\n        if (start > end) {\n            return;\n        }\n\n        int mid = (start + end) / 2;\n\n        if (right.get(mid) + val <= C) {\n            index = mid;\n            binarySearch(mid + 1, end, val);\n        } else {\n            binarySearch(start, mid - 1, val);\n        }\n    }\n\n\tpublic static void calcPart(int s, int e, int sum, ArrayList<Integer> list) {\n\t\tif (sum > C) return;\n\t\tif (s > e) {\n\t\t\tlist.add(sum);\n\t\t\treturn;\n\t\t}\n\t\tcalcPart(s + 1, e, sum, list);\n\t\tcalcPart(s + 1, e, sum + arr[s], list);\n\t}\n\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n\n```\n\n1450번 문제 풀면서 배열 index때문에 삽질을 너무 오래했다 ㅜㅜ\n\nmeet in the middle 알고리즘은 정리 한번 하고 문제 좀 더 풀어봐야 겠다.\n\n\n# Reference \n[라이님 블로그](https://m.blog.naver.com/kks227/220795165570)  \n[meet in the middle 알고리즘 - 반으로 쪼갠다. - chogahui05님 블로그](https://blog.naver.com/chogahui05/221374387858)  \n이것이 코딩테스트다 - 나동빈","excerpt":"투 포인터 알고리즘 리스트에 순차적으로 접근해야 할 때 2개의 점의 위치를 기록하면서 처리하는 알고리즘을 의미한다.    -> 2개의 점을 무조건 증가시키는 방향으로 변화하면서 횟수 계산 Tip!!  -> 연속된 값을 이용해 풀어나가는 문제에 한정적…","fields":{"slug":"/twoPoint/"},"frontmatter":{"date":"Feb 01, 2021","title":"투포인터 알고리즘","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n백준 단계별 문제 - 투포인터에 있는 1644번 문제를 풀다 소수 구하는 알고리즘이 생각이 안나서 정리 해둘 겸 포스팅한다.\n\n# 에라토스테네스의 체란?\n \n> 소수가 되는 수의 배수를 지우면 남는 건 소수가 된다\n\n요런 알고리즘이다.\n\n![위키 이미지](era.gif)\n\n## 백준 1644 - 소수의 연속 합\n---\n\n```\n1. 에라토스테네스의 체로 소수 구하는 방법을 활용해 소수를 구한다.\n2. 투포인터 알고리즘을 활용해 연속 합 확인\n```\n\n![1644pb1](1644pb1.PNG)\n![1644pb2](1644pb2.PNG)\n\n\n---\n\n```java\npackage package25;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class num1644 {\n\tstatic int N, sum = 0, s = 0, e = 0, count = 0;\n\tstatic boolean primeCheckArr[];\n\tstatic ArrayList<Integer> primeList;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tN = stoi(br.readLine());\n\t\tprimeCheckArr = new boolean[N+1];        \n        primeList = new ArrayList<Integer>();\n        \n        getPrimeNumber();\n        \n        getCountResult();\n        \n        System.out.println(count);\n\t\t\n\t}\n\t\n\tpublic static void getCountResult() {\n\t\twhile(true) {\n\t\t\tif(sum>=N) sum-=primeList.get(s++);\n\t\t\telse if(e == primeList.size()) break;\n\t\t\telse sum+=primeList.get(e++);\n\t\t\tif(sum == N) count++;\t\n\t\t}\n\t}\n\t\n\tpublic static void getPrimeNumber() {\n\t\tprimeCheckArr[0] = primeCheckArr[1] = true;  \n\t\t\n        for(int i=2; i*i<=N; i++){\n            if(!primeCheckArr[i]) {\n            \tfor(int j=i*i; j<=N; j+=i)\n            \t\tprimeCheckArr[j]=true;                \n            }\n        }\n        \n        for(int i=1; i<=N;i++){\n        \tif(!primeCheckArr[i]) primeList.add(i); \n        }\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\n}\n```\n\n---\n추가로 소수를 구하는 부분의 for문을 살펴보면 \n\n```java\nfor(int i=2; i*i<=N; i++){\n    if(!primeCheckArr[i]) {\n    \tfor(int j=i*i; j<=N; j+=i)\n    \t\tprimeCheckArr[j]=true;                \n    }\n}\n```\n\n특정한 소수의 제곱근 까지만 구하면 된다\n -> 약수가 아닌경우는 수가 대칭을 이루기 때문\n\n# Reference\n\n[위키 백과](https://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4)  ","excerpt":"백준 단계별 문제 - 투포인터에 있는 1644번 문제를 풀다 소수 구하는 알고리즘이 생각이 안나서 정리 해둘 겸 포스팅한다. 에라토스테네스의 체란? 소수가 되는 수의 배수를 지우면 남는 건 소수가 된다 요런 알고리즘이다. 위키 이미지 백준 1644 …","fields":{"slug":"/primeNumber/"},"frontmatter":{"date":"Feb 01, 2021","title":"소수 구하기 - 에라토스테네스의 체","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# 서로소 집합 자료구조란?\n---\n\n> 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조\n\nUnion-Find Algorithm 은 그래프내 셀프루프 (self-loop : 자기자신을 가리키는 간선)을 포함하면  \n안되고 **무방향그래프에서 사이클 찾는데 유용**\n\n**Union, find 2개의 연산**이 있다.\n\n\n## 전제 조건\n---\n\n> 같은 집합에 포함되어 있는 정점들끼리는 이미 간선으로 연결 된 것이고, 다른 집합의 정점과는 서로 연결되지 않았다는 것을 기반한다.\n\n## 1. Union 연산\n---\n> 2개의 원소가 포함된 집함을 하나의 집합으로 합치는 연산\n\n- Union연산은 간선으로 표현된다.\n  (실제로는 트리 구조)\n\n## 2. Find 연산\n---\n\n> 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산\n\n- 경로 압축 기법을 적용해 시간 복잡도를 개선한다. \n- 경로압축이란? \n  - 여기선 find함수를 재귀적으로 호출한 뒤에 부모 테이블 값을 갱신하는 기법을 말함\n\n## 시간 복잡도\n---\n\n노드의 개수 : V , 최대 V-1개의 union 연산과 M개의 find연산이 가능할 때  \n -> O(V + M(1+log~2-M/V~V))  \n (O(1)이라고 생각하면 된다고 한다.)\n\n## 구현\n---\n```\n1. 초기값 자기 자신을 원소로 가지고 있게 설정\n2. 간선을 확인하며 두 노드의 루트 노드를 확인.\n   2-1. 루트 노드가 서로 다르면 두 노드에 대하여 union 연산을 수행\n   2-2. 루트 노드가 같다면 사이클이 발생\n3. 그래프에 포함되어 있는 모든 간선에 대하여 과정을 반복\n```\n\n## Tip!!\n> 유니온파인드는 상황에 따라 **여러가지 정보 추가 가능**\n\n# 백준 1717번\n---\n\n![1717pb1](1717pb1.PNG)\n![1717pb2](1717pb2.PNG)\n\n\n---\n\n위에서 설명했던 그대로 Union함수와 Find함수를 구현했다.\n\n---\n\n```java\npackage package28;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class num1717 {\n\tstatic int N, M;\n\tstatic int[] parent;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuilder sb = new StringBuilder();\n\t\tString[] NM = br.readLine().split(\" \");\n\t\t\n\t\tN = stoi(NM[0]);\n\t\tM = stoi(NM[1]);\n\t\tparent = new int[N];\n\t\t\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tparent[i] = i;\n\t\t}\n\t\t\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tString[] inputData = br.readLine().split(\" \");\n\t\t\t\n\t\t\tint action = stoi(inputData[0]);\n\t\t\tint a = stoi(inputData[1])-1;\n\t\t\tint b = stoi(inputData[2])-1;\n\t\t\t\n\t\t\t\n\t\t\tif(action == 0) {\n\t\t\t\tunion(a,b);\n\t\t\t}else {\n\t\t\t\tsb.append(find_parent(a) == find_parent(b) ? \"YES\" : \"NO\");\n\t\t\t\tsb.append(\"\\n\");\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\t\n\tpublic static int find_parent(int num) {\n\t\tif(parent[num] != num)\n\t\t\tparent[num] = find_parent(parent[num]);\n\t\treturn parent[num];\n\t}\n\t\n\tpublic static void union(int a, int b) {\n\t\tint aParent = find_parent(a);\n\t\tint bParent = find_parent(b);\n\t\tif(aParent<bParent)\n\t\t\tparent[b] = a;\n\t\telse\n\t\t\tparent[a] = b;\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\n}\n\n```\n\n\n# 백준 1976번\n---\n\n![1976pb1](1976pb1.PNG)\n![1976pb2](1976pb2.PNG)\n\n\n---\n\n1717번 문제와 거의 동일하다.\n\n마지막에 입력받은 값들이 하나의 부모노드를 가지고 있는지 알아보면 된다.\n\n---\n\n```java\npackage package28;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class num1976 {\n\tstatic int N, M;\n\tstatic int[] parent;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tN = stoi(br.readLine());\n\t\tM = stoi(br.readLine());\n\t\tparent = new int[N+1];\n\t\t\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tparent[i] = i;\n\t\t}\n\t\t\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tString[] inputData = br.readLine().split(\" \");\n\t\t\tfor(int j=0; j<N; j++) {\n\t\t\t\tint num = stoi(inputData[j]);\n\t\t\t\tif(num == 1) {\n\t\t\t\t\tunion(i, j+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tString[] map = br.readLine().split(\" \");\n\t\tboolean resultIndex = true;\n\t\tint index = parent[stoi(map[0])];\n\t\t\n\t\tfor(int i=1; i<map.length; i++) {\n\t\t\tif(index != parent[stoi(map[i])])\n\t\t\t\tresultIndex = false;\n\t\t}\n\t\tSystem.out.println(resultIndex == true ? \"YES\" : \"NO\");\n\t}\n\t\n\tpublic static int find_parent(int num) {\n\t\tif(parent[num] == num)\n\t\t\treturn num;\n\t\treturn parent[num] = find_parent(parent[num]);\n\t}\n\t\n\tpublic static void union(int a, int b) {\n\t\ta = find_parent(a);\n\t\tb = find_parent(b);\n\t\tif (a != b) {\n            if (a < b) {\n                parent[b] = a;\n            } else {\n                parent[a] = b;\n            }\n\t\t}\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n\n```\n\n# 백준 4195번\n---\n\n![4195pb1](4195pb1.PNG)\n![4195pb2](4195pb2.PNG)\n\n\n---\n\n이문제는 위의 문제들과 다르게 입력값이 문자열로 들어온다.\n\nHashMap을 사용해서 문자열마다 index를 할당해주는 방식으로 구현했다.\n\n---\n\n```java\npackage package28;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\npublic class num4195 {\n\tstatic int N, F, index;\n\tstatic HashMap<String, Integer> map;\n\tstatic int[] parent;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuilder sb = new StringBuilder();\n\t\tN = stoi(br.readLine());\n\t\t\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tmap = new HashMap<String, Integer>();\n\t\t\tindex = 1;\n\t\t\t\n\t\t\tF = stoi(br.readLine());\n\t\t\tparent = new int[2*F+1];\n\t\t\tArrays.fill(parent, -1);\n\t\t\t\n\t\t\tfor(int j=0; j<F; j++) {\n\t\t\t\tString[] inputData = br.readLine().split(\" \");\n\t\t\t\tint v1 = getMapValue(inputData[0]);\n\t\t\t\tint v2 = getMapValue(inputData[1]);\n\t\t\t\tint result = union(v1,v2);\n\t\t\t\tsb.append(result+\"\\n\");\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sb.toString());\n\t}\n\t\n\tpublic static int find_parent(int num) {\n\t\tif(parent[num] < 0)\n\t\t\treturn num;\n\t\treturn parent[num] = find_parent(parent[num]);\n\t}\n\t\n\tpublic static int union(int a, int b) {\n\t\ta = find_parent(a);\n\t\tb = find_parent(b);\n\t\tif (a != b) {\n            if (a < b) {\n            \tparent[a] += parent[b];\n                parent[b] = a;\n            } else {\n            \tparent[b] += parent[a];\n                parent[a] = b;\n            }\n\t\t}\n\t\treturn parent[a] < 0 ? parent[a] : parent[b];\n\t}\n\t\n\tpublic static int getMapValue(String string) {\n\t\tif(!map.containsKey(string)) {\n\t\t\tmap.put(string, index);\n\t\t\tindex++;\n\t\t}\n\t\treturn map.get(string);\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n\n```\n\n# 백준 20040번\n---\n\n![20045pb1](20045pb1.PNG)\n![20045pb2](20045pb2.PNG)\n![20045pb3](20045pb3.PNG)\n\n\n---\n\n이문제는 첫번째, 두번째 문제와 비슷한데  \n사이클이 존재하면 사이클이 걸린 입력순서를 출력해주는 문제다.\n\n\n---\n\n```java\npackage package28;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class num20040 {\n\tstatic int N, M;\n\tstatic int[] parent;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st;\n\t\t\n\t\tint index = 0;\n\t\tst = new StringTokenizer(br.readLine());\n\t\tN = stoi(st.nextToken());\n\t\tM = stoi(st.nextToken());\n\t\tparent = new int[N+1];\n\t\tfor(int i =0; i<=N; i++) {\n\t\t\tparent[i] = i;\n\t\t}\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tint v1 = stoi(st.nextToken());\n\t\t\tint v2 = stoi(st.nextToken());\n\t\t\tif(!union(v1,v2)) {\n\t\t\t\tindex = i+1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(index);\n\t}\n\t\n\tpublic static boolean union(int a, int b) {\n\t\ta = find_parent(a);\n\t\tb = find_parent(b);\n\t\tif(a==b)\n\t\t\treturn false;\n\t\tif(a!=b) {\n\t\t\tif(a < b) {\n\t\t\t\tparent[b] = a;\n\t\t\t}else {\n\t\t\t\tparent[a] = b;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static int find_parent(int num) {\n\t\tif(parent[num] == num)\n\t\t\treturn num;\n\t\treturn parent[num] = find_parent(parent[num]);\n\t}\n\t\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n\n```\n\n블로그와 책을 읽고 유니온 파인드 개념을 정리해보았다.  \n\n유니온 파인드는 **최소신장트리**에 이용된다고  한다.  \n궁금하니 빠른 시일내로 공부해야겠다 ㅋㅋ    \n\n# Referece\n[라이님 블로그](https://m.blog.naver.com/kks227/220791837179)  \n[잭팟53님 블로그](https://jackpot53.tistory.com/)  \n이것이 취업을 위한 코딩 테스트다 - 나동빈  ","excerpt":"서로소 집합 자료구조란? 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조 Union-Find Algorithm 은 그래프내 셀프루프 (self-loop : 자기자신을 가리키는 간선)을 포함하면 안되고 무방향그래프에서 사이클 찾…","fields":{"slug":"/unionFind/"},"frontmatter":{"date":"Jan 29, 2021","title":"Union Find 정리","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n머리 식힐 겸 재밌어 보이는 문제 찾다가 풀어봤다.\n\n## 문제\n\n![15686pb1](15686pb1.PNG)\n![15686pb2](15686pb2.PNG)\n![15686pb3](15686pb3.PNG)\n![15686pb4](15686pb4.PNG)\n\n## 풀이\n\n풀이는 다음과 같다.\n```\n1. 조합으로 치킨 집 구함\n2. 치킨 집에서 집까지 거리를 찾는다.\n3. 구한 거리의 합이 현재 가지고 있는 최솟값보다 작으면 교체\n```\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic int N, M, result = Integer.MAX_VALUE;\n\tstatic ArrayList<House> house;\n\tstatic ArrayList<Chicken> chicken;\n\tstatic int[] houseLen;\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tString[] NM = br.readLine().split(\" \");\n\t\tN = stoi(NM[0]);\n\t\tM = stoi(NM[1]);\n\t\tboolean[] visited = new boolean[14];\n\t\thouse = new ArrayList<House>();\n\t\tchicken = new ArrayList<Chicken>();\n\t\t\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tString[] inputData = br.readLine().split(\" \");\n\t\t\tfor(int j=0; j<N; j++) {\n\t\t\t\tint num = stoi(inputData[j]);\n\t\t\t\tif(num == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(num == 1) {\n\t\t\t\t\thouse.add(new House(i,j));\n\t\t\t\t}else {\n\t\t\t\t\tchicken.add(new Chicken(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\thouseLen = new int[house.size()];\n\t\tcombination(visited, 0, chicken.size(), M);\n\t\tSystem.out.println(result);\n\t\t\n\t}\n\tpublic static void combination(boolean[] visited, int start, int n, int r) {\n\t\tif(r==0) {\n\t\t\tint len = 0;\n\t\t\tint index = 0;\n\t\t\tArrayList<Chicken> ncr = new ArrayList<Chicken>();\n\t\t\tfor(int i=0; i<visited.length; i++) {\n\t\t\t\tif(visited[i]==true) {\n\t\t\t\t\tncr.add(chicken.get(i));\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlen = calcMinLen(ncr);\n\t\t\tresult = result < len ? result : len;\n\t\t\treturn;\n\t\t}\n\n\t\tfor(int i=start; i<n; i++) {\n\t\t\tvisited[i] = true;\n\t\t\tcombination(visited, i+1, n, r-1);\n\t\t\tvisited[i] = false;\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static int calcMinLen(ArrayList<Chicken> c) {\n\t\tint minLen = 0;\n\t\tArrays.fill(houseLen, Integer.MAX_VALUE);\n\t\tfor(int i=0; i<c.size(); i++) {\n\t\t\tChicken now = c.get(i);\n\t\t\tfor(int k=0; k<house.size(); k++) {\n\t\t\t\tint houseNowLen = Math.abs(now.x - house.get(k).x) + Math.abs(now.y - house.get(k).y);\n\t\t\t\thouseLen[k] = houseLen[k] < houseNowLen ? houseLen[k] : houseNowLen;\n\t\t\t}\n//\t\t\tSystem.out.println(now.x + \" \" + now.y);\n\t\t}\n\t\tfor(int i=0; i<houseLen.length; i++) {\n\t\t\tminLen += houseLen[i];\n//\t\t\tSystem.out.println(houseLen[i]);\n\t\t}\n//\t\tSystem.out.println(minLen);\n\t\t\n\t\treturn minLen;\n\t}\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\n\tstatic class Chicken{\n\t\tint x, y;\n\t\tChicken(int x, int y){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\tstatic class House{\n\t\tint x, y;\n\t\tHouse(int x, int y){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n}\n\n```\n\n주석 해놓은 부분 주석풀고 실행해보면 과정 살펴볼 수 있다.\n\n상어들로 장난치는 문제들도 있는데 아침 공부 시작할 때 풀어보면 좋을 것 같다. \n\n끗","excerpt":"머리 식힐 겸 재밌어 보이는 문제 찾다가 풀어봤다. 문제 \n\n\n 풀이 풀이는 다음과 같다. 주석 해놓은 부분 주석풀고 실행해보면 과정 살펴볼 수 있다. 상어들로 장난치는 문제들도 있는데 아침 공부 시작할 때 풀어보면 좋을 것 같다.  끗","fields":{"slug":"/backjoon15686/"},"frontmatter":{"date":"Jan 29, 2021","title":"백준 15686 - 치킨 배달","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n트리를 정리해보자 ㅎㅎ\n\n## 특징\n```\n1. 연결 그래프\n2. 방향을 무시하였을 때, 싸이클이 존재하지 않는다.\n3. 트리의 간선개수는 정점 개수보다 1작다.\n```\n\n트리의 서브트리는 절대로 영역이 겹치지 않음 -> **분할정복**, **DP**로 장난을 잘 칠 줄 알아야 한다.\n\n## 순회 방법\n\n트리의 순회 방법은 3가지다.\n```\n1. 전위 순회 (root -> left -> right) \n2. 중위 순회 (left -> root -> right)\n3. 후위 순회 (left -> right -> root)\n```\n보통 BFS, DFS로 구현한다.\n\n## [백준 11725] - 트리의 부모찾기 \n\n![11725pb1](11725pb1.PNG)\n![11725pb2](11725pb2.PNG)\n\n### 풀이\n---\n\nBFS, DFS를 사용해 탐색하는 방식으로 구현했다.\n\n---\n```java\npackage package27;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class num11725 {\n\tstatic int N;\n\tstatic ArrayList<ArrayList<Integer>> tree;\n\tstatic StringBuilder sb;\n\tstatic int[] result;\n\tstatic boolean[] visited;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\ttree = new ArrayList<ArrayList<Integer>>();\n\t\tsb = new StringBuilder();\n\t\t\n\t\tint N = stoi(br.readLine());\n\t\tresult = new int[N+1];\n\t\tvisited = new boolean[N+1];\n\t\tfor(int i=0; i<=N; i++) {\n\t\t\ttree.add(new ArrayList<Integer>());\n\t\t}\n\t\t\n\t\tfor(int i=0; i<N-1; i++) {\n\t\t\tString[] edge = br.readLine().split(\" \");\n\t\t\tint node1 = stoi(edge[0]);\n\t\t\tint node2 = stoi(edge[1]);\n\n\t\t\ttree.get(node1).add(node2);\n\t\t\ttree.get(node2).add(node1);\n\t\t}\n\t\t\n//\t\tdfs(1);\n\t\tbfs();\n\t\t\n\t\tfor(int i=2; i<=N; i++) {\n\t\t\tSystem.out.println(result[i]);\n\t\t}\n\t}\n\t\n    private static void dfs(int num){\n        if(visited[num]){\n            return;\n        }\n        visited[num] =true;\n        for (int node: tree.get(num)) {\n            if(!visited[node]){\n                result[node] = num;\n                dfs(num);\n            }\n\n        }\n\n    }\n\t\n\tpublic static void bfs() {\n\t\tQueue<Integer> queue = new LinkedList<Integer>();\n\t\tfor(int value : tree.get(1)) {\n\t\t\tresult[value] = 1;\n\t\t\tqueue.add(value);\n\t\t}\n\t\t\n\t\twhile(!queue.isEmpty()) {\n\t\t\tint node = queue.remove();\n\t\t\t\n\t\t\tfor(int value : tree.get(node)) {\n\t\t\t\tif(result[value] == 0) {\n\t\t\t\t\tresult[value] = node;\n\t\t\t\t\tqueue.add(value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n\n```\n\n\n## [백준 4803] - 트리\n\n![4803pb1](4803pb1.PNG)\n![4803pb2](4803pb2.PNG)\n\n### 풀이\n\n아.... 이거 풀다가 책상 부실뻔 했다. 너무 헤맸다... ㅜㅜ\n\n일단 문제에 T는 트리의 개수다.\n\ndfs로 입력받은 노드 모두 탐색하고, cycle이 존재하면 no tree로 출력하게 짰는데 계속 틀렸다고 나왔다.  ㅎㅎ 정답을 알려줘\n\n열받아서 [마포 코딩박님 블로그](https://mapocodingpark.blogspot.com/2020/05/4803.html) dfs 부분을 참고해서 코드 작성했다.\n\n일단 정답은 맞췄다고 나오는데 \n\n```\n입력값 \n7 4\n1 2\n2 3\n3 1\n6 7\n0 0\n출력값 \nCase 1: A forest of 3 trees.\n```\n\n이렇게 나오는데 이거 틀린거 아님? cycle 있으면 트리 없다고 나와야 하는거 아닌가 아시는 분 알려주세요ㅜㅜㅜㅜㅜ\n\n아 짜증나 ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ 화 좀 식히고 나중에 생각나면 다시 봐야겠다...\n\n```java\npackage package27;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class num4803 {\n\tstatic int N, M, count, caseIndex = 0;\n\tstatic StringBuilder sb;\n\tstatic BufferedReader br; \n\tstatic ArrayList<Integer>[] graph;\n\tstatic boolean[] visited;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tsb = new StringBuilder();\n\t\t\n\t\twhile(true) {\n\t\t\tString[] NM = br.readLine().split(\" \");\n\t\t\t\n\t\t\tN = stoi(NM[0]);\n\t\t\tM = stoi(NM[1]);\n\t\t\tgraph = new ArrayList[N+1];\n\t\t\tvisited = new boolean[N+1];\n\t\t\t\n\t\t\tif(N==0 && M==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tresetData();\n\t\t\t\n\t\t\tinputTreeData();\n\t\t\t\n\t\t\tcheckTree();\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\t\n\tpublic static void inputTreeData() throws IOException {\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tString[] Edge = br.readLine().split(\" \");\n\t\t\tint v1 = stoi(Edge[0]), v2 = stoi(Edge[1]);\n\t\t\t\n\t\t\tgraph[v1].add(v2);\n\t\t\tgraph[v2].add(v1);\n\t\t}\n\t}\n\t\n\tpublic static void checkTree() {\n\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tif(!visited[i]) {\n\t\t\t\tif(dfs(i, 0))\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(count == 1) {\n\t\t\tsb.append(\"Case \"+caseIndex+\": There is one tree.\\n\");\n\t\t}else if(count==0){\n\t\t\tsb.append(\"Case \"+caseIndex+\": No trees.\\n\");\n\t\t}else {\n\t\t\tsb.append(\"Case \"+caseIndex+\": A forest of \"+count+\" trees.\\n\");\n\t\t}\n\t}\n\t\n\tpublic static boolean dfs(int num, int prev) {\n\t\tvisited[num] = true;\n\t\t\n\t\tfor(int node : graph[num]) {\n\t\t\tif (node == prev) continue;\n\t\t\tif (visited[node]) return false;\n\t\t\tif (dfs(node, num) == false) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static void resetData() {\n\t\tfor(int i=0; i<=N; i++) {\n\t\t\tgraph[i] = new ArrayList<Integer>();\n\t\t\tvisited[i] = false;\n\t\t}\n\t\tcount = 0;\n\t\tcaseIndex++;\n\t}\n\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n\n```\n\n## [백준 1967] - 트리의 지름\n\n처음에 문제 접근하는 법을 잘못해서 좀 헤맸다.\n\n트리의 지름을 구하는 방법은 다음과 같다.\n\n```\n1. 트리의 임의의 정점(x)에서 가장 먼 정점(y)을 찾는다.\n2. 가장 먼 정점(y) 에서 가장 먼 정점(z)을 찾는다.\n => 지름은 y - z 까지의 거리다.\n```\n\n증명이 궁금하면 [전명우님 블로그 - 트리의 지름 구하기](https://blog.myungwoo.kr/112) 에 쉽게 설명한 글이 있다.  \n -> 한줄 요약 : 어떤 한 점에서 가장 먼 점이 지름에 무조건 포함된다 (포함 안되는 경우를 증명)\n\n![1967문제1](1967pb1.PNG)\n![1967문제2](1967pb2.PNG)\n\n```java\n\npackage package27;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class num1967 {\n\tstatic int N, result = 0, start;\n\tstatic ArrayList<ArrayList<Edge>> Vertex;\n\tstatic boolean[] visited;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tN = stoi(br.readLine());\n\t\tVertex = new ArrayList<ArrayList<Edge>>();\n\t\t\n\t\tfor(int i=0; i<=N; i++) {\n\t\t\tVertex.add(new ArrayList<Edge>());\n\t\t}\n\t\t\n\t\tfor(int i=1; i<N; i++) {\n\t\t\tString[] inputData = br.readLine().split(\" \");\n\t\t\tint node1 = stoi(inputData[0]);\n\t\t\tint node2 = stoi(inputData[1]);\n\t\t\tint w = stoi(inputData[2]);\n\t\t\t\n\t\t\tVertex.get(node1).add(new Edge(node2, w));\n\t\t\tVertex.get(node2).add(new Edge(node1, w));\n\t\t}\n\t\t\n\t\tvisited = new boolean[N+1];\n\t\tvisited[1] = true;\n\t\tdfs(0, 1);\n\t\t\n\t\tvisited = new boolean[N+1];\n\t\tvisited[start] = true;\n\t\tdfs(0, start);\n\t\t\n\t\tSystem.out.println(result);\n\t}\n\t\n\tpublic static int dfs(int len, int now) {\n\t\tif (result < len) {\n\t\t\tresult = len;\n\t\t\tstart = now;\n\t\t}\n\t\tSystem.out.println(now);\n\n        for (Edge node: Vertex.get(now)) {\n            if(!visited[node.e]){\n            \tvisited[node.e] = true;\n            \tdfs(len + node.w, node.e);\n            }\n        }\n        return result;\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\t\n\tstatic class Edge{\n\t\tint e, w;\n\t\tEdge(int e,int w){\n\t\t\tthis.e = e;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n}\n\n```\n\n[트리의 지름 - 백준1167](https://www.acmicpc.net/problem/1167)번 비슷한 문제다.  \n\n\n\n## [백준 2250] - 트리의 높이와 너비\n\n이문제 풀면서 많이 헤맸다ㅋㅋㅋㅋㅋㅋㅋ \n\n배열 만들어서 깊이마다 맨 오른쪽 값을 맨 왼쪽 값 빼면 될 것 같다는 생각을 했는데.....\n\n양심고백을 조금 해보면 오늘 삽질을 너무 많이 해서 고민 많이 안해보고 정답 해결 방법부터 찾아봤다.\n\n[쾌락코딩님 블로그 - 백준2250번 문제(트리의 높이와 너비) with Java](https://wooooooak.github.io/algorithm/2018/12/05/%EB%B0%B1%EC%A4%802250%EB%AC%B8%EC%A0%9C/)글을 참고했다.\n\n문제의 포인트는 3가지다.\n\n```\n1. 문제에서 루트가 정해져 있지 않다\n   -> 루트를 확인할 수 있는 뭔가 방법이 필요\n2. 트리의 높이마다 가장 오른쪽 값, 가장 왼쪽값 저장\n   -> 오른쪽 - 왼쪽 + 1\n3. 중위 순회로 순회\n   -> 그림보면 왼쪽 - 루트 - 오른쪽 순으로 index가 표시되있음\n```\n\n![2250pb1](2250pb1.PNG)\n![2250pb2](2250pb2.PNG)\n![2250pb3](2250pb3.PNG)\n\n### 풀이\n\n```java\npackage package27;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class num2250 {\n\tstatic int N, maxWidth, maxDepth, root, vCount = 1;\n\tstatic Node[] tree;\n\t\n\tstatic int[] depthLeft;\n\tstatic int[] depthRight;\n\tstatic BufferedReader br;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tN = stoi(br.readLine());\n\t\t\n\t\tinit();\n\t\t\n\t\tinputTreeData();\n\t\t\n\t\tsearchRootIndex();\n\t\t\n\t\tinOrder(root, 1);\n\t\t\n\t\tprintResult();\n\t\t\n\t}\n\t\n\tpublic static void init() {\n\t\ttree = new Node[N+1];\n\t\tdepthLeft = new int[N+1];\n\t\tdepthRight = new int[N+1];\n\t\t\n\t\tfor(int i=0; i<=N; i++) {\n\t\t\ttree[i] = new Node(-1, -1, -1);\n\t\t\tdepthLeft[i] = N+1;\n\t\t}\n\t}\n\t\n\tpublic static void inputTreeData() throws IOException {\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tString[] inputData = br.readLine().split(\" \");\n\t\t\t\n\t\t\tint num = stoi(inputData[0]);\n\t\t\tint left = stoi(inputData[1]);\n\t\t\tint right = stoi(inputData[2]);\n\t\t\t\n\t\t\ttree[num].left = left;\n            tree[num].right = right;\n            if(left != -1)\n                tree[left].parent = num;\n            \n            if(right != -1)\n                tree[right].parent = num;\n\t\t}\n\t}\n\t\n\tpublic static void searchRootIndex() {\n\t\tfor(int i=1; i <= N; i++) {\n\t\t\tif(tree[i].parent == -1) {\n\t\t\t\troot = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void inOrder(int parentIndex, int depth) {\n        Node root = tree[parentIndex];\n        if(maxDepth < depth) maxDepth = depth;\n        if(root.left != -1) {\n            inOrder(root.left, depth + 1);\n        }\n        \n        depthLeft[depth] = Math.min(depthLeft[depth], vCount);\n        depthRight[depth] = vCount++;\n        \n        if(root.right != -1) {\n            inOrder(root.right, depth + 1);\n        }\n\t}\n\t\n\tpublic static void printResult() {\n        int index = 1;\n        int maxWitdh = depthRight[1] - depthLeft[1] + 1;\n        for(int i=2; i <= maxDepth; i++) {\n            int tmp = depthRight[i] - depthLeft[i] +1;\n            if(maxWitdh < tmp) {\n            \tindex = i;\n            \tmaxWitdh = tmp;\n            }\n        }\n        \n        System.out.println(index + \" \" + maxWitdh);\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\t\n\tstatic class Node{\n\t\tint parent, value, left, right;\n\t\tNode(int value, int left, int right){\n\t\t\tthis.parent = -1;\n\t\t\tthis.value = value;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\t}\n}\n\n```\n\n## 정리\n\n사실 트리는 학교 알고리즘 시간에 다뤄봐서 정리하는데 오래걸리지 않을 줄 알았는데 생각보다 오래걸렸다 ㅜㅜㅜㅜ 문제도 많이 풀어봐야 할 듯.... \n\n정.말.알.고.리.즘.문.제.풀.이.는.너.무.재.밌.다.하.하.하.하.하.하.하.하.하.하.하.하.하\n\n오늘 정리한 문제들은 dfs, bfs로 탐색하는 문제들이었다.\n\n\n아래 사진같은3 유형의 문제들도 있던데.....\n![finish](finish.PNG)\n빠른 시일내로 4문제 풀어봐야겠다. (조금 무서워 보인다ㅋ)\n\n# Reference\n[라이님 블로그](https://m.blog.naver.com/kks227/220788265724)  \n[전명우님 블로그](https://blog.myungwoo.kr/112)  \n[쾌락코딩님 블로그 - 백준2250번 문제(트리의 높이와 너비) with Java](https://wooooooak.github.io/algorithm/2018/12/05/%EB%B0%B1%EC%A4%802250%EB%AC%B8%EC%A0%9C/)  \n[마포 코딩박님 블로그](https://mapocodingpark.blogspot.com/2020/05/4803.html)  ","excerpt":"트리를 정리해보자 ㅎㅎ 특징 트리의 서브트리는 절대로 영역이 겹치지 않음 -> 분할정복, DP로 장난을 잘 칠 줄 알아야 한다. 순회 방법 트리의 순회 방법은 3가지다. 보통 BFS, DFS로 구현한다. 백준 11725 - 트리의 부모찾기 \n 풀이 …","fields":{"slug":"/tree/"},"frontmatter":{"date":"Jan 28, 2021","title":"트리","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n백준 11779, 11780, 1738번 문제를 통해 최단경로의 경로출력을 정리해보려고 한다.\n\n---\n\n# 백준 11779 - 다익스트라\n\n![11779문제 사진1](11779pb1.PNG)\n![11779문제 사진2](11779pb2.PNG)\n\n---\n\n소스를 간략히 설명하면\n\n다익스트라 알고리즘에 값이 조건에 맞아 갱신될 때 배열의 값에 이전 노드를 저장한다.\n\n첫 노드부터 순서대로 출력하기 위해 stack을 사용했다.\n\n---\n\n```java\npackage pakcage26;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.PriorityQueue;\nimport java.util.Stack;\n\npublic class num11779 {\n\tstatic int N, M, count=2,INF = Integer.MAX_VALUE;\n\tstatic ArrayList<ArrayList<Edge>> Vertex;\n\tstatic int[] dist, pre;\n\tstatic boolean[] visited;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tN = stoi(br.readLine());\n\t\tM = stoi(br.readLine());\n\t\tVertex = new ArrayList<ArrayList<Edge>>();\n\t\tdist = new int[N];\n\t\tpre = new int[N];\n\t\tvisited = new boolean[N];\n\t\t\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tVertex.add(new ArrayList<Edge>());\n\t\t\tdist[i] = INF;\n\t\t}\n\t\t\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tString[] uvw = br.readLine().split(\" \");\n\t\t\tint u = stoi(uvw[0])-1;\n\t\t\tint v = stoi(uvw[1])-1;\n\t\t\tint w = stoi(uvw[2]);\n\t\t\tVertex.get(u).add(new Edge(v,w));\n\t\t}\n\t\tString[] point = br.readLine().split(\" \");\n\t\tint start = stoi(point[0])-1;\n\t\tint end = stoi(point[1])-1;\n\t\tdijkstra(start, end);\n\t\t\n\t\tlong answer =dist[end];\n\n\t\tStack<Integer> st = new Stack<Integer>();\n\t\tst.add(end);\n\t\t\n\t\twhile (pre[end] != start) {\n\t\t\tst.add(pre[end]);\n\t\t\tend = pre[end];\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\tst.add(start);\n\t\t\n\t\tSystem.out.println(answer);\n\t\tSystem.out.println(count);\n\t\twhile (!st.isEmpty()) {\n\t\t\tSystem.out.print(st.pop()+1 + \" \");\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void dijkstra(int start, int end) {\n\t\tdist[start] = 0;\n\t\tPriorityQueue<Edge> q = new PriorityQueue<Edge>();\n\t\tq.add(new Edge(start, 0));\n\t\t\n\t\twhile(!q.isEmpty()) {\n\t\t\tEdge now = q.remove();\n\t\t\tif(!visited[now.e]) {\n\t\t\t\tvisited[now.e] = true;\n\t\t\t\tfor(Edge next : Vertex.get(now.e)) {\n\t\t\t\t\tif(!visited[next.e] && dist[next.e] >= dist[now.e] + next.w) {\n\t\t\t\t\t\tdist[next.e] = dist[now.e] + next.w;\n\t\t\t\t\t\tq.add(new Edge(next.e, dist[next.e]));\n\t\t\t\t\t\tpre[next.e] = now.e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\t\n\tstatic class Edge implements Comparable<Edge>{\n\t\tint e, w;\n\t\tEdge(int e, int w){\n\t\t\tthis.e = e;\n\t\t\tthis.w = w;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Edge o){\n\t\t\treturn w - o.w;\n\t\t}\n\t}\n}\n```\n\n# 백준 11780 - 플로이드\n---\n![11780문제 사진1](11780pb1.PNG)\n![11780문제 사진2](11780pb2.PNG)\n![11780문제 사진2](11780pb3.PNG)\n---\nnext배열은 a(정점) -> b(정점) 일 때, 출발 정점(a)의 값을 가지고 있다.\n\n플로이드 알고리즘은 i -> k -> j 의 거리가 짧을 경우 최단거리(dist배열)을 갱신해준다.  \n\n동일하게 최단거리가 짧은 경우 출발 노드(next배열)을 k로 바꿔서 갱신해준다.\n\n---\n```java\npackage pakcage26;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Stack;\n\npublic class num11780 {\n\tstatic int N, M, INF = 100000000;\n\tstatic int[][] dist, next;\n\tstatic boolean[][] visited;\n\tstatic Stack<Integer> stack;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuilder sb = new StringBuilder();\n\t\t\n\t\t\n\t\tN = stoi(br.readLine());\n\t\tM = stoi(br.readLine());\n\t\tdist = new int[N][N];\n\t\tnext = new int[N][N];\n\t\t\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tfor(int j=0; j<N; j++) {\n\t\t\t\tdist[i][j] = i == j ? 0 : INF;\n\t\t\t\tnext[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tString[] abc = br.readLine().split(\" \");\n\t\t\tint a = stoi(abc[0])-1;\n\t\t\tint b = stoi(abc[1])-1;\n\t\t\tint c = stoi(abc[2]);\n\t\t\t\n\t\t\tdist[a][b] = Math.min(dist[a][b], c);\n\t\t\tnext[a][b] = a;\n\t\t}\n\t\t\n\t\tfloyd();\n\t\t\n\t\tprintPath();\n\t}\n\t\n\tpublic static void floyd() {\n\t\tfor(int k = 0; k<N; k++) {\n\t\t\tfor(int i = 0; i<N; i++) {\n\t\t\t\tfor(int j=0; j<N; j++) {\n\t\t\t\t\tif(dist[i][j] > dist[i][k] + dist[k][j]) {\n\t\t\t\t\t\tdist[i][j] = dist[i][k] +dist[k][j];\n\t\t\t\t\t\tnext[i][j] = next[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void printPath() {\n\t\tfor(int[] a : dist) {\n\t\t\tfor(int b: a) {\n\t\t\t\tSystem.out.print(b + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t\n        for(int i=0; i<N; i++) {\n            for(int j=0; j<N; j++) {\n                if(next[i][j]==INF)\n                    System.out.println(0);\n\n                else {\n                \tstack = new Stack<>();\n                    int pre = j;\n                    stack.push(j);\n                    while(i != next[i][pre]) {\n                        pre = next[i][pre];\n                        stack.push(pre);\n                    }\n                    System.out.print((stack.size()+1)+\" \");\n                    System.out.print(i+1+\" \");\n                    while(!stack.empty())\n                        System.out.print(stack.pop()+1+\" \");\n                    System.out.println();\n                }\n            }\n        }\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\t\n}\n```\n\n# 벨만포드 - 백준 1738\n\n---\n\n![1738문제1](1738pb1.PNG)\n![1738문제2](1738pb1.PNG)\n\n---\n일차원 배열을 선언해 이전 경로의 값을 가지고 있는다.\n\n기존의 벨만 포드 알고리즘과는 달리 음의 싸이클이 있으면 끝이 아니라,  \n음의 싸이클에 도착점으로 도달 가능해야 답이 -1이다.\n\n```\n4 4\n1 4 3\n2 3 1\n3 2 1\n4 2 1\n```\n위의 테스트 케이스를 통과해야 정답이다.\n\n이거 때문에 삽질 좀 했다 ㅜㅜ\n\n---\n\n```java\npackage MinPath;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Stack;\n\npublic class num1738 {\n\tstatic int N, M, INF = 987654321, INF2=-987654321;\n\tstatic ArrayList<ArrayList<Edge>> Vertex;\n\tstatic int[] preVertex;\n\tstatic long[] dist;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tString[] NM = br.readLine().split(\" \");\n\t\t\n\t\tN = stoi(NM[0]);\n\t\tM = stoi(NM[1]);\n\t\t\n\t\tdist = new long[N];\n\t\tVertex = new ArrayList<ArrayList<Edge>>();\n\t\tpreVertex = new int[N];\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tVertex.add(new ArrayList<Edge>());\n\t\t\tdist[i] = INF;\n\t\t\tpreVertex[i] = -1;\n\t\t}\n\t\t\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tString[] uvw = br.readLine().split(\" \");\n\t\t\tint u = stoi(uvw[0])-1;\n\t\t\tint v = stoi(uvw[1])-1;\n\t\t\tint w = stoi(uvw[2]);\n\t\t\tVertex.get(u).add(new Edge(v, -w));\n\t\t}\n\t\t\n\t\tbellmanFord();\n\t\t\n\t\tprintPath();\n\t}\n\t\n\tpublic static void bellmanFord() {\n\t\tdist[0] = 0;\n\t\tpreVertex[0] = 0;\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tfor(int j=0; j<N; j++) {\n\t\t\t\tfor(Edge edge : Vertex.get(j)) {\n\t\t\t\t\tint next = edge.e, weight = edge.w;\n\t\t\t\t\tif(dist[j]!=INF && dist[next] > dist[j] + weight) {\n\t\t\t\t\t\tdist[next] = (dist[j] + weight);\n\t\t\t\t\t\tpreVertex[next] = j;\n\t\t\t\t\t\tif(i == N-1) {\n\t\t\t\t\t\t\tdist[next] = INF2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void printPath() {\n\t\tStack<Integer> stack = new Stack<Integer>();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(dist[N-1] == INF || dist[N-1] == INF2)\n\t\t\tsb.append(\"-1\");\n\t\telse{\n\t\t\tfor (int i = N-1 ; i != 0; i = preVertex[i]) {\n\t\t\t\tif(dist[i] == INF2) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}else{\n\t\t\t\t\tstack.push(i);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tstack.push(0);\n\t        for (int i = stack.size(); i > 0; --i)\n\t        {\n\t            sb.append(stack.pop()+1+\" \");\n\t        }\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\t\n\tstatic class Edge{\n\t\tint e, w;\n\t\tEdge(int e, int w){\n\t\t\tthis.e = e;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\n}\n```\n\n# 정리\n\n---\n\n세가지 알고리즘 모두 최단거리를 추적하면서  \n**경로를 저장할 공간을 만들어서 저장하는 방식**이다.\n\n# Reference\n---\n[갓킹독님 블로그](https://blog.encrypted.gg/category/%EA%B0%95%EC%A2%8C/%EC%8B%A4%EC%A0%84%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98?page=1)  \n[라이님 블로그](https://m.blog.naver.com/PostList.nhn?blogId=kks227)  \n","excerpt":"백준 11779, 11780, 1738번 문제를 통해 최단경로의 경로출력을 정리해보려고 한다. 백준 11779 - 다익스트라 \n 소스를 간략히 설명하면 다익스트라 알고리즘에 값이 조건에 맞아 갱신될 때 배열의 값에 이전 노드를 저장한다. 첫 노드부터…","fields":{"slug":"/shortestDistance_2/"},"frontmatter":{"date":"Jan 25, 2021","title":"최단거리 경로복원","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n정리 안해두면 까먹을거 같아서 기억력을 조금이라도 향상시키기 위해 정리해둔다.\n\n자, 최단거리 알고리즘을 이해하기 위해 그래프를 간략히 살펴보면\n\n---\n\n# 그래프란?\n\n---\n\n그래프는 **정점(Vertex)** 와 **간선(Edge)** 을 모아놓은 자료구조다.\n\n그래프라는 친구는 보통 간선에 가중치를 가진다.\n\n## 구현 방법\n\n---\n\n1. 인접 행렬\n2. 인접 리스트\n\n# 다익스트라 알고리즘\n\n---\n\n최단 거리 알고리즘은 기본적으로 **그리디 알고리즘** 으로 분류된다.  \n -> **매번 가장 비용이 적은 노드** 를 선택하는 과정을 반복하기 때문이다.\n\n## 전제조건\n\n---\n\n1. 시작 노드 - 시작 노드 사이 거리는 0이다.\n2. 모든 간선은 양의 가중치를 가진다.\n\n## 특징\n\n---\n\n1. 구현 방법은 2가지\n\n## 1. 직관적인 방법 - O(V^2)\n\n---\n\n1. 각 노드에 대한 최단 거리를 담는 1차원 리스트 선언\n2. 방문하지 않은 노드 중에서 거리가 가장 짧은 노드 선택  \n   (거리가 같으면 일반적으로 번호가 작은 노드)\n3. 거리가 더 짧으면 값 갱신\n\n### 최단거리 - 백준 1753\n\n---\n\n![1753문제](1753pb.PNG)\n![1753문제](1753pb2.PNG)\n\n```java\npackage package24;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class num1753 {\n\tstatic int INF = Integer.MAX_VALUE;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString[] inputVE = br.readLine().split(\" \");\n\t\tint V = stoi(inputVE[0]);\n\t\tint E = stoi(inputVE[1]);\n\t\tint K = stoi(br.readLine())-1;\n\n\t\tList<Edge>[] graph = new ArrayList[V];\n        for (int i = 0; i < V; i++)\n        \tgraph[i] = new ArrayList<>();\n\t\tint[] distance = new int[V];\n\t\tboolean[] visited = new boolean[V];\n\n\t\tfor(int i=0; i<V; i++) {\n\t\t\tdistance[i] = INF;\n\t\t}\n\n\t\tfor(int i=0; i<E; i++) {\n\t\t\tString[] uvw = br.readLine().split(\" \");\n\t\t\tint u = stoi(uvw[0])-1;\n\t\t\tint v = stoi(uvw[1])-1;\n\t\t\tint w = stoi(uvw[2]);\n\t\t\tgraph[u].add(new Edge(v,w));\n\t\t}\n\t\tdijkstra(graph, visited, distance, V, E, K);\n\n\t\tfor(int value : distance) {\n\t\t\tif(INF == value)\n\t\t\t\tSystem.out.println(\"INF\");\n\t\t\telse\n\t\t\t\tSystem.out.println(value);\n\t\t}\n\t}\n\n\tpublic static void dijkstra(List<Edge>[] graph, boolean[] visited, int[] distance, int V, int E, int K) {\n\t\tdistance[K] = 0;\n\t\tfor(int i=0; i<V; i++) {\n\t\t\tint minIndex = getSmallestNodeNotVisited(visited, distance, V);\n            for (Edge next : graph[minIndex]) {\n                if(!visited[next.v] && distance[next.v] > distance[minIndex] + next.weight) {\n                \tdistance[next.v] = distance[minIndex] + next.weight;\n                }\n            }\n\n\t\t\tvisited[minIndex] = true;\n\n\t\t}\n\n\t}\n\n\tpublic static int getSmallestNodeNotVisited(boolean[] visited, int[] distance, int V) {\n\t\tint min = INF;\n\t\tint minIndex = 0;\n\t\tfor(int i=0; i<V; i++) {\n\t\t\tif(visited[i] == false && distance[i]<min) {\n\t\t\t\tmin = distance[i];\n\t\t\t\tminIndex = i;\n\t\t\t}\n\t\t}\n\t\treturn minIndex;\n\t}\n\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n\nclass Edge {\n    int v, weight;\n\n    public Edge(int v, int weight) {\n        this.v = v;\n        this.weight = weight;\n    }\n\n}\n\n```\n\n---\n\n소스를 간략히 설명하면  \n노드 arrayList를 만들고 Edge는 클래스로 만들어서 넣어주는 방법으로 구현했다.  \n(배열로만 구현하면 메모리 초과난다.)\n\n매번 최단거리가 가장 짧은 노드를 찾기 위해 O(V) 만큼 탐색하기 때문에 비효율적이다.  \n -> Priority Queue 활용\n\n---\n\n## 2. Priority Queue 활용 - O(ElogV)\n\n---\n\n최단 거리 -> **최소 힙**을 사용한다.\n\n```\n1. 각 노드에 대한 최단 거리를 담는 1차원 리스트 선언\n2. 우선순위 큐을 사용해 거리가 짧은 정점부터 Queue에 넣어 줌.(처음 시작 값 : 0)\n3. 큐가 값이 없을 때까지 반복\n    3-1) 큐에서 값을 하나 꺼냄 (Vertex 선택)\n\t3-2) visited 값 true 설정\n4. 다음 Vertex의 최단거리가 현재Vertex 최단 거리 + 다음 Vertex 가중치보다 크면\n\t(다음 Vertex가 사용되지 않았을 때)\n\t4-1) 값 갱신\n\t4-2) 우선순위 큐에 값 추가\n```\n\n요약하면\n\n```\n1. 아직 방문하지 않은 정점 중 거리가 짧은 정점을 하나 선택해 방문\n2. 해당 정점에 인접하고 아직 방문하지 않은 정점의 최단거리 갱신\n```\n\nTip!!  \n**JAVA PriorityQueue 는 기본적으로 minHeap이다.**\n\n```java\n// 최소 힙\nPriorityQueue<Integer> minHeap = new PriorityQueue<Integer>();\n\n// 최대 힙\nPriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(Comparator.reverseOrder());\n\n// 최대 힙 version2\nPriorityQueue<Integer> maxHeap = PriorityQueue<>(new Comparator<Integer>(){\n\t@Override\n\tpublic int compare(Integer i1, Integer i2) {\n\t\treturn i2-i1;\n\t}\n});\n```\n\n### 최단거리 - 백준 1504\n\n---\n\n![1504문제](1504pb1.PNG)\n![1504문제2](1504pb2.PNG)\n\n---\n\n문제를 보면 정점 2개를 방문해야 한다는 조건이 있다. 정점을 각각 V1, V2라고 한다면\n\n1.  1 -> V1 -> V2 -> N\n2.  1 -> V2 -> V1 -> N\n\n두가지 경우에 대해 구간별로 최소값을 구한 후, 더하면 된다.\n\n---\n\n```java\npackage package24;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class num1504 {\n\tstatic int N,E,v1,v2,result;\n\tstatic ArrayList<ArrayList<Edge>> Vertex;\n\tstatic int[] distance;\n\tstatic boolean[] visited;\n\tstatic int INF = 200000000;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString[] NE = br.readLine().split(\" \");\n\t\tN = stoi(NE[0]);\n\t\tE = stoi(NE[1]);\n\t\tdistance = new int[N+1];\n\t\tvisited = new boolean[N+1];\n\t\tVertex = new ArrayList<>();\n\n\t\tfor(int i=0; i<=N; i++) {\n\t\t\tVertex.add(new ArrayList<>());\n\t\t}\n\n\t\tfor(int i=0; i<E; i++) {\n\t\t\tString[] abc = br.readLine().split(\" \");\n\t\t\tint a = stoi(abc[0]);\n\t\t\tint b = stoi(abc[1]);\n\t\t\tint c = stoi(abc[2]);\n\n\t\t\tVertex.get(a).add(new Edge(b,c));\n\t\t\tVertex.get(b).add(new Edge(a,c));\n\t\t}\n\t\tString[] v1v2 = br.readLine().split(\" \");\n\t\tv1 = stoi(v1v2[0]);\n\t\tv2 = stoi(v1v2[1]);\n\n\t\tresult = solve();\n\t\tSystem.out.println(result);\n\t}\n\n\tpublic static int solve() {\n\t\tint case1=0, case2=0;\n\n\t\tcase1 = dijkstra(1,v1) + dijkstra(v1,v2) + dijkstra(v2,N);\n\t\tcase2 = dijkstra(1,v2) + dijkstra(v2,v1) + dijkstra(v1,N);\n\n\t\treturn (case1 >= INF && case2 >= INF) ? -1 : Math.min(case1, case2);\n\t}\n\n\tpublic static int dijkstra(int start, int end) {\n\t\tArrays.fill(distance, INF);\n\t\tArrays.fill(visited, false);\n\n\t\tPriorityQueue<Edge> queue = new PriorityQueue<Edge>();\n\t\tqueue.add(new Edge(start,0));\n\t\tdistance[start] = 0;\n\n\t\twhile(!queue.isEmpty()) {\n\t\t\tEdge now = queue.remove();\n\t\t\tint nowNode = now.e;\n\t\t\tif(!visited[nowNode]) {\n\t\t\t\tvisited[nowNode] = true;\n\n\t\t\t\tfor(Edge next : Vertex.get(nowNode)) {\n\t\t\t\t\tif(!visited[next.e] && distance[next.e] > distance[nowNode] + next.weight) {\n\t\t\t\t\t\tdistance[next.e] = distance[nowNode] + next.weight;\n\t\t\t\t\t\tqueue.add(new Edge(next.e, distance[next.e]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn distance[end];\n\t}\n\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\n\tstatic class Edge implements Comparable<Edge>{\n\t\tint e, weight;\n\t\tEdge(int e, int weight){\n\t\t\tthis.e = e;\n\t\t\tthis.weight = weight;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge o){\n\t\t\treturn weight - o.weight;\n\t\t}\n\t}\n}\n```\n\n# 벨만-포드 알고리즘\n\n---\n\n## 특징\n\n---\n\n1. 시간 복잡도 - O(VE)\n2. 다익스트라 알고리즘보다 느리지만 음의 가중치를 가진 경로의 최단거리를 구할 수 있다.\n\n## 전제 조건\n\n---\n\n1. **같은 정점을 2번 지날일은 없기 때문에** 간선의 최대 개수는 **V-1**이다.\n2. 음수 사이클이 없는 최단 경로를 구해야 한다.\n\n> 존재하는 모든 간선을 돌아보면서 간선이 통할 수도 있는 거리를 갱신하는 것\n\n## 백준 11657\n\n---\n\n![11607문제1](11657pb1.PNG)\n![11607문제2](11657pb2.PNG)\n![11607문제3](11657pb3.PNG)\n\n```java\npackage package24;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class num11657 {\n\tstatic int N, M;\n\tstatic ArrayList<ArrayList<Edge>> Vertex;\n\tstatic long[] dist;\n\tstatic int INF = Integer.MAX_VALUE;\n\tstatic boolean minusCycle=false;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tString[] inputNM = br.readLine().split(\" \");\n\t\tN = stoi(inputNM[0]);\n\t\tM = stoi(inputNM[1]);\n\n\t\tdist = new long[N];\n\t\tVertex = new ArrayList<ArrayList<Edge>>();\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tVertex.add(new ArrayList<Edge>());\n\t\t\tdist[i] = INF;\n\t\t}\n\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tString[] ABC = br.readLine().split(\" \");\n\t\t\tint A = stoi(ABC[0])-1;\n\t\t\tint B = stoi(ABC[1])-1;\n\t\t\tint C = stoi(ABC[2]);\n\n\t\t\tVertex.get(A).add(new Edge(B,C));\n\t\t}\n\t\tbellman();\n\n\t\tif(minusCycle)\n\t\t\tsb.append(\"-1\\n\");\n\t\telse {\n\t\t\tfor(int i=1; i<N; i++) {\n\t\t\t\tsb.append(dist[i] != INF ? dist[i] : -1);\n\t\t\t\tsb.append(\"\\n\");\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sb.toString());\n\n\t}\n\tpublic static void bellman() {\n\t\tdist[0] = 0;\n\n\t    for(int i=0; i<N; i++){\n\t        for(int j=0; j<N; j++){\n\t            for(Edge edge: Vertex.get(j)){\n\t                int next = edge.e, w = edge.w;\n\t                if(dist[j] != INF && dist[next] > dist[j] + w){\n\t                    dist[next] = dist[j] + w;\n\t                    if(i == N-1) minusCycle = true;\n\t                }\n\t            }\n\t        }\n\t    }\n\t}\n\n\tstatic class Edge {\n\t\tint e, w;\n\t\tEdge(int e, int w) {\n\t\t\tthis.e = e;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n```\n\n---\n\n코드를 간단히 설명해보면\n\n존재하는 모든 간선을 돌아보면서 이 간선을 통할 수도 있는 최단경로들의 거리를 갱신한다.\n같은 정점을 2번 방문하는 경우는 없다는 전제가 있으므로 V-1까지 확인한다\n만약, 음의 사이클이 존재한다면 -> V-1 이후 최단거리가 갱신된다.\n위의 소스에선 V까지 루프의 마지막에 최단거리가 갱신되는지 확인한다.\n\n이 문제는 조금 주의할 점이 있다.\n\n최소 가중치가 -10000이라 언더플로우가 생길 수 있기 때문에 **dist를 long[]으로 설정해야 한다.**\n\n---\n\n# 플로이드 알고리즘\n\n---\n\n## 특징\n\n---\n\n1. 다익스트라, 벨만 포드 알고리즘 : 하나의 시작점에 대한 최단 거리\n2. 플로이드 워셜 알고리즘 : **모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야 하는 경우**\n3. 시간 복잡도 : O(V^3)  \n   -> 노드의 개수 O(V) \\* **현재 노드를 거쳐가는 모든 경로O(V^2)** -> **O(V^3)**\n4. **DP형태** -> 점화식에 맞게 2차원 리스트를 갱신하기 때문\n\n**Tip!!**  \n상황에 따라 자기 자신으로 이동 가능하면 dis[i][j] = 0 / 불가능하면 dis[i][j] = INF\n\n- 가장 바깥쪽 for문은 경유할 정점\n- 가운데 for문은 출발 정점\n- 가장 안쪽 for문은 도착 정점\n\n---\n\n## 백준 11404\n\n```java\npackage package24;\n\nimport java.io.*;\n\npublic class num11404 {\n\tstatic int N, M, INF = 100000000;\n\tstatic int[][] dis;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tBufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tN = stoi(br.readLine());\n\t\tM = stoi(br.readLine());\n\n\t\tdis = new int[N][N];\n\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tfor(int j=0; j<N; j++) {\n\t\t\t\tdis[i][j] = i == j ? 0 : INF;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tString[] abc = br.readLine().split(\" \");\n\t\t\tint a = stoi(abc[0])-1;\n\t\t\tint b = stoi(abc[1])-1;\n\t\t\tint c = stoi(abc[2]);\n\n\t\t\tdis[a][b] = Math.min(dis[a][b], c);\n\t\t}\n\n\t\tfor(int k=0; k<N; k++) {\n\t\t\tfor(int i=0; i<N; i++) {\n\t\t\t\tfor(int j=0; j<N; j++) {\n\t\t\t\t\tdis[i][j] = Math.min(dis[i][j], dis[i][k] +dis[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n            \tdis[i][j] = dis[i][j] == INF ? 0 : dis[i][j];\n                sb.append(dis[i][j] + \" \");\n            }\n            sb.append(\"\\n\");\n        }\n\n        bw.write(sb.toString());\n        bw.flush();\n        bw.close();\n        br.close();\n\t}\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\n}\n```\n\n# 정리\n\n---\n\n이렇게 최단거리 알고리즘 3가지를 알아보았다.\n\n사용하는 경우를 정리해보면\n\n```\n1. 다익스트라 알고리즘[우선순위 큐] -> 한 지점에서 다른 지점까지 최단거리 구하는 문제\n2. 벨만 포드 알고리즘 -> 음의 가중치를 가진 최단거리 구하는 문제\n3. 플로이드 와샬 알고리즘 -> 모든 경로의 최단거리 구하는 문제\n```\n\n로 정리할 수 있다.\n\n생각보다 어려워서 정리하는데 시간이 오래걸렸다.  \n다음 글은 최단경로의 경로출력에 대해 정리해 볼 예정이다.\n\n추가로 [라이님 블로그](https://blog.naver.com/kks227/220796029558) 요기 있는 추가문제 하나씩 풀어봐야겠다.\n\n# Reference\n\n---\n\n[라이님 블로그](https://blog.naver.com/kks227/220796029558)  \n[갓킹독님 블로그](https://blog.encrypted.gg/917?category=773649)  \n[Crocus님 블로그](https://www.crocus.co.kr/546?category=209527)  \n[백준 질문하기 - 출력초과 문제 해결이 되었는데 이유를 모르겠습니다](https://www.acmicpc.net/board/view/55270)  \n이것이 코딩테스트다 - 나동빈\n","excerpt":"정리 안해두면 까먹을거 같아서 기억력을 조금이라도 향상시키기 위해 정리해둔다. 자, 최단거리 알고리즘을 이해하기 위해 그래프를 간략히 살펴보면 그래프란? 그래프는 정점(Vertex) 와 간선(Edge) 을 모아놓은 자료구조다. 그래프라는 친구는 보통…","fields":{"slug":"/shortestDistance_1/"},"frontmatter":{"date":"Jan 23, 2021","title":"최단거리 알고리즘","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n백준 이분 탐색 문제를 풀다 Parametric Search에 대해 알게 되었고, 정리 할 필요성을 느껴서 포스팅한다.\n\n일단 **이분탐색**은 탐색 기법으로 **원하는 탐색 범위를 두 부분으로 분할**해서 찾는 방식이다  \n -> O(logN)의 시간 복잡도를 가지고 있다.\n\n**파라매트릭 서치**는 **최적화 문제 -> 결정문제로 바꾸어 푸는 것**을 말한다.  \n(문제 상황을 만족하는 특정한 값 - 최소값, 최대값)\n\n백준 2110번 문제가 쉽게 이해하기 좋은 문제인 것 같다.\n\n![문제사진](pro1.PNG)\n![문제사진2](pro2.PNG)\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] inputNK = br.readLine().split(\" \");\n\t\tint N = Integer.parseInt(inputNK[0]);\n\t\tlong K = Long.parseLong(inputNK[1]);\n\t\tlong max = 0;\n\n\t\tlong[] houseArr = new long[N];\n\n\t\tfor(int i=0; i<N; i++) {\n\t\t\thouseArr[i] = Long.parseLong(br.readLine());\n\t\t\tmax = max > houseArr[i] ? max : houseArr[i];\n\t\t}\n\t\tArrays.sort(houseArr);\n\n\t\tmax = Psearch(houseArr, K, max);\n\t\tSystem.out.println(max);\n\t}\n\n\tpublic static long Psearch(long[] houseArr, long K, long max) {\n\t\tlong start = 1;\n\t\tlong end = max;\n\t\tlong ans = 0;\n\n\t\twhile(start<=end) {\n\t\t\tlong mid = (start+end)/2;\n\n\t\t\tif(checkHouse(houseArr, mid, K)) {\n\t\t\t\tstart = mid+1;\n\t\t\t\tans = ans > mid ? ans : mid;\n\t\t\t}else {\n\t\t\t\tend = mid-1;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic static boolean checkHouse(long[] houseArr, long mid, long K) {\n\t\tlong temp = houseArr[0];\n\t\tlong index = 0;\n\t\tfor(int i = 1; i<houseArr.length; i++) {\n\t\t\tif(houseArr[i]-temp >= mid) {\n\t\t\t\tindex++;\n\t\t\t\ttemp=houseArr[i];\n\t\t\t}\n\t\t}\n\n\t\tif(index >=K-1)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n}\n\n```\n\n이 문제의 포인트는\n\n1. 공유기 사이 거리를 정한 후, 정한 거리 이상의 간격으로 집에 설치 가능한지 확인\n   - 설치 가능 -> 더 큰 거리값 확인\n   - 설치 불가능 -> 작은 거리값을 확인\n\n추가로 백준 12015번 문제를 풀어보는 것을 추천한다.\ndp를 활용해 가장 긴 증가하는 부분 수열 구할 수 있는데 이분탐색을 사용하면 O(logN)으로 구할 수 있다.\n","excerpt":"백준 이분 탐색 문제를 풀다 Parametric Search에 대해 알게 되었고, 정리 할 필요성을 느껴서 포스팅한다. 일단 이분탐색은 탐색 기법으로 원하는 탐색 범위를 두 부분으로 분할해서 찾는 방식이다  -> O(logN)의 시간 복잡도를 가지고…","fields":{"slug":"/ParametricSearch/"},"frontmatter":{"date":"Jan 17, 2021","title":"이분탐색, 파라매트릭 서치(Parametric Search)","tags":["Algorithm","Parametric Search"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n백준 단계별 문제 - 우선순위 큐 마지막 문제다.\n\n풀다가 조금 헷갈린 부분이 있어 정리하고자 포스팅한다.\n\n# 문제\n\n![문제사진](problem1.PNG)\n![문제사진2](problem2.PNG)\n\n일단 문제에 처음 접근할 땐, 우선순위 큐를 사용해 저장하고 중간 값을 계속 뽑아와 StringBuilder에 넣어주는 방식으로 구현했다.\n\n```java\npackage package21;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.PriorityQueue;\nimport java.util.Stack;\n\npublic class num1655 {\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tPriorityQueue<Integer> q = new PriorityQueue<>();\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tint T = Integer.parseInt(br.readLine());\n\n\t\tfor(int i=0; i<T; i++) {\n\t\t\tint value = Integer.parseInt(br.readLine());\n\t\t\tq.offer(value);\n\t\t\tint len = q.size()/2 + q.size()%2;\n\t\t\tStack<Integer> s = new Stack<>();\n\t\t\tfor(int j=0;j<len;j++) {\n\t\t\t\ts.push(q.remove());\n\t\t\t}\n\t\t\tif(!s.isEmpty())\n\t\t\t\tsb.append(s.peek()+\"\\n\");\n\t\t\twhile(!s.isEmpty()) {\n\t\t\t\tq.offer(s.pop());\n\t\t\t}\n\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\n}\n```\n\n![시간초과](no.PNG)\n\n역시 시간초과.....\n\n## 풀이 1\n\nstack대신 우선순위큐를 하나 더 써서 구현해보려고 생각하였고, 이 부분에서 삽질을 조금 하였다.\n\n포인트는 4가지다.\n\n1. Max Heap(최대 값이 가장 앞에 위치)과 Min Heap(최소 값이 가장 앞에 위치) 사용\n2. 중간 값을 저장(초기 값 = 맨 처음에 입력받은 값)  \n   중간 값 보다 작은 값은 Max Heap / 큰 값은 Min Heap\n3. 큰값을 저장하는 min heap이 길이가 2이상 길면 중앙 값 바꿈  \n   -> 작은 값을 저장하는 max heap에 중간 값 저장  \n   -> 큰 값을 저장하는 min heap에서 가장 작은 값을 중간값으로 바꿈\n4. 작은 값을 저장하는 max heap이 길이가 1이상 길면 중앙 값 바꿈  \n   (길이가 짝수이면 작은수가 중간 값이니 길이= 1 )  \n   -> 큰 값을 저장하는 min heap에 중간 값 저장  \n   -> 작은 값을 저장하는 max heap에서 가장 큰 값을 중간값으로 바꿈\n\n```java\npackage package21;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class num1655v2 {\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuilder sb = new StringBuilder();\n\t\tQueue<Integer> min = new PriorityQueue<>();\n\t\tQueue<Integer> max = new PriorityQueue<>(new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\treturn o2.compareTo(o1);\n\t\t\t}\n\n\t\t});\n\n\t\tint T = Integer.parseInt(br.readLine());\n\n\t\tint index=0;\n\n\t\tfor(int i = 0; i<T; i++) {\n\t\t\tint num = Integer.parseInt(br.readLine());\n\t\t\tif(i==0) {\n\t\t\t\tindex = num;\n\t\t\t\tsb.append(num+\"\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(num<=index) {\n\t\t\t\t// 작은 값이면 max heap에 저장\n\t\t\t\tmax.offer(num);\n\t\t\t\tif(max.size()-min.size()>=1) {\n\t\t\t\t\tmin.offer(index);\n\t\t\t\t\tindex = max.poll();\n\t\t\t\t}\n\t\t\t}else {\n\t\t\t\t// 큰 값이면  min heap에 저장\n\t\t\t\tmin.offer(num);\n\t\t\t\tif(min.size() - max.size() >=2) {\n\t\t\t\t\tmax.offer(index);\n\t\t\t\t\tindex = min.poll();\n\t\t\t\t}\n\t\t\t}\n\t\t\tsb.append(index+\"\\n\");\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\n}\n```\n\n후... 큰 값을 min heap 저장, 작은 값을 max heap 저장, 중간값은 index로 빼놓는게 포인트인데 코드 짜다보니 헷갈려서 헤맸다.\n\n추가) 다른 사람들은 코드를 어떻게 짰는지 구글링 해봤는데 조금 재밌게 푼 코드가 있어서 추가로 풀어봤다.\n\n## 풀이2\n\n1. 중간 값은 항상 max heap의 가장 앞의 값으로 유지\n2. 크기가 같으면 max heap에 값 추가\n   (입력한 값이 min heap의 최소값보다 크면 값 swap)\n3. 크기가 다르면 min heap에 값 추가\n   (입력한 값이 max heap의 최대값보다 작으면 값 swap)\n\n이 코드는 입력값 : 521578 을 넣어서 직접 노트에 풀어보는게 이해하는데 도움됐다.\n\n```java\npackage package21;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class num1655v3 {\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuilder sb = new StringBuilder();\n\t\tQueue<Integer> min = new PriorityQueue<>();\n\t\tQueue<Integer> max = new PriorityQueue<>(new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\treturn o2.compareTo(o1);\n\t\t\t}\n\n\t\t});\n\n\t\tint T = Integer.parseInt(br.readLine());\n\n\t\tint index=0;\n\n\t\tfor(int i = 0; i<T; i++) {\n\t\t\tint num = Integer.parseInt(br.readLine());\n\t\t\tif(max.size() == min.size()) {\n\t\t\t\tmax.offer(num);\n\t\t\t\tif(!min.isEmpty() && max.peek() > min.peek()) {\n\t\t\t\t\tmin.offer(max.poll());\n\t\t\t\t\tmax.offer(min.poll());\n\t\t\t\t}\n\t\t\t}else {\n\t\t\t\tmin.offer(num);\n\t\t\t\tif(max.peek() > min.peek()) {\n\t\t\t\t\tmin.offer(max.poll());\n\t\t\t\t\tmax.offer(min.poll());\n\t\t\t\t}\n\t\t\t}\n\t\t\tsb.append(max.peek()+\"\\n\");\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n}\n\n```\n\n우선순위 큐는 이렇게 마무리!!\n\n# Update) 2021-01-14\n\n백준 2981번이 비슷한 유형이라 풀고 추가로 update 한다.\n\n# 백준 2981\n\n![문제사진3](problem3.PNG)\n![문제사진4](problem4.PNG)\n\n```java\npackage priorityQueue;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class num2696 {\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuilder sb = new StringBuilder();\n\t\tQueue<Integer> minHeap = new PriorityQueue<>();\n\t\tQueue<Integer> maxHeap = new PriorityQueue<>(new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\treturn o2.compareTo(o1);\n\t\t\t}\n\t\t});\n\n\t\tint T = Integer.parseInt(br.readLine());\n\n\t\tfor(int i=0; i<T; i++) {\n\t\t\tint count = Integer.parseInt(br.readLine());\n\t\t\tString[] inputData = br.readLine().split(\" \");\n\t\t\tsb.append(count/2+count%2 + \"\\n\");\n\t\t\tint index = 0;\n\t\t\tint jindex = 0;\n\t\t\tfor(int j=0; j<count; j++) {\n\t\t\t\tif(j%10==0 && j>9) {\n\t\t\t\t\tinputData = br.readLine().split(\" \");\n\t\t\t\t\tif(j%20==0) {\n\t\t\t\t\t\tsb.append(\"\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tjindex=0;\n\t\t\t\t}\n\t\t\t\tint num = Integer.parseInt(inputData[jindex]);\n\t\t\t\tif(jindex==0 && j==0) {\n\t\t\t\t\tjindex++;\n\t\t\t\t\tindex = num;\n\t\t\t\t\tsb.append(num + \" \");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(num <= index) {\n\t\t\t\t\tmaxHeap.offer(num);\n\t\t\t\t\tif(maxHeap.size() - minHeap.size()>=1) {\n\t\t\t\t\t\tminHeap.offer(index);\n\t\t\t\t\t\tindex = maxHeap.poll();\n\t\t\t\t\t}\n\t\t\t\t}else {\n\t\t\t\t\tminHeap.offer(num);\n\t\t\t\t\tif(minHeap.size() - maxHeap.size()>=2) {\n\t\t\t\t\t\tmaxHeap.offer(index);\n\t\t\t\t\t\tindex = minHeap.poll();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(jindex%2==0) {\n\t\t\t\t\tsb.append(index + \" \");\n\t\t\t\t}\n\t\t\t\tjindex++;\n\t\t\t}\n\n\t\t\tsb.append(\"\\n\");\n\t\t\tminHeap.clear();\n\t\t\tmaxHeap.clear();\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\n}\n\n```\n\n이 문제는 한 줄에 10개씩 들어온다는게 포인트다. 10개씩 장난쳐줘야 한다.\n\n정말 끝\n","excerpt":"백준 단계별 문제 - 우선순위 큐 마지막 문제다. 풀다가 조금 헷갈린 부분이 있어 정리하고자 포스팅한다. 문제 \n 일단 문제에 처음 접근할 땐, 우선순위 큐를 사용해 저장하고 중간 값을 계속 뽑아와 StringBuilder에 넣어주는 방식으로 구현했…","fields":{"slug":"/backjoon1655/"},"frontmatter":{"date":"Jan 13, 2021","title":"백준 1655 - 가운데를 말해요 풀이","tags":["Algorithm","BackJoon"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n풀이를 보고 바로 이해하지 못하고 헷갈린 부분이 있어서 정리한다.\n\n![문제사진](problem.PNG)\n\n# LCS란?\n공통적으로 가지고 있는 부분 문자열 중, 가장 긴 문자열(최장 공통 부분 수열)\n\n## 규칙찾기\n\n점화식을 찾아내기 전에 문제에 나온 예제 입력값을 통해 규칙을 찾아보면\n\n```\nindex   C A P C A K\nA       0 1 1 1 1 1\nC       1 1 1 2 2 2\nA       1 2 2 2 3 3\nY       1 2 2 2 3 3\nK       1 2 2 2 3 4\nP       1 2 3 3 3 4\n```\n\n## 접근\n\n문제의 경우는 2가지로 나눌 수 있다.\n\n 1) 두 문자열에 같은 문자가 추가되는 경우\n    - ex) ACAYKP**A** , CAPCAK**A**\n 2) 두 문자열에 다른 문자가 추가되는 경우\n    - ex) ACAYKP**B** , CAPCAK**C**\n\n## 점화식\n두 가지 경우를 각각 점화식으로 나타내 보면\n```\n 1) dp[i][j] = dp[i-1][j-1] + 1\n 2) dp[i][j] = Max(arr[i][j-1], arr[i-1][j])\n```\n\n점화식을 찾아냈으면 코드작성은 쉽다.\n\n## 코드\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class num9251 {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] str1 = br.readLine().split(\"\");\n\t\tString[] str2 = br.readLine().split(\"\");\n\t\t\n\t\tint N = str1.length;\n\t\tint M = str2.length;\n\t\tint[][] arr = new int[N+1][M+1];\n\t\t\n\t\tfor(int i=1;i<=N;i++) {\n\t\t\tfor(int j=1;j<=M;j++) {\n\t\t\t\tif(str1[i-1].equals(str2[j-1])) {\n\t\t\t\t\tarr[i][j] = arr[i-1][j-1] +1;\n\t\t\t\t}else {\n\t\t\t\t\tarr[i][j] = Math.max(arr[i][j-1],arr[i-1][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(arr[N][M]);\n\t}\n}\n```","excerpt":"풀이를 보고 바로 이해하지 못하고 헷갈린 부분이 있어서 정리한다.  LCS란? 공통적으로 가지고 있는 부분 문자열 중, 가장 긴 문자열(최장 공통 부분 수열) 규칙찾기 점화식을 찾아내기 전에 문제에 나온 예제 입력값을 통해 규칙을 찾아보면 접근 문제…","fields":{"slug":"/backjoon9251/"},"frontmatter":{"date":"Dec 28, 2020","title":"백준 9251 - LCS 풀이","tags":["Algorithm","BackJoon"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n백준 DP 단계별 문제에 있는 10844번 문제이다. \n\n접근이 조금 어려웠던 문제라 풀이를 정리해보려고 한다.  \n\n## 접근\n\n일단 이 문제는 DP문제로 2차원 배열을 DP로 사용해야 한다.\n\n규칙을 찾기 위해 값을 적어보고, 개수를 세보면 아래와 같다.  \n(N : 자리수, index : 맨 마지막에오는 숫자)  \n```\nindex   0 1 2 3 4 5 6 7 8 9\nN=1     0 1 1 1 1 1 1 1 1 1  \nN=2     1 1 2 2 2 2 2 2 2 1\nN=3     1 3 3 4 4 4 4 4 3 2\n\nex)\nN=2 -> (10), (21), (32, 12), (43,23), (54,34), (65,45), (76,56), (87,67), (98,78), (89)\n```\ndp[N][index] = dp[N-1][index-1] + dp[N-1][index+1]인 점화식을 얻을 수 있다.\n\n단, 여기서 중요한 점은 index가 0일 경우는 +1 한 값이 허용되고  \n9일 경우는 -1 한 경우만 적용되기 때문에 예외 처리를 해줘야 한다.  \n\n마지막으로 점화식을 정리해보면\n```\n1) index가 1일 경우\ndp[N][index] = dp[N-1][index+1]\n\n2) index가 1~8일 경우\ndp[N][index] = dp[N-1][index-1] + dp[N-1][index+1]\n\n3) index가 9일 경우\ndp[N][index] = dp[N-1][index-1]\n\n```\n\n3가지 경우에 따라 분기처리를 하면 된다.\n\n# Top-down 방식\n\n## 구현코드\n\n```java\npackage package14;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class num10844 {\n\tstatic Long[][] dp;\n\tstatic int N;\n\tfinal static long MOD = 1000000000;\n\t\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tN = Integer.parseInt(br.readLine());\n\t\tdp = new Long[N+1][10];\n\t\t// #1\n\t\tfor(int i = 0; i < 10; i++) {\n\t\t\tdp[1][i] = 1L;\n\t\t}\n\n\t\tlong result = 0;\n\t\t\n\t\tfor(int i = 1; i <= 9; i++) {\n\t\t\tresult += recur(N, i);\n\t\t}\n\t\tSystem.out.println(result % MOD);\n\t}\n\t\n\tstatic long recur(int digit, int val) {\t\t\n\t\t\n\t\tif(digit == 1) {\n\t\t\treturn dp[digit][val];\n\t\t}\n\t\t// #2\n\t\tif(dp[digit][val] == null) {\n\t\t\tif(val == 0) {\n\t\t\t\tdp[digit][val] = recur(digit - 1 ,1);\n\t\t\t}\n\t\t\telse if(val== 9) {\n\t\t\t\tdp[digit][val] = recur(digit - 1, 8);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[digit][val] = recur(digit - 1, val - 1) + recur(digit - 1, val + 1);\n\t\t\t}\n\t\t}\n\t\treturn dp[digit][val] % MOD;\n\t}\n}\n\n\n```\n\n## 코드설명\n 1) N=1인 값들은 값을 초기값으로 값을 넣어준다.\n 2) 점화식과 동일하게 상황에 따라 맞는 값을 재귀로 호출한다.\n\n# Bottom-up 방식\n\n## 구현 코드\n\n```java\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n \npublic class Main {\n\t\n\tfinal static long mod = 1000000000;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tint N = Integer.parseInt(br.readLine());\n\t\t\n\t\tlong[][] dp = new long[N + 1][10];\n\t\t\n\t\tfor(int i = 1; i < 10; i++) {\n\t\t\tdp[1][i] = 1; \n\t\t}\n\t\t\n\t\t// 두 번째 자릿수부터 N까지 탐색 \n\t\tfor(int i = 2; i <= N; i++) {\n\t\t\t\n\t\t\tfor(int j = 0; j < 10; j++) {\n\t\t\t\t\n\t\t\t\tif(j == 0) {\n\t\t\t\t\tdp[i][0] = dp[i - 1][1] % mod;\n\t\t\t\t}\n\t\t\t\telse if (j == 9) {\n\t\t\t\t\tdp[i][9] = dp[i - 1][8] % mod;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j + 1]) % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong result = 0;\n\t\t\n\t\tfor(int i = 0; i < 10; i++) {\n\t\t\tresult += dp[N][i];\n\t\t}\n\t\t\n\t\tSystem.out.println(result % mod);\n\t}\n \n}\n```\n\n## 코드설명\n - Top-down방식과 동일한데 재귀 부분을 for문으로 두번째 자리부터 N까지 탐색한다.\n\n\n# \n<hr>\n\n아직 DP문제를 많이 풀어보지 않아서 그런지 점화식 만들어 내는 과정이 어렵다... ㅜㅜㅜㅜㅜ  \n익숙해질 때까지 열심히 풀어야겠다 (승질 그만내고 ㅎㅎ)","excerpt":"백준 DP 단계별 문제에 있는 10844번 문제이다.  접근이 조금 어려웠던 문제라 풀이를 정리해보려고 한다.   접근 일단 이 문제는 DP문제로 2차원 배열을 DP로 사용해야 한다. 규칙을 찾기 위해 값을 적어보고, 개수를 세보면 아래와 같다. (…","fields":{"slug":"/backjoon10844/"},"frontmatter":{"date":"Dec 03, 2020","title":"백준 10844번 - 쉬운 계단수 풀이","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# Comparable\n > 클래스의 기본 정렬 기준을 설정하는 인터페이스\n\n\n## 1) 특징\n - Comparable 인터페이스 상속 후, compareTo 메소드 오버라이딩\n - compareTo메소드 리턴 값은 음수, 0, 양수가 될 수 있다. **음수가 리턴되면 인자의 순서가 아래로 이동**\n - 자바에서 제공되는 정렬이 가능한 클래스는 모두 Comparable 클래스로 구현되어 있음\n \n## 2) 구현 코드\n\n# Comparator\n > 기본 정렬과 다르게 정렬하고 싶을 때 이용하는 클래스\n## 1) 특징\n - 보통 구현 되어있는 sort함수의 2번째 인자로 Comparator 타입을 받아(익명함수) compare 메소드 오버라이딩을 통해 배열 정렬 순서 재정의\n - 보통 한번 사용하고 사용하지 않기 때문에 익명객체로 만듬\n\n## 2) 구현 코드\n\n# 관련 백준 문제\n - 11650, 11651, 1181, 10814","excerpt":"Comparable 클래스의 기본 정렬 기준을 설정하는 인터페이스 1) 특징 Comparable 인터페이스 상속 후, compareTo 메소드 오버라이딩 compareTo메소드 리턴 값은 음수, 0, 양수가 될 수 있다. 음수가 리턴되면 인자의 순서…","fields":{"slug":"/javaComparableComparator/"},"frontmatter":{"date":"Nov 24, 2020","title":"JAVA Comparable, Comparator 사용","tags":["JAVA"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n이전부터 자주 헷갈렸던 순열, 조합, 부분집합의 개념 정리와 JAVA를 사용해 구현하는 방법을 정리해 보려고 한다.\n\n1. 대표적인 구현 방법\n2. 각, 방법의 특징\n\n두가지 사항으로 정리한다.\n\n<!-- TODO:\nhttps://limkydev.tistory.com/178\nhttps://minhamina.tistory.com/38\n-->\n\n# 순열\n\n- n개의 원소 중, r개를 일렬로 나열하는 수열\n- 중복 X / 순서 고려\n\n## 1. next_permutation\n\n### 1) 특징\n\n- 이게 이해하기 제일 어려웠다.... (나만 어렵나...ㅜㅜ)\n- 무작위 순열의 다음 순열을 구해내는 알고리즘\n- 시작 조건 : 오름차순 / 종료 조건 : 내림차순\n\n```\n  순서\n  1.Find largest index i such that array[i − 1] < array[i].\n  (If no such i exists, then this is already the last permutation.)\n\n  2.Find largest index j such that j ≥ i and array[j] > array[i − 1].\n\n  3.Swap array[j] and array[i − 1].\n\n  4.Reverse the suffix starting at array[i].\n```\n\n### 2) 구현 코드\n\n```java\npublic class num1 {\n    public static void main(String[] args) {\n    \tint[] list = new int[]{5,4,3};\n    \t// #1 시작 조건에 맞게 list 오름차순 정렬 (시작조건)\n    \tArrays.sort(list);\n    \tpermutation(list);\n    }\n    // #2 처음 list값 print 후, 다음 순열 찾음\n    public static void permutation(int[] list) {\n        int[] curArray = list;\n        while (true) {\n        \tprintArray(curArray);\n        \tcurArray = nextPermutation(curArray);\n            if (curArray == null) {\n                break;\n            }\n        }\n    }\n\n    public static int[] nextPermutation(int[] list) {\n    \t  // #3 수열의 바로 앞 값 보다 큰 값 중 가장 큰 index 찾는다.\n        // (가장 적은 차이로 순서를 바꾸기 위해서 가장 큰 index를 찾음)\n        int i = list.length -1;\n        while(i>0 && list[i-1] >= list[i])\n        \ti--;\n\n        // #6 list가 내림차순으로 정렬되어 있으면 순열을 끝까지 찾은 것 (종료조건)\n        if(i<=0)\n        \treturn null;\n\n        int j = list.length -1;\n        // #4 다음 수열의 특징 : 이전 순열보다 값이 큼\n        // -> list[i-1] < list[j] 값을 찾고, 값을 바꿔준다.\n        while(list[j] <= list[i-1])\n        \tj--;\n\n        int temp = list[i-1];\n        list[i - 1] = list[j];\n        list[j] = temp;\n        // #5 a[i] 이후 부분을 오름차순으로 셋팅\n        j= list.length-1;\n        while (i < j) {\n            temp = list[i];\n            list[i] = list[j];\n            list[j] = temp;\n            i++;\n            j--;\n        }\n\n        return list;\n    }\n\n    public static void printArray(int[] array) {\n    \tfor(int i=0;i<array.length;i++)\n    \t\tSystem.out.print(array[i] + \" \");\n    \tSystem.out.println();\n    }\n\n}\n\n```\n\n### 3) 코드 설명\n\n1. 시작 조건에 맞게 list 오름차순 정렬 (시작조건)\n2. 처음 list값 print 후, 다음 순열 찾음\n3. 수열의 바로 앞 값 보다 큰 값 중 가장 큰 index 찾는다.  \n   (가장 적은 차이로 순서를 바꾸기 위해서 가장 큰 index를 찾음)\n4. 다음 수열의 특징 : 이전 순열보다 값이 큼 -> list[i-1] < list[j] 값을 찾고, 값을 바꿔준다.\n5. a[i] 이후 부분을 오름차순으로 셋팅\n6. list가 내림차순으로 정렬되어 있으면 순열을 끝까지 찾은 것 (종료조건)\n\n### 4) 코드 출력값\n\n```\n3 4 5\n3 5 4\n4 3 5\n4 5 3\n5 3 4\n5 4 3\n\n```\n\n## 2. Swap\n\n### 1) 특징\n\n- 순열의 순서가 보장되지 않는다. (사전식 X)\n\n### 2) 구현 코드\n\n```java\npublic class Main {\n  public static void main(String[] args) {\n  \tint[] arr = {1,2,3};\n  \tpermutation(arr,0,3,3);\n  \tSystem.out.println(Arrays.toString(arr));\n  }\n\n  static void permutation(int[] arr, int depth, int n, int r) {\n  \tif (depth == r) {\n  \t\tarrPrint(arr,r);\n  \t\treturn;\n  \t}\n  \tfor (int i=depth; i<n; i++) {\n      // #1\n  \t\tswap(arr, depth, i);\n      // #2\n  \t\tpermutation(arr, depth + 1, n, r);\n      // #3\n     \tswap(arr, depth, i);\n  \t}\n  }\n\n  static void arrPrint(int[] arr, int r) {\n    for (int i=0 ; i<r; i++)\n    \tSystem.out.print(arr[i] + \" \");\n    System.out.println();\n  }\n\n  static void swap(int[] arr, int depth, int i) {\n    int temp = arr[depth];\n    arr[depth] = arr[i];\n    arr[i] = temp;\n  }\n}\n```\n\n### 3) 코드 설명\n\n1. 배열의 첫번째 값부터 하나씩 바꾸면서 swap\n2. depth를 기준(Inex)으로 depth보다 작은 인데스 값들은 고정, depth보다 큰 값들을 가지고 swap\n3. 재귀함수가 종료조건에 의해 return되면 swap을 한번 더 해줘서 이전 상태 유지\n\n### 4) 코드 출력값\n\n```\n1 2 3\n1 3 2\n2 1 3\n2 3 1\n3 2 1\n3 1 2\n[1, 2, 3]\n```\n\n## 3. Visit Index 사용\n\n### 1) 특징\n\n- DFS, 재귀 함수\n\n### 2) 구현 코드\n\n```java\npublic class Main {\n\tpublic static void main(String[] args) {\n\t    int n = 3;\n\t    int[] arr = {1, 2, 3};\n      // #1\n\t    int[] output = new int[n];\n\t    boolean[] visited = new boolean[n];\n\t    perm(arr, output, visited, 0, n, 2);\n\t    System.out.println();\n\t}\n\n\tstatic void perm(int[] arr, int[] output, boolean[] visited, int depth, int n, int r) {\n\t    if (depth == r) {\n\t        print(output, r);\n\t        return;\n\t    }\n\n\t    for (int i = 0; i < n; i++) {\n\t        if (visited[i] != true) {\n\t            visited[i] = true;\n              output[depth] = arr[i];\n              // #2\n\t            perm(arr, output, visited, depth + 1, n, r);\n              // #3\n\t            visited[i] = false;\n\t        }\n\t    }\n\t}\n\n\tstatic void print(int[] arr, int r) {\n\t    for (int i = 0; i < r; i++)\n\t        System.out.print(arr[i] + \" \");\n\t    System.out.println();\n\t}\n\n}\n\n```\n\n### 3) 코드 설명\n\n1. output : 코드 출력 값 / visited : 방문 여부 체크\n2. depth -> output 길이라고 생각\n3. 방문 여부 false로 체크 -> 모든 인덱스 방문\n\n### 4) 코드 출력값\n\n```\n1 2\n1 3\n2 1\n2 3\n3 1\n3 2\n```\n\n## 관련 백준 문제\n\n> n과m 시리즈 0 ~ 12\n\n# 10\n\n# Reference\n\n[BaaaaaaaarkingDog님 블로그](https://blog.encrypted.gg/945?category=773649)  \n[뱀귤님 블로그](https://bcp0109.tistory.com/entry/%EC%88%9C%EC%97%B4-Permutation-Java?category=848939)  \n[junhok82님 블로그](https://velog.io/@junhok82/>Java%EB%A1%9C-%EC%88%9C%EC%97%B4Permutation-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0>)  \n[Crocus님 블로그](https://www.crocus.co.kr/1240)\n","excerpt":"이전부터 자주 헷갈렸던 순열, 조합, 부분집합의 개념 정리와 JAVA를 사용해 구현하는 방법을 정리해 보려고 한다. 대표적인 구현 방법 각, 방법의 특징 두가지 사항으로 정리한다. 순열 n개의 원소 중, r개를 일렬로 나열하는 수열 중복 X / 순서…","fields":{"slug":"/permutation/"},"frontmatter":{"date":"Nov 23, 2020","title":"순열 정리, 구현","tags":["Algorithm"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}},"staticQueryHashes":["2027115977","694178885"]}