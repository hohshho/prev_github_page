{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\r\n# Rsync(Remote sync)\r\n---\r\n> 파일과 디렉토리를 로컬 및 원격으로 동기화(복사) 하는데 사용\r\n\r\n## 특징\r\n---\r\n\r\n- 네트워크 대역폭을 최소화하는 델타 인코딩 알고리즘을 사용해 변경이 일어난 부분만 전송  \r\n  -> **빠르고 효율적으로 동기화 가능!**  \r\n- 설치\r\n```bash\r\n$ yum install rsync # CentOS\r\n$ apt-get install rsync # Ubuntu\r\n```\r\n\r\n- [rsync 홈페이지](https://rsync.samba.org/documentation.html)\r\n\r\n## 장점\r\n---\r\n\r\n- Cli툴로 쉘스크립트 프로그램 개발 가능 (cron으로 활용 가능)\r\n- 데이터를 압축하여 송/수신하기 때문에 빠르고 효율적\r\n- **link, 파일 소유자, 권한등 파일의 부가 정보를 함께 복사가능**\r\n- remote 업데이트를 이용하여 차이가 있는 파일만 복사한다. \r\n\r\n## 동기화 알고리즘\r\n---\r\n\r\n### 1. 파일 전송결정\r\n> 파일의 크기와 수정시간을 비교하는 것으로 파일을 전송할지 말지 결정한다.\r\n\r\n파일의 크기와 수정시간을 비교하는 것을, 아주 작은 cpu자원을 소모하지만 실수가 발생할 수 있다\r\n -> **checksum** 옵션 사용\r\n\r\n### 2. 전송할 파일 부분 결정\r\n\r\n1) 파일을 고정크기를 가지는 청크(Chunk)로 나눈다음에 checksum을 계산한다.\r\n2) 다를 경우 해당부분 chunk만 복사한다\r\n\r\nchunk파일의 체크섬을 비교하는 방식은 파일의 앞부분이 수정되서 정보가 밀리면 모든 청크와 checksum이 밀릴 것이다.\r\n -> **Rolling hash** 사용!\r\n\r\n#### 참고자료\r\n[위키트리](https://en.wikipedia.org/wiki/Rolling_hash)  \r\n[Quora답변](https://www.quora.com/What-is-a-rolling-hash-and-when-is-it-useful)  \r\n\r\n## 옵션\r\n---\r\n\r\n```\r\n-v : 진행 상황을 상세하게 보여줌\r\n-r : 지정한 디렉토리의 하위 디렉토리까지 재귀적으로 실행\r\n-l : 소프트 링크 보존\r\n-H : 하드 링크 보존\r\n-h : -human-readable 읽을 수 있는 형식으로 출력 번호를 출력합니다.\r\n-p : 버전 속성 보존\r\n-o : 소유 속성 보존(루트)\r\n-g : 그룹 속성 보존\r\n-t : 타임스탬프 보존\r\n-D : 디바이스 파일 보존(루트)\r\n-z : 데이터 압축 전송\r\n-b : 낡은 파일은 ~가 붙음\r\n-u : 추가된 파일만 전송 새 파일은 갱신하지 않음\r\n-a : 아카이브 모드. rlptgoD를 자동 지정\r\n-c : 서버와 클라이언트의 파일 크기를 세밀히 체크\r\n-e ssh(rsh) : 전송 암호화\r\n\r\n--stats : 결과를 보고\r\n--delete : 서버에 없는 파일은 클라이언트에서도 삭제\r\n# 데이터 백업시 사용하지 않는 것이 좋다.\r\n--progress : 전송시 진행상황을 보여줌\r\n--existing : 추가된 파일은 전송하지 않고 갱신된 파일만 전송\r\n--exclude=PATTERN : 패턴에 제외할 파일, 디렉토리 유형을 써주면 동기화하지 않는다.\r\n```\r\n\r\n\r\n## Rsync 사용 예시\r\n---\r\n\r\n### 기본 사용법\r\n```bash\r\n$ rsync [option] [source] [destination]\r\n```\r\n\r\n### 1. 로컬로 디렉토리 복사 또는 동기화\r\n> rsync -zvh\r\n\r\n![](local1.PNG)\r\n![](local2.PNG)\r\n\r\n\r\n### 2. 로컬로 파일 복사 또는 동기화\r\n> rsync -zavh\r\n\r\n### 3. 원격으로 파일 복사 또는 동기화\r\n> 원격 Pull\r\n```bash\r\n$ rsync {options}  <User_Name>@<Remote-Host>:<Source-File-Dir>  <Destination>\r\n```\r\n> 원격 Push\r\n```bash\r\n$ rsync  <Options>  <Source-Files-Dir>   <User_Name>@<Remote-Host>:<Destination>\r\n```\r\n\r\n[17가지 예제 - linuxtechi.com](https://www.linuxtechi.com/rsync-command-examples-linux/)\r\n\r\n# Reference\r\n---\r\n\r\n[](https://m.blog.naver.com/PostView.nhn?blogId=asdf2017&logNo=221491533057&proxyReferer=https:%2F%2Fwww.google.com%2F)  \r\n[](https://skibis.tistory.com/16)  \r\n[](https://www.lesstif.com/linux-infra-book/rsync-18219605.html)  \r\n[](https://www.joinc.co.kr/w/Site/Tip/Rsync)  \r\n[](https://twpower.github.io/153-copy-file-or-directory-using-rsync-command)  ","excerpt":"Rsync(Remote sync) 파일과 디렉토리를 로컬 및 원격으로 동기화(복사) 하는데 사용 특징 네트워크 대역폭을 최소화하는 델타 인코딩 알고리즘을 사용해 변경이 일어난 부분만 전송 -> 빠르고 효율적으로 동기화 가능!   설치 rsync 홈페…","fields":{"slug":"/Rsync/"},"frontmatter":{"date":"May 05, 2021","title":"Rsync 정리","tags":["Rsync"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n개발 프로젝트를 진행하면 코드를 관리하기 위해  \r\n보통 **코드베이스**, **코드리뷰**, **배포방법**에 대해 고민한다.\r\n\r\n오늘은 코드베이스, 코드리뷰에 대해 정리해보자\r\n\r\n# 코드베이스란?\r\n---\r\n > 특정 시스템, 어플리케이션, 컴포넌트 따위를 빌드할 때 사용되는 소스코드의 전체집합, 그것을 담은 저장소 \r\n\r\n가장 대중적으로 많이 쓰이는 도구는 **git, svn**이 있다.\r\n\r\n보통 git을 가장 많이 사용하고 추가로 개발을 하며\r\n\r\nbranch를 어떻게 관리할지 고민하는데\r\n\r\ngit-flow, github-flow, gitlab-flow 브랜치 전략이 가장 대중적인 방법이다.\r\n\r\n## 1. Git-flow\r\n\r\n![](gitflow.png)\r\n\r\ngit-flow를 설명할 때 가장 많이 보이는 그림이다.  \r\n\r\n사진을 보면 5개의 브랜치가 있는데 브랜치를 정리해보면\r\n\r\n```\r\nmaster : 배포할 수 있는 브랜치\r\ndevelop : 개발 브랜치\r\nfeature : 기능별 개발 브랜치\r\nhotfixes : 버그를 수정하는 브랜치\r\nrelease : 배포 전 테스트를 통해 버그를 찾아내는 브랜치\r\n```\r\n\r\n진행과정을 살펴보면\r\n```\r\n1. 기능 개발을 위해 feature 브랜치를 생성 후 작업\r\n2. develop 브랜치에 merge\r\n3. 배포 전 테스트를 위해 release 브랜치 생성\r\n4. 테스트 완료 시, 배포를 위해 master 브랜치로 merge 후 태그를 달고 배포\r\n+ master branch에서 버그 발생 시, hotfix 브랜치 생성 \r\n  -> hotfix에서 작업한 내용은 master와 develop에 merge된다.\r\n```\r\n\r\n## 2. Github-flow\r\n---\r\n> 자동화 개념이 들어가 있는게 핵심!\r\n\r\n![](github-flow.PNG)\r\n\r\n가장 쉽고, 접하기 쉬운 브랜치 전략이라고 생각한다.   \r\n(혼자 개발할 때는 pull request가 없지만 ㅋ)\r\n\r\ngithub flow는 master 브랜치가 핵심이다. \r\n\r\nmaster 브랜치는 **항상 최신 상태, 안정적인 상태이다.**\r\n\r\ngithub flow를 잘 사용하기 위한 몇가지 특징을 정리해보면\r\n\r\n- 커밋 메세지를 명확히 작성한다.\r\n- pull request, role은 엄격해야한다.\r\n- CI가 필수!\r\n\r\n## 3. Gitlab-flow\r\n---\r\n\r\n![](gitlab-flow.PNG)\r\n\r\ngit-flow와 github flow의 중간버전 느낌이다.\r\n\r\nproduction 브랜치가 있는데 이 브랜치는 배포를 위한 브랜치이다.\r\n\r\n음... 더 알아 볼수록 짬뽕 시킨 것 같으므로 요런게 있다는 것만 알고 넘어가자 ㅋ\r\n\r\n# 정리\r\n---\r\n\r\n3가지 브랜치 전략을 알아보았는데 \r\n\r\n세가지 모두 효율적인 소스 관리, 좋은 배포를 위한 고민이다.\r\n\r\n어쨋든 가장 중요한건 **개발팀 상황에 맞게 구성원과 전략을 세우는 것**으로 정리하고 글을 마친다. \r\n\r\n# 잡담\r\n\r\n혼자 개발하고, 친구들이랑 공모전 준비할 땐 이런 문제를 딱히 고민하지 않았는데  \r\n회사에서 직접 버그를 수정하고, 간단한 기능개발 하며   \r\n협업 방법과 코드로 대화하는 것에 대해 계속 고민하게 된다.\r\n\r\n\r\n# Reference\r\n[git flow 참고 자료](https://nvie.com/posts/a-successful-git-branching-model/)  \r\n[github flow 참고 자료(공식 홈페이지)](https://guides.github.com/introduction/flow/)  \r\n[gitlab flow 참고 자료(공식 홈페이지)](https://about.gitlab.com/topics/version-control/what-is-gitlab-flow/)  ","excerpt":"개발 프로젝트를 진행하면 코드를 관리하기 위해 보통 코드베이스, 코드리뷰, 배포방법에 대해 고민한다. 오늘은 코드베이스, 코드리뷰에 대해 정리해보자 코드베이스란? 특정 시스템, 어플리케이션, 컴포넌트 따위를 빌드할 때 사용되는 소스코드의 전체집합, …","fields":{"slug":"/gitflow/"},"frontmatter":{"date":"Apr 20, 2021","title":"git branch 전략","tags":["git"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n\r\ncodeigniter3를 공부해보자\r\n\r\n# codeigniter3\r\n\r\n# 1. CI 동작\r\n\r\n![data flow image](dataFlow.PNG)\r\n\r\n1. index.php CI가 동작하기 위한 기반 리소스 초기화\r\n2. Router 모듈 동작 결정\r\n   2.1) 캐시 파일 존재 -> 캐시 파일 전송\r\n3. Security 모듈이 Controller로 이동하기 전에 필터링\r\n4. Controller 사용자 요청 처리\r\n5. View 모듈 렌더링 -> 전송 (캐시 추가)\r\n\r\n## CI URL\r\n\r\n새그먼트 기반 URL 사용\r\n\r\n```\r\nexample.com/news/article/my_article\r\n{호스트 주소}/{호출될 Controller}/{클래스 안의 호출될 Function}/{변수}\r\n```\r\n\r\n<!-- TODO : nginx index.php 제거 방법 -->\r\n\r\n# 2. MVC\r\n\r\n1. Model : 데이터구조 표현, 모델 클래스는 데이터 함수 포함\r\n2. View : 사용자에게 보여질 화면\r\n3. Controller : Model과 View사이 동작\r\n\r\n![](phpMVCpattrenEx.gif)\r\n\r\n<!-- TODO : 파일 구조 설명 -->\r\n\r\n## Controller\r\n> URL과 상호작용하는 클래스 파일\r\n\r\n#### 특징\r\n - 클래스 명은 항상 **대문자로 시작**\r\n\r\n### 추가로 알아야 될 사항\r\n\r\n#### 1. Controller에 나오는 _의 의미\r\n> Controller에서 _를 함수 이름 앞에 작성하면 **Routing**되지 않는다. (private한 메소드가 된다.)\r\n\r\n\r\n#### 2. $this, self, -> 차이\r\n<!-- TODO : 정리해야 한다. -->\r\n\r\n[참고 블로그](https://m.blog.naver.com/PostView.nhn?blogId=vefe&logNo=221454883593&proxyReferer=https:%2F%2Fwww.google.com%2F)\r\n\r\n#### 3. _remap() 함수\r\n> 함수요청 재매핑\r\n\r\n\r\n```php\r\npublic function _remap($method, $params = array()) {\r\n   $method = 'process_'.$method;\r\n   if (method_exists($this, $method)) {\r\n      return call_user_func_array(array($this, $method), $params);\r\n   }\r\n   show_404();\r\n}\r\n```\r\n\r\n\r\n**컨트롤러가 _remap()함수 가지고 있으면 무조건 호출된다**\r\n\r\n#### 4. _output() 함수\r\n> \r\n\r\n<!-- TODO : VIEW, Output 클래스 내용 정리하고 다시보자 -->\r\n\r\n**추가로 알아야 될 사항은 내용은 내용을 조금 더 추가 할 예정이다.**\r\n\r\n## Route\r\n> application/config/routes.php에 작성\r\n<!-- TODO : 생활코딩 강의 -> ref문서 정리 -->\r\n\r\n## View\r\n> 화면에 출력되는 부분\r\n\r\n## Model\r\n> Model은 데이터를 가져오는 로직을 메소드로 정의, Controller를 통해 사용된다.\r\n\r\n### 데이터 베이스 설정\r\n\r\n> Application/config/database.php 파일을 수정\r\n\r\n파일 속성\r\n```\r\nhostname : 데이터베이스 서버의 주소 (localhost는 PHP와 같은 머신을 의미)\r\nusername : 데이터베이스 사용자의 이름\r\npassword : 데이터베이스 비밀번호\r\ndatabase : 데이터베이스 명\r\ndbdriver : 데이터베이스의 종류로 지원되는 드라이브의 목록은 system/database/drivers 디렉토리명을 참고한다.\r\n```\r\n\r\n### 데이터 베이스 라이브러리 로드\r\n\r\nPHP에서 MySQL을 사용하기 위해 mysqli를 설치한다\r\n\r\n```bash\r\n$ sudo apt-get install php-mysqli\r\n```\r\n\r\n데이터 베이스 라이브러리 로드 방법은 2가지가 있다.\r\n\r\n```\r\n1. application/config/autoload.php 파일의 $autoload['libraries'] 배열에 'database'를 추가한다. \r\n2. controller 내에서 $this->load->database()를 호출한다.\r\n```\r\n\r\n### Model 파일 생성 규칙\r\n - **application/models/{모델 명_model}.php** 형식으로 생성\r\n - 파일은 **CI_Model 클래스 상속**\r\n - 클래스 명은 **대문자로 시작**\r\n\r\n### Model load\r\n\r\n1. Model load\r\n> $this->load->model('소문자로된 모델 클래스 명');  \r\n\r\nex)\r\n```\r\n$this->load->model('topic_model');\r\n```\r\n\r\n1. Model call\r\n> 모델 클래스 명 -> 메소드 명\r\n\r\nex)\r\n```\r\n$topics = $this -> topic_model -> gets();\r\n```\r\n\r\n### Model 내 쿼리 사용\r\n> $this->db 이용!\r\n\r\n- 사용 예제 \r\n  \r\n```php\r\n$query - $this->db->query('SELECT name, title, email FROM my_table')\r\n\r\nforeach($query->result() as $row) {\r\n   echo $row->title;\r\n   echo $row->name;\r\n   echo $row->email;\r\n}\r\n\r\necho 'Total Results: ' . $query->num_rows();\r\n```\r\n\r\n#### 결과 불러오기\r\n> **객체 배열 리턴**한다.\r\n\r\n1. 다중 결과(객체)\r\n   - result()\r\n2. 다중 결과(배열)\r\n   - result_array()\r\n3. 단일 결과(객체)\r\n   - row()\r\n4. 단일 결과(배열)\r\n   - row_array()\r\n\r\n<!-- TODO : 표준 입력 예제, 쿼리 빌더 -->\r\n<!-- http://www.ciboard.co.kr/user_guide/kr/database/examples.html#standard-insert -->\r\n\r\n<!-- TODO : Active Record vs JPA 비교 -->\r\n\r\n## Tip!!\r\n\r\n```bash\r\nif (!-e $request_filename ) {\r\n\trewrite ^(.*)$ /index.php last;\r\n}\r\n```\r\nfile이 존재하지 않으면, index.php로 이동\r\n\r\n### ?> 닫는 태그를 생략하는 경우\r\n\r\nPHP 구문은 기본적으로 \r\n```php\r\n<?php\r\n  ...\r\n?>\r\n```\r\n위와 같이 구성된다. 문장의 종료는 반드시 **세미 콜론**이 찍혀야 한다.\r\n\r\n하지만 php코드를 보면 닫는 코드인 ?> 을 생략한 구문이 있다. 이상하게 코드는 잘 동작한다.\r\n\r\n그 이유를 알아보면 순수 PHP코드로만 이루어진 코드는 닫는 태그를 생략하는 것이 더 유리하다고 한다.\r\n\r\n왜냐하면 닫는 태그인 ?> 앞 뒤에 공백이나 Enter가 실수로 들어가는 경우가 많기 때문이다.\r\n\r\n이런 상황에는 의도하지 않은 에러가 날 수 있고, 디버깅 하기 힘듬\r\n\r\n하지만 **HTML 코드와 같이 사용할 경우에는 반드시 사용해야 한다.**\r\n\r\n\r\n# 3. Library, Helper\r\n\r\n## Helper\r\n> 자주 사용하는 로직을 재활용 할 수 있게 만드는 Library\r\n\r\n**Library vs Helper**  \r\n> Helper : 일반적인 함수로 만들어짐 / Library : 객체로 만들어짐\r\n\r\n1. 기본적인 로드 방법\r\n```php\r\n$this->load->helper('헬퍼 이름')\r\n```\r\n\r\n2. 복수의 헬퍼를 로드하기 위한 방법\r\n```php\r\n$this->load->helper(array('헬퍼1의 이름', '헬퍼2의 이름'));\r\n```\r\n\r\n## Tip!!\r\n헬퍼는 보통 직접적으로 스크립트를 실행하는 경우가 많이 없으므로\r\n\r\n```php\r\n<?php if (! defined('BASEPATH')) exit('No Direct script access allowed');\r\n```\r\n구문을 상단에 최상단에 추가하여 스크립트의 실행을 막는다.\r\n\r\n## Library\r\n> 웹개발에서 자주 사용되는 로직을 내장(Core) 라이브러리로 제공하고 있다.\r\n\r\n# 4. CI Config\r\n> 필요에 따라 Application 동작 방법을 변경한다.\r\n> Application/config/ 디렉토리 아래에 위치\r\n\r\n**Tip!!**\r\n개발환경과 실서비스 환경과 설정을 다르게 위해 index.php의\r\n```php\r\ndefine('ENVIRONMENT', 'development');\r\n```\r\n두 번째 인자값을 development, testing / production 으로 바꿀 수 있지만\r\n**dev.php를 하나 더 만들어서 접속 경로를 다르게 하는 방법도 있음**\r\n\r\n```\r\ndevelopment : 개발 환경에서 사용한다. 모든 에러가 출력된다. \r\ntesting, production : 테스팅이나 실서비스 환경에서 사용된다. 에러가 출력되지 않는다. \r\n```\r\n\r\n## 1. config.php\r\n> CI에 필요한 기본적인 설정파일 / CI가 동작하는 방식에 대한 다양한 설정 값이 저장되어 있음.\r\n\r\n파일을 보면 쿠키, 세션, 보안, 캐시파일/로그파일 저장 위치 같은 것을 확인할 수 있다.\r\n\r\n## 2. database.php\r\n> database에 필요한 설정파일\r\n\r\n## 3. autoload.php\r\n> Helper, Library같은 리소스들을 자동 로드 -> 편의성 증대 / 성능 감소 주의\r\n\r\n## 4. hooks.php\r\n> 사용자가 Core의 기본 실행 흐름을 설정 가능 (자신만의 로직 추가 가능 / config.php에서 설정 해야지 사용 가능)\r\n\r\n## 설정 정보 사용\r\n> config 라이브러리와 config.php 파일은 자동 로딩하기 때문에 별도 작업 필요 없음\r\n\r\n```php\r\n$this->config->item('base_url');\r\n```\r\n\r\n### 사용자 정의 설정\r\n> $config 배열에 값 추가, 파일을 통한 설정 값 추가 가능(로딩 절차 필요)\r\n\r\n```php\r\n$this->load->config('hsh');\r\n// file을 통한 설정 load \r\n$this->config->item('hsh');\r\n// item 메소드는 설정이 없으면 false 리턴\r\n```\r\n\r\n## 5. CI debugging / log\r\n\r\napplication/config/config.php에 보면\r\n\r\n```php\r\n$config['log_threshold'] = 0;\r\n```\r\n구문 수정을 통해 log수준을 설정할 수 있다.\r\n\r\n```\r\n0 = 로깅을 비활성화\r\n1 = 에러로그만 기록\r\n2 = 디버그 로그도 기록 \r\n3 = 정보 로그도 기록\r\n4 = 모든 메시지를 기록\r\n```\r\n\r\ncontroller에서 아래와 같이 사용하면 원하는 log메세지를 추가 할 수 있다.\r\n\r\n```php\r\n// debug 메세지 추가\r\nlog_message('debug', 'topic 초기화');\r\n\r\n// error 메세지 추가\r\nlog_message('error', 'topic의 값이 없습니다');       \r\n```\r\n\r\n## 6. 파일 처리\r\n> Upload 클래스의 doupload가 핵심 메소드\r\n\r\n현재 다니고 있는 회사에선 file upload는 **Fine-Uploader**를 사용하고  \r\n**CKEditor**를 사용해서 HTML 코드 없이 글을 작성하는 기능을 구현했다.\r\n\r\n## 7. Core 확장\r\n> CI는 코어 상속, Hook방법을 통해 Core기능 \r\n\r\n\r\n\r\n\r\n<!-- ## 8. 세션 / 비밀번호 암호화\r\n\r\n## 9. CRI 프로그램\r\n\r\n## 10. Queue / Cron\r\n\r\n## 11. Caching -->\r\n\r\n<!-- \r\n[쿠키와 세션](https://opentutorials.org/course/62/240\r\n[Session](https://opentutorials.org/course/697/398)\r\n[회원가입 & 비밀번호 암호화](https://opentutorials.org/course/697/4278)\r\n[리다이렉션과 로그인 개선](https://opentutorials.org/course/697/4129)\r\n[이메일 전송 & 라이브러리 장]()\r\n[CLI](https://opentutorials.org/course/697/4282)\r\n[Queue & cron](https://opentutorials.org/course/697/4130)\r\n[Caching](https://opentutorials.org/course/697/3839)\r\n -->\r\n\r\n## 경로에 index.php 없애기\r\n\r\n1. application/config/config.php\r\n\r\n```php\r\n$config['index_page'] = '';\r\n```\r\nindex.php를 찾아서 빈 값으로 설정한다\r\n\r\n2. index.php가 존재하는 폴더에 .htaccess파일을 추가한다.\r\n(Permisson은 755로 설정한다.)\r\n\r\n**.htaccess 파일**\r\n```\r\n<IfModule mod_rewrite.c>\r\n    RewriteEngine On\r\n    RewriteCond %{REQUEST_FILENAME} !-f\r\n    RewriteCond %{REQUEST_FILENAME} !-d\r\n    RewriteRule ^(.*)$ index.php/$1 [L]\r\n</IfModule>\r\n```","excerpt":"codeigniter3를 공부해보자 codeigniter3 1. CI 동작  index.php CI가 동작하기 위한 기반 리소스 초기화 Router 모듈 동작 결정\n2.1) 캐시 파일 존재 -> 캐시 파일 전송 Security 모듈이 Controll…","fields":{"slug":"/phpNginxCI_4/"},"frontmatter":{"date":"Mar 01, 2021","title":"Codeigniter 학습","tags":["Codeigniter"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n# 1. SQLite .명령어 정리\r\n> SQLITE의 특징은 명령어 앞에 마침표(.)를 붙인다.\r\n\r\n파일 접속\r\n```bash\r\n$ sqlite3 {파일명}\r\n```\r\n\r\n파일 접속 종료\r\n```bash\r\n> .quit\r\n> .exit\r\n```\r\n\r\n테이블 확인\r\n```bash\r\n> .tables\r\n```\r\n\r\n테이블 구조 확인\r\n```bash\r\n> .schema access_log\r\n```\r\n\r\n헤더(컬럼 명) 함께 출력\r\n```bash\r\n> .header on\r\n```\r\n\r\n라인별로 나눠 출력\r\n```bash\r\n> .mode line\r\n```\r\n\r\n컬럼별로 나눠 출력\r\n```bash\r\n> .mode column\r\n```\r\n\r\n추가 기능 확인\r\n```bash\r\n> .help\r\n```\r\n\r\n# 2. 파일 I/0\r\n> sqlite3는 쿼리 결과를 표준 출력으로 보낸다.\r\n - \".output\", \".once\" 명령어를 사용하여 변경 가능\r\n\r\n\r\n1) .OUTPUT 명령어 \r\n > .output에 인수로 파일명 넣으면 해당 파일에 기록 (.output을 사용하면 표준 출력 상태로 되돌아간다)\r\n\r\n2) .import 명령어를 사용해 csv데이터를 sqlite 테이블로 가져올 수 있다.\r\n```bash\r\nsqlite> .import C:/CVS/aaa.csv aaa\r\n```\r\n\r\n**주의할 점**\r\n - SQLite3은 기본적으로 UTF-8형식 / 윈도우 엑셀은 CP949형식","excerpt":"1. SQLite .명령어 정리 SQLITE의 특징은 명령어 앞에 마침표(.)를 붙인다. 파일 접속 파일 접속 종료 테이블 확인 테이블 구조 확인 헤더(컬럼 명) 함께 출력 라인별로 나눠 출력 컬럼별로 나눠 출력 추가 기능 확인 2. 파일 I/0 s…","fields":{"slug":"/SQLite/"},"frontmatter":{"date":"Feb 26, 2021","title":"SQLite","tags":["SQLite"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\nphp 문법을 간략히 정리해보자\r\n\r\n# 1. 변수\r\n\r\nPHP는 아래와 같은 자료형을 사용할 수 있다\r\n문자열 String  \r\n정수형 Integer  \r\n실수형 Float  \r\n논리형 Boolean  \r\n배열 Array  \r\n객체형 Object  \r\n널 NULL  \r\n리소스 Resource  \r\n\r\n아래의 방법으로 변수의 자료형을 알아내거나, 자료형을 변경할 수 있다.\r\n\r\n```php\r\n// 변수 자료형 알아내기 \r\nvar_dump({변수 이름});\r\necho gettype({변수 이름});\r\n\r\n// 변수 자료형 변경\r\nsettype({변수이름},'{자료형}');\r\n```\r\n\r\nPHP의 특징으로 동적으로 변수명 설정이 가능하다.\r\n\r\n```php\r\n<?php\r\n$title = 'subject';\r\n$$title = 'PHP tutorial';\r\necho $subject;\r\n?>\r\n```\r\n\r\n아래의 구문을 실행하면 실행값이\r\n```\r\nPHP tutorial\r\n```\r\n이 나온다.\r\n\r\n\\$\\$가 두번 표시되어 있는데, $title 의 값으로 변수가 생성된 것을 의미한다.\r\n\r\n\r\n# 2. 연관배열\r\n\r\n두번째 특징으로 연관배열이 있다.\r\n\r\n## 연관배열\r\n> 배열의 키 값으로 숫자와 문자 모두 사용\r\n\r\n예제를 보면 \r\n\r\n값 할당 및 출력 구문\r\n```php\r\n<?php\r\n$grades = array('egoing'=>10, 'k8805'=>6, 'sorialgi'=>80);\r\n$grades = array('egoing'=>10, 'k8805'=>6, 'sorialgi'=>80);\r\nforeach($grades as $key => $value){\r\n    echo \"key: {$key} value:{$value}<br />\";\r\n}\r\n?>\r\n```\r\n\r\n결과값\r\n```php\r\nkey : sorialgi  value : 80\r\nkey : k8805     value : 6\r\nkey : egoing    value : 10  \r\n```\r\n\r\n키값 형태로 사용한다.\r\n\r\n# 3. File load\r\n\r\n## require, import \r\n\r\nphp에는 **1. require** , **2. import** 두가지 방법으로 file호출 가능  \r\n뒤에 \\_once를 붙여 include\\_once 처럼 사용하면 파일을 로드할 때 단 한번만 로드하면 된다는 의미\r\n\r\n기능상 차이는 없는데 error 표시가 다르다.  \r\n\r\nrequire가 더 높은 에러 수준으로 error를 알리고, 코드의 실행을 중단시킨다.  \r\n\r\n\r\n**1) 파일 복사**\r\n> copy(\\$file, \\$newfile)\r\n\r\n**2) 파일 삭제**\r\n> unlink('file.txt');\r\n\r\n**3) 파일 읽기**\r\n> file_get_contents($file);\r\n\r\n**4) 파일 저장**\r\n> file_put_contents($file, 'coding everybody');\r\n\r\n**5) file etc**\r\n> is\\_readable, is\\_writable, file_exists 같은 함수를 통해 파일 확인이 가능하다\r\n\r\n**6) 디렉토리**\r\n```php\r\n// directory 읽기\r\n$dir    = './';\r\n$files1 = scandir($dir);\r\n\r\n// directory 만들기\r\nmkdir(\"1/2/3/4\", 0700, true);\r\n```\r\n\r\n# 4. Class\r\n\r\n클래스 선언 및 인스턴스 생성\r\n```php\r\nclass MyObject{\r\n  function __contruct($fname){\r\n    $this->filename = $fname;\r\n  }\r\n}\r\n\r\n$obj = new MyObject('file1');\r\n```\r\n\r\nClass내 함수 사용\r\n```php\r\nprint_r($obj->func());\r\n```\r\n\r\n# 5. 접근 제어자\r\n> private, public 키워드를 사용해서 접근을 제어할 수 있다.\r\n\r\n# 6. 상속\r\n> extends 키워드를 사용해 클래스를 상속할 수 있다.\r\n\r\n**Tip!!**  \r\n클래스 안에 static 키워드를 추가한 변수를 만들어주면 모든 인스턴스가 공유하는 변수를 만들어줄 수 있다.\r\n\r\n```php\r\nclass car{\r\n  private static $count = 0;\r\n  private $name;\r\n  function __construct($name){\r\n    $this->name = $name;\r\n    self::$count = self::$count+1;\r\n  }\r\n}\r\n```\r\n\r\n### 클래스 접근\r\n\r\n부모 클래스를 접근할 때는 parent(parent::) 연산자를 사용한다.\r\n자신의 클래스를 접근할 때는 self(self::) 연산자를 사용한다.\r\n\r\n**\\::는 new 지시자로 class를 미리 객체화 시켜놓지 않고 사용하는 시점에서 객체가 생성되고 지정된 메소드가 실행되도록 하는 접근자이다.**\r\n\r\n\r\n# 7. Namespace, use\r\n> Namespace : 동일한 이름을 가진 class가 존재할 때 구분하여 사용하기 위한 이름\r\n> use : 키워드를 통해 불러올 수 있다.\r\n\r\nJava에서 package와 import 같은 개념이다. \r\n\r\n[PSR](https://www.php-fig.org/psr/psr-4/)에서는 아래와 같은 방식으로 사용하는 것을 권장한다\r\n> \\<NamespaceName>(\\<SubNamespaceNames>)*\\<ClassName>\r\n\r\n사용법은\r\n```php\r\n<?php\r\n// 파일명 : greeting_en_ns.php\r\n\r\nnamespace language\\en;\r\nclass Hi{\r\n  function welcome(){\r\n      return 'Hello world';\r\n  }\r\n}\r\n```\r\n상단에 namespace 를 명시해준다.\r\n\r\n사용할 땐\r\n```php\r\n<?php\r\nrequire_once 'greeting_en_ns.php';\r\nuse \\greeting\\en\\Hi as hien\r\nnew HiEn();\r\n?>\r\n```\r\n\r\n불러와서 사용해주면 된다.\r\n\r\n# 8. 인터페이스\r\n\r\n```php\r\ninterface myInterface{\r\n  public function promiseMethod(array $param):int;\r\n}\r\n```\r\n\r\n# 9. abstract\r\n> 하위 클래스가 반드시 오버라이드하게 강제한다.\r\n\r\n강제하고 싶은 메소드 앞에 abstract 키워드를 붙여주면 된다.\r\n\r\n# 10. 컴포저\r\n> PHP의 Package Manager\r\n\r\ncomposer.json파일로 관리\r\n\r\n[packagist](https://packagist.org/)를 들어가보면 PHP Repository를 검색할 수 있다.\r\n\r\nCI3의 composer.json\r\n\r\n![](ciComposer.PNG)\r\n\r\n추가로 ci는 composer를 사용하려면 config/config.php 부분에 아래 구문을 수정 해야한다.\r\n\r\n```php\r\n$config['composer_autoload'] = '/vendor/autoload.php';\r\n```\r\n\r\n---\r\n\r\n위 내용을 바탕으로 간단하게 CI3 + Nginx로 띄운 서버에 id, password 입력 폼을 만들고 정규식으로 값들을 체크하는 코드를 작성해보았다.\r\n\r\ncontroller 소스다.\r\n![](1.PNG)\r\n\r\nview 소스다.\r\n![](2.PNG)\r\n\r\n/playground\r\n![](4.PNG)\r\n\r\n/playground/go 로 이동한 결과\r\n![](3.PNG)\r\n\r\n끗","excerpt":"php 문법을 간략히 정리해보자 1. 변수 PHP는 아래와 같은 자료형을 사용할 수 있다\n문자열 String 정수형 Integer 실수형 Float 논리형 Boolean 배열 Array 객체형 Object 널 NULL 리소스 Resource   아래…","fields":{"slug":"/phpNginxCI_3/"},"frontmatter":{"date":"Feb 25, 2021","title":"PHP 기본 문법 정리","tags":["PHP"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n<!-- \r\n   학습 강의\r\n   1. nginx \r\n   2. php 기본 문법\r\n   3. php 객체지향\r\n   4. php + mysql\r\n -->\r\n\r\n1. PHP + Nginx 개발 환경 설정\r\n2. Nginx 이해\r\n3. PHP 언어 사용방법 학습\r\n4. Codeigniter를 사용한 MVC 구현 방법 학습\r\n5. Codeigniter + MySQL + React 게시판 구현\r\n\r\n# 1. Window / Linux 환경 설정\r\n\r\n**아파치와 php7는 라이브러리 충돌 및 오류 때문에 잘 쓰이지 않음**\r\n\r\n## Window PHP 환경 설정\r\n\r\n1. WNMP 설치\r\n2. {설치경로}/conf/nginx/nginx.conf - root directory 변경 \r\n\r\n## Linux 환경 설정\r\n\r\n환경 설정 방법\r\n\r\n1. PHP-fpm 실행\r\n2. nginx 실행\r\n\r\n```bash\r\n$ apt-get install nginx\r\nNginx 실행 : service nginx start \r\nNginx 중단 : service nginx stop \r\nNginx 재시작 : service nginx restart  / nginx 서버 중단 후 재가동\r\nNginx 리로드 : service nginx reload  / 설정만 다시 적용\r\nNginx 자동 시작 : service nginx enable \r\nNginx 상태 : service nginx status\r\n```\r\n\r\n3. php 설치\r\n\r\n```bash\r\n$ apt-get install php-fpm\r\n```\r\n\r\n4. /etc/nginx/sites-available/default 파일 수정\r\n\r\n```\r\n1. index.php 자동 인식하게 설정\r\nindex index.html index.htm index.nginx-debian.html;\r\n\r\n2. 설치한 php fpm에 맞게 수정\r\nlocation ~ \\.php$ {\r\n  include snippets/fastcgi-php.conf;\r\n  fastcgi_pass unix:/var/run/php/php7.2-fpm.sock\r\n}\r\n\r\n3. 원하는 root경로 설정\r\nroot /{원하는 경로}\r\n```\r\n\r\n간단하게 index.php 파일을 만들어 들어가봤다.\r\n\r\n```php\r\n<?php\r\n  phpinfo();\r\n>\r\n```\r\n\r\n![](phpinfo.PNG)\r\n\r\n## **Tip!!**  \r\n설정파일 이상 여부 검사 \r\n```bash\r\nnginx -t\r\n```\r\nerror log확인 \r\n```bash\r\ntail -f /var/log/nginx/error.log  \r\n```  \r\n텍스트 모드 부팅 설정 (더 빨라짐)\r\n```bash\r\nsudo systemctl set-default multi-user.target\r\n```\r\n\r\n[putty로 virtualbox 연결하기 - 숭숭이님 블로그](https://m.blog.naver.com/skddms/220575084716)  \r\n[[Vim]vim 설정하기 - heyhyo님 블로그](https://hyoje420.tistory.com/51)  ","excerpt":"PHP + Nginx 개발 환경 설정 Nginx 이해 PHP 언어 사용방법 학습 Codeigniter를 사용한 MVC 구현 방법 학습 Codeigniter + MySQL + React 게시판 구현 1. Window / Linux 환경 설정 아파치와 …","fields":{"slug":"/phpNginxCI_1/"},"frontmatter":{"date":"Feb 24, 2021","title":"PHP + Nginx 개발 환경 설정","tags":["PHP"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"# Nginx\r\n\r\n## CGI(Common Gateway Interface) 란?\r\n> 웹서버와 외부 프로그램(C, PHP, Python 등) 사이에서 정보를 주고받는 방법과 규약\r\n\r\n**이 표준에 맞춰 만들어진 것이 CGI 스크립트이다.**\r\n\r\n![](cgipic.PNG)\r\n\r\n### 관련 용어\r\n - Web Server : 웹 클라이언트에게 콘텐츠를 제공하는 서버\r\n - WAS : 서버 단에서 Application을 동작할 수 있도록 지원\r\n\r\n### 장점\r\n - 언어, 플랫폼에 독립적\r\n - 매우 단순하고 다른 서버 사이드 프로그래밍 언어에 비해 쉽게 수행\r\n - 라이브러리가 풍부하다\r\n - 가볍다\r\n\r\n### 단점\r\n - 느리다(요청이 올 때 마다 DB connection을 새로 열어야 한다)\r\n<!-- TODO : 확인해보자 -->\r\n - HTTP 요청마다 **새로운 프로세스를 만들어** 서버 메모리를 사용한다 (Fork로 구현되어 있음)\r\n - 데이터가 메모리에 캐시될 수 없다.\r\n\r\n### 추가\r\n[RPC 3875-1.4 항목](https://tools.ietf.org/html/rfc3875#section-1.4)\r\n```\r\n1. CGI 프로그램을 호출하는 WEB 서버 역할\r\n  1) 전송 단계에서의 인증 및 보안\r\n  2) CGI 프로그램의 선택\r\n  3) CGI Request 로 변환\r\n  4) CGI Response에서의 변환\r\n2. 호출 프로그램의 지정 방법 (URI)\r\n3. WEB 서버에서 CGI Request의 해석 방법 (경로 및 프로토콜)\r\n4. WEB 서버에서 CGI Response에 대한 반환 방법 (경로 및 프로토콜)\r\n```\r\n\r\n## FastCGI란?\r\n> 하나의 큰 프로세스로 동작한다. 이 프로세스가 계속해서 새로운 요청(Request) 처리(CGI 단점 해결)\r\n\r\n![](fastcgip.PNG)\r\n\r\n대부분의 웹서버 **(Nginx, IIS, Apache)** 가 FastCGI를 제공한다.\r\n\r\n## PHP-FPM(Fast Process Manager)\r\n> PHP를 FastCGI 모드로 동작하게 해준다.\r\n\r\n\r\n## 1. 역할\r\n1. 정적 파일을 처리하는 **HTTP 서버**로서의 역할\r\n\r\n![](webserver.PNG)\r\n\r\n2. 응용 프로그램 서버에 요청을 보내는 **리버스 프록시** 역할\r\n\r\n![](reverseProxy.PNG)\r\n\r\n프록시는, **클라이언트와 서버 통신 사이에서 통신을 대신!! 해주는 서버를 의미한다.**\r\n\r\n### 리버스 프록시란?\r\n > 클라이언트가 서버에 요청하면, 프록시 서버가 배후 서버(응용프로그램 서버)로부터 데이터를 가져옴\r\n\r\n추가로 포워드 프록시는 클라이언트 앞단에서\r\n**보안을 위해 사용을 제한할 목적**\r\n\r\n리버스 프록시는 서버의 앞단에서 요청을 처리  \r\n**좀 더 안전하게 Request, Response를 관리**\r\n\r\n### 리버스 프록시를 쓰는 이유\r\n > 1. **프록시 서버를 둠으로써 요청을 배분하는 역할**  \r\n > 2. cli가 직접 App 서버에 요청하면 프로세스 1개가 응답대기 상태가 되어서 요청에 대한 버퍼링이 생긴다  \r\n > 3. 보안상 이점! -> WAS는 대부분 DB서버와 연결되어 있으므로 WS - WAS가 통신을 통해 클라이언트에게 제공하는 방식\r\n\r\n추가로 스위치(로드밸런서)로써 역할도 가능하다.\r\n> 프로세스 응답 대기를 막고, 요청을 배분하는 역할 \r\n### Event-driven 방식\r\n\r\nThread 기반은 하나의 커넥션당 하나의 쓰레드를 사용\r\n\r\nEvent-driven 방식은 Event Handler를 통해 비동기 방식으로 처리해 먼저 처리되는 것부터 로직이 진행된다.\r\n\r\n![](threadp.PNG)\r\n\r\n![](eventp.PNG)\r\n\r\n## 2. 파일 구조\r\n\r\n5개 폴더 및 파일을 알아보고 넘어가겠다.\r\n\r\n```\r\nconf.d : nginx.conf에서 불러들일 수 있는 파일을 저장\r\nfastcgi.conf : FastCGI 환경설정 파일\r\nnginx.conf : 접속자 수, 동작 프로세스 수 등 퍼포먼스에 관한 설정들\r\nsites-available : 비활성화된 사이트들의 설정 파일들이 위치한다.\r\nsites-enabled : 활성화된 사이트들의 설정 파일들이 위치한다. \r\n```\r\n\r\n사실 기본 설정이 이렇다는 거고, 폴더명 같은 경우는 상황에 따라 변경이 가능하다. \r\n\r\n## 3. 변수\r\n\r\n#### $arg_{PARAMETER}\r\n> URI의 파라미터 변수의 이름 의미\r\n#### $host\r\n> 현재 요청의 호스트 명\r\n\r\n#### $uri\r\n> 현재 요청의 URI (호스트명과 파라미터는 제외된다.)\r\n\r\n#### $args\r\n> URL의 질의 문자열\r\n\r\n#### $binary_remote_addr\r\n> 바이너리 형식의 클라이언트 주소\r\n\r\n#### $body_bytes_sent\r\n> 전송된 바디의 바이트 수\r\n\r\n#### $content_length\r\n> HTTP 요청헤더의 Content-length\r\n\r\n#### $content_type\r\n> HTTP 요청헤더의 Content-type\r\n\r\n#### $document_root\r\n> 현재 요청의 document root 값\r\n\r\n#### $http_HEADER\r\n> HTTP 헤더의 값을 소문자로 한 값(-는 _로 변환된다.)\r\n\r\n#### \\$server\\_name / \\$server\\_port / \\$server\\_protocol\r\n> 각각 name, port, protocol을 의미한다.\r\n\r\n#### cookie_{쿠키이름}\r\n> 해당 쿠키의 값을 얻을 수 있다.\r\n## 4. 설정\r\n\r\n**설정 수정 시 원본을 복사해 보관해 두는 습관 가지자!**\r\n\r\n### 설정 파일\r\n\r\n설정파일은 크게 4가지로 나뉜다.\r\n1. nginx.conf : 메인 설정 파일\r\n2. fcgi.conf : FastCGI 환경 설정파일\r\n3. sites-enabled : 활성화된 사이트들의 설정 파일 위치\r\n4. sites-available : 비활성화된 사이트들의 설정 파일 위치\r\n\r\n\r\n두개의 파일을 보며 Nginx 설정에 대해 확인해보자\r\n> /etc/nginx/nginx.conf  \r\n> /etc/nginx/sites-available/default\r\n\r\n#### /etc/nginx/nginx.conf\r\n```\r\nuser www-data;\r\nworker_processes auto;\r\npid /run/nginx.pid;\r\n\r\nevents {\r\n        worker_connections 768;\r\n        # multi_accept on; #기본값:off\r\n}\r\n\r\nhttp {\r\n        sendfile on;\r\n        tcp_nopush on;\r\n        tcp_nodelay on;\r\n        keepalive_timeout 10; #기본값:75\r\n        types_hash_max_size 2048;\r\n        server_tokens off;\r\n\r\n        server_names_hash_bucket_size 64; #기본값:32\r\n        server_names_hash_max_size 2048; #기본값:512\r\n        # server_name_in_redirect off;\r\n\r\n        include /etc/nginx/mime.types;\r\n        default_type application/octet-stream;\r\n\r\n        access_log off; log_not_found off;\r\n        error_log /var/log/nginx/error.log warn;\r\n\r\n        include /etc/nginx/conf.d/*.conf;\r\n        include /etc/nginx/sites-enabled/*;\r\n}\r\n\r\n```\r\nnginx.conf 파일은 접속자 수, 동작 프로세스 수 등 퍼포먼스에 대한 기본적인 설정 항목을 포함한다.\r\n\r\n크게 3가지 항목으로 나뉜다.\r\n\r\n#### 1. 최상단 (Core 모듈)\r\n\r\nuser : Nginx 프로세스(워커 프로세스)가 실행되는 권한\r\n - nginx는 master process, worker process로 동작한다.\r\n - 실질적으로 **worker process가 실직적인 웹서버 역할** 수행\r\n - root로 설정되어 있을 경우, 워커 프로세스를 root 권한으로 동작  \r\n   -> 악의적인 사용자가 제어하게 된다면 보안상 위험  \r\n   -> 보통 **www-data, www, nginx**와 같이 계정이 하는 일에 대한 대표성 있는 이름 사용  \r\n    - (default 값 - ubuntu : www-data, 기타 nobody )  \r\n   -> 이 계정들은 일반 유저의 권한으로 쉘에 접속 할 수 없어야 안전하다.  \r\n    - ubuntu 에서 계정 생성방법  \r\n```bash\r\n$ useradd --shell /usr/sbin/nologin www-data\r\n```\r\n\r\nworker_processes : Nginx 프로세스 실행 가능 수\r\n - auto일 경우도 있지만, 명시적으로 서버의 코어 수 만큼 할당하는 것이 보통 (더 높게도 가능)\r\n\r\npid : Nginx 마스터 프로세스 정보\r\n\r\n\r\n#### 2. events\r\n주로 네트워크의 동작 방법과 관련된 설정값을 가진다. \r\n\r\nworker_connections : 몇개의 접속을 동시에 처리할 것인가\r\n - worker_processes * worker_connections = **처리 할 수 있는 커넥션의 양**\r\n - Tip!!\r\n   - 여러 자료와 퍼포먼스 테스트를 하며 값을 조정해야 한다.\r\n\r\n#### 3. http\r\n> server, location의 루트 블록이라 할 수 있고, 여기서 설정된 값들은 하위 블록들이 상속한다.  \r\n> http 블록은 여러개를 사용할 수 있지만 관리상의 이유로 한번 사용하는 것이 좋다.\r\n\r\n - keepalive_timeout : 클라이언트에서 커넥션을 유지하는 시간을 의미\r\n - servers token : Nginx 버전 숨길 수 있는 기능 (주석을 제거해 보안 이슈를 방지하는 것이 좋다.)\r\n - server_names_hash_max_size, server_names_hash_bucket_size : 호스트의 도메인 이름에 대한 공간(너무 낮으면 에러 발생 가능)\r\n - **log관련 설정**은 각 **호스트 마다 배분**하는 것이 관리하기 편하므로 http block에선 off로 처리한다.\r\n\r\n\r\n#### etc\r\n - **include 옵션** : 별도의 파일에 설정을 기록해서 설정의 그룹핑, 재활용성을 높이는 방법\r\n - ex) 리버스 프록시를 각 도메인에 설정한다고 했을 때 헤더 처리 옵션등을 conf.d에 넣어두고 불러온다. (nginx.conf 설정 파일이 깔끔해짐)\r\n   - 리버스 프록시란? : \r\n\r\n#### 4. server / location\r\n/etc/nginx/sites-available/default에 server, location 블록이 작성되어 있다.\r\n\r\nserver 블록 : 하나의 웹사이트를 선언하는데 사용 (가상 호스팅 개념)\r\nlocation 블록 : server 블록 안에 등장하며 특정 URL을 처리한다.\r\n\r\n```\r\nserver {\r\n    listen       80;\r\n    server_name  localhost;\r\n \r\n    root   /usr/share/nginx/html;\r\n    location / {\r\n        index  index.html index.htm index.php;\r\n    }\r\n \r\n    location = /50x.html {\r\n        root   /usr/share/nginx/html;\r\n    }\r\n\r\n    location ~ \\.php$ {\r\n        fastcgi_pass   unix:/var/run/php5-fpm.sock;\r\n        fastcgi_index  index.php;\r\n        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;\r\n        include        fastcgi_params;\r\n    }\r\n}\r\n```\r\nlocation 블록을 상세히 살펴보면\r\n\r\n1. fastcgi_pass : \r\n2. fastcgi_param : \r\n\r\n**설정 파일을 변경하면 nginx에 반영해야 하는데, reload 명령을 이용한다**\r\n\r\n## 추가!!\r\n\r\n- 보통 가상 호스트 설정 파일의 경우 sites-available 디렉토리 아래 위치  \r\n- sites-enabled 디렉토리에 심볼릭 링크를 걸어주면서 nginx에서 사용하게 설정\r\n- 에러 같은 경우 중요한 오류 이외에는 로그로 남기지 않게 설정해서 로그로 인해 디스크 엑세스를 하지 않게 설정한다!\r\n\r\n**conf파일 구성은 상황마다 다르다.**\r\n\r\n### 로그 파일 위치\r\n> /var/log/nginx\r\n\r\n## Upstream Module\r\n> NGINX를 일종의 LoadBalancer(부하분산, 속도개선)로 이용할 수 있게 해주는 모듈\r\n\r\n- conf파일의 upstream블록을 통해 사용한다. \r\n- was를 의미하고, nginx는 downstream에 해당한다고 할 수 있다.\r\n\r\n**형식**\r\n```\r\nupstream 이름 {\r\n    [ip_hash;]\r\n    server host 주소:포트 [옵션];\r\n    .....\r\n}\r\n```\r\n\r\n**예제**\r\n```\r\nupstream backend {\r\n    ip_hash;\r\n    server 192.168.125.142:9000 weight=3;\r\n    server 192.168.125.143:9000;\r\n    server 192.168.125.144:9000 max_fails=5 fail_timeout=30s;\r\n    server unix:/var/run/php5-fpm.sock backup;\r\n}\r\n```\r\n\r\n**옵션**\r\n```\r\nip_hash : 같은 방문자로부터 도착한 요청은 항상 같은 업스트림 서버가 처리하게 설정\r\nweight=n : 업스트림 서버의 비중(2 -> 2배 더 자주 사용)\r\nmax_fails=n : n으로 지정한 횟수만큼 실패가 일어나면 서버가 죽은 것으로 간주한다.\r\nfail_timeout=n : max_fails가 지정된 상태에서 이 값이 설정만큼 서버가 응답하지 않으면 죽은 것으로 간주한다.\r\ndown : 해당 서버를 사용하지 않게 지정한다. ip_hash; 지시어가 설정된 상태에서만 유효하다.\r\nbackup : 모든 서버가 동작하지 않을 때 backup으로 표시된 서버가 사용되고 그 전까지는 사용되지 않는다.\r\n```\r\n\r\n다음 사진과 같이 사용한다.\r\n![](upstream.PNG)\r\n\r\n## 재작성(rewrite)\r\n> rewrite 모듈을 통해 URL 재작성\r\n\r\n예제\r\n```\r\nlocation ~ /tutorials/javascript.html {\r\n    rewrite ^ http://opentutorials.org/course/48;\r\n}\r\n```\r\n\r\n리다이렉션을 디버깅 하기 위해선 **error_log 지시자를 server나 location블록 아래에 위치!!**\r\n\r\n```\r\nserver {\r\n    server_name opentutorials.org\r\n    error_log /var/log/opentutorials.org.error debug;\r\n    location ~ /.php$ {\r\n        error_log /var/log/opentutorials.org.php.error debug;\r\n    }\r\n}\r\n```\r\n\r\n위와 같이 사용하면 error log는 debug수준에서 출력 -> 에러 출력 debug레벨 사용\r\n\r\nwww를 제거하는 예제\r\n```\r\nif ($host ~* ^www\\.(.*)){\r\n    set $host_without_www $1;\r\n    rewrite ^/(.*)$ $scheme://$host_without_www/$1 permanent;\r\n}\r\n```","excerpt":"Nginx CGI(Common Gateway Interface) 란? 웹서버와 외부 프로그램(C, PHP, Python 등) 사이에서 정보를 주고받는 방법과 규약 이 표준에 맞춰 만들어진 것이 CGI 스크립트이다.  관련 용어 Web Server :…","fields":{"slug":"/phpNginxCI_2/"},"frontmatter":{"date":"Feb 24, 2021","title":"Nginx 학습","tags":["Nginx"],"update":"Mar 01, 2021"}}},{"node":{"rawMarkdownBody":"\r\n# #!/bin/bash를 왜 쓸까\r\n\r\nbash파일은 주석을 #으로 단다.\r\n\r\nbash스크립트 파일 문제 풀면서 별 생각없이 #!/bin/bash 부분이 그냥 표시해주는 부분인 줄 알았는데\r\n\r\n\\#!/bin/bash를 꼭 달아줘야 한다고 한다.\r\n\r\n\"#!\"는 **Shebang**이라고 부르고, 실행 가능한 쉘 스크립트라는 것을 나타내는 특별한 표시자이다.  \r\n\r\n\"#!\" 뒤에 나오는 것은 경로명으로, 스크립트에 들어있는 명령어를 해석할 위치를 나타낸다.  \r\n**정확히 Full PATH로 작성해야한다.**  \r\n\r\n이 명령어 해석기가 주석은 무시하면서 스크립트의 첫번째 줄부터 명령어를 실행시킨다.\r\n\r\n\r\n## 쉘 스크립트의 구조\r\n\r\n\r\n```bash\r\n#!인터프리터(Interpreter)\r\n\r\n#\r\n# 주석(Comment)\r\n#\r\n\r\n함수명() {\r\n  명령\r\n  ...\r\n}\r\n\r\n명령1.. (Command)\r\n명령2..\r\n명령3..\r\n\r\n흐름제어 (Flow Control)\r\n\r\n함수 호출\r\n```","excerpt":"#!/bin/bash를 왜 쓸까 bash파일은 주석을 #으로 단다. bash스크립트 파일 문제 풀면서 별 생각없이 #!/bin/bash 부분이 그냥 표시해주는 부분인 줄 알았는데 #!/bin/bash를 꼭 달아줘야 한다고 한다. \"#!\"는 Sheba…","fields":{"slug":"/whyBash/"},"frontmatter":{"date":"Feb 23, 2021","title":"쉘 스크립트 첫 줄에 [#!/bin/bash]를 쓰는 이유","tags":["Linux"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\nbash 20문제 풀이\r\n\r\n## 풀이\r\n\r\n1. 현재 자기신의 pc(linux기준)의 cpu모델명, Os 종류 및 버전, kernel 버전을 출력하시오.\r\n\r\n```bash\r\ncat /proc/cpuinfo | egrep  'model name'\r\ncat /etc/issue\r\nuname -r\r\n```\r\n\r\n2. 매주 일요일, 새벽4시 30분과 낮12시 30분에, /tmp/* 를 삭제하는 crontab \r\n예) * * * * * 실행문\r\n\r\n```bash\r\ncat <(crontab -l) <(echo \"30 4,12 * * * rm /tmp/*\") | crontab\r\ncrontab -l\r\n```\r\n\r\n3. 정수인자 2개를 받아 인자 개수 검증 후 4칙연산별 함수를 구현하여 결과값을 모두 \r\n\r\n```bash\r\nfunction add(){\r\n\tlet value=$1+$2\r\n\techo \"$1 + $2 : ${value}\"\r\n}\r\n\r\nfunction minus(){\r\n\tlet value=$1-$2\r\n\techo \"$1 - $2 : ${value}\"\r\n}\r\n\r\nfunction multiply(){\r\n\tlet value=$1*$2\r\n\techo \"$1 * $2 : ${value}\"\r\n}\r\n\r\nfunction divide(){\r\n\tlet value=$1/$2\r\n\techo \"$1 / $2 : ${value}\"\r\n}\r\n\r\nadd $1 $2\r\nminus $1 $2\r\nmultiply $1 $2\r\ndivide $1 $2\r\n```\r\n\r\n4. 2초마다 현재시간을 출력하는 스크립트를 작성하세요.\r\n\r\n(3번 실행되도록 작성)\r\n\r\n```bash\r\nnumber=0\r\n\r\nwhile [ $number -le 2 ]\r\ndo\r\n\tdate\r\n\t((number++))\r\n\tsleep 2\r\ndone\r\n```\r\n\r\n5. 첨부파일 lastlog를 이용하여 한번도 로그인한 적 없는 사용자를 삭제하는 명령어를 문자열로 아래와 같이 출력.\r\n\r\n```bash\r\nwhile read A B C D E F G H I\r\ndo\r\n\tif [[ \"$B\" =~ \"**Never\" ]]; then\r\n\t\techo \"userdel -r \" $A\r\n\tfi\r\ndone < lastlog\r\n```\r\n\r\n6. 첨부파일 lastlog를 이용하여 로그인한 적 없는 사용자를 제외하고 년 월 일 시간 사용자계정 순서로 아래와 같이 출력 i\r\n\r\n```bash\r\nwhile read A B C D E F G H I\r\ndo\r\n\tif [[ \"$B\" =~ \"pts\" ]]; then\r\n\t\techo ${I:0:-1} $E $F $G $A\r\n\tfi\r\ndone < lastlog\r\n```\r\n\r\n7. 첨부파일 lastlog를 이용하여 ntp와 firenwo user 라인사이에 ‘end of system user’라인 삽입.\r\n\r\n```bash\r\nsed -i'' -r -e \"/ntp/a\\end of system user\" lastlog\r\ncat lastlog\r\n```\r\n\r\n8. 첨부파일 checkpassword를 이용하여 09:59:57부터 10:21:45까지의 라인만 출력\r\n\r\n```bash\r\ncat checkpassword | awk '/[9]:59:5[7-9]/'\r\ncat checkpassword | awk '/[10]:[0-1][0-9]:[0-5][0-9]/'\r\ncat checkpassword | awk '/[10]:2[0-1]:[0-3][0-9]/'\r\ncat checkpassword | awk '/[10]:21:4[0-5]/'\r\n```\r\n\r\n9.  첨부파일 checkpassword를 이용하여 121.156.118.254를 pop3.mailplug.co.kr로, 14.36.253.67는 office.ip.wiro.kr로 치환하여 출력\r\n\r\n```bash\r\ncat checkpassword | sed 's/121.156.118.254/pop3.mailplug.co.kr/g' | sed 's/14.36.253.67/office.ip.wiro.kr/g' checkpassword\r\n```\r\n\r\n10. 첨부파일 maillog를 이용하여 root@ma10.mailplug.co.kr에서 수신된 메일의 수를 출력\r\n\r\n```bash\r\nindex=0\r\n\r\nwhile read line\r\ndo\r\n\tif [[ \"$line\" =~ \"from <root@ma10.mailplug.co.kr>\" ]]; then\r\n\t\tlet value=$index+1\r\n\t\tindex=$value\r\n\tfi\r\ndone < maillog\r\n\r\necho $index\r\n```\r\n\r\n11. 첨부파일 maillog를 이용하여 시간별 총 용량만 아래와 같이 출력(bytes)\r\n\r\n```bash\r\nwhile read time byte\r\ndo\r\n\techo \"$time $byte\"\r\ndone < maillog | grep bytes | awk '{print $3\":\"$11}' | awk -F \":\" '{arr[$1]+=$4} END { for (i in arr) {print i \"\\t\" arr[i]}}' | sort | awk '{ if($1~\"(0[0-9])\") {sub(/0/,\"\")} print $1 \"시\\t\" $2}'\r\n```\r\n\r\n12. 첨부파일 conf를 이용하여 ; 로된 주석라인과 공백라인을 제외한 라인 출력\r\n\r\n```bash\r\ncat conf | egrep -v ^[[:space:]]*$ | grep -v \";\"\r\n```\r\n\r\n13. ps 명령어를 이용하여 pid값이 낮은순에서 높은순으로 정렬하여 출력\r\n\r\n```bash\r\nps -ef --sort=+pid \r\n```\r\n\r\n14. 첨부파일 nginx를 이용하여 접근을 한 국가별 카운트와 국가명 출력.\r\n\r\n```bash\r\nwhile read A B C D E F line\r\ndo\r\n\tgeoiplookup $F >> ip\r\ndone < nginx\r\n\r\ngrep '' ip | awk '{print $1,$2,$3,$4,$5,$6,$7}' | sort | uniq -c > 14result\r\ncat 14result\r\nrm ip\r\n```\r\n\r\n15. 첨부파일 nginx를 이용하여 3번 이상 접근한 국가별 카운트와 국가명 출력\r\n\r\n```bash\r\ncat 14result | awk '{if ($1>3) {print $0}}'\r\n```\r\n\r\n16. 반복문을 이용하여 1M의 용량을 가진 파일부터 10M까지의 총 10개 파일 생성(1M씩 증가)\r\n\r\n```bash\r\nfor time in {01..10}\r\ndo\r\n\ttruncate -s ${time}M ./${time}file\r\ndone\r\n\r\nfind ./ -name \"*file\"\r\n```\r\n\r\n17. 16번에서 생성한 파일 중 5M이상의 파일의 생성시간을 2017년 12월 31일로 변경\r\n\r\n```bash\r\nfind ./ -type f -size +5M -exec touch -t \"201712310000\" {} \\;\r\n```\r\n\r\n18. 17번에서 만든 파일 중 2017년 12월 31일 이후에 만들어진 파일을 찾아 해당파일명.new로 변경\r\n\r\n```bash\r\nfind -type f -newermt '2017-12-31' | grep file | xargs rename 's/file/file.new/'\r\n```\r\n\r\n19. 아래 그림을 test.c 파일로 작성 후 result.exe란 파일로 컴파일하여 실행하고 출력값을 test.txt로 저장\r\n\r\n```bash\r\ngcc -o result test.c\r\n./result > test.txt\r\necho \"test.txt 파일 내용\"\r\ncat test.txt\r\n```\r\n\r\n20. 121.156.118.15서버의 오픈 된 포트를 확인 후 해당 포트로 통신이 가능한지 모니터링하는 스크립트를 작성\r\n\r\n```bash\r\nwhile :\r\ndo\r\n\tnmap -sT 121.156.118.15\r\n\tsleep 5\r\ndone\r\n```\r\n\r\n모든 bash 파일 실행\r\n\r\nresult.bash\r\n```bash\r\nfor i in {1..19}\r\ndo\r\n\tbash $i.bash 5 5\r\n\techo \" \"\r\ndone\r\nrm 01file.new 02file.new 03file.new 04file.new 05file.new 06file 07file 08file 09file 10file\r\n\r\nbash 20.bash\r\n```\r\n\r\n## 배운 부분\r\n\r\n2번\r\n - 매주 일요일 부분을 빠트림\r\n\r\n6번\r\n - Window와 Linux는 개행 방식이 다르다.\r\n\r\n|window|Unix(Linux 및 Mac)|\r\n|------|-------|\r\n| \\r\\n | \\n |\r\n\r\n**vscode같은 곳에서 연결해서 사용한다면 관련된 설정 해줘야 한다.**\r\n\r\n17번\r\n - 문제를 보면 5M이상임. -size +4M으로 작성해야 한다.\r\n\r\n주의할점\r\n - dd 명령어 사용 시 input / output에 주의해라!\r\n - chown 명령어 사용 시 -R 옵션 줄 때 ./* 같이 경로를 정확히 사용 (/ 이렇게 주면 큰일난다.)\r\n\r\n중요한 명령어와 개념\r\n - find, ls, du, awk, sed, free, chown, chmod, 리눅스 권한부분은 상당히 중요!","excerpt":"bash 20문제 풀이 풀이 현재 자기신의 pc(linux기준)의 cpu모델명, Os 종류 및 버전, kernel 버전을 출력하시오. 매주 일요일, 새벽4시 30분과 낮12시 30분에, /tmp/* 를 삭제하는 crontab \n예) * * * * *…","fields":{"slug":"/bashMission/"},"frontmatter":{"date":"Feb 23, 2021","title":"bash 문제 풀이","tags":["Linux"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n리눅스 자주쓰는 명령어와 중요 개념 정리한다.\r\n\r\n# 1. find\r\n> find [path] [Option] [expression] : 파일이나 디렉터리를 찾고 싶을 때 사용하는 명령어\r\n\r\n**Tip!!**\r\n- 옵션을 통해 다양한 경우의 상황으로 찾기 가능\r\n- 시간 옵션 뒤에 부여해야 하는 숫자 tip!!\r\n![linux time 옵션](./findTimeOption.PNG)\r\n\r\n## 옵션\r\n```\r\n -name : 파일이나 디렉토리 이름\r\n -iname : 대소문자 구분 없이 이름으로 검색\r\n -user : 사용자 이름\r\n -group : 그룹 이름\r\n -uid : uid로 검색\r\n -gid : gid로 검색\r\n -perm : 권한으로 검색\r\n -type : 파일 유형으로 검색\r\n    (d : 디렉토리, f : 파일, l : 링크, s : 소켓)\r\n -atime n : 파일에 접근한 시간(파일을 Open할 때 마다 갱신된다)\r\n -ctime n : inode의 값(파일 속성, 권한, 크기 등)으로 검색\r\n -mtime n : 파일이 수정되었을 때 기준으로 검색\r\n   * time부분을 min으로 사용하면 분으로 검색\r\n   * 추가로 Suffix를 붙여 정확한 시간 지정 가능\r\n -empty : 빈 파일 찾기\r\n -exec : 명령 내릴 수 있는 옵션 / 결과 값 {}, \\;로 끝내야 한다.\r\n -size n : n블록 길이의 파일\r\n -inum n : inode\r\n -maxdepth n : 파일 계층 depth의 최대값 설정\r\n -mindepth n : 파일 계층 depth의 최소값 설정\r\n -prune : 값을 찾으면 하위 디렉토리에 들어가서 찾지 않음\r\n -newer : 뒤에 적힌 파일보다 최근에 변경된 파일 찾음\r\n```\r\n\r\n## 사용 예제\r\n```bash\r\n# 수정된지 100일이 지난 파일 목록 출력\r\n$ find -mtime +100\r\n\r\n# php 디렉토리 파일 중, 오늘 생성한 디렉토리를 삭제하시오\r\n$ find ~/php/* -ctime 0 -type d -exec rm -r {} \\;\r\n\r\n# 연결되지 않은 심볼릭 링크 찾는 방법\r\n$ find -L . -type l\r\n\r\n# 현재 디렉토리에서 test로 시작하는 디렉토리만 찾아 삭제\r\n$ rm -r `find -name 'test*' -type d`\r\n\r\n```\r\n\r\n\r\n**Tip!!**\r\n - 명령어에서 `(backtick)사용 : 스크립트 내에서 명령어를 실행할 경우 이용\r\n - 2>/dev/null : 명령어 뒤에 추가로 달아주면 권한 없는건 화면에 출력되지 않는다.  \r\n\r\n\r\n\r\n# 2. grep\r\n> grep [option] [pattern] [file_name] : 특정 문자열을 파일에서 찾아주는 명령어\r\n\r\n- pattren에는 정규 표현식 메타 문자가 들어간다.\r\n\r\n**Tip!!**\r\n- egrep\r\n- egrep은 grep의 확장판\r\n- grep이 하나의 문자열을 찾는 것 과는 달리, 여러 개의 문자열을 동시에 찾기 가능  \r\n- grep에서 활용할 수 있는 메타문자 이외에 추가 정규 표현식 메타문자 사용 가능\r\n\r\n+: +앞의 정규표현식이 1회 이상 나타남  \r\n?: ?앞의 정규표현식이 0회 또는 1회 나타남  \r\n|: 문자열간의 OR연산자  \r\n(): 정규표현식을 둘러쌈  \r\n\r\n## 옵션\r\n```\r\n -b : 검색 결과의 각 행 앞에 블록번호 표시\r\n -c : 찾아낸 행의 총 개수 출력\r\n -i : 대소문자 구분 x\r\n -l : 대소문자 구분 o\r\n -n : 파일 내에서 행 번호를 함께 출력\r\n -s : 에러 메세지 외에 표시 x\r\n -G : 기본 정규식으로 검색\r\n```\r\n\r\n## 사용 예제\r\n\r\n```bash\r\n# 'm'으로 시작하는 모든 파일에서 'hamster'를 포함하는 모든 행을 찾으시오\r\n$ grep -n hamster m*\r\n\r\n# grep을 사용하여 마침표로 시작되는 줄을 찾으시오\r\n$ grep ^\\. {찾을 파일 / 디렉토리 명}\r\n\r\n# NW나 EA가 포함된 행을 출력한다\r\n$ egrep 'NW|EA' {file 명}\r\n\r\n# 숫자 3이 한 번 이상 등장하는 행 출력\r\n$ egrep '3+' {file 명}\r\n\r\n```\r\n\r\n\r\n# 3. awk\r\n> awk [옵션] \r\n문서에서 패턴을 검사해 원하는 값 얻는다.\r\n\r\n```\r\n$ awk {-f 파일명} {-F 필드 구분자} {\"패턴\"} {처리할 파일명}\r\n```\r\n- pattern 생략 시 **모든 레코드 적용**\r\n- action 생략 시 **print 적용**\r\n- pattern과 action에 작성되는 awk program 코드에는 표현식, 변수, 함수 사용 가능\r\n\r\n## 옵션\r\n```\r\n-F : 필드 구분 문자 지정\r\n-f : awk program 파일 경로 지정\r\n-v : awk program에서 사용될 특정 variable값 지정\r\n```\r\n\r\n\r\n## 사용 예제\r\n```bash\r\n# pattern 생략\r\n$ awk '{print}' ./file.txt\r\n\r\n# action 생략\r\n$ awk '/p/' ./file.txt\r\n\r\n# 레코드의 길이가 10 이상인 경우, 세 번째($3), 네 번째($4), 다섯 번째($5) 필드를 출력\r\n$ awk 'length($0) > 10 { print $3, $4, $5} ' {파일 이름}\r\n\r\n\r\n```\r\n\r\n\r\n# 4. Redirection\r\n> 명령의 결과를 모니터로 출력하지 않고, 파일로 저장할 수 있다. (리다이렉션을 사용해 출력, 입력 방향 지정 가능)\r\n\r\n표준 입출력(Standard I/O)  \r\n\r\n|구분|파일 디스크럽터|\r\n|----|----|\r\n| 표준 입력 | 0 |\r\n| 표준 출력 | 1 |\r\n| 표준 에러 | 2 |\r\n\r\n\r\n|기호|기능|\r\n|----|----|\r\n|>/>>| 출력 방향 재지정 |\r\n|</<<| 입력 방향 재지정 |\r\n|>| 덮어 쓴다.|\r\n|>> | 추가된다. |\r\n\r\n# 5. vi\r\n\r\n- 텍스트 편집기\r\n- 3가지 모드가 있다.\r\n  - 입력(내용입력), 명령(편집기능), 콜론(열기, 저장, 추가기능 수행)\r\n\r\n\r\n## 문자열 치환\r\n>: [범위] / [매칭 문자열] / [치환문자열] / [행범위] \r\n\r\n**Tip!!**\r\n- gg : 최상단으로 커서 옮김\r\n- 0 : 현재 줄 맨 앞\r\n- $ : 현재 줄 맨 뒤\r\n- dd : 라인 삭제\r\n- u : 복구\r\n- p : 붙여 넣기\r\n- yy : 라인 복사\r\n- :wq : 저장 후 종료\r\n- .vimrc 파일에 환경설정 가능!\r\n\r\n\r\n# 6. sed(stream deitor) \r\n> 필터링과 텍스트를 변환하는 스트림 편집기\r\n\r\n## 주요기능\r\n```bash\r\n# 1. 치환\r\n# addrass를 address로 바꾼다.\r\n$ sed 's/addrass/address/' {파일이름}\r\n\r\n# tab문자를 enter로 변환\r\n$ sed 's/\\t/\\ /' {파일이름}\r\n\r\n# 2. 삭제\r\n# 처음 1줄, 2줄을 지운다.\r\n\r\n# 공백라인을 삭제하는 명령\r\n$ sed '/^$/d {파일 이름}\r\n\r\n```\r\n\r\n[jhnyang님 블로그](https://jhnyang.tistory.com/287)\r\n\r\n# 7. ls\r\n> 현재 폴더의 하위 디렉토리의 리스트 출력\r\n## 옵션\r\n\r\n\r\n# 8.  사용자 권한 (chmod, chown)\r\n\r\n리눅스는 사용자 및 그룹에 기반하여 액세스를 허가하거나 금지한다.\r\n\r\n## chown\r\n> 파일의 소유권 바꾸기 위해 사용\r\n\r\n```bash\r\nchown [OPTION]... [OWNER][:[GROUP]] FILE...\r\n```\r\n\r\n## chmod\r\n> 파일이나 디렉토리의 모드를 변경\r\n\r\n```bash\r\n$ chmod {옵션} {권한} {파일}\r\n```\r\n\r\n# 9.  tty\r\n\r\n- 로그인 한 모든 세션은 각각 고유의 tty를 가지고 있다.\r\n- 입력과 출력을 처리한다.\r\n  \r\n```bash\r\n$ tty\r\n\r\n/dev/pts/0\r\n```\r\n\r\n# 10.  alias  \r\n> 사용자가 원하는 명령어를 추가하기 위한 명령어\r\n\r\n사용 예제\r\n```\r\n$ alias la='ls -a'\r\n$ alias lf='ls -F'\r\n$ alias lr='ls -R'\r\n$ alias ri='rm -i'\r\n$ alias mi='mv -i'\r\n```\r\n\r\n- alias를 입력하면 입력 된 alias를 확인할 수 있다.\r\n- ~/.bashrc에 정의하면 쉘이 시작할 때 자동으로 정의된다.\r\n\r\n\r\n# 11. history\r\n> 커맨드 이력 관리 명령어\r\n\r\n- ~/.bash_history 에 저장\r\n\r\n히스토리 관련 환경변수\r\n```\r\nHISTFILE : command 저장 파일\r\nHISTFILESIZE : 히스토리 파일 최대 크기\r\nHISTSIZE : 히스토리에 저장 가능한 최대 명령어 개수\r\n```\r\n\r\n**Tip!!**\r\n\r\n- history -w {파일 이름}: 별도의 파일로 저장\r\n- !! : 바로 직전 커맨드 실행\r\n- !n : history n 번째에 저장된 명령어 실행\r\n- !{string} : string으로 시작하는 가장 최근 실행한 커맨드 찾아 실행\r\n- :p : :p를 붙여서 실행 시 커맨드만 출력\r\n\r\n\r\n# 12. jobs / 포그라운드 백그라운드\r\n\r\n- jobs : 현재 쉘에서 작업 중지된 상태나 백그라운드로 진행되는 작업 표시\r\n- bg : 백그라운드 프로세스 확인\r\n- & : 프로세스를 백그라운드로 실행\r\n\r\n\r\n# 13. ps\r\n> 현재 실행중인 프로세스 목록과 상태를 보여준다.\r\n\r\n# 14. 심볼릭 링크, 하드 링크\r\n> 하나의 파일에 두개의 이름 사용하게 링크를 연결\r\n\r\n사용하는 경우\r\n - 매우 긴 파일명이 있을 때\r\n - 경로를 입력하지 않고 파일명만 입력해 사용할 때\r\n\r\n+ 서버(nginx)가 바라보는 경로설정 같은 경우에도 사용한다.\r\n\r\n## 차이점\r\n\r\n|하드 링크|심볼릭 링크|\r\n|----|----|\r\n| 파일에만 링크 가능 | 파일 또는 디렉토리에 링크 할 수 있음 |\r\n| 존재하지 않는 파일 링크 불가능 | 존재하지 않는 파일에 대해 링크 가능 |\r\n| 같은 파일 시스템에서만 가능 | 다른 파일 시스템에서 가능 |\r\n\r\n\r\n# 15. du / df\r\n\r\n## du\r\n> 디렉토리 사용량 확인\r\n\r\n### 옵션\r\n```\r\n-a : 모든 파일들의 기본정보를 보여준다.\r\n-b : 표시단위를 기본 KB 대신 Byte로 한다.\r\n-k : 표시단위를 KB 단위로 한다.\r\n-h : 파일들의 용량단위가 보기좋게 정리되어 보여준다.\r\n-c : 모든 파일들의 디스크 사용정보를 보여주고 나서 합계를 보여준다.\r\n-s : 총 사용량만 표시\r\n-x : 체크하는 경로안에 다른 시스템이 있으면 생략\r\n```\r\n\r\n## df\r\n> 디스크의 사용가능한 용량 확인\r\n\r\n# 16. dd\r\n> 파일을 변환하고 복사하는 명령어\r\n\r\n```\r\n$ dd if={입력} of={출력} bs={바이트} count={반복}\r\n\r\nibs = bytes     #한번에 bytes 바이트씩 읽는다.\r\nobs = bytes     #한번에 bytes 바이트씩 쓴다.\r\nskip = n        #n*ibs 바이트만큼 무시하고 읽는다.\r\nseek = n        #n*obs 바이트만큼 무시하고 쓴다.\r\n```\r\n\r\n# 17. cat\r\n> cat {옵션} 파일명\r\n\r\n파일 내용 출력\r\n\r\n# 18. cron\r\n> unix 운영체제에서 어떤 작업을 특정 시간에 실행시키기 위한 데몬\r\n\r\ncron 작업을 설정하는 파일을 crontab이라고 부른다.\r\n\r\n형식\r\n```\r\n* * * * * {명령어}\r\n\r\n분/시/일/월/요일 \r\n``` \r\n\r\n추가 기호\r\n```\r\n , : 복수개의 시간 지정\r\n * : 모든 시간 지정\r\n - : 시간의 범위 지정\r\n / : 시간 간격을 지정\r\n```\r\n\r\n크론 조회\r\n```bash\r\n$ crontab -l\r\n```\r\n\r\n크론 접근 권한 설정은 관련된 파일로 명시해준다.\r\n- /etc/cron.allow\r\n- /etc/cron.deny\r\n- /etc/con.d/cron.deny\r\n\r\n\r\n# 19. cut\r\n> cut {option} {file}\r\n\r\n파일에서 필드 추출, 필드는 구분자로 구분 가능\r\n\r\n옵션\r\n```\r\n -c : 잘라낼 곳의 위치 지정. (콤마나 하이픈으로 범위 설정 가능)\r\n -f : 잘라낼 필드 설정\r\n -d : 필드 구분 문자 지정\r\n```\r\n\r\n# 20. tar / gzip\r\n\r\ntar : gzip 명령이 포함된 압축 툴\r\ngzip : 파일 압축 명령어\r\n\r\n# 21. wc\r\n> wc {옵션} {파일}\r\n각각의 파일에 대한 줄(line), 단어(word), 문자(char), 바이트(byte) 수를 알려준다.\r\n\r\n## 옵션\r\n```\r\n-c : byte 수를 알려준다.\r\n-m : 문자 수를 알려준다.\r\n-l : 줄 수를 알려준다.\r\n-L : 가장 긴 줄의 길이를 알려준다.\r\n```\r\n\r\n# 22. Tree\r\n\r\ntree 명령어는 기본적으로 존재하는 명령어가 아니므로 apt이나 yum을 이용해 설치한다.\r\n\r\n```bash\r\n$ tree --help\r\n```\r\n명령어로 트리의 옵션을 볼 수 있다.\r\n![tree 옵션](./treeOption.PNG)\r\n\r\ntree 명령어의 실행 화면이다.\r\n\r\n![tree 실행 화면](./treeResult.PNG)\r\n\r\n# 23. Rsync\r\n\r\n","excerpt":"리눅스 자주쓰는 명령어와 중요 개념 정리한다. 1. find find path Option expression : 파일이나 디렉터리를 찾고 싶을 때 사용하는 명령어 Tip!! 옵션을 통해 다양한 경우의 상황으로 찾기 가능 시간 옵션 뒤에 부여해야 하…","fields":{"slug":"/linuxStudy/"},"frontmatter":{"date":"Feb 22, 2021","title":"Linux Study","tags":["Linux"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n1.소유자가 george이고 그룹이 others일때 data파일의 소유자와 그룹을 동시에 변경하시오.\r\n\r\n```bash\r\n$ chown georage:others data\r\n```\r\n\r\n2.현재 로그인한 사용자의 목록에서 2016­01­07에 접속한 사용자를 출력하시오.\r\n\r\n```bash\r\n$ who | grep '2016-01-07'\r\n```\r\n\r\n3.접근권한이 755인 data 디렉토리를 생성하시오(명령어 1개 이용).\r\n\r\n```bash\r\n$ mkdir -m 755 data\r\n```\r\n\r\n4.현재 디렉토리에서 링크파일만 찾는 lnfind란 alias를 생성하시오.\r\n\r\n```bash\r\n$ alias lnfind='find ./ -type l'\r\n```\r\n\r\n5.현재 디렉토리에서 24시간 내에 수정된 파일을 찾으시오.\r\n\r\n```bash\r\n$ find ./ -mtime -1\r\n```\r\n\r\n6.현재 디렉토리에서 test로 시작하는 디렉토리만 찾아 삭제하시오.\r\n\r\n```bash\r\n$ rm -r `find -name 'test*' -type d`\r\n```\r\n\r\n7.ssh를 이용하여 kumquat란 서버에 /test2란 디렉토리를 생성하시오.\r\n\r\n```bash\r\n$ ssh root@kumquat mkdir /test2\r\n```\r\n\r\n8.test1과 test2의 내용을 비교하는 명령어를 작성하시오.\r\n\r\n```bash\r\n$ diff test1 test2\r\n```\r\n\r\n9.test1 test2 test3을 리다이렉트를 이용하여 test4의 파일로 합치시오.\r\n\r\n```bash\r\n$ cat test1 test2 test3 > test4\r\n```\r\n\r\n10.test5 파일의 마지막 10개의 행을 출력하시오.\r\n\r\n```bash\r\n$ tail test5\r\n```\r\n\r\n11./etc/group과 /etc/passwd에서 root가 있는 라인의 개수를 출력하시오.\r\n\r\n```bash\r\n$ grep -c 'root' /etc/group/* /etc/etc/password/*\r\n```\r\n\r\n12.test6파일에서 시작문자가 a, 마지막 문자가 z로 끝나는 문장을 출력하시오.\r\n\r\n```bash\r\n$ grep -E '^a.*z$' test 6\r\n```\r\n\r\n13.test6파일에서 mail이 나오는 행과 plug가 나오는 행 사이의 모든 행을 출력하시오.\r\n\r\n```bash\r\n$ sed -e '/mail/, /plug/' test6\r\n```\r\n\r\n14.test7파일을 gzip으로 압축하시오.\r\n\r\n```bash\r\n$ gzip test7\r\n```\r\n\r\n15.test8파일의 가장 긴 줄의 길이를 출력하시오.\r\n\r\n```bash\r\n$ wc -L test8\r\n```\r\n\r\n16.vi ex에서 10행부터 파일의 끝까지를 test9로 저장하시오.\r\n\r\n```bash\r\n:10,$ w test9\r\n```\r\n\r\n17.vi ex에서 help 또는 Help라는 단어를 모두 HELP로 변경하시오.\r\n\r\n```bash\r\n:%s/[Hh]elp/HELP/g\r\n```\r\n\r\n18.dd를 사용하여 블록사이즈가 2바이트이고 10블록으로 null(/dev/zero)문자로 채워진 test10파일을 생성하시오.\r\n\r\n```bash\r\n$ dd if=/dev/zero of=test10 bs=2 count=10\r\n```\r\n\r\n19.test11파일의 3번째 필드를 기준으로 정렬하시오.\r\n\r\n```bash\r\n$ sort -k 3 test11\r\n```\r\n\r\n20.test12파일을 역순으로 정렬하고 중복되는 라인을 제거하고 출력하시오.\r\n\r\n```bash\r\n$ sort -ur test12\r\n```\r\n\r\n21.월요일마다 새벽 4시 30분에 /bin/date를 실행하는 cron문을 작성하시오.\r\n\r\n```bash\r\n$ 30 4 * * 1 /bin/date\r\n```\r\n\r\n22.최근에 사용한 명령 20개를 출력하시오.\r\n\r\n```bash\r\n$ history 20\r\n```\r\n\r\n23.cut명령어로 test14파일의 \"_\"를 구분자로 지정하여 두번째 필드를 출력하시오.\r\n\r\n```bash\r\n$ cut -d\"_\" -f2\r\n```\r\n\r\n24.touch명령어를 이용하여 test15파일을 2016년 1월 1일로 변경하시오.\r\n\r\n```bash\r\n$ touch -t 201601010000 test15\r\n```\r\n\r\n25.nginx프로세스에 대한 정보를 출력하시오.\r\n\r\n```bash\r\n$ ps -ef | grep nginx\r\n```\r\n\r\n26.2342의 pid를 가진 프로세스를 종료하시오.\r\n\r\n```bash\r\n$ kill -9 2342\r\n```\r\n\r\n27.ls를 백그라운드로 동작시키시오.\r\n\r\n```bash\r\n$ ls &\r\n```\r\n\r\n28.백그라운듸 작업목록을 출력하시오.\r\n\r\n```bash\r\n$ jobs\r\n```\r\n\r\n29.test16의 파일을 test.tar로 압축하시오.\r\n\r\n```bash\r\n$ tar -cvf test.tar test16\r\n```\r\n\r\n30.일정한 크기를 가진 여러 개의 작은 파일로 분할하는 명령어를 이용하여 test17파일을 20행씩 분할하시오.\r\n\r\n```bash\r\n$ split -l 20 test17\r\n```\r\n\r\n31.memory의 상세정보를 볼수있는 파일의 위치를 작성하시오.\r\n\r\n```bash\r\n$ which free\r\n\r\n=> /usr/bin/free\r\n```\r\n\r\n32.명령어의 위치를 찾을 수 있는 명령어를 작성하시오.\r\n\r\n```bash\r\n$ which\r\n$ whereis\r\n```\r\n\r\n33.60초동안 대기하는 명령어를 작성하시오.\r\n\r\n```bash\r\n$ sleep 60\r\n```\r\n\r\n34./dev/sda5를 /mnt에 마운트하는 명령어를 작성하시오.\r\n\r\n```bash\r\n$ mount /dev/sda5 /mnt\r\n```\r\n\r\n35.작업 중인 터미널창이 종료 되더라도 실행 중인 프로세스를 백그라운드 프로세스로 계속 작업할 수 있도록 하는 명령어를 작성하시오.\r\n\r\n```bash\r\n$ nohup {실행}&\r\n```\r\n\r\n\r\n36.apt­get 명령이 패키지 관련 정보를 확인하기 위해 참조하는 파일의 위치를 작성하시오.\r\n\r\n```bash\r\n$ /etc/apt/sources.list\r\n```\r\n\r\n37.yum을 이용하여 nginx 패키지를 제거하는 명령어를 작성하시오.\r\n\r\n```bash\r\n$ yum remove nginx\r\n```\r\n\r\n38.커널에 로드되어 있는 모듈을 확인하는 명령어를 작성하시오.\r\n\r\n```bash\r\n$ lsmod\r\n```\r\n\r\n39.현재 파일시스템들의 사용량을 MB단위로 출력하시오.\r\n\r\n```bash\r\n$ df -m\r\n```\r\n\r\n40./home/test18읠 디렉토리의 사용량을 KB단위로 출력하시오.\r\n\r\n```bash\r\n$ du -k ./home/test18\r\n```\r\n\r\n41.awk를 이용하여 test19파일의 필드 개수를 출력하시오.\r\n\r\n```bash\r\n$ awk '{print NF}' test19\r\n```\r\n\r\n42.awk를 이용하여 test20파일의 \"_\"를 구분자로 하는 첫번째와 세번째 필드를 출력하시오.\r\n\r\n```bash\r\n$ awk -F_ '{print $1, $3}' test20\r\n```\r\n\r\n43.cat nofile의 표준에러를 표준출력으로 리다이렉트하시오.\r\n\r\n```bash\r\n$ awk -F_ '{print $1, $3}' test19\r\n```\r\n\r\n44.basename /home/mkel/bin/test.sh 의 결과값을 작성하시오.\r\n\r\n```bash\r\n$ test.sh\r\n```\r\n\r\n45.test21의 계정의 로그인 쉘을 sh로 변경하시오.\r\n\r\n```bash\r\n$ vi /etc/passwd\r\n\r\ntest21의 7번째 필드 값을 sh로 변경\r\n```\r\n\r\n46.시스템을 부팅 시 자동으로 마운트되게 하기 위해 설정해야 하는 파일의 위치를 작성하시오.\r\n\r\n```bash\r\n/etc/fstab\r\n```\r\n\r\n47.호스트끼리 메일 메시지를 주고받기 위한 간단하고 확장성이 있는 프롤토콜은 무엇인가?\r\n\r\n```bash\r\n$ SMTP(Simple Mail Transfer Protocol) 프로토콜\r\n```\r\n\r\n48.mailplug.co.kr의 DNS 질의를 할 수 있는 명령어를 작성하시오.\r\n\r\n```bash\r\n$ nslookup mailplug.co.kr\r\n```\r\n\r\n49.listen되고 있는 포트의 네트워크 정보상태를 출력하시오.\r\n\r\n```bash\r\n$ netstat -tnlp\r\n```\r\n\r\n50.bash에서 2MB보다 큰 파일을 만들지 못하게 하는 명령어를 작성하시오.\r\n\r\n```bash\r\n$ ulimit -f 2000\r\n```\r\n\r\n","excerpt":"1.소유자가 george이고 그룹이 others일때 data파일의 소유자와 그룹을 동시에 변경하시오. 2.현재 로그인한 사용자의 목록에서 2016­01­07에 접속한 사용자를 출력하시오. 3.접근권한이 755인 data 디렉토리를 생성하시오(명령어 …","fields":{"slug":"/linuxProblem2/"},"frontmatter":{"date":"Feb 21, 2021","title":"Linux 문제 풀이2","tags":["Linux"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n1. 수정된지 100일이 지난 파일 목록을 출력하시오. (명령어 : find)\r\n\r\n```bash\r\n$ find -mtime +100\r\n```\r\n\r\n2. (a)에서 (b)의 결과를 얻으시오 (명령어: ll)\r\n![](2번.PNG)\r\n\r\n```bash\r\n$ ll -rt\r\n```\r\n\r\n3. 명령어가 저장되는 history 파일의 경로는 어디인가\r\n\r\n```bash\r\n$ ~/.bash_history\r\n```\r\n\r\n4. 저장된 히스토리를 파일명 ‘myhistory.log’ 으로 저장하시오\r\n\r\n```bash\r\n$ history > myhistory.log\r\n```\r\n\r\n5. 아래 디렉토리의 소유자/그룹을 하위 디렉토리, 파일까지 전부 nobody 로 변경하시오. (명령어:chown)\r\n![](5번.PNG)\r\n\r\n```bash\r\n$ chown -R nobody:nobody ./*\r\n```\r\n\r\n6. temp 디렉토리의 파일 중, 하루가 지난 파일을 삭제하시오 (명령어: find)\r\n\r\n```bash\r\n$ find /temp -ctime +0 -type f -exec rm -f {} \\;\r\n```\r\n\r\n7. screen 명령어를 사용하여, 서버와의 연결이 비정상종료되더라도, session은 유지한 채 작업을 할 수 있다. 이\r\n때 단축키를 사용하여 screen에서 빠져 나오시오.\r\n\r\n```bash\r\nCTRL + a + d\r\n```\r\n\r\n8. 자신이 사용하고 있는 tty를 출력하시오.\r\n\r\n```bash\r\ntty\r\n```\r\n\r\n9. 아래 그림과 같이 단계적인 디렉토리를 한번에 생성하시오.\r\n![](9번.PNG)\r\n\r\n```bash\r\nmkdir -p 1/2/3/4\r\n```\r\n\r\n10. grep 명령어의 위치를 출력하시오.\r\n\r\n```bash\r\n$ which grep\r\n\r\n$ whereis grep\r\n```\r\n\r\n11. 상위디렉토리로 이동하는 ‘cd..’ 를 ‘pd’로 정의하시오. (alias)\r\n\r\n```bash\r\nalias pd='cd..'\r\n``` \r\n\r\n12. 이전에 친 ‘vi mytest’ 명령어를 다시 출력하는 방법은 무엇인가.\r\n\r\n```bash\r\n$ !!\r\n\r\n$ !{history에 명령어 번호}\r\n```\r\n\r\n13. 아래 출력결과를 현재 경로 내에 result.txt 파일로 저장하시오.\r\n![](13번.PNG)\r\n\r\n```bash\r\n$ ll > result.txt\r\n```\r\n\r\n14. 5개의 백그라운드(background) 작업 중, 3번 작업을 포그라운드(foreground)로 가져오시오.\r\n\r\n```bash\r\n$ fg %3\r\n```\r\n\r\n15. 이름 ‘vi’ 프로세스를 찾아 종료시키시오. (‘vi’ 프로세스 id는 9140으로 가정한다.)\r\n\r\n```bash\r\n$ ps -ef | grep vi\r\n\r\n$ kill 9140\r\n```\r\n\r\n16. (a)에서 (b)의 결과를 얻으시오 (명령어: ll)\r\n![](16번.PNG)\r\n\r\n```bash\r\n$ ll -d\r\n```\r\n\r\n17. ‘test.txt’ 파일에서 상단 10줄을 읽어 오류만 ‘error.txt’ 에 저장하시오.\r\n\r\n```bash\r\n$ head test.txt 2> error.txt\r\n```\r\n\r\n18. ‘test.txt’ 파일에 ‘link_test’ 이름으로 심볼릭 링크를 생성하시오.\r\n\r\n```bash\r\n$ ln -s test.txt link_test\r\n```\r\n\r\n19. (a)에서 (b)의 결과를 얻으시오 (명령어: du)\r\n![](19번.PNG)\r\n\r\n```bash\r\n$ du -ah\r\n``` \r\n\r\n20.  현재 디렉토리의 모든 파일에서 ‘mail’ 이라는 패턴이 들어간 파일의 이름을 출력하라. (명령어 : grep)\r\n\r\n```bash\r\n$ grep -l 'mail' *\r\n```\r\n\r\n1.  ‘m’으로 시작하는 모든 파일에서 ‘hamster’ 를 포함하는 모든 행을 찾으시오.(명령어 : grep)\r\n\r\n```bash\r\n$ grep -n hamster m*\r\n```\r\n\r\n22. 현재 디렉토리 내의 ‘test.txt’ 파일에서 ‘:’ 구분자를 이용하여 3번째 필드를 출력하라 (명령어 : awk)\r\n\r\n```bash\r\n$ awk -F: '{ print $3 }' test.txt\r\n```\r\n\r\n23. 현재 디렉토리 내의 ‘test.txt’ 파일에서 1행에서 3행까지 출력하라. (명령어 : sed)\r\n\r\n```bash\r\n$ sed -n '1,3p' test.txt\r\n```\r\n\r\n24. vi 에디터의 탭간격을 4로 설정하시오. (vi 에디터를 실행시켰다고 가정)\r\n \r\n```bash\r\n:set sts=4\r\n```\r\n\r\n25. 다음 vi 화면에서 ‘if’를 ‘testif’ 로 한번에 변경하시오.\r\n![](25번.PNG)\r\n\r\n```bash\r\n:%s/if/testif/g\r\n``` \r\n\r\n1.  실행중인 터미널의 사이즈를 구하시오.\r\n\r\n```bash\r\n$ stty size\r\n```\r\n\r\n27. 로그인 하고 있는 모든 사용자를 출력하시오.\r\n\r\n```bash\r\n$ who\r\n```\r\n\r\n28. 현재 서버의 메모리와 캐시사용량을 mb 단위로 출력하시오.\r\n\r\n```bash\r\n$ free -m\r\n```\r\n\r\n29. 현재 디렉토리에 linuxwr.txt라는 파일을 만드는 alias를 작성하시오. (alias명 : linuxtest)\r\n \r\n```bash\r\n$ alias linux=\"touch linuxwr.txt\"\r\n```\r\n\r\n30. 포그라운드(foreground)로 실행중인 프로세스를 일시 중지하는 단축키는 무엇인가.\r\n \r\n```bash\r\nCTRL + Z\r\n```\r\n\r\n31.  아래 리스트에서 ‘6자리 단어이자, 대소문자 구분없이 ‘y’ 가 포함되는’ 단어의 개수를 출력하라.\r\n(명령어:more)\r\n![](31번.PNG)\r\n\r\n```bash\r\nmore list | grep -w '......' | -ic 'y'\r\n```\r\n\r\n32. ‘diff -u b a’ 명령어를 이용하여 아래와 같은 결과를 도출하였다. 결과값을 가지고 a파일을 만드시오.\r\n![](32번.PNG)\r\n\r\n```bash\r\ndiff -u b a > a\r\n```\r\n\r\n33. 당일 오후 1시로 알람을 지정한 뒤, 프로세스를 죽이시오 (PID는 9140으로 가정한다.)\r\n \r\n```bash\r\nkill -14 9999 | at 13:00\r\n```\r\n\r\n34.  10G의 더미파일(빈파일)을 만들고자 한다. 흰색을 채우시오. (파일명은 ‘mailplug’로 지정한다.)\r\n![](34번.PNG)\r\n\r\n```bash\r\n$ dd if=/dev/zero of=파일명 bs=1GB count=10\r\n```\r\n\r\n35. 시그널 이름 중 ‘SIGQUIT’ 는 몇 번에 해당하는가?  \r\n\r\n```\r\na. 19 b.17 c.15 d.3 e.1\r\n```\r\n\r\n```bash\r\n3\r\n``` \r\n\r\n36.  csh 에서 로그아웃할 때 백그라운드 프로세스들을 자동으로 죽일 때, 어느 파일을 참조하는가?\r\n```\r\na. .logout b. .bash_history c. .bashrc d. .bash_logout e. hamster\r\n```\r\n\r\n정답 : a\r\n\r\n```bash\r\n$ ~/logout\r\n```\r\n\r\n37.  grep 을 사용하여 마침표로 시작되는 줄을 찾으시오.\r\n\r\n```bash\r\n$ grep ^\\. {찾을 파일/디렉토리 명}\r\n```\r\n\r\n38. 디렉토리 내에서 가장 새로운 파일의 이름을 출력하는 방법은 무엇인가 (명령어: ls)\r\n\r\n```bash\r\n$ ls -t1 | head -1\r\n```\r\n\r\n39. 연결되지 않은 심볼릭 링크 찾아내는 방법은 무엇인가 (명령어: find)\r\n\r\n```bash\r\n$ find -L . -type l\r\n```\r\n\r\n40. ‘rm’ 명령어 사용시, 바로 삭제시키지 않고 한번 더 물어본 후 삭제시키고자 할 때 사용하는 옵션은?\r\n\r\n```bash\r\n$ rm -l file\r\n```\r\n\r\n41. ‘cat’ 명령어 옵션 중, ‘tab과 행바꿈 문자를 제외한 제어 문자를 ^ 형태로 출력해 주는’ 옵션은?\r\n\r\n```bash\r\n$ cat -v file\r\n```\r\n\r\n42. 0.0.0.0 에서 999.999.999.999 까지 표현할 수 있는 정규표현식을 작성하시오.\r\n\r\n```bash\r\n$ [0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\r\n```\r\n\r\n43. ‘egrep’ 명령어를 이용하여 ‘testfile’ 내 ‘숫자 3이 한 번 이상 등장하는 행을 출력하시오’.\r\n\r\n```bash\r\n$ egrep '3+' testfile\r\n```\r\n\r\n44. 디렉토리 구조는 아래와 같다. a.py 를 vi 편집기로 연 후, 빠져 나오지 않은 채, b.py 로 전환하시오.\r\n (cf. a.py 파일을 연 후, :q 명령은 내리지 않는다.)  \r\n\r\n![](44번.PNG)\r\n\r\n```bash\r\n:e b.py\r\n```\r\n\r\n45. 파일의 제일 앞부분에 있는 100개의 문자를 삭제하시오 (명령어 : dd)\r\n\r\n```bash\r\ndd if={input file이름} of={output file이름} ibs=1 slip100 conv=cotrunc\r\n```\r\n\r\n46. ‘test.log’ 파일을 정렬하여, 동일 디렉토리 내 ‘result.log’ 에 작성하시오. (명령어 : sort)\r\n\r\n```bash\r\n$ sort -o result.log test.log\r\n```\r\n\r\n47. 백그라운드로 실행중인 프로세스나 현재 중지된 프로세스 목록을 PID와 같이 출력하라.\r\n\r\n```bash\r\n$ jobs -l\r\n```\r\n\r\n48. 현재 등록된 crontab에 등록된 작업을 출력하시오\r\n\r\n```bash\r\n$ crontab -l\r\n```\r\n\r\n49. 아래 crontab 에 대해 맞는 설명은?\r\n![](49번.PNG)\r\n\r\n```\r\n a. 새벽 4시부터 낮12까지 30분 간격으로 로그파일 삭제.\r\n b. 매주 일요일, 새벽4시 30분과 낮12시 30분에, 로그파일 삭제.\r\n c. 매월 4일, 12일에 매시간 30분에 로그파일 삭제\r\n d. 새벽4시와 낮 12시, 30분에 로그파일 삭제\r\n e. 매월 30일 새벽4시와 낮12시에 로그파일 삭제\r\n```\r\n\r\n정답 : d\r\n```bash\r\n매일 4시 30분 12시 30분에 홈디렉토리의 모든 로그파일 삭제\r\n```\r\n\r\n1.   vi 편집기내에서 문서 최상단으로 커서를 위치시키는 명령어는?\r\n\r\n```bash\r\ngg\r\n\r\n1G\r\n```\r\n","excerpt":"수정된지 100일이 지난 파일 목록을 출력하시오. (명령어 : find) (a)에서 (b)의 결과를 얻으시오 (명령어: ll)\n 명령어가 저장되는 history 파일의 경로는 어디인가 저장된 히스토리를 파일명 ‘myhistory.log’ 으로 저장하…","fields":{"slug":"/linuxProblem1/"},"frontmatter":{"date":"Feb 20, 2021","title":"Linux 문제 풀이1","tags":["Linux"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n# 위상 정렬\r\n> 싸이클이 없는 방향 그래프의 모든 노드를 **방향성에 거스르지 않도록 순서대로 나열**\r\n\r\n**Tip!!**\r\n1. 그래프에서 **방문 조건이 주어질 때 사용!!**\r\n2. 시간 복잡도 **O(V+E)**이다.\r\n   (모든 노드를 확인하면서, 해당 노드에서 출발하는 간선을 차례대로 제거하기 때문)\r\n\r\n## 구현 방법\r\n\r\n### 1. DFS 활용\r\n\r\n```\r\n1. DFS 실행\r\n2. DFS가 끝날 때 스택에 삽입\r\n\r\n```\r\n\r\n### 2. BFS와 In-degree 활용\r\n\r\n```\r\n1. 모든 간선을 읽으며 InDegree 테이블을 채운다.\r\n2. Indegree가 0인 정점을 모두 큐에 넣는다.\r\n3. 큐의 Front에 있는 정점을 가져와 위상정렬 결과에 추가한다.\r\n4. 해당 정점으로부터 연결된 모든 정점의 Indegree값을 1 감소 시킨다.\r\n   이 때 Indegree가 0이면 그 정점을 큐에 추가\r\n5. 큐게 빌 때까지 3,4번을 반복\r\n```\r\n\r\n**Tip!!**\r\n - **루프가 V번 돌기전에 큐가 비면** 위상정렬이 **불가능**\r\n - **큐의 크기가 2이상인 경우가 생기면** 위상정렬 **결과가 2개 이상**\r\n\r\n## 백준 2623 - 음악 프로그램\r\n\r\n---\r\n\r\n![2623pb1](2623pb1.PNG)  \r\n![2623pb2](2623pb2.PNG)  \r\n\r\n---\r\n\r\n### 풀이\r\n---\r\n\r\n간선을 입력받을 때 슬라이딩 윈도우 방식을 사용한다. \r\n\r\nBFS / Indegree를 활용해 위상정렬\r\n\r\n---\r\n\r\n```java\r\npackage TopologySort;\r\n\r\nimport java.io.*;\r\nimport java.util.*;\r\n\r\npublic class num2623 {\r\n\tstatic int N, M;\r\n\tstatic int[] indegree;\r\n\tstatic Queue<Integer> q = new LinkedList<Integer>();\r\n\tstatic ArrayList<Edge>[] edge;\r\n\tstatic int[] result;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tStringTokenizer st;\r\n\t\tst = new StringTokenizer(br.readLine());\r\n\t\t\r\n\t\tN = stoi(st.nextToken());\r\n\t\tM = stoi(st.nextToken());\r\n\t\t\r\n\t\tindegree = new int[N+1];\r\n\t\tresult = new int[N+1];\r\n\t\tedge = new ArrayList[N+1];\r\n\t\t\r\n\t\tfor(int i=1; i<=N; i++) {\r\n\t\t\tedge[i] = new ArrayList<Edge>();\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<M; i++) {\r\n\t\t\tst = new StringTokenizer(br.readLine());\r\n\t\t\tint testCase = stoi(st.nextToken());\r\n\t\t\tif(testCase==0) continue;\r\n\t\t\t\r\n\t\t\tint prev = stoi(st.nextToken());\r\n\t\t\tfor(int j=1; j<testCase; j++) {\r\n\t\t\t\tint now = stoi(st.nextToken());\r\n\t\t\t\tindegree[now]++;\r\n\t\t\t\tedge[prev].add(new Edge(prev, now));\r\n\t\t\t\tprev = now;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=1; i<=N; i++)\r\n\t\t\tif(indegree[i]==0) q.add(i);\r\n\t\t\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tif(q.isEmpty()) {\r\n\t\t\t\tSystem.out.println(\"0\");\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tint now = q.poll();\r\n\t\t\tresult[i] = now;\r\n\t\t\tfor(Edge e : edge[now]) {\r\n\t\t\t\tindegree[e.e]--;\r\n\t\t\t\tif(indegree[e.e]==0)\r\n\t\t\t\t\tq.add(e.e);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor(int num : result) {\r\n\t\t\tSystem.out.println(num);\r\n\t\t}\r\n\t\t\r\n\t}\r\n\tstatic class Edge{\r\n\t\tint s, e;\r\n\t\tEdge(int s, int e){\r\n\t\t\tthis.s = s;\r\n\t\t\tthis.e = e;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\r\n}\r\n\r\n```\r\n\r\n## 백준 1516 - 게임 개발\r\n\r\n---\r\n\r\n![1516pb1](1516pb1.PNG)  \r\n![1516pb2](1516pb2.PNG)  \r\n\r\n---\r\n\r\n### 풀이\r\n---\r\n\r\n이 전 문제와 비슷한데 출력을 비용으로 해준다.\r\n -> result배열에 간선의 값을 더해준다.\r\n\r\n---\r\n\r\n```java\r\npackage TopologySort;\r\n\r\nimport java.io.*;\r\nimport java.util.*;\r\n\r\npublic class num1516 {\r\n\tstatic int N, M;\r\n\tstatic int[] indegree, result, weight;\r\n\tstatic Queue<Integer> q = new LinkedList<Integer>();\r\n\tstatic ArrayList<Edge>[] edge;\r\n\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\r\n\t\t\r\n\t\tN = stoi(st.nextToken());\r\n\t\t\r\n\t\tindegree = new int[N+1];\r\n\t\tresult = new int[N+1];\r\n\t\tedge = new ArrayList[N+1];\r\n\t\tweight = new int[N+1];\r\n\t\t\r\n\t\tfor(int i=1; i<=N; i++) {\r\n\t\t\tedge[i] = new ArrayList<Edge>();\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=1; i<=N; i++) {\r\n\t\t\tst = new StringTokenizer(br.readLine());\r\n\t\t\tweight[i] = stoi(st.nextToken());\r\n\t\t\twhile(true) {\r\n\t\t\t\tint prev = stoi(st.nextToken());\r\n\t\t\t\tif(prev == -1) break;\r\n\t\t\t\tindegree[i]++;\r\n\t\t\t\tedge[prev].add(new Edge(prev, i));\r\n\t\t\t}\r\n\t\t\tif(indegree[i] == 0){\r\n\t            result[i] = weight[i];\r\n\t            q.add(i);\r\n\t        }\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=1; i<=N; i++) {\r\n\t\t\tif(q.isEmpty()) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tint now = q.poll();\r\n\t\t\t\r\n\t\t\tfor(Edge next : edge[now]) {\r\n\t\t\t\tresult[next.e] = Math.max(result[next.e], result[now]+weight[next.e]);\r\n\t\t\t\tindegree[next.e]--;\r\n\t\t\t\tif(indegree[next.e]==0)\r\n\t\t\t\t\tq.add(next.e);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=1; i<=N; i++)\r\n\t\t\tSystem.out.println(result[i]);\r\n\t\t\r\n\t}\r\n\tstatic class Edge{\r\n\t\tint s, e;\r\n\t\tEdge(int s, int e){\r\n\t\t\tthis.s = s;\r\n\t\t\tthis.e = e;\r\n\t\t}\r\n\t}\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\r\n}\r\n\r\n```\r\n\r\n## 백준 2252 - 줄 세우기\r\n\r\n---\r\n\r\n![2252pb1](2252pb1.PNG)  \r\n![2252pb2](2252pb2.PNG)  \r\n\r\n---\r\n\r\n### 풀이\r\n---\r\n\r\n2623번과 거의 동일하다\r\n\r\n---\r\n\r\n```java\r\npackage package34;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\nimport java.util.LinkedList;\r\nimport java.util.Queue;\r\n\r\npublic class num2252 {\r\n\tstatic int N, M;\r\n\tstatic int[] indegree,result;\r\n\tstatic ArrayList<Edge>[] edge;\r\n\tstatic Queue<Integer> q = new LinkedList<Integer>();\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tString[] NM = br.readLine().split(\" \");\r\n\t\t\r\n\t\tN = stoi(NM[0]);\r\n\t\tM = stoi(NM[1]);\r\n\t\tindegree = new int[N+1];\r\n\t\tresult = new int[N+1];\r\n\t\tedge = new ArrayList[N+1];\r\n\t\t\r\n\t\tfor(int i=1; i<=N; i++) {\r\n\t\t\tedge[i] = new ArrayList<Edge>();\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=1; i<=M; i++) {\r\n\t\t\tString[] edgeData = br.readLine().split(\" \");\r\n\t\t\tint s = stoi(edgeData[0]);\r\n\t\t\tint e = stoi(edgeData[1]);\r\n\t\t\t\r\n\t\t\tedge[s].add(new Edge(s, e));\r\n\t\t\tindegree[e]++;\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=1; i<=N; i++) {\r\n\t\t\tif(indegree[i] == 0) q.add(i);\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=1; i<=N; i++) {\r\n\t\t\tif(q.isEmpty()) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tint temp = q.poll();\r\n\t\t\tresult[i] = temp;\r\n\t\t\tfor(Edge e : edge[temp]) {\r\n\t\t\t\tindegree[e.e]--;\r\n\t\t\t\tif(indegree[e.e] == 0)\r\n\t\t\t\t\tq.add(e.e);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=1; i<=N; i++) {\r\n\t\t\tSystem.out.print(result[i] + \" \");\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\tstatic class Edge{\r\n\t\tint s, e;\r\n\t\tEdge(int s, int e){\r\n\t\t\tthis.s = s;\r\n\t\t\tthis.e = e;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n}\r\n\r\n```\r\n\r\n## 백준 3665 - 최종 순위\r\n\r\n---\r\n\r\n![3665pb1](3665pb1.PNG)  \r\n![3665pb2](3665pb2.PNG)  \r\n\r\n---\r\n\r\n### 풀이\r\n---\r\n\r\n일단 문제가 이해가 안되서\r\n\r\n[stack07142님 블로그](https://stack07142.tistory.com/223)를 참고했다.\r\n\r\n1. 그래프를 인접 행렬로 구현한다.  \r\n2. 바뀐 순위에 따라 간선과 indegree를 갱신한다.  \r\n3. 위상 정렬을 한다.  \r\n   3-1. **정상일 경우**에 1등 팀 부터 순서대로 출력  \r\n   3-2. **확실한 순위를 찾을 수 없다면** \"?\"출력  \r\n   3-2. **사이클이 생겨** 순위를 정할 수 없는 경우   \"IMPOSSIBLE\"출력  \r\n\r\n어렵당...\r\n\r\n---\r\n\r\n```java\r\npackage package34;\r\n\r\nimport java.io.*;\r\nimport java.util.*;\r\n\r\npublic class num3665 {\r\n    static final int NONE = 0;\r\n    static final int IMPOSSIBLE = 1;\r\n    static final int NOT_DETERMINED = 2;\r\n\r\n    static int T, N, M;\r\n    static int[] indegree, result, prev;\r\n    static Queue<Integer> q = new LinkedList<Integer>();\r\n    static int[][] graph;\r\n    \r\n    public static void main(String[] args) throws IOException {\r\n\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n        StringBuilder sb = new StringBuilder();\r\n\r\n        T = stoi(br.readLine());\r\n\r\n        for(int i=0; i<T; i++){\r\n            N = stoi(br.readLine());\r\n\r\n            indegree = new int[N + 1];\r\n            result = new int[N+1];\r\n            prev = new int[N+1];\r\n            graph = new int[N+1][N+1];\r\n\r\n            StringTokenizer st = new StringTokenizer(br.readLine());\r\n            for (int j=0; j < N; j++) \r\n                prev[j] = stoi(st.nextToken());\r\n            \r\n\r\n            for (int j = 0; j < N; j++) {\r\n                for (int k = j + 1; k < N; k++) {\r\n                    graph[prev[j]][prev[k]] = 1;\r\n                    indegree[prev[k]]++;\r\n                }\r\n            }\r\n\r\n            M = stoi(br.readLine());\r\n\r\n            for (int j=0; j<M; j++) {\r\n\r\n                st = new StringTokenizer(br.readLine());\r\n\r\n                int a = stoi(st.nextToken());\r\n                int b = stoi(st.nextToken());\r\n\r\n                if (graph[a][b] == 1) {\r\n                    graph[a][b] = 0;\r\n                    graph[b][a] = 1;\r\n\r\n                    indegree[a]++;\r\n                    indegree[b]--;\r\n                } else {\r\n                \tgraph[a][b] = 1;\r\n                    graph[b][a] = 0;\r\n                    \r\n                    indegree[b]++;\r\n                    indegree[a]--;\r\n                }\r\n            }\r\n            \r\n            for (int j=1; j<=N; j++) {\r\n                if (indegree[j] == 0) {\r\n                    q.add(j);\r\n                }\r\n            }\r\n\r\n            int ans = NONE;\r\n            for (int j=1; j<=N; j++) {\r\n                if (q.isEmpty()) {\r\n                    ans = IMPOSSIBLE;\r\n                    break;\r\n                }\r\n                if (q.size() > 1) {\r\n                    ans = NOT_DETERMINED;\r\n                    break;\r\n                }\r\n\r\n                int u = q.poll();\r\n                result[j] = u;\r\n\r\n                for (int k=1; k<=N; k++) {\r\n                    if (graph[u][k] == 1) {\r\n                        indegree[k]--;\r\n                        if (indegree[k] == 0) q.add(k);\r\n                    }\r\n                }\r\n            }\r\n            \r\n            if (ans == NONE) {\r\n                for (int j=1; j<=N; j++)sb.append(result[j] + \" \");\r\n                sb.append(\"\\n\");\r\n            } else if (ans == IMPOSSIBLE) sb.append(\"IMPOSSIBLE\\n\");\r\n            else if (ans == NOT_DETERMINED) sb.append(\"?\\n\");\r\n        }\r\n        System.out.println(sb);\r\n    }\r\n    \r\n    public static int stoi(String string) {\r\n    \treturn Integer.parseInt(string);\r\n    }\r\n}\r\n```\r\n\r\n## 백준 1005 - ACM Craft\r\n\r\n---\r\n\r\n![1005pb1](1005pb1.PNG)  \r\n![1005pb2](1005pb2.PNG)  \r\n![1005pb3](1005pb3.PNG)  \r\n![1005pb4](1005pb4.PNG)  \r\n![1005pb5](1005pb5.PNG)  \r\n\r\n---\r\n\r\n### 풀이\r\n---\r\n\r\n1516문제와 비슷하다.\r\n\r\n---\r\n\r\n```java\r\npackage package34;\r\n\r\nimport java.io.*;\r\nimport java.util.*;\r\n\r\npublic class num1005 {\r\n\tstatic int T, N, K;\r\n    static int[] result, indegree, weight;\r\n\tstatic ArrayList<Edge>[] edge;\r\n\tstatic Queue<Integer> q = new LinkedList<Integer>();\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\tStringTokenizer st;\r\n\t\t\r\n\t\tT = stoi(br.readLine());\r\n\t\t\r\n\t\twhile(T-- >0) {\r\n\t\t\tst = new StringTokenizer(br.readLine());\r\n\t\t\tN = stoi(st.nextToken());\r\n\t\t\tK = stoi(st.nextToken());\r\n\t\t\t\r\n\t\t\tresult = new int[N+1];\r\n\t\t\tindegree = new int[N+1];\r\n\t\t\tweight = new int[N+1];\r\n\t\t\tedge = new ArrayList[N+1];\r\n\t\t\t\r\n\t\t\tfor(int i=1; i<=N; i++) {\r\n\t\t\t\tedge[i] = new ArrayList<Edge>();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tst = new StringTokenizer(br.readLine());\r\n\t\t\tfor(int i=1; i<=N; i++) {\r\n\t\t\t\tweight[i] = stoi(st.nextToken());\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor(int i=1; i<=K; i++) {\r\n\t\t\t\tst = new StringTokenizer(br.readLine());\r\n\t\t\t\tint s = stoi(st.nextToken());\r\n\t\t\t\tint e = stoi(st.nextToken());\r\n\t\t\t\t\r\n\t\t\t\tedge[s].add(new Edge(s,e));\r\n\t\t\t\tindegree[e]++;\r\n\t\t\t}\r\n\t        for(int i=1; i<=N; i++) {\r\n\t            result[i] = weight[i];\r\n\t \r\n\t            if(indegree[i] == 0)\r\n\t                q.offer(i);\r\n\t        }\r\n\t        \r\n\t\t\tfor(int i=1; i<=N; i++) {\r\n\t\t\t\tif(q.isEmpty()) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tint now = q.poll();\r\n\t\t\t\tfor(Edge next : edge[now]) {\r\n\t\t\t\t\t// 요기 중요함 둘 중 큰거 들어감\r\n\t\t\t\t\tresult[next.e] = Math.max(result[next.e], result[now]+weight[next.e]);\r\n\t\t\t\t\tindegree[next.e]--;\r\n\t\t\t\t\tif(indegree[next.e]==0)\r\n\t\t\t\t\t\tq.add(next.e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tint num = stoi(br.readLine());\r\n\t\t\tsb.append(result[num]+\"\\n\");\r\n\t\t}\r\n\t\tSystem.out.println(sb);\r\n\t\t\r\n\t}\r\n\t\r\n\tstatic class Edge{\r\n\t\tint s, e;\r\n\t\tEdge(int s, int e){\r\n\t\t\tthis.s = s;\r\n\t\t\tthis.e = e;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\t\r\n}\r\n```\r\n\r\n## 백준 1766 - 문제집\r\n\r\n---\r\n\r\n![1766pb1](1766pb1.PNG)  \r\n![1766pb1](1766pb2.PNG)  \r\n\r\n---\r\n\r\n### 풀이\r\n---\r\n\r\n문제를 보면 **가능한 쉬운 문제부터 풀어야 한다.** 라는 조건이 있다.  \r\n -> 이 조건은 Queue대신 PriorityQueue를 사용해 minheap에 저장하면 쉽게 구현 가능하다.\r\n\r\n---\r\n\r\n```java\r\npackage package34;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\nimport java.util.LinkedList;\r\nimport java.util.PriorityQueue;\r\nimport java.util.Queue;\r\n\r\npublic class num1766 {\r\n\tstatic int N, M;\r\n\tstatic int[] indegree,result;\r\n\tstatic ArrayList<Edge>[] edge;\r\n\tstatic PriorityQueue<Integer> q = new PriorityQueue<Integer>();\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tString[] NM = br.readLine().split(\" \");\r\n\t\t\r\n\t\tN = stoi(NM[0]);\r\n\t\tM = stoi(NM[1]);\r\n\t\tindegree = new int[N+1];\r\n\t\tresult = new int[N+1];\r\n\t\tedge = new ArrayList[N+1];\r\n\t\t\r\n\t\tfor(int i=1; i<=N; i++) {\r\n\t\t\tedge[i] = new ArrayList<Edge>();\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=1; i<=M; i++) {\r\n\t\t\tString[] edgeData = br.readLine().split(\" \");\r\n\t\t\tint s = stoi(edgeData[0]);\r\n\t\t\tint e = stoi(edgeData[1]);\r\n\t\t\t\r\n\t\t\tedge[s].add(new Edge(s, e));\r\n\t\t\tindegree[e]++;\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=1; i<=N; i++) {\r\n\t\t\tif(indegree[i] == 0) q.add(i);\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=1; i<=N; i++) {\r\n\t\t\tif(q.isEmpty()) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tint temp = q.poll();\r\n\t\t\tresult[i] = temp;\r\n\t\t\tfor(Edge e : edge[temp]) {\r\n\t\t\t\tindegree[e.e]--;\r\n\t\t\t\tif(indegree[e.e] == 0)\r\n\t\t\t\t\tq.add(e.e);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=1; i<=N; i++) {\r\n\t\t\tSystem.out.print(result[i] + \" \");\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\tstatic class Edge{\r\n\t\tint s, e;\r\n\t\tEdge(int s, int e){\r\n\t\t\tthis.s = s;\r\n\t\t\tthis.e = e;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n}\r\n```\r\n\r\n---\r\n\r\n끗\r\n\r\n\r\n# Reference\r\n\r\n[[그래프]위상 정렬 - JuticeHui님 블로그](https://justicehui.github.io/easy-algorithm/2018/03/24/TopologicalSort/)   \r\n[갓킹독님 블로그](https://blog.encrypted.gg/910?category=773649)   \r\n[라이님 블로그](https://m.blog.naver.com/kks227/220800013823)  \r\n","excerpt":"위상 정렬 싸이클이 없는 방향 그래프의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열 Tip!! 그래프에서 방문 조건이 주어질 때 사용!! 시간 복잡도 O(V+E)이다.\n(모든 노드를 확인하면서, 해당 노드에서 출발하는 간선을 차례대로 제거하기…","fields":{"slug":"/topologicalSort/"},"frontmatter":{"date":"Feb 09, 2021","title":"위상정렬 정리","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n# 신장 트리(Spnning Tree)\r\n> 하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프\r\n\r\n# 최소 신장 트리(Minimum Spanning Tree)\r\n> 트리의 간선마다 가중치가 있을 때, **간선의 가중치 합이 최소**인 트리\r\n\r\n신장 트리의 최소비용을 구하는 크루스칼 알고리즘, 프림 알고리즘 2가지 알고리즘에 대해 정리한다.\r\n\r\n## 크루스칼 알고리즘\r\n---\r\n> 간선 선택 기반의 알고리즘으로, 탐욕적인 방법을 이용, 간선을 하나씩 선택해서 MST를 찾는 알고리즘입니다.\r\n\r\n### 특징\r\n---\r\n1. 그리디 알고리즘의 일종 -> 작은 간선부터 훑기 때문에  \r\n2. 시간 복잡도 : **O(ElogE)**  \r\n   -> 가중치 별로 정렬 : O(ElogE) + 정점이 같은 컴포넌트에 속해있는지 확인 : 약 O(1) = **O(ElogE)**  \r\n\r\n\r\n### 구현 방법\r\n---\r\n\r\n```\r\n1. 간선을 비용에 따라 오름차순으로 정리하고, 정점을 초기화한다\r\n2. 간선을 하나씩 확인하며 간선이 싸이클을 발생시키지 않으면 간선을 포함시킨다.\r\n3. 간선을 V-1개 뽑았을 때, 이루는 그래프가 MST이다.\r\n```\r\n\r\n## 백준 1197 - 최소 스패닝 트리\r\n\r\n---\r\n\r\n![1197pb1](1197pb1.PNG)\r\n![1197pb2.PNG](1197pb2.PNG)\r\n\r\n---\r\n\r\n### 풀이\r\n---\r\n\r\n1. 간선 클래스를 만들어 우선순위 큐로 저장한다.\r\n2. union find를 사용해 싸이클 검사와 거리를 더해준다.\r\n\r\n---\r\n\r\n```java\r\npackage package29;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.PriorityQueue;\r\nimport java.util.StringTokenizer;\r\n\r\npublic class num1197 {\r\n\tstatic int V, E, result=0, cnt=0;\r\n\tstatic int[] parent;\r\n\tstatic PriorityQueue<Edge> pq = new PriorityQueue<Edge>();\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tString[] VE = br.readLine().split(\" \");\r\n\t\tV = stoi(VE[0]);\r\n\t\tE = stoi(VE[1]);\r\n\t\t\r\n\t\tparent = new int[V+1];\r\n\t\t\r\n\t\tfor(int i=0; i<V+1; i++) {\r\n            parent[i] = i;\r\n        }\r\n\t\t\r\n\t    for(int i=0; i<E; i++) {\r\n\t    \tStringTokenizer st = new StringTokenizer(br.readLine());\r\n\t    \tpq.add(new Edge(stoi(st.nextToken()),stoi(st.nextToken()),stoi(st.nextToken())));\r\n\t    }\r\n\t\t\r\n\t    for(int i=0; i<E; i++) {\r\n\t    \tEdge temp = pq.poll();\r\n\t    \t\r\n\t    \tint a = temp.s;\r\n\t    \tint b = temp.e;\r\n\t    \tif(!union(a, b))\r\n\t    \t\tcontinue;\r\n\t    \tresult+= temp.w;\r\n\t    \tcnt++;\r\n\t    \tif(cnt == V-1)\r\n\t    \t\tbreak;\r\n\t    }\r\n\t    System.out.println(result);\r\n\t}\r\n\t\r\n\tstatic class Edge implements Comparable<Edge>{\r\n\t\tint s, e, w;\r\n\t\tEdge(int s, int e, int w){\r\n\t\t\tthis.s = s;\r\n\t\t\tthis.e = e;\r\n\t\t\tthis.w = w;\r\n\t\t}\r\n\t\t@Override\r\n\t\tpublic int compareTo(Edge o) {\r\n\t\t\treturn o.w >= this.w ? -1: 1;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static int find_parent(int num) {\r\n\t\tif(parent[num] != num)\r\n\t\t\treturn parent[num] = find_parent(parent[num]);\r\n\t\treturn parent[num];\r\n\t}\r\n\r\n\tpublic static boolean union(int a, int b) {\r\n\t\ta = find_parent(a);\r\n\t\tb = find_parent(b);\r\n\t\t\r\n\t\tif(a==b) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse if(a < b)\r\n\t\t\tparent[b] = a;\r\n\t\telse\r\n\t\t\tparent[a] = b;\r\n\t\treturn true;\r\n\t}\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\t\r\n}\r\n\r\n```\r\n\r\n## 백준 4386 - 별자리 만들기\r\n\r\n---\r\n\r\n![4386pb1](4386pb1.PNG)\r\n![4386pb2](4386pb2.PNG)\r\n\r\n---\r\n\r\n### 풀이\r\n---\r\n\r\n정점의 x좌표와 y좌표를 저장할 수 있는 클래스를 만들어 사용했다.\r\n\r\n위의 문제는 가중치가 주어졌지만, 4386번문제는 가중치를 두 점사이 거리로 계산해서 넣어야 한다.\r\n\r\n---\r\n\r\n```java\r\npackage package29;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.PriorityQueue;\r\nimport java.util.StringTokenizer;\r\n\r\npublic class num4386 {\r\n\tstatic int N, cnt=0;\r\n\tstatic double result = 0;\r\n\tstatic int[] parent;\r\n\tstatic PriorityQueue<Edge> pq = new PriorityQueue<Edge>();\r\n\tstatic Vertex[] v;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tN = stoi(br.readLine());\r\n\t\t\r\n\t\tparent = new int[N+1];\r\n\t\tv = new Vertex[N+1];\r\n\t\tfor(int i=1; i<=N+1; i++) {\r\n            parent[i] = i;\r\n        }\r\n\t\t\r\n\t    for(int i=1; i<=N; i++) {\r\n\t    \tStringTokenizer st = new StringTokenizer(br.readLine(),\" \");\r\n\t    \tv[i] = new Vertex(stod(st.nextToken()), stod(st.nextToken()));\r\n\t    }\r\n\t    \r\n\t    for(int i=1; i<=N; i++) {\r\n\t    \tfor(int j=i+1; j<=N; j++) {\r\n\t    \t\tpq.add(new Edge(i, j, getDistance(v[i].x, v[j].x, v[i].y, v[j].y)));\r\n\t    \t}\r\n\t    }\r\n\t    \r\n\t    for(int i=0; i<pq.size(); i++) {\r\n\t    \tEdge temp = pq.poll();\r\n\t    \t\r\n\t    \tint a = temp.s;\r\n\t    \tint b = temp.e;\r\n\t    \tif(!union(a, b))\r\n\t    \t\tcontinue;\r\n\t    \tresult+= temp.w;\r\n\t    \tcnt++;\r\n\t    \tif(cnt == N-1)\r\n\t    \t\tbreak;\r\n\t    }\r\n\t    System.out.println(String.format(\"%.2f\", result));\r\n\t}\r\n\t\r\n\tstatic class Vertex{\r\n\t\tdouble x, y;\r\n\t\tVertex(double x, double y){\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t}\r\n\t}\r\n\t\r\n\tstatic class Edge implements Comparable<Edge>{\r\n\t\tint s, e;\r\n\t\tdouble w;\r\n\t\tEdge(int s, int e, double w){\r\n\t\t\tthis.s = s;\r\n\t\t\tthis.e = e;\r\n\t\t\tthis.w = w;\r\n\t\t}\r\n\t\t@Override\r\n\t\tpublic int compareTo(Edge o) {\r\n\t\t\treturn o.w >= this.w ? -1: 1;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static int find_parent(int num) {\r\n\t\tif(parent[num] != num)\r\n\t\t\treturn parent[num] = find_parent(parent[num]);\r\n\t\treturn parent[num];\r\n\t}\r\n\r\n\tpublic static boolean union(int a, int b) {\r\n\t\ta = find_parent(a);\r\n\t\tb = find_parent(b);\r\n\t\t\r\n\t\tif(a==b) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse if(a < b)\r\n\t\t\tparent[b] = a;\r\n\t\telse\r\n\t\t\tparent[a] = b;\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tpublic static double getDistance(double x1, double x2, double y1, double y2) {\r\n\t\treturn Math.sqrt(Math.pow(Math.abs(x1 - x2), 2) + Math.pow(Math.abs(y1 - y2), 2));\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\t\r\n\tpublic static double stod(String string) {\r\n\t\treturn Double.parseDouble(string);\r\n\t}\r\n\t\r\n}\r\n\r\n\r\n```\r\n\r\n## 백준 1647 - 도시 분할 계획\r\n\r\n---\r\n\r\n![1647pb1](1647pb1.PNG)\r\n![1647pb2](1647pb2.PNG)\r\n\r\n---\r\n\r\n### 풀이\r\n---\r\n\r\n도시를 2개로 나눈다고 했으니 크루스칼 알고리즘이 끝나는 조건을 N-2로 작성해야 한다.\r\n\r\n---\r\n\r\n```java\r\npackage MST;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.PriorityQueue;\r\nimport java.util.StringTokenizer;\r\n\r\npublic class num1647 {\r\n\tstatic int N, M, result=0, cnt=0;\r\n\tstatic int[] parent;\r\n\tstatic PriorityQueue<Edge> pq = new PriorityQueue<Edge>();\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tStringTokenizer st;\r\n\t\t\r\n\t\tst = new StringTokenizer(br.readLine());\r\n\t\tN = stoi(st.nextToken());\r\n\t\tM = stoi(st.nextToken());\r\n\t\r\n\t\tparent = new int[N+1];\r\n\t\tfor(int i=1; i<=N; i++) {\r\n            parent[i] = i;\r\n        }\r\n\t\t\r\n\t\tfor(int i=0; i<M; i++) {\r\n\t\t\tst = new StringTokenizer(br.readLine());\r\n\t\t\tint s = stoi(st.nextToken()), e = stoi(st.nextToken()), w = stoi(st.nextToken());\r\n\t\t\tpq.add(new Edge(s,e,w));\r\n\t\t}\r\n\t\t\r\n\t\twhile(!pq.isEmpty()) {\r\n\t\t\tEdge temp = pq.poll();\r\n\t\t\t\r\n\t\t\tint a = temp.s;\r\n\t\t\tint b = temp.e;\r\n\t\t\tif(!union(a, b))\r\n\t\t\t\tcontinue;\r\n\t\t\tresult += temp.w;\r\n\t\t\tcnt++;\r\n\t\t\tif(cnt == N-2)\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tSystem.out.println(result);\r\n\t}\r\n\t\r\n\tstatic class Edge implements Comparable<Edge> {\r\n\t\tint s, e, w;\r\n\t\tEdge(int s, int e, int w) {\r\n\t\t\tthis.s = s;\r\n\t\t\tthis.e = e;\r\n\t\t\tthis.w = w;\r\n\t\t}\r\n\t\t\r\n\r\n\t\t@Override\r\n\t\tpublic int compareTo(Edge o) {\r\n\t\t\treturn o.w >= this.w ? -1 : 1;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static int find_parent(int num) {\r\n\t\tif(parent[num] != num)\r\n\t\t\treturn parent[num] = find_parent(parent[num]);\r\n\t\treturn parent[num];\r\n\t}\r\n\t\r\n\tpublic static boolean union(int a, int b) {\r\n\t\ta = find_parent(a);\r\n\t\tb = find_parent(b);\r\n\t\t\r\n\t\tif(a==b)\r\n\t\t\treturn false;\r\n\t\tif(a < b)\r\n\t\t\tparent[b] = a;\r\n\t\telse\r\n\t\t\tparent[a] = b;\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\r\n}\r\n\r\n```\r\n\r\n## 백준 1774 - 우주신과의 교감\r\n\r\n---\r\n\r\n![1774pb1](1774pb1.PNG)\r\n![1774pb2](1774pb2.PNG)\r\n\r\n---\r\n\r\n### 풀이\r\n---\r\n\r\n일반적인 최소 스패닝 트리 문제다. 1197번과 풀이가 동일하다.\r\n\r\n---\r\n\r\n```java\r\npackage package29;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.PriorityQueue;\r\n\r\npublic class num1774 {\r\n\tstatic int N, M, cnt = 0;\r\n\tstatic PriorityQueue<Edge> pq = new PriorityQueue<Edge>();\r\n\tstatic int[] parent;\r\n\tstatic Node[] arr;\r\n\tstatic double minLen = 0;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tString[] NM = br.readLine().split(\" \");\r\n\t\t\r\n\t\tN = stoi(NM[0]);\r\n\t\tM = stoi(NM[1]);\r\n\t\tNode[] arr = new Node[N+1];\r\n\t\tparent = new int[N+1];\r\n\t\t\r\n\t\tfor(int i=1; i<=N; i++) {\r\n            parent[i] = i;\r\n        }\r\n\t\t\r\n\t\tfor(int i=1; i<=N; i++) {\r\n\t\t\tString[] XY = br.readLine().split(\" \");\r\n\t\t\tarr[i] = new Node(stoi(XY[0]), stoi(XY[1]));\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<M; i++) {\r\n\t\t\tString[] se = br.readLine().split(\" \");\r\n\t\t\tint s = stoi(se[0]);\r\n\t\t\tint e = stoi(se[1]);\r\n\t\t\tunion(s, e);\r\n\t\t}\r\n\t\tfor (int i = 1; i <= N; i++) {\r\n\t\t\tfor (int j = i + 1; j <= N; j++) {\r\n\t\t\t\tpq.add(new Edge(i, j, getDistance(arr[i].x, arr[j].x, arr[i].y, arr[j].y)));\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t    for(int i=0; i<pq.size(); i++) {\r\n\t    \tEdge temp = pq.poll();\r\n\t    \t\r\n\t    \tint a = temp.s;\r\n\t    \tint b = temp.e;\r\n\t    \tif(!union(a, b))\r\n\t    \t\tcontinue;\r\n\t    \tminLen+= temp.w;\r\n\t    }\r\n\t    System.out.println(String.format(\"%.2f\", minLen));\r\n\t\t\r\n\t}\r\n\tstatic class Edge implements Comparable<Edge>{\r\n\t\tint s, e;\r\n\t\tdouble w;\r\n\t\tEdge(int s, int e, double w){\r\n\t\t\tthis.s = s;\r\n\t\t\tthis.e = e;\r\n\t\t\tthis.w = w;\r\n\t\t}\r\n\t\t@Override\r\n\t\tpublic int compareTo(Edge o) {\r\n\t\t\treturn o.w >= this.w ? -1: 1;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static double getDistance(double x1, double x2, double y1, double y2) {\r\n\t\treturn Math.sqrt(Math.pow(Math.abs(x1 - x2), 2) + Math.pow(Math.abs(y1 - y2), 2));\r\n\t}\r\n\t\r\n\tpublic static int find_parent(int num) {\r\n\t\tif(parent[num] != num)\r\n\t\t\treturn parent[num] = find_parent(parent[num]);\r\n\t\treturn parent[num];\r\n\t}\r\n\r\n\tpublic static boolean union(int a, int b) {\r\n\t\ta = find_parent(a);\r\n\t\tb = find_parent(b);\r\n\t\t\r\n\t\tif(a==b) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse if(a < b)\r\n\t\t\tparent[b] = a;\r\n\t\telse\r\n\t\t\tparent[a] = b;\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\t\r\n\tstatic class Node{\r\n\t\tdouble x, y;\r\n\t\tNode(double x, double y){\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n## 백준 2887 - 행성 터널\r\n\r\n---\r\n\r\n![2887pb1](2887pb1.PNG)\r\n![2887pb2](2887pb2.PNG)\r\n\r\n---\r\n\r\n### 풀이\r\n---\r\n\r\n이 문제가 어려웠다.\r\n\r\nN의 개수가 상당히 커서 모든 간선을 추가하면 시간 초과가 나온다.\r\n\r\n간선 비용은 문제에 주어진대로 Min(x좌표 차이, y좌표 차이, z좌표 차이)이다.\r\n\r\n행성을 연결할 때 드는 비용을 x, y, z을 각각 오름차순으로 정렬하고\r\n\r\n인접한 좌표의 비용을 PriorityQueue에 넣는다.\r\n\r\n그 뒤 크루스칼 알고리즘을 통해 답을 구한다.\r\n\r\n---\r\n\r\n```java\r\npackage package29;\r\n\r\nimport java.io.*;\r\nimport java.util.*;\r\n\r\npublic class num2887 {\r\n\tstatic int N;\r\n\tstatic Vertex[] vertexs;\r\n\tstatic PriorityQueue<Edge> pq = new PriorityQueue<Edge>(new Comparator<Edge>() {\r\n\t\t@Override\r\n\t\tpublic int compare(Edge o1,Edge o2) {\r\n\t\t\treturn (o1.w-o2.w);\r\n\t\t}\r\n\t});\t\t\t\r\n\tstatic int[] parent; \r\n\t\r\n\tpublic static void main(String[] args) throws IOException { \r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in)); \r\n\t\tN = Integer.parseInt(br.readLine()); \r\n\t\tvertexs = new Vertex[N]; \r\n\t\t\r\n\t\tStringTokenizer st; \r\n\t\tfor (int i = 0; i < N ; i++) { \r\n\t\t\tst = new StringTokenizer(br.readLine().trim(), \" \");\r\n\t\t\tint X = stoi(st.nextToken()); \r\n\t\t\tint Y = stoi(st.nextToken());\r\n\t\t\tint Z = stoi(st.nextToken()); \r\n\t\t\tvertexs[i] = new Vertex(X, Y, Z, i);\r\n\t\t} \r\n\t\t\r\n\t\tArrays.sort(vertexs,new Comparator<Vertex>() {\r\n\t\t\t@Override\r\n\t\t\tpublic int compare(Vertex o1, Vertex o2) {\r\n\t\t\t\treturn Integer.compare(o1.x, o2.x);\r\n\t\t\t}\r\n\t\t});\r\n\t\tfor (int i = 1; i <N ; i++) {\r\n\t\t\tpq.add(new Edge(vertexs[i-1].id, vertexs[i].id, Math.abs(vertexs[i].x-vertexs[i-1].x)));\r\n\t\t}\r\n\t\t\t\r\n\t\tArrays.sort(vertexs,new Comparator<Vertex>() {\r\n\t\t\t@Override\r\n\t\t\tpublic int compare(Vertex o1, Vertex o2) {\r\n\t\t\t\treturn Integer.compare(o1.y, o2.y);\r\n\t\t\t}\r\n\t\t});\r\n\t\tfor (int i = 1; i <N ; i++) {\r\n\t\t\tpq.add(new Edge(vertexs[i-1].id, vertexs[i].id, Math.abs(vertexs[i].y-vertexs[i-1].y)));\r\n\t\t} \r\n\t\t\r\n\t\tArrays.sort(vertexs,new Comparator<Vertex>() {\r\n\t\t\t@Override\r\n\t\t\tpublic int compare(Vertex o1, Vertex o2) {\r\n\t\t\t\treturn Integer.compare(o1.z, o2.z);\r\n\t\t\t}\r\n\t\t});\r\n\t\tfor (int i = 1; i <N ; i++) {\r\n\t\t\tpq.add(new Edge(vertexs[i-1].id, vertexs[i].id, Math.abs(vertexs[i].z-vertexs[i-1].z)));\r\n\t\t} \r\n\t\t\r\n\t\t\r\n\t\tparent = new int[N+1];\r\n\t\tfor (int i = 1; i <= N ; i++)\r\n\t\t\tparent[i] = i; \r\n\t\tlong result=0;\r\n\t\t\r\n\t\twhile(!pq.isEmpty()) {\r\n\t\t\tEdge tmp = pq.poll();\r\n\t\t\tif(find_parent(tmp.s)!=find_parent(tmp.e)) {\r\n\t\t\t\tresult +=tmp.w;\r\n\t\t\t\tunion(tmp.s,tmp.e);\r\n\t\t\t}\r\n\t\t}\r\n\t\tSystem.out.println(result);\r\n\t}\r\n\t\r\n\tstatic class Vertex {\r\n\t\tint x, y, z, id;\r\n\t\tVertex(int x, int y, int z, int id) {\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t\tthis.z = z;\r\n\t\t\tthis.id = id;\r\n\t\t}\r\n\t}\r\n\t\r\n\tstatic class Edge {\r\n\t\tint s, e, w;\r\n\t\tEdge(int s, int e, int w) {\r\n\t\t\tthis.s = s; \r\n\t\t\tthis.e = e; \r\n\t\t\tthis.w = w;\r\n\t\t} \r\n\t} \r\n\t\r\n\tpublic static int find_parent(int num) {\r\n\t\tif(parent[num] != num)\r\n\t\t\treturn parent[num] = find_parent(parent[num]);\r\n\t\treturn parent[num];\r\n\t}\r\n\t\r\n\tpublic static boolean union(int a, int b) {\r\n\t\ta = find_parent(a);\r\n\t\tb = find_parent(b);\r\n\t\t\r\n\t\tif(a==b) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse if(a < b)\r\n\t\t\tparent[b] = a;\r\n\t\telse\r\n\t\t\tparent[a] = b;\r\n\t\treturn true;\r\n\t}\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n}\r\n\r\n\r\n```\r\n\r\n## 백준 17472 - 다리 만들기2\r\n\r\n---\r\n\r\n![17472pb1](17472pb1.PNG)\r\n![17472pb2](17472pb2.PNG)\r\n![17472pb3](17472pb3.PNG)\r\n![17472pb4](17472pb4.PNG)\r\n![17472pb5](17472pb5.PNG)\r\n![17472pb6](17472pb6.PNG)\r\n\r\n---\r\n\r\n### 풀이\r\n---\r\n\r\n이전 문제들을 모두 풀어봤으면 어렵진 않은데 삽질을 많이했다.\r\n\r\n내가 실수한 부분은 2가지였다.\r\n\r\n```\r\n1. dfs로 체크하는데 자기 자신을 바꾸지 않음\r\n2. for(int i=0; i<pq.size(); i++) 이런식으로 사용\r\n```\r\n\r\n어떤 친절하신 분이 반례를 정리해놔서 참고했다.  \r\n\r\n[반례모음 - promise12mee](https://www.acmicpc.net/board/view/63536)\r\n\r\n---\r\n\r\n```java\r\npackage package29;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.PriorityQueue;\r\n\r\n\r\npublic class num17472 {\r\n\tstatic int N, M, landCount=0, result = 0, cnt=0;\r\n\tstatic int[] parent;\r\n\tstatic int[][] map;\r\n\tstatic int[] dx = new int[]{0,0,1,-1};\r\n\tstatic int[] dy = new int[]{1,-1,0,0};\r\n\tstatic PriorityQueue<Edge> pq = new PriorityQueue<Edge>();\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\r\n\t\tString[] NM = br.readLine().split(\" \");\r\n\t\t\r\n\t\tN = stoi(NM[0]);\r\n\t\tM = stoi(NM[1]);\r\n\t\tmap = new int[N][M];\r\n\t\t\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tString[] mapData = br.readLine().split(\" \");\r\n\t\t\tfor(int j=0; j<M; j++) {\r\n\t\t\t\tmap[i][j] = stoi(mapData[j]);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tcheckLand();\r\n\t\t\r\n\t\tparent = new int[landCount+1];\r\n\t\tfor(int i=0; i<=landCount; i++) {\r\n\t\t\tparent[i] = i;\r\n\t\t}\r\n\t\t\r\n        for(int i=0; i<N; i++) {\r\n            for(int j=0; j<M; j++) {\r\n                if(map[i][j] != 0) {\r\n                    makeBridge(i, j, map[i][j]);\r\n                }\r\n            }\r\n        }\r\n        \r\n        int size = pq.size();\r\n\t    for(int i=0; i<size; i++) {\r\n\t    \tEdge temp = pq.poll();\r\n\t    \tint a = temp.s;\r\n\t    \tint b = temp.e;\r\n\t    \tif(!union(a, b))\t\t\r\n\t    \t\tcontinue;\r\n\t    \tunion(temp.s, temp.e);\r\n\t    \tresult+= temp.w;\r\n\t    \tcnt++;\r\n\t    }\r\n\t    if(result == 0 || cnt != landCount-1) {\r\n            System.out.println(-1);\r\n        } else {\r\n            System.out.println(result);\r\n        }\r\n\t}\r\n\t\r\n\tstatic void makeBridge(int x, int y, int landNum) {\r\n        int newX = x;\r\n        int newY = y;\r\n\t\tint length = 0;\r\n        \r\n        for(int i=0; i<4; i++) {\r\n            while(true) {\r\n                newX = newX + dx[i];\r\n                newY = newY + dy[i];\r\n                \r\n                if(isPossibleIndex(newX, newY)) {\r\n                    if(map[newX][newY] == landNum) {\r\n                        length = 0;\r\n                        newX = x;\r\n                        newY = y;\r\n                        break;\r\n                    } else if(map[newX][newY] == 0){\r\n                        length++;\r\n                    } else {\r\n                        if(length > 1) {\r\n                        \tpq.add(new Edge(landNum, map[newX][newY], length));\r\n                        }\r\n                        length = 0;\r\n                        newX = x;\r\n                        newY = y;\r\n                        break;\r\n                    }\r\n                } else {\r\n                    length = 0;\r\n                    newX = x;\r\n                    newY = y;\r\n                    break;\r\n                }\r\n            }\r\n        }\t\r\n\t}\r\n\t\r\n\tstatic class Edge implements Comparable<Edge>{\r\n\t\tint s, e, w;\r\n\t\tEdge(int s, int e, int w){\r\n\t\t\tthis.s = s;\r\n\t\t\tthis.e = e;\r\n\t\t\tthis.w = w;\r\n\t\t}\r\n\t\t@Override\r\n\t\tpublic int compareTo(Edge o) {\r\n\t\t\treturn o.w >= this.w ? -1 : 1;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static int find_parent(int num) {\r\n\t\tif(parent[num] != num)\r\n\t\t\treturn parent[num] = find_parent(parent[num]);\r\n\t\treturn parent[num];\r\n\t}\r\n\t\r\n\tpublic static boolean union(int a, int b) {\r\n\t\ta = find_parent(a);\r\n\t\tb = find_parent(b);\r\n\t\t\r\n\t\tif(a==b) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse if(a < b)\r\n\t\t\tparent[b] = a;\r\n\t\telse\r\n\t\t\tparent[a] = b;\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tpublic static void checkLand() {\r\n\t\tboolean[][] visited = new boolean[N][M];\r\n\t\t\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tfor(int j=0; j<M; j++) {\r\n\t\t\t\tif(map[i][j] != 0 && !visited[i][j]) {\r\n\t\t\t\t\tlandCount++;\r\n\t\t\t\t\tdfs(i, j, visited);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic static void dfs(int x, int y, boolean[][] visited) {\r\n\t\tmap[x][y] = landCount;\r\n\t\tfor(int i=0; i<4; i++) {\r\n\t\t\tint newX = x + dx[i];\r\n\t\t\tint newY = y + dy[i];\r\n\t\t\tif(isPossibleIndex(newX, newY) && !visited[newX][newY] && map[newX][newY] != 0) {\r\n\t\t\t\tvisited[x + dx[i]][y + dy[i]] = true;\r\n\t\t\t\tmap[newX][newY] = landCount;\r\n\t\t\t\tdfs(x + dx[i], y + dy[i], visited);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static boolean isPossibleIndex(int x, int y) {\r\n\t\treturn x >= 0 && y >= 0 && x < N && y < M ? true : false;\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n}\r\n\r\n```\r\n\r\n\r\n## 프림 알고리즘\r\n---\r\n> 정점 선택 기반의 알고리즘으로, 하나의 정점에서 연결된 간선들 중에 최소 간선 비용을 가진 정점을 하나씩 선택하면서 MST를 찾는 알고리즘\r\n\r\n### 구현 방법\r\n---\r\n\r\n```\r\n1. 임의의 정점 하나를 선택해서 시작\r\n2. 선택한 정점과 인접하는 정점들 중에 최소비용의 간선을 가지는 정점을 선택\r\n3. 모든 정점이 선택될 때 까지 반복\r\n\r\n```\r\n\r\n---\r\n\r\n## 주절주절\r\n\r\n크루스칼 알고리즘과 프림 알고리즘에 대해 알아보았다. 대부분 최소 신장 트리문제는 크루스칼 알고리즘을 통해 대부분 해결 가능하기 때문에 백준 단계별 문제에 있는 MST문제는 모두 크루스칼 알고리즘을 사용해서 문제를 풀었다.\r\n\r\n# Reference\r\n이것이 취업을 위한 코딩테스트다 - 나동빈  \r\n[라이님 블로그](https://m.blog.naver.com/kks227/220799105543)  \r\n[갓킹독님 블로그](https://blog.encrypted.gg/915?category=773649)  \r\n[주남2님 블로그](https://ju-nam2.tistory.com/112)  \r\n[두 점 사이의 거리, 좌표평면위의 두 점 사이의 거리](https://mathbang.net/408)  \r\n[Java - 반올림해서 소수점 n번째 자리까지 출력 - chacha님 블로그](https://codechacha.com/ko/java-round-a-number-to-decimal-point/)  ","excerpt":"신장 트리(Spnning Tree) 하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프 최소 신장 트리(Minimum Spanning Tree) 트리의 간선마다 가중치가 있을 때, 간선의 가중치 합이 최소인 트리 신장…","fields":{"slug":"/MST/"},"frontmatter":{"date":"Feb 04, 2021","title":"최소 신장 트리 정리","tags":["Algorithm"],"update":"Feb 08, 2021"}}},{"node":{"rawMarkdownBody":"\r\n# 슬라이딩 윈도우\r\n\r\n투포인터 알고리즘과 비슷하지만 슬라이딩 윈도우는 **어느 순간에도 그 구간의 넓이가 동일하다**  \r\n -> 사용하지 않는 값을 삭제하거나 갱신하는 기법이다.\r\n## 백준 2096번 - 내려가기\r\n---\r\n\r\n![2096pb1](2096pb1.PNG)\r\n![2096pb2](2096pb2.PNG)\r\n\r\n---\r\n\r\n### 풀이\r\n---\r\n\r\n이 문제는 슬라이딩 윈도우 + DP문제다. \r\n\r\n문제를 보면 메모리 제한이 있다.\r\n\r\n계단의 최대값과 최솟값을 저장하는데 이전의 값들만 저장하고 있으면 된다.\r\n\r\n---\r\n\r\n```java\r\npackage slidingWindow;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.Arrays;\r\n\r\npublic class num2096 {\r\n\tstatic int N, MAX, MIN;\r\n\tstatic int[] tempMaxDp, tempMinDp, maxDp, minDp;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tN = stoi(br.readLine());\r\n\t\ttempMaxDp = new int[3]; tempMinDp = new int[3]; maxDp = new int[3]; minDp = new int[3];\r\n\t\t\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tString[] step = br.readLine().split(\" \");\r\n\t\t\tfor(int j=0; j<3; j++) {\r\n\t\t\t\ttempMinDp[j] = tempMaxDp[j] = stoi(step[j]);\r\n\t\t\t\ttempMaxDp[j] += Math.max(maxDp[1] , j == 1 ? Math.max(maxDp[0], maxDp[2]) : maxDp[j]);\r\n\t\t\t\ttempMinDp[j] += Math.min(minDp[1] , j == 1 ? Math.min(minDp[0], minDp[2]) : minDp[j]);\r\n\t\t\t\tMAX = j==0 ? tempMaxDp[j] : MAX > tempMaxDp[j] ? MAX : tempMaxDp[j];\r\n\t\t\t\tMIN = j==0 ? tempMinDp[j] : MIN < tempMinDp[j] ? MIN : tempMinDp[j];\r\n\t\t\t}\r\n\t\t\tarrayCopy(maxDp, tempMaxDp);\r\n\t\t\tarrayCopy(minDp, tempMinDp);\r\n\t\t\t\r\n\t\t}\r\n\t\tSystem.out.println(MAX + \" \" + MIN);\r\n\t}\r\n\t\r\n\tpublic static void arrayCopy(int[] to, int[] from) {\r\n\t\tfor(int i=0; i<3; i++) {\r\n\t\t\tto[i] = from[i];\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\r\n}\r\n\r\n```\r\n\r\n\r\n## 백준 11003번 - 최솟값 찾기\r\n---\r\n\r\n![11003번](11003pb1.PNG)\r\n![11003번](11003pb2.PNG)\r\n\r\n---\r\n\r\n### 풀이\r\n---\r\n\r\n문제를 보면 범위가 심상치 않다.....ㅋㅋㅋ\r\n\r\n문제가 좀 어려워서 노트로 작성하면서 정리했다.\r\n\r\n![11003번sol](11003sol.PNG)\r\n\r\n---\r\n\r\n```java\r\npackage slidingWindow;\r\n\r\nimport java.io.*;\r\nimport java.util.*;\r\n\r\npublic class num11003 {\r\n    public static void main(String[] args) throws Exception {\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\r\n        Deque<Integer> deque = new LinkedList<>();\r\n        StringTokenizer st = new StringTokenizer(br.readLine(), \" \");\r\n        \r\n        int N = stoi(st.nextToken());\r\n        int L = stoi(st.nextToken());\r\n        \r\n        int[] arr = new int[N];\r\n        st = new StringTokenizer(br.readLine(), \" \");\r\n        \r\n        \r\n        StringBuilder sb = new StringBuilder();\r\n        for (int i = 0; i < N; i++) {\r\n        \tarr[i] = stoi(st.nextToken());\r\n            if (!deque.isEmpty() && deque.getFirst() <= i - L) {\r\n            \tdeque.removeFirst();\r\n            }\r\n            while (!deque.isEmpty() && arr[deque.getLast()] > arr[i]) {\r\n            \tdeque.removeLast();\r\n            }\r\n            deque.addLast(i);\r\n            sb.append(arr[deque.peekFirst()] + \" \");\r\n        }\r\n        bw.write(sb.toString());\r\n\t\tbw.flush();\r\n\t\tbw.close();\r\n    }\r\n    \r\n    public static int stoi(String string) {\r\n    \treturn Integer.parseInt(string);\r\n    }\r\n}\r\n```\r\n\r\n## 백준 3078번 - 좋은 친구\r\n---\r\n\r\n![3078pb1](3078pb1.PNG)\r\n![3078pb2](3078pb2.PNG)\r\n\r\n### 풀이\r\n---\r\n\r\n이전 문제를 풀었다면 어렵지 않게 풀 수 있다.\r\n\r\ncnt범위 때문에 long으로 설정해야 한다.\r\n\r\ncnt 때문에 책상 부술뻔.... 후.....하...후...하...\r\n\r\n---\r\n\r\n```java\r\npackage slidingWindow;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.LinkedList;\r\nimport java.util.Queue;\r\nimport java.util.StringTokenizer;\r\n\r\npublic class num3078 {\r\n\tstatic int N, K;\r\n\tstatic long cnt=0;\r\n\tstatic Queue[] qarr;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\r\n\t\tN = stoi(st.nextToken());\r\n\t\tK = stoi(st.nextToken());\r\n\t\t\r\n\t\tqarr = new Queue[21];\r\n\t\tfor(int i=0; i<=20; i++) {\r\n\t\t\tqarr[i] = new LinkedList<Integer>();\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tint nowLen = br.readLine().length();\r\n\t\t\t\r\n\t\t\tif(qarr[nowLen].isEmpty()) {\r\n\t\t\t\tqarr[nowLen].offer(i);\r\n\t\t\t}else {\r\n\t\t\t\twhile ((i - (int) qarr[nowLen].peek()) > K) {\r\n\t\t\t\t\tqarr[nowLen].poll();\r\n\t\t\t\t\tif (qarr[nowLen].isEmpty()) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tcnt += qarr[nowLen].size();\r\n\t\t\t\tqarr[nowLen].offer(i);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(cnt);\r\n\t}\r\n\t\r\n\tstatic int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\r\n}\r\n\r\n```\r\n\r\n# Reference\r\n[라이님 블로그](https://m.blog.naver.com/kks227/220795165570)","excerpt":"슬라이딩 윈도우 투포인터 알고리즘과 비슷하지만 슬라이딩 윈도우는 어느 순간에도 그 구간의 넓이가 동일하다  -> 사용하지 않는 값을 삭제하거나 갱신하는 기법이다. 백준 2096번 - 내려가기 \n 풀이 이 문제는 슬라이딩 윈도우 + DP문제다.  문제…","fields":{"slug":"/slidingWindow/"},"frontmatter":{"date":"Feb 03, 2021","title":"슬라이딩 윈도우 정리","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n# 구간합 배열\r\n> 전처리를 통해 모든 부분합을 O(1)으로 구할 수 있는 방법\r\n\r\n\r\n```\r\n1. 원래 배열 이외에 pSum배열을 추가로 하나 만들어 준다. \r\n2. pSum[x] 배열에는 앞에서 부터 x개 원소의 합을 저장한다.\r\n  -> pSum[i+1] = pSum[i] + A[i]\r\n\r\n```\r\n\r\n## 백준 11659 - 구간 합 구하기4\r\n\r\n---\r\n\r\n![11659](11659pb1.PNG)\r\n\r\n---\r\n\r\n### 풀이\r\n\r\npSum[i+1] - pSum[j]를 해주면 된다.\r\n\r\n---\r\n\r\n```java\r\npackage sumOfInterval;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class num11659 {\r\n\tstatic int N, M;\r\n\tstatic int[] arr, pSum;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\tString[] NM = br.readLine().split(\" \");\r\n\t\t\r\n\t\tN = stoi(NM[0]);\r\n\t\tM = stoi(NM[1]);\r\n\t\t\r\n\t\tarr = new int[N];\r\n\t\tpSum = new int[N+1];\r\n\t\t\r\n\t\tString[] arrData = br.readLine().split(\" \");\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tarr[i] = stoi(arrData[i]);\r\n\t\t\tpSum[i+1] = arr[i] + pSum[i];\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<M; i++) {\r\n\t\t\tString[] AB = br.readLine().split(\" \");\r\n\t\t\tint a = stoi(AB[0])-1;\r\n\t\t\tint b = stoi(AB[1])-1;\r\n\t\t\t\r\n\t\t\tsb.append(pSum[b+1] - pSum[a] + \"\\n\");\r\n\t\t}\r\n\t\tSystem.out.println(sb);\r\n\t}\r\n\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n}\r\n\r\n```\r\n\r\n## 백준 11660 - 구간 합 구하기5\r\n\r\n---\r\n\r\n![11660](11660pb1.PNG)\r\n![11660](11660pb2.PNG)\r\n![11660](11660pb3.PNG)\r\n\r\n---\r\n\r\n### 풀이\r\n\r\n이전 문제와 비슷한데 2차원 배열을 사용해 pSum을 저장한다.\r\n\r\n빼줄 때 범위 설정에 주의한다.\r\n\r\n---\r\n\r\n```java\r\npackage sumOfInterval;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class num11660 {\r\n\tstatic int N, M, x1, x2, y1, y2;\r\n\tstatic int[][] map, pSum;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException{\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\r\n\t\tString[] NM = br.readLine().split(\" \");\r\n\t\tN = stoi(NM[0]);\r\n\t\tM = stoi(NM[1]);\r\n\t\tmap = new int[N+1][N+1];\r\n\t\tpSum = new int[N+2][N+2];\r\n\t\t\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tString[] row = br.readLine().split(\" \");\r\n\t\t\tfor(int j=0; j<N; j++) {\r\n\t\t\t\tmap[i][j] = stoi(row[j]);\r\n\t\t\t\tpSum[i+1][j+1] = pSum[i+1][j] + pSum[i][j+1] - pSum[i][j] + map[i][j];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=1; i<=M; i++) {\r\n\t\t\tString[] point = br.readLine().split(\" \");\r\n\t\t\tx1 = stoi(point[0]);\r\n\t\t\ty1 = stoi(point[1]);\r\n\t\t\tx2 = stoi(point[2]);\r\n\t\t\ty2 = stoi(point[3]);\r\n\t\t\t\r\n\t\t\tsb.append(pSum[x2][y2] - pSum[x1-1][y2] - pSum[x2][y1-1] + pSum[x1-1][y1-1] + \"\\n\");\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(sb.toString());\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n}\r\n\r\n```\r\n\r\n## 백준 10211 - Maximum Subarray\r\n\r\n---\r\n\r\n![10211](10211pb1.PNG)\r\n![10211](10211pb2.PNG)\r\n\r\n---\r\n\r\n### 풀이\r\n---\r\n```\r\n1\r\n2\r\n-7 5\r\n```\r\n\r\n별 생각 없이 풀다가 위 CASE에 걸리는 걸 알았다.\r\n\r\n**전까지 합이 음수고, 새롭게 들어온 값이 양수라면 새롭게 들어온 값부터 더해준 값이 최대값이다.**\r\n\r\n위 문장에 대한 처리를 해야한다.\r\n\r\n---\r\n\r\n```java\r\npackage sumOfInterval;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class num10211 {\r\n\tstatic int N, X, MAX;\r\n\tstatic int[] arr, pSum;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\r\n\t\tN = stoi(br.readLine());\r\n\t\t\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tMAX = Integer.MIN_VALUE;\r\n\t\t\tX = stoi(br.readLine());\r\n\t\t\tString[] arrData = br.readLine().split(\" \");\r\n\t\t\tarr = new int[X];\r\n\t\t\tpSum = new int[X+1];\r\n\t\t\t\r\n\t\t\tfor(int j=0; j<X; j++) {\r\n\t\t\t\tarr[j] = stoi(arrData[j]);\r\n\t\t\t\tpSum[j+1] = Math.max(pSum[j], 0) + arr[j];\r\n\t\t\t\tMAX = MAX > pSum[j+1] ? MAX : pSum[j+1];\r\n\t\t\t}\r\n\t\t\tsb.append(MAX+\"\\n\");\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(sb.toString());\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n}\r\n\r\n```\r\n\r\n## 백준 10986 - 나머지 합\r\n\r\n---\r\n\r\n![10986](10986pb1.PNG)\r\n![10986](10986pb2.PNG)\r\n\r\n---\r\n\r\n### 풀이\r\n\r\n이 문제는 발상의 전환이 필요하다.\r\n\r\npSum[j] % M 와 pSum[i] % M 나머지가 같으면 나누어 떨어지는 구간이다.  \r\n -> M으로 나눴을 때 나머지를 저장하는 누적합 배열을 만든다.  \r\n -> 나머지의 개수를 저장하는 배열을 하나 더 만들어서 나머지에 대한 개수를 저장한다.  \r\n -> 나머지의 순서에 상관없이 2개씩 뽑는 개수를 모두 더한다.   \r\n\r\n---\r\n\r\n```java\r\npackage sumOfInterval;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class num10986 {\r\n\tstatic long N, M, ans;\r\n\tstatic long[] cnt, pSum;\r\n\tstatic final int MAX = 1000000 + 1;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tString[] NM = br.readLine().split(\" \");\r\n\t\t\r\n\t\tN = stol(NM[0]);\r\n\t\tM = stol(NM[1]);\r\n\t\tcnt = new long[(int)M];\r\n\t\tpSum = new long[(int)N+1];\r\n\t\t\r\n\t\tString[] arrData = br.readLine().split(\" \");\r\n\t\tfor(int i=1; i<=N; i++) {\r\n\t\t\tlong num = stol(arrData[i-1]);\r\n\t\t\tpSum[i] = (pSum[i - 1] + num) % M;\r\n\t\t\tcnt[(int) pSum[i]]++;\r\n\t\t\tif(pSum[i] == 0) ans++;\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i = 0 ; i < M ; ++i) {\r\n\t\t\tans += cnt[i] * (cnt[i] - 1) / 2;\r\n\t\t}\r\n\t\tSystem.out.println(ans);\r\n\t}\r\n\tpublic static long stol(String string) {\r\n\t\treturn Long.parseLong(string);\r\n\t}\r\n\r\n}\r\n\r\n```\r\n\r\n# Reference\r\n[라이님 블로그](https://m.blog.naver.com/kks227/220787178657)  ","excerpt":"구간합 배열 전처리를 통해 모든 부분합을 O(1)으로 구할 수 있는 방법 백준 11659 - 구간 합 구하기4  풀이 pSumi+1 - pSumj를 해주면 된다. 백준 11660 - 구간 합 구하기5 \n\n 풀이 이전 문제와 비슷한데 2차원 배열을 사…","fields":{"slug":"/prefixSum/"},"frontmatter":{"date":"Feb 02, 2021","title":"구간합(Prefix Sum) 배열","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n# 투 포인터 알고리즘\r\n---\r\n\r\n> 리스트에 순차적으로 접근해야 할 때 2개의 점의 위치를 기록하면서 처리하는 알고리즘을 의미한다.  \r\n\r\n -> **2개의 점을 무조건 증가시키는 방향으로 변화하면서 횟수 계산**\r\n\r\nTip!!  \r\n -> 연속된 값을 이용해 풀어나가는 문제에 한정적으로 사용해야 한다.\r\n (정렬을 통해 연속성을 줄 수 있다.)\r\n\r\n## 백준 2470 - 두 용액\r\n---\r\n\r\n![2470pb1](2470pb1.PNG)\r\n![2470pb2](2470pb2.PNG)\r\n\r\n---\r\n소스를 간략히 설명해보면\r\n\r\n1. end점을 마지막, start점을 처음값을 가르키게 설정한다.\r\n\r\n2. 입력받은 값을 정렬\r\n\r\n3. sum값이 0보다 크면 end점의 index를 -1해주고, 0보다 작으면 start값을 +1해준다.\r\n   (두 점이 가운데로 모이면서 진행된다.)\r\n\r\n---\r\n\r\n```java\r\npackage package25;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.Arrays;\r\n\r\npublic class num2470 {\r\n\tstatic int N, s = 0, e, sum = 0, min = Integer.MAX_VALUE;\r\n\tstatic int[] arr, result;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tN = stoi(br.readLine());\r\n\t\te = N-1;\r\n\t\tarr = new int[N];\r\n\t\tresult = new int[2];\r\n\t\t\r\n\t\tString[] inputData = br.readLine().split(\" \");\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tarr[i] = stoi(inputData[i]);\r\n\t\t}\r\n\t\tArrays.sort(arr);\r\n\t\t\r\n\t\tgetResult();\r\n\t\t\r\n\t\tSystem.out.println(result[0] + \" \" + result[1]);\r\n\t}\r\n\t\r\n\tpublic static void getResult() {\r\n\t\twhile(s < e) {\r\n\t\t\tsum = arr[s] + arr[e];\r\n\t\t\tif(min > Math.abs(sum)) {\r\n\t\t\t\tmin = Math.abs(sum);\r\n\t\t\t\tresult[0] = arr[s];\r\n\t\t\t\tresult[1] = arr[e];\r\n\t\t\t}\r\n\t\t\tif(sum > 0) e--;\r\n\t\t\telse s++;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n}\r\n\r\n```\r\n\r\n## 백준 1806 - 부분 합\r\n---\r\n\r\n![1806pb1](1806pb1.PNG)\r\n![1806pb2](1806pb2.PNG)\r\n\r\n---\r\n\r\n연속 된 수들의 부분합이니 정렬 할 필요는 없다.\r\n\r\n입력받은 S값 보다 작으면 end점을 늘려주고 S값 보다 크면 S점을 늘려준다.\r\n\r\n---\r\n\r\n```java\r\npackage package25;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class num1806 {\r\n\tstatic int INF = Integer.MAX_VALUE;\r\n\tstatic int N, S, result=INF, sum = 0, s = 0, e = 0;\r\n\tstatic int[] arr;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tString[] NS = br.readLine().split(\" \");\r\n\t\tN = stoi(NS[0]);\r\n\t\tS = stoi(NS[1]);\r\n\t\tarr = new int[N];\r\n\t\t\r\n\t\tString[] inputArr = br.readLine().split(\" \");\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tarr[i] = stoi(inputArr[i]);\r\n\t\t}\r\n\t\t\r\n\t\tcalcCount();\r\n\t\t\r\n\t\tresult = result == INF ? 0 : result;\r\n\t\tSystem.out.println(result);\r\n\t}\r\n\t\r\n\tpublic static void calcCount() {\r\n\t\twhile(true) {\r\n\t\t\tif(sum >= S) {\r\n\t\t\t\tsum-=arr[s++];\r\n\t\t\t\tresult = Math.min(result, (e-s)+1);\r\n\t\t\t}else if(e == N) break;\r\n\t\t\telse sum+=arr[e++];\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n}\r\n\r\n```\r\n\r\n## 백준 1450 - 냅색 문제\r\n\r\n이 문제가 어려웠다.\r\n\r\n이 친구는 **Meet in the 알고리즘**을 사용한다.\r\n\r\n### Meet in the 알고리즘이란?\r\n\r\n> 구간을 반으로 나눈다.\r\n\r\n범위를 2개로 나누면  \r\n -> O(2^n)의 시간복잡도가 O(2^(N/2)) 시간으로 줄어든다.\r\n\r\n---\r\n\r\n![1450pb1](1450pb1.PNG)\r\n![1450pb2](1450pb2.PNG)\r\n\r\n---\r\n\r\n앞쪽과 뒤쪽으로 범위를 나눈다. 양쪽 구간에서 가능한 모든 합을 구해다 정렬하고 \r\n\r\n한쪽 값들을 순회하면서 다른 구간를 탐색하면서 모든 합을 확인하고 C값보다 작거나 같은 값이 몇개인지 이분 탐색을 사용해 찾는다.\r\n\r\n배열의 index값을 사용하기 때문에 count계산할 때 +1을 해주거나, 입력 받을 때 배열값을 장난쳐놔야 한다.\r\n\r\n---\r\n\r\n```java\r\npackage package25;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\n\r\npublic class num1450 {\r\n\tstatic int N, C, count =0, index;\r\n\tstatic int[] arr;\r\n\tstatic ArrayList<Integer> left, right;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tString[] NC = br.readLine().split(\" \");\r\n\t\tN = stoi(NC[0]);\r\n\t\tC = stoi(NC[1]);\r\n\t\tarr = new int[N];\r\n\t\t\r\n\t\tString[] arrData = br.readLine().split(\" \");\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tarr[i] = stoi(arrData[i]);\r\n\t\t}\r\n\t\t\r\n\t\tleft = new ArrayList<Integer>();\r\n\t\tright = new ArrayList<Integer>();\r\n\t\t\r\n\t\tcalcPart(0,N/2,0,left);\r\n\t\tcalcPart(N/2+1,N-1,0,right);\r\n\t\t\r\n\t\tCollections.sort(right);\r\n\t\t\r\n\t\tfor (int i = 0; i < left.size(); i++) {\r\n            index = 0;\r\n            binarySearch(0, right.size() - 1, left.get(i));\r\n            count += index +1;\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(count);\r\n\t}\r\n\t\r\n    static void binarySearch(int start, int end, int val) {\r\n        if (start > end) {\r\n            return;\r\n        }\r\n\r\n        int mid = (start + end) / 2;\r\n\r\n        if (right.get(mid) + val <= C) {\r\n            index = mid;\r\n            binarySearch(mid + 1, end, val);\r\n        } else {\r\n            binarySearch(start, mid - 1, val);\r\n        }\r\n    }\r\n\r\n\tpublic static void calcPart(int s, int e, int sum, ArrayList<Integer> list) {\r\n\t\tif (sum > C) return;\r\n\t\tif (s > e) {\r\n\t\t\tlist.add(sum);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tcalcPart(s + 1, e, sum, list);\r\n\t\tcalcPart(s + 1, e, sum + arr[s], list);\r\n\t}\r\n\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n}\r\n\r\n```\r\n\r\n1450번 문제 풀면서 배열 index때문에 삽질을 너무 오래했다 ㅜㅜ\r\n\r\nmeet in the middle 알고리즘은 정리 한번 하고 문제 좀 더 풀어봐야 겠다.\r\n\r\n\r\n# Reference \r\n[라이님 블로그](https://m.blog.naver.com/kks227/220795165570)  \r\n[meet in the middle 알고리즘 - 반으로 쪼갠다. - chogahui05님 블로그](https://blog.naver.com/chogahui05/221374387858)  \r\n이것이 코딩테스트다 - 나동빈","excerpt":"투 포인터 알고리즘 리스트에 순차적으로 접근해야 할 때 2개의 점의 위치를 기록하면서 처리하는 알고리즘을 의미한다.    -> 2개의 점을 무조건 증가시키는 방향으로 변화하면서 횟수 계산 Tip!!  -> 연속된 값을 이용해 풀어나가는 문제에 한정적…","fields":{"slug":"/twoPoint/"},"frontmatter":{"date":"Feb 01, 2021","title":"투포인터 알고리즘","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n백준 단계별 문제 - 투포인터에 있는 1644번 문제를 풀다 소수 구하는 알고리즘이 생각이 안나서 정리 해둘 겸 포스팅한다.\r\n\r\n# 에라토스테네스의 체란?\r\n \r\n> 소수가 되는 수의 배수를 지우면 남는 건 소수가 된다\r\n\r\n요런 알고리즘이다.\r\n\r\n![위키 이미지](era.gif)\r\n\r\n## 백준 1644 - 소수의 연속 합\r\n---\r\n\r\n```\r\n1. 에라토스테네스의 체로 소수 구하는 방법을 활용해 소수를 구한다.\r\n2. 투포인터 알고리즘을 활용해 연속 합 확인\r\n```\r\n\r\n![1644pb1](1644pb1.PNG)\r\n![1644pb2](1644pb2.PNG)\r\n\r\n\r\n---\r\n\r\n```java\r\npackage package25;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\n\r\npublic class num1644 {\r\n\tstatic int N, sum = 0, s = 0, e = 0, count = 0;\r\n\tstatic boolean primeCheckArr[];\r\n\tstatic ArrayList<Integer> primeList;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tN = stoi(br.readLine());\r\n\t\tprimeCheckArr = new boolean[N+1];        \r\n        primeList = new ArrayList<Integer>();\r\n        \r\n        getPrimeNumber();\r\n        \r\n        getCountResult();\r\n        \r\n        System.out.println(count);\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic static void getCountResult() {\r\n\t\twhile(true) {\r\n\t\t\tif(sum>=N) sum-=primeList.get(s++);\r\n\t\t\telse if(e == primeList.size()) break;\r\n\t\t\telse sum+=primeList.get(e++);\r\n\t\t\tif(sum == N) count++;\t\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static void getPrimeNumber() {\r\n\t\tprimeCheckArr[0] = primeCheckArr[1] = true;  \r\n\t\t\r\n        for(int i=2; i*i<=N; i++){\r\n            if(!primeCheckArr[i]) {\r\n            \tfor(int j=i*i; j<=N; j+=i)\r\n            \t\tprimeCheckArr[j]=true;                \r\n            }\r\n        }\r\n        \r\n        for(int i=1; i<=N;i++){\r\n        \tif(!primeCheckArr[i]) primeList.add(i); \r\n        }\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\r\n}\r\n```\r\n\r\n---\r\n추가로 소수를 구하는 부분의 for문을 살펴보면 \r\n\r\n```java\r\nfor(int i=2; i*i<=N; i++){\r\n    if(!primeCheckArr[i]) {\r\n    \tfor(int j=i*i; j<=N; j+=i)\r\n    \t\tprimeCheckArr[j]=true;                \r\n    }\r\n}\r\n```\r\n\r\n특정한 소수의 제곱근 까지만 구하면 된다\r\n -> 약수가 아닌경우는 수가 대칭을 이루기 때문\r\n\r\n# Reference\r\n\r\n[위키 백과](https://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4)  ","excerpt":"백준 단계별 문제 - 투포인터에 있는 1644번 문제를 풀다 소수 구하는 알고리즘이 생각이 안나서 정리 해둘 겸 포스팅한다. 에라토스테네스의 체란? 소수가 되는 수의 배수를 지우면 남는 건 소수가 된다 요런 알고리즘이다. 위키 이미지 백준 1644 …","fields":{"slug":"/primeNumber/"},"frontmatter":{"date":"Feb 01, 2021","title":"소수 구하기 - 에라토스테네스의 체","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n# 서로소 집합 자료구조란?\r\n---\r\n\r\n> 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조\r\n\r\nUnion-Find Algorithm 은 그래프내 셀프루프 (self-loop : 자기자신을 가리키는 간선)을 포함하면  \r\n안되고 **무방향그래프에서 사이클 찾는데 유용**\r\n\r\n**Union, find 2개의 연산**이 있다.\r\n\r\n\r\n## 전제 조건\r\n---\r\n\r\n> 같은 집합에 포함되어 있는 정점들끼리는 이미 간선으로 연결 된 것이고, 다른 집합의 정점과는 서로 연결되지 않았다는 것을 기반한다.\r\n\r\n## 1. Union 연산\r\n---\r\n> 2개의 원소가 포함된 집함을 하나의 집합으로 합치는 연산\r\n\r\n- Union연산은 간선으로 표현된다.\r\n  (실제로는 트리 구조)\r\n\r\n## 2. Find 연산\r\n---\r\n\r\n> 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산\r\n\r\n- 경로 압축 기법을 적용해 시간 복잡도를 개선한다. \r\n- 경로압축이란? \r\n  - 여기선 find함수를 재귀적으로 호출한 뒤에 부모 테이블 값을 갱신하는 기법을 말함\r\n\r\n## 시간 복잡도\r\n---\r\n\r\n노드의 개수 : V , 최대 V-1개의 union 연산과 M개의 find연산이 가능할 때  \r\n -> O(V + M(1+log~2-M/V~V))  \r\n (O(1)이라고 생각하면 된다고 한다.)\r\n\r\n## 구현\r\n---\r\n```\r\n1. 초기값 자기 자신을 원소로 가지고 있게 설정\r\n2. 간선을 확인하며 두 노드의 루트 노드를 확인.\r\n   2-1. 루트 노드가 서로 다르면 두 노드에 대하여 union 연산을 수행\r\n   2-2. 루트 노드가 같다면 사이클이 발생\r\n3. 그래프에 포함되어 있는 모든 간선에 대하여 과정을 반복\r\n```\r\n\r\n## Tip!!\r\n> 유니온파인드는 상황에 따라 **여러가지 정보 추가 가능**\r\n\r\n# 백준 1717번\r\n---\r\n\r\n![1717pb1](1717pb1.PNG)\r\n![1717pb2](1717pb2.PNG)\r\n\r\n\r\n---\r\n\r\n위에서 설명했던 그대로 Union함수와 Find함수를 구현했다.\r\n\r\n---\r\n\r\n```java\r\npackage package28;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class num1717 {\r\n\tstatic int N, M;\r\n\tstatic int[] parent;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\tString[] NM = br.readLine().split(\" \");\r\n\t\t\r\n\t\tN = stoi(NM[0]);\r\n\t\tM = stoi(NM[1]);\r\n\t\tparent = new int[N];\r\n\t\t\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tparent[i] = i;\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<M; i++) {\r\n\t\t\tString[] inputData = br.readLine().split(\" \");\r\n\t\t\t\r\n\t\t\tint action = stoi(inputData[0]);\r\n\t\t\tint a = stoi(inputData[1])-1;\r\n\t\t\tint b = stoi(inputData[2])-1;\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tif(action == 0) {\r\n\t\t\t\tunion(a,b);\r\n\t\t\t}else {\r\n\t\t\t\tsb.append(find_parent(a) == find_parent(b) ? \"YES\" : \"NO\");\r\n\t\t\t\tsb.append(\"\\n\");\r\n\t\t\t}\r\n\t\t}\r\n\t\tSystem.out.println(sb);\r\n\t}\r\n\t\r\n\tpublic static int find_parent(int num) {\r\n\t\tif(parent[num] != num)\r\n\t\t\tparent[num] = find_parent(parent[num]);\r\n\t\treturn parent[num];\r\n\t}\r\n\t\r\n\tpublic static void union(int a, int b) {\r\n\t\tint aParent = find_parent(a);\r\n\t\tint bParent = find_parent(b);\r\n\t\tif(aParent<bParent)\r\n\t\t\tparent[b] = a;\r\n\t\telse\r\n\t\t\tparent[a] = b;\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\r\n}\r\n\r\n```\r\n\r\n\r\n# 백준 1976번\r\n---\r\n\r\n![1976pb1](1976pb1.PNG)\r\n![1976pb2](1976pb2.PNG)\r\n\r\n\r\n---\r\n\r\n1717번 문제와 거의 동일하다.\r\n\r\n마지막에 입력받은 값들이 하나의 부모노드를 가지고 있는지 알아보면 된다.\r\n\r\n---\r\n\r\n```java\r\npackage package28;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.StringTokenizer;\r\n\r\npublic class num1976 {\r\n\tstatic int N, M;\r\n\tstatic int[] parent;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tN = stoi(br.readLine());\r\n\t\tM = stoi(br.readLine());\r\n\t\tparent = new int[N+1];\r\n\t\t\r\n\t\tfor(int i=1; i<=N; i++) {\r\n\t\t\tparent[i] = i;\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=1; i<=N; i++) {\r\n\t\t\tString[] inputData = br.readLine().split(\" \");\r\n\t\t\tfor(int j=0; j<N; j++) {\r\n\t\t\t\tint num = stoi(inputData[j]);\r\n\t\t\t\tif(num == 1) {\r\n\t\t\t\t\tunion(i, j+1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tString[] map = br.readLine().split(\" \");\r\n\t\tboolean resultIndex = true;\r\n\t\tint index = parent[stoi(map[0])];\r\n\t\t\r\n\t\tfor(int i=1; i<map.length; i++) {\r\n\t\t\tif(index != parent[stoi(map[i])])\r\n\t\t\t\tresultIndex = false;\r\n\t\t}\r\n\t\tSystem.out.println(resultIndex == true ? \"YES\" : \"NO\");\r\n\t}\r\n\t\r\n\tpublic static int find_parent(int num) {\r\n\t\tif(parent[num] == num)\r\n\t\t\treturn num;\r\n\t\treturn parent[num] = find_parent(parent[num]);\r\n\t}\r\n\t\r\n\tpublic static void union(int a, int b) {\r\n\t\ta = find_parent(a);\r\n\t\tb = find_parent(b);\r\n\t\tif (a != b) {\r\n            if (a < b) {\r\n                parent[b] = a;\r\n            } else {\r\n                parent[a] = b;\r\n            }\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n}\r\n\r\n```\r\n\r\n# 백준 4195번\r\n---\r\n\r\n![4195pb1](4195pb1.PNG)\r\n![4195pb2](4195pb2.PNG)\r\n\r\n\r\n---\r\n\r\n이문제는 위의 문제들과 다르게 입력값이 문자열로 들어온다.\r\n\r\nHashMap을 사용해서 문자열마다 index를 할당해주는 방식으로 구현했다.\r\n\r\n---\r\n\r\n```java\r\npackage package28;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.Arrays;\r\nimport java.util.HashMap;\r\n\r\npublic class num4195 {\r\n\tstatic int N, F, index;\r\n\tstatic HashMap<String, Integer> map;\r\n\tstatic int[] parent;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\tN = stoi(br.readLine());\r\n\t\t\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tmap = new HashMap<String, Integer>();\r\n\t\t\tindex = 1;\r\n\t\t\t\r\n\t\t\tF = stoi(br.readLine());\r\n\t\t\tparent = new int[2*F+1];\r\n\t\t\tArrays.fill(parent, -1);\r\n\t\t\t\r\n\t\t\tfor(int j=0; j<F; j++) {\r\n\t\t\t\tString[] inputData = br.readLine().split(\" \");\r\n\t\t\t\tint v1 = getMapValue(inputData[0]);\r\n\t\t\t\tint v2 = getMapValue(inputData[1]);\r\n\t\t\t\tint result = union(v1,v2);\r\n\t\t\t\tsb.append(result+\"\\n\");\r\n\t\t\t}\r\n\t\t}\r\n\t\tSystem.out.println(sb.toString());\r\n\t}\r\n\t\r\n\tpublic static int find_parent(int num) {\r\n\t\tif(parent[num] < 0)\r\n\t\t\treturn num;\r\n\t\treturn parent[num] = find_parent(parent[num]);\r\n\t}\r\n\t\r\n\tpublic static int union(int a, int b) {\r\n\t\ta = find_parent(a);\r\n\t\tb = find_parent(b);\r\n\t\tif (a != b) {\r\n            if (a < b) {\r\n            \tparent[a] += parent[b];\r\n                parent[b] = a;\r\n            } else {\r\n            \tparent[b] += parent[a];\r\n                parent[a] = b;\r\n            }\r\n\t\t}\r\n\t\treturn parent[a] < 0 ? parent[a] : parent[b];\r\n\t}\r\n\t\r\n\tpublic static int getMapValue(String string) {\r\n\t\tif(!map.containsKey(string)) {\r\n\t\t\tmap.put(string, index);\r\n\t\t\tindex++;\r\n\t\t}\r\n\t\treturn map.get(string);\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n}\r\n\r\n```\r\n\r\n# 백준 20040번\r\n---\r\n\r\n![20045pb1](20045pb1.PNG)\r\n![20045pb2](20045pb2.PNG)\r\n![20045pb3](20045pb3.PNG)\r\n\r\n\r\n---\r\n\r\n이문제는 첫번째, 두번째 문제와 비슷한데  \r\n사이클이 존재하면 사이클이 걸린 입력순서를 출력해주는 문제다.\r\n\r\n\r\n---\r\n\r\n```java\r\npackage package28;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.Arrays;\r\nimport java.util.StringTokenizer;\r\n\r\npublic class num20040 {\r\n\tstatic int N, M;\r\n\tstatic int[] parent;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tStringTokenizer st;\r\n\t\t\r\n\t\tint index = 0;\r\n\t\tst = new StringTokenizer(br.readLine());\r\n\t\tN = stoi(st.nextToken());\r\n\t\tM = stoi(st.nextToken());\r\n\t\tparent = new int[N+1];\r\n\t\tfor(int i =0; i<=N; i++) {\r\n\t\t\tparent[i] = i;\r\n\t\t}\r\n\t\tfor(int i=0; i<M; i++) {\r\n\t\t\tst = new StringTokenizer(br.readLine());\r\n\t\t\tint v1 = stoi(st.nextToken());\r\n\t\t\tint v2 = stoi(st.nextToken());\r\n\t\t\tif(!union(v1,v2)) {\r\n\t\t\t\tindex = i+1;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tSystem.out.println(index);\r\n\t}\r\n\t\r\n\tpublic static boolean union(int a, int b) {\r\n\t\ta = find_parent(a);\r\n\t\tb = find_parent(b);\r\n\t\tif(a==b)\r\n\t\t\treturn false;\r\n\t\tif(a!=b) {\r\n\t\t\tif(a < b) {\r\n\t\t\t\tparent[b] = a;\r\n\t\t\t}else {\r\n\t\t\t\tparent[a] = b;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tpublic static int find_parent(int num) {\r\n\t\tif(parent[num] == num)\r\n\t\t\treturn num;\r\n\t\treturn parent[num] = find_parent(parent[num]);\r\n\t}\r\n\t\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n}\r\n\r\n```\r\n\r\n블로그와 책을 읽고 유니온 파인드 개념을 정리해보았다.  \r\n\r\n유니온 파인드는 **최소신장트리**에 이용된다고  한다.  \r\n궁금하니 빠른 시일내로 공부해야겠다 ㅋㅋ    \r\n\r\n# Referece\r\n[라이님 블로그](https://m.blog.naver.com/kks227/220791837179)  \r\n[잭팟53님 블로그](https://jackpot53.tistory.com/)  \r\n이것이 취업을 위한 코딩 테스트다 - 나동빈  ","excerpt":"서로소 집합 자료구조란? 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조 Union-Find Algorithm 은 그래프내 셀프루프 (self-loop : 자기자신을 가리키는 간선)을 포함하면 안되고 무방향그래프에서 사이클 찾…","fields":{"slug":"/unionFind/"},"frontmatter":{"date":"Jan 29, 2021","title":"Union Find 정리","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n머리 식힐 겸 재밌어 보이는 문제 찾다가 풀어봤다.\r\n\r\n## 문제\r\n\r\n![15686pb1](15686pb1.PNG)\r\n![15686pb2](15686pb2.PNG)\r\n![15686pb3](15686pb3.PNG)\r\n![15686pb4](15686pb4.PNG)\r\n\r\n## 풀이\r\n\r\n풀이는 다음과 같다.\r\n```\r\n1. 조합으로 치킨 집 구함\r\n2. 치킨 집에서 집까지 거리를 찾는다.\r\n3. 구한 거리의 합이 현재 가지고 있는 최솟값보다 작으면 교체\r\n```\r\n\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\n\r\npublic class Main {\r\n\tstatic int N, M, result = Integer.MAX_VALUE;\r\n\tstatic ArrayList<House> house;\r\n\tstatic ArrayList<Chicken> chicken;\r\n\tstatic int[] houseLen;\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tString[] NM = br.readLine().split(\" \");\r\n\t\tN = stoi(NM[0]);\r\n\t\tM = stoi(NM[1]);\r\n\t\tboolean[] visited = new boolean[14];\r\n\t\thouse = new ArrayList<House>();\r\n\t\tchicken = new ArrayList<Chicken>();\r\n\t\t\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tString[] inputData = br.readLine().split(\" \");\r\n\t\t\tfor(int j=0; j<N; j++) {\r\n\t\t\t\tint num = stoi(inputData[j]);\r\n\t\t\t\tif(num == 0) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}else if(num == 1) {\r\n\t\t\t\t\thouse.add(new House(i,j));\r\n\t\t\t\t}else {\r\n\t\t\t\t\tchicken.add(new Chicken(i,j));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\thouseLen = new int[house.size()];\r\n\t\tcombination(visited, 0, chicken.size(), M);\r\n\t\tSystem.out.println(result);\r\n\t\t\r\n\t}\r\n\tpublic static void combination(boolean[] visited, int start, int n, int r) {\r\n\t\tif(r==0) {\r\n\t\t\tint len = 0;\r\n\t\t\tint index = 0;\r\n\t\t\tArrayList<Chicken> ncr = new ArrayList<Chicken>();\r\n\t\t\tfor(int i=0; i<visited.length; i++) {\r\n\t\t\t\tif(visited[i]==true) {\r\n\t\t\t\t\tncr.add(chicken.get(i));\r\n\t\t\t\t\tindex++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlen = calcMinLen(ncr);\r\n\t\t\tresult = result < len ? result : len;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfor(int i=start; i<n; i++) {\r\n\t\t\tvisited[i] = true;\r\n\t\t\tcombination(visited, i+1, n, r-1);\r\n\t\t\tvisited[i] = false;\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic static int calcMinLen(ArrayList<Chicken> c) {\r\n\t\tint minLen = 0;\r\n\t\tArrays.fill(houseLen, Integer.MAX_VALUE);\r\n\t\tfor(int i=0; i<c.size(); i++) {\r\n\t\t\tChicken now = c.get(i);\r\n\t\t\tfor(int k=0; k<house.size(); k++) {\r\n\t\t\t\tint houseNowLen = Math.abs(now.x - house.get(k).x) + Math.abs(now.y - house.get(k).y);\r\n\t\t\t\thouseLen[k] = houseLen[k] < houseNowLen ? houseLen[k] : houseNowLen;\r\n\t\t\t}\r\n//\t\t\tSystem.out.println(now.x + \" \" + now.y);\r\n\t\t}\r\n\t\tfor(int i=0; i<houseLen.length; i++) {\r\n\t\t\tminLen += houseLen[i];\r\n//\t\t\tSystem.out.println(houseLen[i]);\r\n\t\t}\r\n//\t\tSystem.out.println(minLen);\r\n\t\t\r\n\t\treturn minLen;\r\n\t}\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\r\n\tstatic class Chicken{\r\n\t\tint x, y;\r\n\t\tChicken(int x, int y){\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t}\r\n\t}\r\n\tstatic class House{\r\n\t\tint x, y;\r\n\t\tHouse(int x, int y){\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n```\r\n\r\n주석 해놓은 부분 주석풀고 실행해보면 과정 살펴볼 수 있다.\r\n\r\n상어들로 장난치는 문제들도 있는데 아침 공부 시작할 때 풀어보면 좋을 것 같다. \r\n\r\n끗","excerpt":"머리 식힐 겸 재밌어 보이는 문제 찾다가 풀어봤다. 문제 \n\n\n 풀이 풀이는 다음과 같다. 주석 해놓은 부분 주석풀고 실행해보면 과정 살펴볼 수 있다. 상어들로 장난치는 문제들도 있는데 아침 공부 시작할 때 풀어보면 좋을 것 같다.  끗","fields":{"slug":"/backjoon15686/"},"frontmatter":{"date":"Jan 29, 2021","title":"백준 15686 - 치킨 배달","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n트리를 정리해보자 ㅎㅎ\r\n\r\n## 특징\r\n```\r\n1. 연결 그래프\r\n2. 방향을 무시하였을 때, 싸이클이 존재하지 않는다.\r\n3. 트리의 간선개수는 정점 개수보다 1작다.\r\n```\r\n\r\n트리의 서브트리는 절대로 영역이 겹치지 않음 -> **분할정복**, **DP**로 장난을 잘 칠 줄 알아야 한다.\r\n\r\n## 순회 방법\r\n\r\n트리의 순회 방법은 3가지다.\r\n```\r\n1. 전위 순회 (root -> left -> right) \r\n2. 중위 순회 (left -> root -> right)\r\n3. 후위 순회 (left -> right -> root)\r\n```\r\n보통 BFS, DFS로 구현한다.\r\n\r\n## [백준 11725] - 트리의 부모찾기 \r\n\r\n![11725pb1](11725pb1.PNG)\r\n![11725pb2](11725pb2.PNG)\r\n\r\n### 풀이\r\n---\r\n\r\nBFS, DFS를 사용해 탐색하는 방식으로 구현했다.\r\n\r\n---\r\n```java\r\npackage package27;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\nimport java.util.LinkedList;\r\nimport java.util.Queue;\r\n\r\npublic class num11725 {\r\n\tstatic int N;\r\n\tstatic ArrayList<ArrayList<Integer>> tree;\r\n\tstatic StringBuilder sb;\r\n\tstatic int[] result;\r\n\tstatic boolean[] visited;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\ttree = new ArrayList<ArrayList<Integer>>();\r\n\t\tsb = new StringBuilder();\r\n\t\t\r\n\t\tint N = stoi(br.readLine());\r\n\t\tresult = new int[N+1];\r\n\t\tvisited = new boolean[N+1];\r\n\t\tfor(int i=0; i<=N; i++) {\r\n\t\t\ttree.add(new ArrayList<Integer>());\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<N-1; i++) {\r\n\t\t\tString[] edge = br.readLine().split(\" \");\r\n\t\t\tint node1 = stoi(edge[0]);\r\n\t\t\tint node2 = stoi(edge[1]);\r\n\r\n\t\t\ttree.get(node1).add(node2);\r\n\t\t\ttree.get(node2).add(node1);\r\n\t\t}\r\n\t\t\r\n//\t\tdfs(1);\r\n\t\tbfs();\r\n\t\t\r\n\t\tfor(int i=2; i<=N; i++) {\r\n\t\t\tSystem.out.println(result[i]);\r\n\t\t}\r\n\t}\r\n\t\r\n    private static void dfs(int num){\r\n        if(visited[num]){\r\n            return;\r\n        }\r\n        visited[num] =true;\r\n        for (int node: tree.get(num)) {\r\n            if(!visited[node]){\r\n                result[node] = num;\r\n                dfs(num);\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\t\r\n\tpublic static void bfs() {\r\n\t\tQueue<Integer> queue = new LinkedList<Integer>();\r\n\t\tfor(int value : tree.get(1)) {\r\n\t\t\tresult[value] = 1;\r\n\t\t\tqueue.add(value);\r\n\t\t}\r\n\t\t\r\n\t\twhile(!queue.isEmpty()) {\r\n\t\t\tint node = queue.remove();\r\n\t\t\t\r\n\t\t\tfor(int value : tree.get(node)) {\r\n\t\t\t\tif(result[value] == 0) {\r\n\t\t\t\t\tresult[value] = node;\r\n\t\t\t\t\tqueue.add(value);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n}\r\n\r\n```\r\n\r\n\r\n## [백준 4803] - 트리\r\n\r\n![4803pb1](4803pb1.PNG)\r\n![4803pb2](4803pb2.PNG)\r\n\r\n### 풀이\r\n\r\n아.... 이거 풀다가 책상 부실뻔 했다. 너무 헤맸다... ㅜㅜ\r\n\r\n일단 문제에 T는 트리의 개수다.\r\n\r\ndfs로 입력받은 노드 모두 탐색하고, cycle이 존재하면 no tree로 출력하게 짰는데 계속 틀렸다고 나왔다.  ㅎㅎ 정답을 알려줘\r\n\r\n열받아서 [마포 코딩박님 블로그](https://mapocodingpark.blogspot.com/2020/05/4803.html) dfs 부분을 참고해서 코드 작성했다.\r\n\r\n일단 정답은 맞췄다고 나오는데 \r\n\r\n```\r\n입력값 \r\n7 4\r\n1 2\r\n2 3\r\n3 1\r\n6 7\r\n0 0\r\n출력값 \r\nCase 1: A forest of 3 trees.\r\n```\r\n\r\n이렇게 나오는데 이거 틀린거 아님? cycle 있으면 트리 없다고 나와야 하는거 아닌가 아시는 분 알려주세요ㅜㅜㅜㅜㅜ\r\n\r\n아 짜증나 ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ 화 좀 식히고 나중에 생각나면 다시 봐야겠다...\r\n\r\n```java\r\npackage package27;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\n\r\npublic class num4803 {\r\n\tstatic int N, M, count, caseIndex = 0;\r\n\tstatic StringBuilder sb;\r\n\tstatic BufferedReader br; \r\n\tstatic ArrayList<Integer>[] graph;\r\n\tstatic boolean[] visited;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tsb = new StringBuilder();\r\n\t\t\r\n\t\twhile(true) {\r\n\t\t\tString[] NM = br.readLine().split(\" \");\r\n\t\t\t\r\n\t\t\tN = stoi(NM[0]);\r\n\t\t\tM = stoi(NM[1]);\r\n\t\t\tgraph = new ArrayList[N+1];\r\n\t\t\tvisited = new boolean[N+1];\r\n\t\t\t\r\n\t\t\tif(N==0 && M==0) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tresetData();\r\n\t\t\t\r\n\t\t\tinputTreeData();\r\n\t\t\t\r\n\t\t\tcheckTree();\r\n\t\t}\r\n\t\tSystem.out.println(sb);\r\n\t}\r\n\t\r\n\tpublic static void inputTreeData() throws IOException {\r\n\t\tfor(int i=0; i<M; i++) {\r\n\t\t\tString[] Edge = br.readLine().split(\" \");\r\n\t\t\tint v1 = stoi(Edge[0]), v2 = stoi(Edge[1]);\r\n\t\t\t\r\n\t\t\tgraph[v1].add(v2);\r\n\t\t\tgraph[v2].add(v1);\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static void checkTree() {\r\n\r\n\t\tfor(int i=1; i<=N; i++) {\r\n\t\t\tif(!visited[i]) {\r\n\t\t\t\tif(dfs(i, 0))\r\n\t\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif(count == 1) {\r\n\t\t\tsb.append(\"Case \"+caseIndex+\": There is one tree.\\n\");\r\n\t\t}else if(count==0){\r\n\t\t\tsb.append(\"Case \"+caseIndex+\": No trees.\\n\");\r\n\t\t}else {\r\n\t\t\tsb.append(\"Case \"+caseIndex+\": A forest of \"+count+\" trees.\\n\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static boolean dfs(int num, int prev) {\r\n\t\tvisited[num] = true;\r\n\t\t\r\n\t\tfor(int node : graph[num]) {\r\n\t\t\tif (node == prev) continue;\r\n\t\t\tif (visited[node]) return false;\r\n\t\t\tif (dfs(node, num) == false) return false;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tpublic static void resetData() {\r\n\t\tfor(int i=0; i<=N; i++) {\r\n\t\t\tgraph[i] = new ArrayList<Integer>();\r\n\t\t\tvisited[i] = false;\r\n\t\t}\r\n\t\tcount = 0;\r\n\t\tcaseIndex++;\r\n\t}\r\n\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n}\r\n\r\n```\r\n\r\n## [백준 1967] - 트리의 지름\r\n\r\n처음에 문제 접근하는 법을 잘못해서 좀 헤맸다.\r\n\r\n트리의 지름을 구하는 방법은 다음과 같다.\r\n\r\n```\r\n1. 트리의 임의의 정점(x)에서 가장 먼 정점(y)을 찾는다.\r\n2. 가장 먼 정점(y) 에서 가장 먼 정점(z)을 찾는다.\r\n => 지름은 y - z 까지의 거리다.\r\n```\r\n\r\n증명이 궁금하면 [전명우님 블로그 - 트리의 지름 구하기](https://blog.myungwoo.kr/112) 에 쉽게 설명한 글이 있다.  \r\n -> 한줄 요약 : 어떤 한 점에서 가장 먼 점이 지름에 무조건 포함된다 (포함 안되는 경우를 증명)\r\n\r\n![1967문제1](1967pb1.PNG)\r\n![1967문제2](1967pb2.PNG)\r\n\r\n```java\r\n\r\npackage package27;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\n\r\npublic class num1967 {\r\n\tstatic int N, result = 0, start;\r\n\tstatic ArrayList<ArrayList<Edge>> Vertex;\r\n\tstatic boolean[] visited;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tN = stoi(br.readLine());\r\n\t\tVertex = new ArrayList<ArrayList<Edge>>();\r\n\t\t\r\n\t\tfor(int i=0; i<=N; i++) {\r\n\t\t\tVertex.add(new ArrayList<Edge>());\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=1; i<N; i++) {\r\n\t\t\tString[] inputData = br.readLine().split(\" \");\r\n\t\t\tint node1 = stoi(inputData[0]);\r\n\t\t\tint node2 = stoi(inputData[1]);\r\n\t\t\tint w = stoi(inputData[2]);\r\n\t\t\t\r\n\t\t\tVertex.get(node1).add(new Edge(node2, w));\r\n\t\t\tVertex.get(node2).add(new Edge(node1, w));\r\n\t\t}\r\n\t\t\r\n\t\tvisited = new boolean[N+1];\r\n\t\tvisited[1] = true;\r\n\t\tdfs(0, 1);\r\n\t\t\r\n\t\tvisited = new boolean[N+1];\r\n\t\tvisited[start] = true;\r\n\t\tdfs(0, start);\r\n\t\t\r\n\t\tSystem.out.println(result);\r\n\t}\r\n\t\r\n\tpublic static int dfs(int len, int now) {\r\n\t\tif (result < len) {\r\n\t\t\tresult = len;\r\n\t\t\tstart = now;\r\n\t\t}\r\n\t\tSystem.out.println(now);\r\n\r\n        for (Edge node: Vertex.get(now)) {\r\n            if(!visited[node.e]){\r\n            \tvisited[node.e] = true;\r\n            \tdfs(len + node.w, node.e);\r\n            }\r\n        }\r\n        return result;\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\t\r\n\tstatic class Edge{\r\n\t\tint e, w;\r\n\t\tEdge(int e,int w){\r\n\t\t\tthis.e = e;\r\n\t\t\tthis.w = w;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n```\r\n\r\n[트리의 지름 - 백준1167](https://www.acmicpc.net/problem/1167)번 비슷한 문제다.  \r\n\r\n\r\n\r\n## [백준 2250] - 트리의 높이와 너비\r\n\r\n이문제 풀면서 많이 헤맸다ㅋㅋㅋㅋㅋㅋㅋ \r\n\r\n배열 만들어서 깊이마다 맨 오른쪽 값을 맨 왼쪽 값 빼면 될 것 같다는 생각을 했는데.....\r\n\r\n양심고백을 조금 해보면 오늘 삽질을 너무 많이 해서 고민 많이 안해보고 정답 해결 방법부터 찾아봤다.\r\n\r\n[쾌락코딩님 블로그 - 백준2250번 문제(트리의 높이와 너비) with Java](https://wooooooak.github.io/algorithm/2018/12/05/%EB%B0%B1%EC%A4%802250%EB%AC%B8%EC%A0%9C/)글을 참고했다.\r\n\r\n문제의 포인트는 3가지다.\r\n\r\n```\r\n1. 문제에서 루트가 정해져 있지 않다\r\n   -> 루트를 확인할 수 있는 뭔가 방법이 필요\r\n2. 트리의 높이마다 가장 오른쪽 값, 가장 왼쪽값 저장\r\n   -> 오른쪽 - 왼쪽 + 1\r\n3. 중위 순회로 순회\r\n   -> 그림보면 왼쪽 - 루트 - 오른쪽 순으로 index가 표시되있음\r\n```\r\n\r\n![2250pb1](2250pb1.PNG)\r\n![2250pb2](2250pb2.PNG)\r\n![2250pb3](2250pb3.PNG)\r\n\r\n### 풀이\r\n\r\n```java\r\npackage package27;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class num2250 {\r\n\tstatic int N, maxWidth, maxDepth, root, vCount = 1;\r\n\tstatic Node[] tree;\r\n\t\r\n\tstatic int[] depthLeft;\r\n\tstatic int[] depthRight;\r\n\tstatic BufferedReader br;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tN = stoi(br.readLine());\r\n\t\t\r\n\t\tinit();\r\n\t\t\r\n\t\tinputTreeData();\r\n\t\t\r\n\t\tsearchRootIndex();\r\n\t\t\r\n\t\tinOrder(root, 1);\r\n\t\t\r\n\t\tprintResult();\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic static void init() {\r\n\t\ttree = new Node[N+1];\r\n\t\tdepthLeft = new int[N+1];\r\n\t\tdepthRight = new int[N+1];\r\n\t\t\r\n\t\tfor(int i=0; i<=N; i++) {\r\n\t\t\ttree[i] = new Node(-1, -1, -1);\r\n\t\t\tdepthLeft[i] = N+1;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static void inputTreeData() throws IOException {\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tString[] inputData = br.readLine().split(\" \");\r\n\t\t\t\r\n\t\t\tint num = stoi(inputData[0]);\r\n\t\t\tint left = stoi(inputData[1]);\r\n\t\t\tint right = stoi(inputData[2]);\r\n\t\t\t\r\n\t\t\ttree[num].left = left;\r\n            tree[num].right = right;\r\n            if(left != -1)\r\n                tree[left].parent = num;\r\n            \r\n            if(right != -1)\r\n                tree[right].parent = num;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static void searchRootIndex() {\r\n\t\tfor(int i=1; i <= N; i++) {\r\n\t\t\tif(tree[i].parent == -1) {\r\n\t\t\t\troot = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static void inOrder(int parentIndex, int depth) {\r\n        Node root = tree[parentIndex];\r\n        if(maxDepth < depth) maxDepth = depth;\r\n        if(root.left != -1) {\r\n            inOrder(root.left, depth + 1);\r\n        }\r\n        \r\n        depthLeft[depth] = Math.min(depthLeft[depth], vCount);\r\n        depthRight[depth] = vCount++;\r\n        \r\n        if(root.right != -1) {\r\n            inOrder(root.right, depth + 1);\r\n        }\r\n\t}\r\n\t\r\n\tpublic static void printResult() {\r\n        int index = 1;\r\n        int maxWitdh = depthRight[1] - depthLeft[1] + 1;\r\n        for(int i=2; i <= maxDepth; i++) {\r\n            int tmp = depthRight[i] - depthLeft[i] +1;\r\n            if(maxWitdh < tmp) {\r\n            \tindex = i;\r\n            \tmaxWitdh = tmp;\r\n            }\r\n        }\r\n        \r\n        System.out.println(index + \" \" + maxWitdh);\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\t\r\n\tstatic class Node{\r\n\t\tint parent, value, left, right;\r\n\t\tNode(int value, int left, int right){\r\n\t\t\tthis.parent = -1;\r\n\t\t\tthis.value = value;\r\n\t\t\tthis.left = left;\r\n\t\t\tthis.right = right;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n```\r\n\r\n## 정리\r\n\r\n사실 트리는 학교 알고리즘 시간에 다뤄봐서 정리하는데 오래걸리지 않을 줄 알았는데 생각보다 오래걸렸다 ㅜㅜㅜㅜ 문제도 많이 풀어봐야 할 듯.... \r\n\r\n정.말.알.고.리.즘.문.제.풀.이.는.너.무.재.밌.다.하.하.하.하.하.하.하.하.하.하.하.하.하\r\n\r\n오늘 정리한 문제들은 dfs, bfs로 탐색하는 문제들이었다.\r\n\r\n\r\n아래 사진같은3 유형의 문제들도 있던데.....\r\n![finish](finish.PNG)\r\n빠른 시일내로 4문제 풀어봐야겠다. (조금 무서워 보인다ㅋ)\r\n\r\n# Reference\r\n[라이님 블로그](https://m.blog.naver.com/kks227/220788265724)  \r\n[전명우님 블로그](https://blog.myungwoo.kr/112)  \r\n[쾌락코딩님 블로그 - 백준2250번 문제(트리의 높이와 너비) with Java](https://wooooooak.github.io/algorithm/2018/12/05/%EB%B0%B1%EC%A4%802250%EB%AC%B8%EC%A0%9C/)  \r\n[마포 코딩박님 블로그](https://mapocodingpark.blogspot.com/2020/05/4803.html)  ","excerpt":"트리를 정리해보자 ㅎㅎ 특징 트리의 서브트리는 절대로 영역이 겹치지 않음 -> 분할정복, DP로 장난을 잘 칠 줄 알아야 한다. 순회 방법 트리의 순회 방법은 3가지다. 보통 BFS, DFS로 구현한다. 백준 11725 - 트리의 부모찾기 \n 풀이 …","fields":{"slug":"/tree/"},"frontmatter":{"date":"Jan 28, 2021","title":"트리","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n백준 11779, 11780, 1738번 문제를 통해 최단경로의 경로출력을 정리해보려고 한다.\r\n\r\n---\r\n\r\n# 백준 11779 - 다익스트라\r\n\r\n![11779문제 사진1](11779pb1.PNG)\r\n![11779문제 사진2](11779pb2.PNG)\r\n\r\n---\r\n\r\n소스를 간략히 설명하면\r\n\r\n다익스트라 알고리즘에 값이 조건에 맞아 갱신될 때 배열의 값에 이전 노드를 저장한다.\r\n\r\n첫 노드부터 순서대로 출력하기 위해 stack을 사용했다.\r\n\r\n---\r\n\r\n```java\r\npackage pakcage26;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\nimport java.util.PriorityQueue;\r\nimport java.util.Stack;\r\n\r\npublic class num11779 {\r\n\tstatic int N, M, count=2,INF = Integer.MAX_VALUE;\r\n\tstatic ArrayList<ArrayList<Edge>> Vertex;\r\n\tstatic int[] dist, pre;\r\n\tstatic boolean[] visited;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\r\n\t\tN = stoi(br.readLine());\r\n\t\tM = stoi(br.readLine());\r\n\t\tVertex = new ArrayList<ArrayList<Edge>>();\r\n\t\tdist = new int[N];\r\n\t\tpre = new int[N];\r\n\t\tvisited = new boolean[N];\r\n\t\t\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tVertex.add(new ArrayList<Edge>());\r\n\t\t\tdist[i] = INF;\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<M; i++) {\r\n\t\t\tString[] uvw = br.readLine().split(\" \");\r\n\t\t\tint u = stoi(uvw[0])-1;\r\n\t\t\tint v = stoi(uvw[1])-1;\r\n\t\t\tint w = stoi(uvw[2]);\r\n\t\t\tVertex.get(u).add(new Edge(v,w));\r\n\t\t}\r\n\t\tString[] point = br.readLine().split(\" \");\r\n\t\tint start = stoi(point[0])-1;\r\n\t\tint end = stoi(point[1])-1;\r\n\t\tdijkstra(start, end);\r\n\t\t\r\n\t\tlong answer =dist[end];\r\n\r\n\t\tStack<Integer> st = new Stack<Integer>();\r\n\t\tst.add(end);\r\n\t\t\r\n\t\twhile (pre[end] != start) {\r\n\t\t\tst.add(pre[end]);\r\n\t\t\tend = pre[end];\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\t\r\n\t\tst.add(start);\r\n\t\t\r\n\t\tSystem.out.println(answer);\r\n\t\tSystem.out.println(count);\r\n\t\twhile (!st.isEmpty()) {\r\n\t\t\tSystem.out.print(st.pop()+1 + \" \");\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic static void dijkstra(int start, int end) {\r\n\t\tdist[start] = 0;\r\n\t\tPriorityQueue<Edge> q = new PriorityQueue<Edge>();\r\n\t\tq.add(new Edge(start, 0));\r\n\t\t\r\n\t\twhile(!q.isEmpty()) {\r\n\t\t\tEdge now = q.remove();\r\n\t\t\tif(!visited[now.e]) {\r\n\t\t\t\tvisited[now.e] = true;\r\n\t\t\t\tfor(Edge next : Vertex.get(now.e)) {\r\n\t\t\t\t\tif(!visited[next.e] && dist[next.e] >= dist[now.e] + next.w) {\r\n\t\t\t\t\t\tdist[next.e] = dist[now.e] + next.w;\r\n\t\t\t\t\t\tq.add(new Edge(next.e, dist[next.e]));\r\n\t\t\t\t\t\tpre[next.e] = now.e;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\t\r\n\tstatic class Edge implements Comparable<Edge>{\r\n\t\tint e, w;\r\n\t\tEdge(int e, int w){\r\n\t\t\tthis.e = e;\r\n\t\t\tthis.w = w;\r\n\t\t}\r\n\t\t@Override\r\n\t\tpublic int compareTo(Edge o){\r\n\t\t\treturn w - o.w;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n# 백준 11780 - 플로이드\r\n---\r\n![11780문제 사진1](11780pb1.PNG)\r\n![11780문제 사진2](11780pb2.PNG)\r\n![11780문제 사진2](11780pb3.PNG)\r\n---\r\nnext배열은 a(정점) -> b(정점) 일 때, 출발 정점(a)의 값을 가지고 있다.\r\n\r\n플로이드 알고리즘은 i -> k -> j 의 거리가 짧을 경우 최단거리(dist배열)을 갱신해준다.  \r\n\r\n동일하게 최단거리가 짧은 경우 출발 노드(next배열)을 k로 바꿔서 갱신해준다.\r\n\r\n---\r\n```java\r\npackage pakcage26;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.Stack;\r\n\r\npublic class num11780 {\r\n\tstatic int N, M, INF = 100000000;\r\n\tstatic int[][] dist, next;\r\n\tstatic boolean[][] visited;\r\n\tstatic Stack<Integer> stack;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\r\n\t\t\r\n\t\tN = stoi(br.readLine());\r\n\t\tM = stoi(br.readLine());\r\n\t\tdist = new int[N][N];\r\n\t\tnext = new int[N][N];\r\n\t\t\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tfor(int j=0; j<N; j++) {\r\n\t\t\t\tdist[i][j] = i == j ? 0 : INF;\r\n\t\t\t\tnext[i][j] = INF;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\t\t\r\n\t\tfor(int i=0; i<M; i++) {\r\n\t\t\tString[] abc = br.readLine().split(\" \");\r\n\t\t\tint a = stoi(abc[0])-1;\r\n\t\t\tint b = stoi(abc[1])-1;\r\n\t\t\tint c = stoi(abc[2]);\r\n\t\t\t\r\n\t\t\tdist[a][b] = Math.min(dist[a][b], c);\r\n\t\t\tnext[a][b] = a;\r\n\t\t}\r\n\t\t\r\n\t\tfloyd();\r\n\t\t\r\n\t\tprintPath();\r\n\t}\r\n\t\r\n\tpublic static void floyd() {\r\n\t\tfor(int k = 0; k<N; k++) {\r\n\t\t\tfor(int i = 0; i<N; i++) {\r\n\t\t\t\tfor(int j=0; j<N; j++) {\r\n\t\t\t\t\tif(dist[i][j] > dist[i][k] + dist[k][j]) {\r\n\t\t\t\t\t\tdist[i][j] = dist[i][k] +dist[k][j];\r\n\t\t\t\t\t\tnext[i][j] = next[k][j];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static void printPath() {\r\n\t\tfor(int[] a : dist) {\r\n\t\t\tfor(int b: a) {\r\n\t\t\t\tSystem.out.print(b + \" \");\r\n\t\t\t}\r\n\t\t\tSystem.out.println();\r\n\t\t}\r\n\t\t\r\n        for(int i=0; i<N; i++) {\r\n            for(int j=0; j<N; j++) {\r\n                if(next[i][j]==INF)\r\n                    System.out.println(0);\r\n\r\n                else {\r\n                \tstack = new Stack<>();\r\n                    int pre = j;\r\n                    stack.push(j);\r\n                    while(i != next[i][pre]) {\r\n                        pre = next[i][pre];\r\n                        stack.push(pre);\r\n                    }\r\n                    System.out.print((stack.size()+1)+\" \");\r\n                    System.out.print(i+1+\" \");\r\n                    while(!stack.empty())\r\n                        System.out.print(stack.pop()+1+\" \");\r\n                    System.out.println();\r\n                }\r\n            }\r\n        }\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\t\r\n}\r\n```\r\n\r\n# 벨만포드 - 백준 1738\r\n\r\n---\r\n\r\n![1738문제1](1738pb1.PNG)\r\n![1738문제2](1738pb1.PNG)\r\n\r\n---\r\n일차원 배열을 선언해 이전 경로의 값을 가지고 있는다.\r\n\r\n기존의 벨만 포드 알고리즘과는 달리 음의 싸이클이 있으면 끝이 아니라,  \r\n음의 싸이클에 도착점으로 도달 가능해야 답이 -1이다.\r\n\r\n```\r\n4 4\r\n1 4 3\r\n2 3 1\r\n3 2 1\r\n4 2 1\r\n```\r\n위의 테스트 케이스를 통과해야 정답이다.\r\n\r\n이거 때문에 삽질 좀 했다 ㅜㅜ\r\n\r\n---\r\n\r\n```java\r\npackage MinPath;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\nimport java.util.Stack;\r\n\r\npublic class num1738 {\r\n\tstatic int N, M, INF = 987654321, INF2=-987654321;\r\n\tstatic ArrayList<ArrayList<Edge>> Vertex;\r\n\tstatic int[] preVertex;\r\n\tstatic long[] dist;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tString[] NM = br.readLine().split(\" \");\r\n\t\t\r\n\t\tN = stoi(NM[0]);\r\n\t\tM = stoi(NM[1]);\r\n\t\t\r\n\t\tdist = new long[N];\r\n\t\tVertex = new ArrayList<ArrayList<Edge>>();\r\n\t\tpreVertex = new int[N];\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tVertex.add(new ArrayList<Edge>());\r\n\t\t\tdist[i] = INF;\r\n\t\t\tpreVertex[i] = -1;\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<M; i++) {\r\n\t\t\tString[] uvw = br.readLine().split(\" \");\r\n\t\t\tint u = stoi(uvw[0])-1;\r\n\t\t\tint v = stoi(uvw[1])-1;\r\n\t\t\tint w = stoi(uvw[2]);\r\n\t\t\tVertex.get(u).add(new Edge(v, -w));\r\n\t\t}\r\n\t\t\r\n\t\tbellmanFord();\r\n\t\t\r\n\t\tprintPath();\r\n\t}\r\n\t\r\n\tpublic static void bellmanFord() {\r\n\t\tdist[0] = 0;\r\n\t\tpreVertex[0] = 0;\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tfor(int j=0; j<N; j++) {\r\n\t\t\t\tfor(Edge edge : Vertex.get(j)) {\r\n\t\t\t\t\tint next = edge.e, weight = edge.w;\r\n\t\t\t\t\tif(dist[j]!=INF && dist[next] > dist[j] + weight) {\r\n\t\t\t\t\t\tdist[next] = (dist[j] + weight);\r\n\t\t\t\t\t\tpreVertex[next] = j;\r\n\t\t\t\t\t\tif(i == N-1) {\r\n\t\t\t\t\t\t\tdist[next] = INF2;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static void printPath() {\r\n\t\tStack<Integer> stack = new Stack<Integer>();\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\tif(dist[N-1] == INF || dist[N-1] == INF2)\r\n\t\t\tsb.append(\"-1\");\r\n\t\telse{\r\n\t\t\tfor (int i = N-1 ; i != 0; i = preVertex[i]) {\r\n\t\t\t\tif(dist[i] == INF2) {\r\n\t\t\t\t\tSystem.out.println(-1);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tstack.push(i);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tstack.push(0);\r\n\t        for (int i = stack.size(); i > 0; --i)\r\n\t        {\r\n\t            sb.append(stack.pop()+1+\" \");\r\n\t        }\r\n\t\t}\r\n\t\tSystem.out.println(sb);\r\n\t}\r\n\t\r\n\tstatic class Edge{\r\n\t\tint e, w;\r\n\t\tEdge(int e, int w){\r\n\t\t\tthis.e = e;\r\n\t\t\tthis.w = w;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\r\n}\r\n```\r\n\r\n# 정리\r\n\r\n---\r\n\r\n세가지 알고리즘 모두 최단거리를 추적하면서  \r\n**경로를 저장할 공간을 만들어서 저장하는 방식**이다.\r\n\r\n# Reference\r\n---\r\n[갓킹독님 블로그](https://blog.encrypted.gg/category/%EA%B0%95%EC%A2%8C/%EC%8B%A4%EC%A0%84%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98?page=1)  \r\n[라이님 블로그](https://m.blog.naver.com/PostList.nhn?blogId=kks227)  \r\n","excerpt":"백준 11779, 11780, 1738번 문제를 통해 최단경로의 경로출력을 정리해보려고 한다. 백준 11779 - 다익스트라 \n 소스를 간략히 설명하면 다익스트라 알고리즘에 값이 조건에 맞아 갱신될 때 배열의 값에 이전 노드를 저장한다. 첫 노드부터…","fields":{"slug":"/shortestDistance_2/"},"frontmatter":{"date":"Jan 25, 2021","title":"최단거리 경로복원","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n정리 안해두면 까먹을거 같아서 기억력을 조금이라도 향상시키기 위해 정리해둔다.\r\n\r\n자, 최단거리 알고리즘을 이해하기 위해 그래프를 간략히 살펴보면\r\n\r\n---\r\n\r\n# 그래프란? \r\n\r\n---\r\n\r\n그래프는 **정점(Vertex)** 와 **간선(Edge)** 을 모아놓은 자료구조다.\r\n\r\n그래프라는 친구는 보통 간선에 가중치를 가진다.\r\n\r\n## 구현 방법\r\n---\r\n1. 인접 행렬\r\n2. 인접 리스트\r\n\r\n# 다익스트라 알고리즘\r\n---\r\n\r\n최단 거리 알고리즘은 기본적으로 **그리디 알고리즘** 으로 분류된다.  \r\n -> **매번 가장 비용이 적은 노드** 를 선택하는 과정을 반복하기 때문이다.\r\n\r\n## 전제조건\r\n---\r\n\r\n1. 시작 노드 - 시작 노드 사이 거리는 0이다.\r\n2. 모든 간선은 양의 가중치를 가진다.\r\n\r\n## 특징\r\n---\r\n\r\n1. 구현 방법은 2가지\r\n\r\n## 1. 직관적인 방법 - O(V^2)\r\n---\r\n1. 각 노드에 대한 최단 거리를 담는 1차원 리스트 선언\r\n2. 방문하지 않은 노드 중에서 거리가 가장 짧은 노드 선택  \r\n(거리가 같으면 일반적으로 번호가 작은 노드)\r\n3. 거리가 더 짧으면 값 갱신\r\n\r\n### 최단거리 - 백준 1753\r\n---\r\n![1753문제](1753pb.PNG)\r\n![1753문제](1753pb2.PNG)\r\n\r\n```java\r\npackage package24;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\npublic class num1753 {\r\n\tstatic int INF = Integer.MAX_VALUE;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tString[] inputVE = br.readLine().split(\" \");\r\n\t\tint V = stoi(inputVE[0]);\r\n\t\tint E = stoi(inputVE[1]);\r\n\t\tint K = stoi(br.readLine())-1;\r\n\t\t\r\n\t\tList<Edge>[] graph = new ArrayList[V];\r\n        for (int i = 0; i < V; i++) \r\n        \tgraph[i] = new ArrayList<>();\r\n\t\tint[] distance = new int[V];\r\n\t\tboolean[] visited = new boolean[V];\r\n\t\t\r\n\t\tfor(int i=0; i<V; i++) {\r\n\t\t\tdistance[i] = INF; \r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<E; i++) {\r\n\t\t\tString[] uvw = br.readLine().split(\" \");\r\n\t\t\tint u = stoi(uvw[0])-1;\r\n\t\t\tint v = stoi(uvw[1])-1;\r\n\t\t\tint w = stoi(uvw[2]);\r\n\t\t\tgraph[u].add(new Edge(v,w));\r\n\t\t}\r\n\t\tdijkstra(graph, visited, distance, V, E, K);\r\n\t\t\r\n\t\tfor(int value : distance) {\r\n\t\t\tif(INF == value)\r\n\t\t\t\tSystem.out.println(\"INF\");\r\n\t\t\telse\r\n\t\t\t\tSystem.out.println(value);\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static void dijkstra(List<Edge>[] graph, boolean[] visited, int[] distance, int V, int E, int K) {\r\n\t\tdistance[K] = 0;\r\n\t\tfor(int i=0; i<V; i++) {\r\n\t\t\tint minIndex = getSmallestNodeNotVisited(visited, distance, V);\r\n            for (Edge next : graph[minIndex]) {\r\n                if(!visited[next.v] && distance[next.v] > distance[minIndex] + next.weight) {\r\n                \tdistance[next.v] = distance[minIndex] + next.weight;\r\n                }\r\n            }\r\n\r\n\t\t\tvisited[minIndex] = true;\r\n\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic static int getSmallestNodeNotVisited(boolean[] visited, int[] distance, int V) {\r\n\t\tint min = INF;\r\n\t\tint minIndex = 0;\r\n\t\tfor(int i=0; i<V; i++) {\r\n\t\t\tif(visited[i] == false && distance[i]<min) {\r\n\t\t\t\tmin = distance[i];\r\n\t\t\t\tminIndex = i;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn minIndex;\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n}\r\n\r\nclass Edge {\r\n    int v, weight;\r\n\r\n    public Edge(int v, int weight) {\r\n        this.v = v;\r\n        this.weight = weight;\r\n    }\r\n    \r\n}\r\n\r\n```\r\n---\r\n\r\n소스를 간략히 설명하면  \r\n노드 arrayList를 만들고 Edge는 클래스로 만들어서 넣어주는 방법으로 구현했다.  \r\n(배열로만 구현하면 메모리 초과난다.)\r\n\r\n매번 최단거리가 가장 짧은 노드를 찾기 위해 O(V) 만큼 탐색하기 때문에 비효율적이다.  \r\n -> Priority Queue 활용\r\n\r\n---\r\n\r\n## 2. Priority Queue 활용 - O(ElogV)\r\n\r\n---\r\n\r\n최단 거리 -> **최소 힙**을 사용한다.\r\n\r\n```\r\n1. 각 노드에 대한 최단 거리를 담는 1차원 리스트 선언\r\n2. 우선순위 큐을 사용해 거리가 짧은 정점부터 Queue에 넣어 줌.(처음 시작 값 : 0)  \r\n3. 큐가 값이 없을 때까지 반복  \r\n    3-1) 큐에서 값을 하나 꺼냄 (Vertex 선택)  \r\n\t3-2) visited 값 true 설정  \r\n4. 다음 Vertex의 최단거리가 현재Vertex 최단 거리 + 다음 Vertex 가중치보다 크면   \r\n\t(다음 Vertex가 사용되지 않았을 때)  \r\n\t4-1) 값 갱신  \r\n\t4-2) 우선순위 큐에 값 추가  \r\n```\r\n\r\n요약하면\r\n```\r\n1. 아직 방문하지 않은 정점 중 거리가 짧은 정점을 하나 선택해 방문\r\n2. 해당 정점에 인접하고 아직 방문하지 않은 정점의 최단거리 갱신\r\n```\r\n\r\nTip!!  \r\n**JAVA PriorityQueue 는 기본적으로 minHeap이다.**\r\n\r\n\r\n```java\r\n// 최소 힙\r\nPriorityQueue<Integer> minHeap = new PriorityQueue<Integer>();\r\n\r\n// 최대 힙\r\nPriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(Comparator.reverseOrder());\r\n\r\n// 최대 힙 version2\r\nPriorityQueue<Integer> maxHeap = PriorityQueue<>(new Comparator<Integer>(){\r\n\t@Override\r\n\tpublic int compare(Integer i1, Integer i2) {\r\n\t\treturn i2-i1;\r\n\t}\r\n});\r\n```\r\n\r\n### 최단거리 - 백준 1504\r\n\r\n---\r\n\r\n![1504문제](1504pb1.PNG)\r\n![1504문제2](1504pb2.PNG)\r\n\r\n---\r\n\r\n문제를 보면 정점 2개를 방문해야 한다는 조건이 있다. 정점을 각각 V1, V2라고 한다면 \r\n 1. 1 -> V1 -> V2 -> N\r\n 2. 1 -> V2 -> V1 -> N\r\n\r\n두가지 경우에 대해 구간별로 최소값을 구한 후, 더하면 된다.\r\n\r\n---\r\n\r\n```java\r\npackage package24;\r\n\r\nimport java.io.*;\r\nimport java.util.*;\r\n\r\npublic class num1504 {\r\n\tstatic int N,E,v1,v2,result;\r\n\tstatic ArrayList<ArrayList<Edge>> Vertex;\r\n\tstatic int[] distance;\r\n\tstatic boolean[] visited;\r\n\tstatic int INF = 200000000;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tString[] NE = br.readLine().split(\" \");\r\n\t\tN = stoi(NE[0]);\r\n\t\tE = stoi(NE[1]);\r\n\t\tdistance = new int[N+1];\r\n\t\tvisited = new boolean[N+1];\r\n\t\tVertex = new ArrayList<>();\r\n\t\t\r\n\t\tfor(int i=0; i<=N; i++) {\r\n\t\t\tVertex.add(new ArrayList<>());\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<E; i++) {\r\n\t\t\tString[] abc = br.readLine().split(\" \");\r\n\t\t\tint a = stoi(abc[0]);\r\n\t\t\tint b = stoi(abc[1]);\r\n\t\t\tint c = stoi(abc[2]);\r\n\t\t\t\r\n\t\t\tVertex.get(a).add(new Edge(b,c));\r\n\t\t\tVertex.get(b).add(new Edge(a,c));\r\n\t\t}\r\n\t\tString[] v1v2 = br.readLine().split(\" \");\r\n\t\tv1 = stoi(v1v2[0]);\r\n\t\tv2 = stoi(v1v2[1]);\r\n\t\t\r\n\t\tresult = solve();\r\n\t\tSystem.out.println(result);\r\n\t}\r\n\r\n\tpublic static int solve() {\r\n\t\tint case1=0, case2=0;\r\n\t\t\r\n\t\tcase1 = dijkstra(1,v1) + dijkstra(v1,v2) + dijkstra(v2,N);\r\n\t\tcase2 = dijkstra(1,v2) + dijkstra(v2,v1) + dijkstra(v1,N);\r\n\r\n\t\treturn (case1 >= INF && case2 >= INF) ? -1 : Math.min(case1, case2);\r\n\t}\r\n\t\r\n\tpublic static int dijkstra(int start, int end) {\r\n\t\tArrays.fill(distance, INF);\r\n\t\tArrays.fill(visited, false);\r\n\t\t\r\n\t\tPriorityQueue<Edge> queue = new PriorityQueue<Edge>();\r\n\t\tqueue.add(new Edge(start,0));\r\n\t\tdistance[start] = 0;\r\n\t\t\r\n\t\twhile(!queue.isEmpty()) {\r\n\t\t\tEdge now = queue.remove();\r\n\t\t\tint nowNode = now.e;\r\n\t\t\tif(!visited[nowNode]) {\r\n\t\t\t\tvisited[nowNode] = true;\r\n\t\t\t\t\r\n\t\t\t\tfor(Edge next : Vertex.get(nowNode)) {\r\n\t\t\t\t\tif(!visited[next.e] && distance[next.e] > distance[nowNode] + next.weight) {\r\n\t\t\t\t\t\tdistance[next.e] = distance[nowNode] + next.weight;\r\n\t\t\t\t\t\tqueue.add(new Edge(next.e, distance[next.e]));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn distance[end];\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\t\r\n\tstatic class Edge implements Comparable<Edge>{\r\n\t\tint e, weight;\r\n\t\tEdge(int e, int weight){\r\n\t\t\tthis.e = e;\r\n\t\t\tthis.weight = weight;\r\n\t\t}\r\n\t\t\r\n\t\t@Override\r\n\t\tpublic int compareTo(Edge o){\r\n\t\t\treturn weight - o.weight;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n\r\n\r\n# 벨만-포드 알고리즘\r\n---\r\n\r\n## 특징\r\n---\r\n\r\n1. 시간 복잡도 - O(VE)\r\n2. 다익스트라 알고리즘보다 느리지만 음의 가중치를 가진 경로의 최단거리를 구할 수 있다.\r\n\r\n## 전제 조건\r\n---\r\n1. **같은 정점을 2번 지날일은 없기 때문에** 간선의 최대 개수는 **V-1**이다.\r\n2. 음수 사이클이 없는 최단 경로를 구해야 한다.\r\n\r\n> 존재하는 모든 간선을 돌아보면서 간선이 통할 수도 있는 거리를 갱신하는 것\r\n\r\n## 백준 11657\r\n---\r\n![11607문제1](11657pb1.PNG)\r\n![11607문제2](11657pb2.PNG)\r\n![11607문제3](11657pb3.PNG)\r\n\r\n```java\r\npackage package24;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\n\r\npublic class num11657 {\r\n\tstatic int N, M;\r\n\tstatic ArrayList<ArrayList<Edge>> Vertex;\r\n\tstatic long[] dist;\r\n\tstatic int INF = Integer.MAX_VALUE;\r\n\tstatic boolean minusCycle=false;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\r\n\t\tString[] inputNM = br.readLine().split(\" \");\r\n\t\tN = stoi(inputNM[0]);\r\n\t\tM = stoi(inputNM[1]);\r\n\t\t\r\n\t\tdist = new long[N];\r\n\t\tVertex = new ArrayList<ArrayList<Edge>>();\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tVertex.add(new ArrayList<Edge>());\r\n\t\t\tdist[i] = INF;\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<M; i++) {\r\n\t\t\tString[] ABC = br.readLine().split(\" \");\r\n\t\t\tint A = stoi(ABC[0])-1;\r\n\t\t\tint B = stoi(ABC[1])-1;\r\n\t\t\tint C = stoi(ABC[2]);\r\n\t\t\t\r\n\t\t\tVertex.get(A).add(new Edge(B,C));\r\n\t\t}\r\n\t\tbellman();\r\n\t\t\r\n\t\tif(minusCycle)\r\n\t\t\tsb.append(\"-1\\n\");\r\n\t\telse {\r\n\t\t\tfor(int i=1; i<N; i++) {\r\n\t\t\t\tsb.append(dist[i] != INF ? dist[i] : -1);\r\n\t\t\t\tsb.append(\"\\n\");\r\n\t\t\t}\r\n\t\t}\r\n\t\tSystem.out.println(sb.toString());\r\n\t\t\r\n\t}\r\n\tpublic static void bellman() {\r\n\t\tdist[0] = 0;\r\n\t\t\r\n\t    for(int i=0; i<N; i++){ \r\n\t        for(int j=0; j<N; j++){\r\n\t            for(Edge edge: Vertex.get(j)){\r\n\t                int next = edge.e, w = edge.w;\r\n\t                if(dist[j] != INF && dist[next] > dist[j] + w){\r\n\t                    dist[next] = dist[j] + w;\r\n\t                    if(i == N-1) minusCycle = true;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t}\r\n\t\r\n\tstatic class Edge {\r\n\t\tint e, w;\r\n\t\tEdge(int e, int w) {\r\n\t\t\tthis.e = e;\r\n\t\t\tthis.w = w;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n}\r\n```\r\n\r\n---\r\n\r\n코드를 간단히 설명해보면\r\n\r\n존재하는 모든 간선을 돌아보면서 이 간선을 통할 수도 있는 최단경로들의 거리를 갱신한다.\r\n같은 정점을 2번 방문하는 경우는 없다는 전제가 있으므로 V-1까지 확인한다\r\n만약, 음의 사이클이 존재한다면 -> V-1 이후 최단거리가 갱신된다. \r\n위의 소스에선 V까지 루프의 마지막에 최단거리가 갱신되는지 확인한다.\r\n\r\n\r\n이 문제는 조금 주의할 점이 있다. \r\n\r\n최소 가중치가 -10000이라 언더플로우가 생길 수 있기 때문에 **dist를 long[]으로 설정해야 한다.**  \r\n\r\n---\r\n\r\n# 플로이드 알고리즘 \r\n---\r\n## 특징\r\n---\r\n\r\n1. 다익스트라, 벨만 포드 알고리즘 : 하나의 시작점에 대한 최단 거리\r\n2. 플로이드 워셜 알고리즘 : **모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야 하는 경우**  \r\n3. 시간 복잡도 : O(V^3)  \r\n\t-> 노드의 개수 O(V) * **현재 노드를 거쳐가는 모든 경로O(V^2)** -> **O(V^3)**\r\n4. **DP형태** -> 점화식에 맞게 2차원 리스트를 갱신하기 때문\r\n\r\n**Tip!!**  \r\n상황에 따라 자기 자신으로 이동 가능하면 dis[i][j] = 0 / 불가능하면 dis[i][j] = INF\r\n\r\n- 가장 바깥쪽 for문은 경유할 정점\r\n- 가운데 for문은 출발 정점\r\n- 가장 안쪽 for문은 도착 정점\r\n\r\n---\r\n\r\n## 백준 11404\r\n\r\n```java\r\npackage package24;\r\n\r\nimport java.io.*;\r\n\r\npublic class num11404 {\r\n\tstatic int N, M, INF = 100000000;\r\n\tstatic int[][] dis;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\r\n\t\tN = stoi(br.readLine());\r\n\t\tM = stoi(br.readLine());\r\n\t\t\r\n\t\tdis = new int[N][N];\r\n\t\t\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tfor(int j=0; j<N; j++) {\r\n\t\t\t\tdis[i][j] = i == j ? 0 : INF;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<M; i++) {\r\n\t\t\tString[] abc = br.readLine().split(\" \");\r\n\t\t\tint a = stoi(abc[0])-1;\r\n\t\t\tint b = stoi(abc[1])-1;\r\n\t\t\tint c = stoi(abc[2]);\r\n\t\t\t\r\n\t\t\tdis[a][b] = Math.min(dis[a][b], c);\r\n\t\t}\r\n\t\t\r\n\t\tfor(int k=0; k<N; k++) {\r\n\t\t\tfor(int i=0; i<N; i++) {\r\n\t\t\t\tfor(int j=0; j<N; j++) {\r\n\t\t\t\t\tdis[i][j] = Math.min(dis[i][j], dis[i][k] +dis[k][j]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n        for (int i = 0; i < N; i++) {\r\n            for (int j = 0; j < N; j++) {\r\n            \tdis[i][j] = dis[i][j] == INF ? 0 : dis[i][j];\r\n                sb.append(dis[i][j] + \" \");\r\n            }\r\n            sb.append(\"\\n\");\r\n        }\r\n \r\n        bw.write(sb.toString());\r\n        bw.flush();\r\n        bw.close();\r\n        br.close();\r\n\t}\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n# 정리\r\n---\r\n\r\n이렇게 최단거리 알고리즘 3가지를 알아보았다.  \r\n\r\n사용하는 경우를 정리해보면  \r\n```\r\n1. 다익스트라 알고리즘[우선순위 큐] -> 한 지점에서 다른 지점까지 최단거리 구하는 문제  \r\n2. 벨만 포드 알고리즘 -> 음의 가중치를 가진 최단거리 구하는 문제  \r\n3. 플로이드 와샬 알고리즘 -> 모든 경로의 최단거리 구하는 문제\r\n``` \r\n로 정리할 수 있다.\r\n\r\n\r\n생각보다 어려워서 정리하는데 시간이 오래걸렸다.  \r\n다음 글은 최단경로의 경로출력에 대해 정리해 볼 예정이다.\r\n\r\n추가로 [라이님 블로그](https://blog.naver.com/kks227/220796029558) 요기 있는 추가문제 하나씩 풀어봐야겠다.\r\n\r\n\r\n# Reference\r\n---\r\n[라이님 블로그](https://blog.naver.com/kks227/220796029558)  \r\n[갓킹독님 블로그](https://blog.encrypted.gg/917?category=773649)  \r\n[Crocus님 블로그](https://www.crocus.co.kr/546?category=209527)  \r\n[백준 질문하기 - 출력초과 문제 해결이 되었는데 이유를 모르겠습니다](https://www.acmicpc.net/board/view/55270)  \r\n이것이 코딩테스트다 - 나동빈\r\n\r\n\r\n","excerpt":"정리 안해두면 까먹을거 같아서 기억력을 조금이라도 향상시키기 위해 정리해둔다. 자, 최단거리 알고리즘을 이해하기 위해 그래프를 간략히 살펴보면 그래프란? 그래프는 정점(Vertex) 와 간선(Edge) 을 모아놓은 자료구조다. 그래프라는 친구는 보통…","fields":{"slug":"/shortestDistance_1/"},"frontmatter":{"date":"Jan 23, 2021","title":"최단거리 알고리즘","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n백준 이분 탐색 문제를 풀다 Parametric Search에 대해 알게 되었고, 정리 할 필요성을 느껴서 포스팅한다.\r\n\r\n일단 **이분탐색**은 탐색 기법으로 **원하는 탐색 범위를 두 부분으로 분할**해서 찾는 방식이다  \r\n -> O(logN)의 시간 복잡도를 가지고 있다.\r\n\r\n**파라매트릭 서치**는 **최적화 문제 -> 결정문제로 바꾸어 푸는 것**을 말한다.  \r\n(문제 상황을 만족하는 특정한 값 - 최소값, 최대값) \r\n\r\n백준 2110번 문제가 쉽게 이해하기 좋은 문제인 것 같다.\r\n\r\n![문제사진](pro1.PNG)\r\n![문제사진2](pro2.PNG)\r\n\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.Arrays;\r\n\r\npublic class Main {\r\n\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tString[] inputNK = br.readLine().split(\" \");\r\n\t\tint N = Integer.parseInt(inputNK[0]);\r\n\t\tlong K = Long.parseLong(inputNK[1]);\r\n\t\tlong max = 0;\r\n\t\t\r\n\t\tlong[] houseArr = new long[N];\r\n\t\t\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\thouseArr[i] = Long.parseLong(br.readLine());\r\n\t\t\tmax = max > houseArr[i] ? max : houseArr[i];\r\n\t\t}\r\n\t\tArrays.sort(houseArr);\r\n\t\t\r\n\t\tmax = Psearch(houseArr, K, max);\r\n\t\tSystem.out.println(max);\r\n\t}\r\n\t\r\n\tpublic static long Psearch(long[] houseArr, long K, long max) {\r\n\t\tlong start = 1;\r\n\t\tlong end = max;\r\n\t\tlong ans = 0;\r\n\t\t\r\n\t\twhile(start<=end) {\r\n\t\t\tlong mid = (start+end)/2;\r\n\t\t\t\r\n\t\t\tif(checkHouse(houseArr, mid, K)) {\r\n\t\t\t\tstart = mid+1;\r\n\t\t\t\tans = ans > mid ? ans : mid;\r\n\t\t\t}else {\r\n\t\t\t\tend = mid-1;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn ans;\r\n\t}\r\n\t\r\n\tpublic static boolean checkHouse(long[] houseArr, long mid, long K) {\r\n\t\tlong temp = houseArr[0];\r\n\t\tlong index = 0;\r\n\t\tfor(int i = 1; i<houseArr.length; i++) {\r\n\t\t\tif(houseArr[i]-temp >= mid) {\r\n\t\t\t\tindex++;\r\n\t\t\t\ttemp=houseArr[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif(index >=K-1)\r\n\t\t\treturn true;\r\n\t\telse\r\n\t\t\treturn false;\r\n\t}\r\n\r\n}\r\n\r\n```\r\n\r\n이 문제의 포인트는  \r\n1. 공유기 사이 거리를 정한 후, 정한 거리 이상의 간격으로 집에 설치 가능한지 확인\r\n    - 설치 가능 -> 더 큰 거리값 확인\r\n    - 설치 불가능 -> 작은 거리값을 확인  \r\n\r\n\r\n추가로 백준 12015번 문제를 풀어보는 것을 추천한다.\r\ndp를 활용해 가장 긴 증가하는 부분 수열 구할 수 있는데 이분탐색을 사용하면 O(logN)으로 구할 수 있다.\r\n\r\n\r\n \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","excerpt":"백준 이분 탐색 문제를 풀다 Parametric Search에 대해 알게 되었고, 정리 할 필요성을 느껴서 포스팅한다. 일단 이분탐색은 탐색 기법으로 원하는 탐색 범위를 두 부분으로 분할해서 찾는 방식이다  -> O(logN)의 시간 복잡도를 가지고…","fields":{"slug":"/ParametricSearch/"},"frontmatter":{"date":"Jan 17, 2021","title":"이분탐색, 파라매트릭 서치(Parametric Search)","tags":["Algorithm","Parametric Search"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n백준 단계별 문제 - 우선순위 큐 마지막 문제다.  \r\n\r\n풀다가 조금 헷갈린 부분이 있어 정리하고자 포스팅한다.  \r\n\r\n# 문제\r\n![문제사진](problem1.PNG)\r\n![문제사진2](problem2.PNG)\r\n\r\n일단 문제에 처음 접근할 땐, 우선순위 큐를 사용해 저장하고 중간 값을 계속 뽑아와 StringBuilder에 넣어주는 방식으로 구현했다.  \r\n\r\n```java\r\npackage package21;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.PriorityQueue;\r\nimport java.util.Stack;\r\n\r\npublic class num1655 {\r\n\r\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tPriorityQueue<Integer> q = new PriorityQueue<>();\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\r\n\t\tint T = Integer.parseInt(br.readLine());\r\n\t\t\r\n\t\tfor(int i=0; i<T; i++) {\r\n\t\t\tint value = Integer.parseInt(br.readLine());\r\n\t\t\tq.offer(value);\r\n\t\t\tint len = q.size()/2 + q.size()%2;\r\n\t\t\tStack<Integer> s = new Stack<>();\r\n\t\t\tfor(int j=0;j<len;j++) {\r\n\t\t\t\ts.push(q.remove());\r\n\t\t\t}\r\n\t\t\tif(!s.isEmpty())\r\n\t\t\t\tsb.append(s.peek()+\"\\n\");\r\n\t\t\twhile(!s.isEmpty()) {\r\n\t\t\t\tq.offer(s.pop());\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\tSystem.out.println(sb);\r\n\t}\r\n\r\n}\r\n```\r\n![시간초과](no.PNG)\r\n\r\n역시 시간초과.....\r\n\r\n## 풀이 1\r\nstack대신 우선순위큐를 하나 더 써서 구현해보려고 생각하였고, 이 부분에서 삽질을 조금 하였다.  \r\n\r\n포인트는 4가지다.\r\n1. Max Heap(최대 값이 가장 앞에 위치)과 Min Heap(최소 값이 가장 앞에 위치) 사용   \r\n2. 중간 값을 저장(초기 값 = 맨 처음에 입력받은 값)  \r\n   중간 값 보다 작은 값은 Max Heap / 큰 값은 Min Heap\r\n3. 큰값을 저장하는 min heap이 길이가 2이상 길면 중앙 값 바꿈  \r\n    -> 작은 값을 저장하는 max heap에 중간 값 저장  \r\n    -> 큰 값을 저장하는 min heap에서 가장 작은 값을 중간값으로 바꿈  \r\n4. 작은 값을 저장하는 max heap이 길이가 1이상 길면 중앙 값 바꿈  \r\n   (길이가 짝수이면 작은수가 중간 값이니 길이= 1 )  \r\n   -> 큰 값을 저장하는 min heap에 중간 값 저장  \r\n   -> 작은 값을 저장하는 max heap에서 가장 큰 값을 중간값으로 바꿈  \r\n\r\n```java\r\npackage package21;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.Comparator;\r\nimport java.util.PriorityQueue;\r\nimport java.util.Queue;\r\n\r\npublic class num1655v2 {\r\n\r\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\tQueue<Integer> min = new PriorityQueue<>();\r\n\t\tQueue<Integer> max = new PriorityQueue<>(new Comparator<Integer>() {\r\n\t\t\t@Override\r\n\t\t\tpublic int compare(Integer o1, Integer o2) {\r\n\t\t\t\treturn o2.compareTo(o1);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t});\r\n\t\t\r\n\t\tint T = Integer.parseInt(br.readLine());\r\n\t\t\r\n\t\tint index=0;\r\n\t\t\r\n\t\tfor(int i = 0; i<T; i++) {\r\n\t\t\tint num = Integer.parseInt(br.readLine());\r\n\t\t\tif(i==0) {\r\n\t\t\t\tindex = num;\r\n\t\t\t\tsb.append(num+\"\\n\");\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif(num<=index) {\r\n\t\t\t\t// 작은 값이면 max heap에 저장\r\n\t\t\t\tmax.offer(num);\r\n\t\t\t\tif(max.size()-min.size()>=1) {\r\n\t\t\t\t\tmin.offer(index);\r\n\t\t\t\t\tindex = max.poll();\r\n\t\t\t\t}\r\n\t\t\t}else {\r\n\t\t\t\t// 큰 값이면  min heap에 저장\r\n\t\t\t\tmin.offer(num);\r\n\t\t\t\tif(min.size() - max.size() >=2) {\r\n\t\t\t\t\tmax.offer(index);\r\n\t\t\t\t\tindex = min.poll();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tsb.append(index+\"\\n\");\r\n\t\t}\r\n\t\tSystem.out.println(sb);\r\n\t}\r\n\r\n}\r\n```\r\n\r\n후... 큰 값을 min heap 저장, 작은 값을 max heap 저장, 중간값은 index로 빼놓는게 포인트인데 코드 짜다보니 헷갈려서 헤맸다.\r\n\r\n\r\n\r\n추가) 다른 사람들은 코드를 어떻게 짰는지 구글링 해봤는데 조금 재밌게 푼 코드가 있어서 추가로 풀어봤다.\r\n\r\n## 풀이2\r\n1. 중간 값은 항상 max heap의 가장 앞의 값으로 유지\r\n2. 크기가 같으면 max heap에 값 추가\r\n   (입력한 값이 min heap의 최소값보다 크면 값 swap)\r\n3. 크기가 다르면 min heap에 값 추가\r\n   (입력한 값이 max heap의 최대값보다 작으면 값 swap)\r\n\r\n이 코드는 입력값 : 521578 을 넣어서 직접 노트에 풀어보는게 이해하는데 도움됐다.\r\n```java\r\npackage package21;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.Comparator;\r\nimport java.util.PriorityQueue;\r\nimport java.util.Queue;\r\n\r\npublic class num1655v3 {\r\n\r\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\tQueue<Integer> min = new PriorityQueue<>();\r\n\t\tQueue<Integer> max = new PriorityQueue<>(new Comparator<Integer>() {\r\n\t\t\t@Override\r\n\t\t\tpublic int compare(Integer o1, Integer o2) {\r\n\t\t\t\treturn o2.compareTo(o1);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t});\r\n\t\t\r\n\t\tint T = Integer.parseInt(br.readLine());\r\n\t\t\r\n\t\tint index=0;\r\n\t\t\r\n\t\tfor(int i = 0; i<T; i++) {\r\n\t\t\tint num = Integer.parseInt(br.readLine());\r\n\t\t\tif(max.size() == min.size()) {\r\n\t\t\t\tmax.offer(num);\r\n\t\t\t\tif(!min.isEmpty() && max.peek() > min.peek()) {\r\n\t\t\t\t\tmin.offer(max.poll());\r\n\t\t\t\t\tmax.offer(min.poll());\r\n\t\t\t\t}\r\n\t\t\t}else {\r\n\t\t\t\tmin.offer(num);\r\n\t\t\t\tif(max.peek() > min.peek()) {\r\n\t\t\t\t\tmin.offer(max.poll());\r\n\t\t\t\t\tmax.offer(min.poll());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tsb.append(max.peek()+\"\\n\");\r\n\t\t}\r\n\t\tSystem.out.println(sb);\r\n\t}\r\n}\r\n\r\n```\r\n\r\n우선순위 큐는 이렇게 마무리!!\r\n\r\n# Update) 2021-01-14\r\n백준 2981번이 비슷한 유형이라 풀고 추가로 update 한다.\r\n# 백준 2981\r\n![문제사진3](problem3.PNG)\r\n![문제사진4](problem4.PNG)\r\n\r\n\r\n```java\r\npackage priorityQueue;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.Comparator;\r\nimport java.util.PriorityQueue;\r\nimport java.util.Queue;\r\n\r\npublic class num2696 {\r\n\r\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\tQueue<Integer> minHeap = new PriorityQueue<>();\r\n\t\tQueue<Integer> maxHeap = new PriorityQueue<>(new Comparator<Integer>() {\r\n\t\t\t@Override\r\n\t\t\tpublic int compare(Integer o1, Integer o2) {\r\n\t\t\t\treturn o2.compareTo(o1);\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\tint T = Integer.parseInt(br.readLine());\r\n\t\t\r\n\t\tfor(int i=0; i<T; i++) {\r\n\t\t\tint count = Integer.parseInt(br.readLine());\r\n\t\t\tString[] inputData = br.readLine().split(\" \");\r\n\t\t\tsb.append(count/2+count%2 + \"\\n\");\r\n\t\t\tint index = 0;\r\n\t\t\tint jindex = 0;\r\n\t\t\tfor(int j=0; j<count; j++) {\r\n\t\t\t\tif(j%10==0 && j>9) {\r\n\t\t\t\t\tinputData = br.readLine().split(\" \");\r\n\t\t\t\t\tif(j%20==0) {\r\n\t\t\t\t\t\tsb.append(\"\\n\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tjindex=0;\r\n\t\t\t\t}\r\n\t\t\t\tint num = Integer.parseInt(inputData[jindex]);\r\n\t\t\t\tif(jindex==0 && j==0) {\r\n\t\t\t\t\tjindex++;\r\n\t\t\t\t\tindex = num;\r\n\t\t\t\t\tsb.append(num + \" \");\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif(num <= index) {\r\n\t\t\t\t\tmaxHeap.offer(num);\r\n\t\t\t\t\tif(maxHeap.size() - minHeap.size()>=1) {\r\n\t\t\t\t\t\tminHeap.offer(index);\r\n\t\t\t\t\t\tindex = maxHeap.poll();\r\n\t\t\t\t\t}\r\n\t\t\t\t}else {\r\n\t\t\t\t\tminHeap.offer(num);\r\n\t\t\t\t\tif(minHeap.size() - maxHeap.size()>=2) {\r\n\t\t\t\t\t\tmaxHeap.offer(index);\r\n\t\t\t\t\t\tindex = minHeap.poll();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(jindex%2==0) {\r\n\t\t\t\t\tsb.append(index + \" \");\r\n\t\t\t\t}\r\n\t\t\t\tjindex++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tsb.append(\"\\n\");\r\n\t\t\tminHeap.clear();\r\n\t\t\tmaxHeap.clear();\r\n\t\t}\r\n\t\tSystem.out.println(sb);\r\n\t}\r\n\r\n}\r\n\r\n```\r\n\r\n이 문제는 한 줄에 10개씩 들어온다는게 포인트다. 10개씩 장난쳐줘야 한다.\r\n\r\n정말 끝","excerpt":"백준 단계별 문제 - 우선순위 큐 마지막 문제다.   풀다가 조금 헷갈린 부분이 있어 정리하고자 포스팅한다.   문제 \n 일단 문제에 처음 접근할 땐, 우선순위 큐를 사용해 저장하고 중간 값을 계속 뽑아와 StringBuilder에 넣어주는 방식으로…","fields":{"slug":"/backjoon1655/"},"frontmatter":{"date":"Jan 13, 2021","title":"백준 1655 - 가운데를 말해요 풀이","tags":["Algorithm","BackJoon"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n문제를 풀다 조금 재밌는 부분이 생겨 정리한다.\r\n\r\n![문제사진](problem1.PNG)\r\n![문제사진2](problem2.PNG)\r\n\r\n백준 문제를 풀 때 한가지 팁은 문제가 낮은 정답비율이면  \r\n입출력이나 시간복잡도를 확인하는게 좋은거같다.  \r\n\r\n일단 뭔가 최대공약수로 장난치는 문제인 느낌을 받아서 규칙을 찾아보았다.\r\n\r\n```\r\narr[1] % M + r = arr[2] % M + r = arr[3] % M + r\r\n -> 요런 식이 나온다. 조금 장난쳐보면\r\n\r\narr[3] % M + r - arr[2] % M - r = arr[2] % M + r - arr[1] % M - r\r\n\r\n(arr[3] - arr[2]) % M = (arr[2] - arr[1]) % M\r\n\r\n(arr[n] - arr[n-1]) % M\r\n```\r\n\r\nㅋ 찾았다.\r\n\r\n```java\r\npackage package16;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class num2981 {\r\n\r\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tint N = Integer.parseInt(br.readLine());\r\n\t\tint[] arr = new int[N];\r\n\t\tint arrGcdValue = 0;\r\n\t\t\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tarr[i] = Integer.parseInt(br.readLine());\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=1; i<N; i++) {\r\n\t\t\tarrGcdValue = gcd(arrGcdValue, Math.abs(arr[i] - arr[i-1]));\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=2; i<=arrGcdValue; i++) {\r\n\t\t\tif(arrGcdValue % i == 0)\r\n\t\t\t\tSystem.out.print(i + \" \");\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static int gcd(int a, int b) {\r\n\t\treturn a % b == 0 ? b : gcd(b, a % b);\r\n\t}\r\n\r\n}\r\n```\r\n아 조금 주의할 점, arr[n] - arr[n-1]값이 음수일 수 있어서 절대값으로 받아야 한다.\r\n\r\n오늘은 뭔가 낚이지 않은 기분이다. 👌하핳","excerpt":"문제를 풀다 조금 재밌는 부분이 생겨 정리한다. \n 백준 문제를 풀 때 한가지 팁은 문제가 낮은 정답비율이면 입출력이나 시간복잡도를 확인하는게 좋은거같다.   일단 뭔가 최대공약수로 장난치는 문제인 느낌을 받아서 규칙을 찾아보았다. ㅋ 찾았다. 아 …","fields":{"slug":"/backjoon2981/"},"frontmatter":{"date":"Jan 09, 2021","title":"백준 2981 - 검문 풀이","tags":["Algorithm","BackJoon"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n풀이를 보고 바로 이해하지 못하고 헷갈린 부분이 있어서 정리한다.\r\n\r\n![문제사진](problem.PNG)\r\n\r\n# LCS란?\r\n공통적으로 가지고 있는 부분 문자열 중, 가장 긴 문자열(최장 공통 부분 수열)\r\n\r\n## 규칙찾기\r\n\r\n점화식을 찾아내기 전에 문제에 나온 예제 입력값을 통해 규칙을 찾아보면\r\n\r\n```\r\nindex   C A P C A K\r\nA       0 1 1 1 1 1\r\nC       1 1 1 2 2 2\r\nA       1 2 2 2 3 3\r\nY       1 2 2 2 3 3\r\nK       1 2 2 2 3 4\r\nP       1 2 3 3 3 4\r\n```\r\n\r\n## 접근\r\n\r\n문제의 경우는 2가지로 나눌 수 있다.\r\n\r\n 1) 두 문자열에 같은 문자가 추가되는 경우\r\n    - ex) ACAYKP**A** , CAPCAK**A**\r\n 2) 두 문자열에 다른 문자가 추가되는 경우\r\n    - ex) ACAYKP**B** , CAPCAK**C**\r\n\r\n## 점화식\r\n두 가지 경우를 각각 점화식으로 나타내 보면\r\n```\r\n 1) dp[i][j] = dp[i-1][j-1] + 1\r\n 2) dp[i][j] = Max(arr[i][j-1], arr[i-1][j])\r\n```\r\n\r\n점화식을 찾아냈으면 코드작성은 쉽다.\r\n\r\n## 코드\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class num9251 {\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tString[] str1 = br.readLine().split(\"\");\r\n\t\tString[] str2 = br.readLine().split(\"\");\r\n\t\t\r\n\t\tint N = str1.length;\r\n\t\tint M = str2.length;\r\n\t\tint[][] arr = new int[N+1][M+1];\r\n\t\t\r\n\t\tfor(int i=1;i<=N;i++) {\r\n\t\t\tfor(int j=1;j<=M;j++) {\r\n\t\t\t\tif(str1[i-1].equals(str2[j-1])) {\r\n\t\t\t\t\tarr[i][j] = arr[i-1][j-1] +1;\r\n\t\t\t\t}else {\r\n\t\t\t\t\tarr[i][j] = Math.max(arr[i][j-1],arr[i-1][j]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tSystem.out.println(arr[N][M]);\r\n\t}\r\n}\r\n```","excerpt":"풀이를 보고 바로 이해하지 못하고 헷갈린 부분이 있어서 정리한다.  LCS란? 공통적으로 가지고 있는 부분 문자열 중, 가장 긴 문자열(최장 공통 부분 수열) 규칙찾기 점화식을 찾아내기 전에 문제에 나온 예제 입력값을 통해 규칙을 찾아보면 접근 문제…","fields":{"slug":"/backjoon9251/"},"frontmatter":{"date":"Dec 28, 2020","title":"백준 9251 - LCS 풀이","tags":["Algorithm","BackJoon"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n기술 면접을 준비하면서 면접에 자주 나오는 문항들을 정리해보려고 한다.\r\n\r\n본 포스트는 취업 준비를 하면서 부족한 부분을 지속해서 업데이트할 예정이다.\r\n\r\n# 시작하기전에\r\n - 1) 수행한 프로젝트, 준비한 사항은 **분명하고 간결하게** 설명 가능해야 한다.\r\n - 2) 쫄지말자, 당당하게\r\n - 3) 답변을 추상적이게 하지 말고, **구체적으로 아는 쪽으로 답변**\r\n\r\n\r\n# 목차\r\n\r\n# Part1. CS\r\n\r\n\r\n### 1. 객체 지향 프로그래밍\r\n\r\n```\r\n1. 정의\r\n  프로그램을 수많은 '객체'라는 기본 단위로 나누고 이 객체들의 상호작용으로 서술\r\n  - 객체란, 하나의 역할을 수행하는 '메소드와 변수(데이터)'\r\n\r\n2. 특징\r\n - 인간 중심적 프로그래밍 패러다임\r\n - 프로그램 설계 방법론이자 개념의 일종\r\n - 현실 세계 사물 -> 객체\r\n - 어플리케이션 특징(객체의 상호작용) -> 프로그래밍(=추상화)\r\n\r\n3. 장점\r\n - 코드 재사용 용이\r\n - 유지 보수 쉬움\r\n - 강한 응집력과 약한 결합력을 가진다\r\n - (응집력 : 기능을 수행하기 위해 얼마만큼의 연관된 책임과 아이디어가 뭉친 정도)\r\n - (결합력 : 프로그램의 요소가 다른 것과 얼마나 연결되어 있는지, 의존적인지)\r\n\r\n4. 단점\r\n - 설계시 많은 시간 필요\r\n - 객체들간의 통신시 오버헤드 발생해서 처리속도가 상대적으로 느림\r\n```\r\n\r\n **1. 객체 지향 프로그래밍이 뭔가요?**  \r\n    - 프로그램 설계 방법론입니다. 현실 세계의 사물을 추상화하여 객체를 만들고, 객체간의 상호작용을 통해 시스템을 구성하는 프로그래밍 방법입니다.  \r\n    특징으로는 추상화, 캡슐화, 상속, 다형성이 있습니다\r\n    장점으로는 코드 재사용이 용이, 유지보수가 쉬움, 강한 응집력과 약한 결합력을 가지는 것이 있고,  \r\n    단점으로는 설계시 많은 시간이 필요하고, 객체들간의 통신시 오버헤드가 발생해 처리속도가 상대적으로 느립니다.\r\n\r\n**1-1. 객체지향에서 말하는 추상화가 뭔가요?**  \r\n    - 객체에서 공통된 속성과 행위를 뽑아내는 것을 말합니다.  \r\n\r\n\r\n**1-2. 객체지향에서 말하는 캡슐화가 뭔가요?**  \r\n    - 변수와 함수를 하나의 단위로 묶는 것을 의미합니다. 추가로 자바에서는 접근 제어자를 통해 정보 은닉 기능을 제공합니다. 정보 은닉은, 프로그램의 세부 구현을 외부로 드러내지 않도록 감추는 것을 말합니다.  \r\n\r\n\r\n**1-3. 객체지향에서 말하는 상속이 뭔가요?**  \r\n    - 기존 클래스를 활용하여 새로운 클래스를 작성하는 것을 말합니다. 상속의 장점은 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램 생산성과 유지보수에 기여합니다.    \r\n\r\n\r\n**1-4. 객체지향에서 말하는 다형성이 뭔가요?**  \r\n    - 다향한 형태로 나타날 수 있는 특성을 말합니다.  \r\n\r\n**1-5. 객체지향에서 말하는 응집력과 결합력이 뭔가요?**  \r\n    - 응집력은 기능을 수행하기 위해 얼마만큼의 책임과 아이디어가 뭉쳐있는지 나타내는 정도입니다.  \r\n    - 결합력은 다른 요소와 얼마나 의존적인지 나타내는 정도입니다.\r\n\r\n**2. 객체와 인스턴스가 뭔가요?**  \r\n    - 인스턴스는 객체를 실체화한 것입니다. 즉, 프로그램 코드 상에서 자료형이 임의의 클래스로 선언된 클래스를 객체라 하고, 코드 컴파일 후 프로그램이 실행될 때 해당 객체가 메모리에 적재되면 인스턴스라 합니다. \r\n\r\n**3. 객체 지향 프로그래밍과 절차지향 프로그래밍을 설명해주세요**\r\n    - 절차지향 프로그래밍이란 '프로그램이 무슨일을 하는가'의 관점으로 바라본 프로그래밍 기법이고,\r\n    - 객체지향 프로그래밍은 '어떤 대상을 모델링하는가'의 관점으로 바라본 프로그래밍 기법입니다.\r\n    - 즉, 절차지향 프로그래밍은 프로그램의 순서와 흐름을 먼저 세우고 필요한 자료구조와 함수들을 설계하는 방식이고, 객체지향 프로그래밍은 반대로 자료구조와 이를 중심으로 한 모듈들을 먼저 설계한 다음에 이들의 실행순서와 흐름을 짜는 방식이다.\r\n\r\n### 2. RESTful API\r\n\r\n```\r\n1. 정의\r\n - 소프트웨어 아키텍처의 한 형식으로 자원을 정의하고 자원에 대한 주소를 지정하는 방법  \r\n\r\n2. 특징\r\n - 지정한 주소를 HTTP Method를 통해 자원을 처리한다.\r\n - REST의 6가지 기본 원칙을 성실히 지킨 서비스 디자인을 RESTful하다라고 표현\r\n\r\n3. 장점\r\n - 기존 웹 인프라를 그대로 사용할 수 있다.\r\n - 쉽고, 빠르다\r\n - 세부적인 표현 문구를 JSON, XML등 다양한 언어를 이용하여 작성할 수 있다.\r\n\r\n4. 단점\r\n - 메소드 형태가 제한적이다.\r\n - 표준 규약이 없다.\r\n - HTTP 통신 모델에 대해서만 지원합니다.\r\n```\r\n\r\n**1. API란 무엇인가요?**  \r\n    - API란, 응용 프로그램에서 사용할 수 있도록 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻합니다.  \r\n\r\n**2. REST API란 무엇인가요?**  \r\n    - 자원이 있는 곳을 URI로 정의하고, 자원을 이용하는 방법을 HTTP Method를 통해 자원을 처리하는 것을 말합니다.  \r\n\r\n**3. RESTful 하게 API를 디자인 한다는 것은 무엇을 의미하는가?**  \r\n    - REST API의 6가지 기본 원칙을 성실히 지킨 서비스를 RESTful하다라고 표현합니다.  \r\n\r\n### 3. TDD\r\n\r\n```\r\n1. 정의\r\n - 테스트 주도 개발\r\n - (개발 테스트 단위가 함수단위로 매우 작아서 작성하는 거의 모든 함수가 테스트에 포함된다.)\r\n\r\n2. 관련 용어\r\n 1) BDD : 시나리오 기반으로 테스트 케이스 작성\r\n  - Given -> When -> Then\r\n  - 어떤 상태 (Given) -> 어떤 상태 변화를 가했을 때(When) -> 기대하는 상태로 완료(Then)\r\n\r\n3. 장점\r\n - 피드백이 많아진다.\r\n - (테스트를 통과하는 것으로 개발이 잘 진행되는지 자주 확인가능해진다.)\r\n - 코드 복잡도가 낮아진다.\r\n\r\n4. 단점\r\n - 개발시간이 길어진다.\r\n```\r\n\r\n**1. TDD에 대해 설명해주세요**\r\n\r\n**2. BDD에 대해 아시나요?**\r\n\r\n**3. 좋은 코드에 대해 어떻게 생각하시나요? (내생각)**  \r\n    - 저는 좋은 코드를 판단하는 기준으로 **가독성, 효율성**이 가장 중요하다고 생각합니다.  \r\n   Coding Convention을 잘 지키고 일관성있게 작성되며, 문제상황에서 필요한 요구사항을 적절히 충족하고 효율적으로 해결하는 코드가 좋은 코드라고 생각합니다.\r\n\r\n\r\n\r\n### 4. GIT\r\n\r\n```\r\n1. 정의\r\n - 버전 관리 시스템\r\n\r\n2. 장점\r\n - 여러명이 동시에 작업하는 병렬 개발이 가능하다.\r\n - 분산 버전관리이기 때문에 인터넷이 연결되지 않은 곳에서도 개발을 진행할 수 있다.\r\n - 체계적인 개발이 가능해진다.\r\n```\r\n\r\n**1. Git의 장점에 대해 설명해주세요**\r\n    - 여러명이 동시 작업하는 병렬 개발이 가능하고, 분산 버전관리기 때문에 인터넷이 연결되지 않은 곳에서도 개발을 진행할 수 있는 것이 장점입니다.\r\n\r\n## Part 1-2 자료구조\r\n\r\n### 1. Array / LinkedList\r\n\r\n### 2. Stack / Queue\r\n\r\n**1. Stack에 대해 설명해주세요**  \r\n    - 선형 자료구조의 일종으로 Firt In Last Out (FILO)구조를 가집니다.\r\n\r\n\r\n**2. Queue에 대해 설명해주세요**  \r\n    - 선형 자료구조의 일종으로 First In First Out (FIFO)구조를 가집니다.\r\n\r\n\r\n### 3. Tree\r\n```\r\n 1. Binary Tree(이진트리)\r\n\r\n 2. BST(Binary Search Tree)\r\n\r\n 3. Binary Heap\r\n\r\n 4. Red Black Tree\r\n\r\n 5. Graph\r\n\r\n```\r\n**1. Tree에 대해 설명해주세요**  \r\n    - 비선형 자료구조이다. 트리는 계층적 관계(Hierarchical Relationship)을 표현하는 자료구조이다. \r\n\r\n**2. 이진트리(Binary Tree)에 대해 설명해주세요.**\r\n\r\n## Part 1-3 알고리즘\r\n\r\n## Part 1-4 네트워크\r\n\r\n### 1. HTTP Method\r\n\r\n\r\n### 2. TCP/UDP\r\n\r\n\r\n\r\n### 3. HTTP/HTTPS\r\n\r\n\r\n### 4. 웹 통신의 흐름\r\n\r\n\r\n## Part 1-5 운영체제\r\n\r\n### 1. 프로세스/스레드\r\n\r\n\r\n\r\n\r\n### 2. 멀티스레드/멀티 프로세스\r\n\r\n\r\n### 3. 동기/비동기\r\n\r\n\r\n**1.재귀 호출의 단점은?**  \r\n    - 재귀 호출 시, 함수를 반복해서 호출해야 하는데, 매번 호출할 때마다 시간과 스택 공간에서 오버헤드 발생.\r\n\r\n\r\n## Part 1-6 데이터 베이스\r\n\r\n### 1. 데이터 베이스 사용하는 이유\r\n\r\n\r\n### 2. 정규화\r\n\r\n\r\n### 3. 트랜잭션\r\n\r\n### 4. NoSQL\r\n\r\n\r\n## Part 1-7 디자인 패턴\r\n\r\n### 디자인 패턴이란?\r\n> 프로그램 개발 시에 자주 생기는 에로 상황에 대한 일반적이고 재사용 가능한 추상화된 해결책이다.\r\n\r\n\r\n### 1. MVC 패턴이란?\r\n\r\n```\r\n1. 정의 - Model-View-Controller의 약자로, 개발할 때 3가지 형태로 나눠 개발하는 방법론\r\n\r\n2. 특징\r\n - Model : 어플리케이션이 무엇을 할 지 정의\r\n - View : 어플리케이션 화면에 무엇을 보여줄지\r\n - Controller : 어플리케이션이 어떻게 처리할지\r\n   -> Model, View가 무엇을 해야 할 지를 알고 통제\r\n\r\n3. 관련 용어\r\n - Service\r\n\r\n4. 장점\r\n -\r\n\r\n5. 단점\r\n```\r\n\r\n## Part 1-8 보안\r\n\r\n# Part2. Language\r\n\r\n## 1. JAVA\r\n\r\n1. JVM이란?\r\n   - 자바가상머신의 약자를 줄여서 부르는 용어입니다. **프로그램을 실행하기 위해 물리적 머신과 유사한 머신을 소프트웨어로 구현**한 것을 말합니다.\r\n\r\n2. GC이란?\r\n   - \r\n\r\n## 2. JavaScript\r\n > 프로그래밍 언어로 브라우저가 가진 기능을 코드로 제어\r\n > (이벤트를 제어하기 위함)\r\n\r\n### 2.1 NodeJS\r\n > 자바스크립트의 언어와 환경이 분리 필요\r\n -> 웹서버를 동작하기 위한 도구로 구글의 V8 Engine기반 **NodeJS** 탄생!!\r\n\r\n## 3. C\r\n\r\n1. C에서는 메모리를 어떻게 할당하는가?\r\n    - d\r\n\r\n# Part3. FrontEnd\r\n**프레임 워크와 플랫폼의 차이가 뭔가요?**\r\n\r\n**Cookie, Session Storage, LocalStorage의 차이점을 말해주세요**\r\n\r\n\r\n**UI(User Interface)란?**\r\n   - 사용자와 시스템의 접점\r\n\r\n\r\n## 1. Vitual DOM\r\n\r\n## 2. React.js\r\n\r\n\r\n## 3. Vue.js\r\n\r\n\r\n# Part4. BackEnd\r\n\r\n## 1. Spring\r\n\r\n## 2. Express\r\n\r\n# Part5. Project\r\n\r\n\r\n## IoT\r\n\r\n### 1. MQTT\r\n\r\n","excerpt":"기술 면접을 준비하면서 면접에 자주 나오는 문항들을 정리해보려고 한다. 본 포스트는 취업 준비를 하면서 부족한 부분을 지속해서 업데이트할 예정이다. 시작하기전에 수행한 프로젝트, 준비한 사항은 분명하고 간결하게 설명 가능해야 한다. 쫄지말자, 당당하…","fields":{"slug":"/techInterview/"},"frontmatter":{"date":"Dec 28, 2020","title":"개발 기술 면접 준비","tags":["면접"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\nAWS EC2를 사용해서 구현해야 할 일이 생겨서 간만에 사용하다 잘 안되서 기록해둔다.\r\n\r\n1. AWS EC2 인스턴스 생성\r\n\r\n2. vscode extensions에서 ftp-simple을 설치해준다.\r\n\r\n3. F1을 눌러 ftp-simple : Config - FTP connection setting 실행.  \r\n 다음 사진과 같이 설정해준다.\r\n\r\n![설정 json](./201205_jsoncapture.PNG \"json파일\")\r\n\r\n1. F1 눌러 Remote directory open to workspace 실행하면 된다.\r\n","excerpt":"AWS EC2를 사용해서 구현해야 할 일이 생겨서 간만에 사용하다 잘 안되서 기록해둔다. AWS EC2 인스턴스 생성 vscode extensions에서 ftp-simple을 설치해준다. F1을 눌러 ftp-simple : Config - FTP c…","fields":{"slug":"/vscode_connect_aws/"},"frontmatter":{"date":"Dec 05, 2020","title":"AWS EC2 Visual Studio Code로 사용하기","tags":["AWS"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n백준 DP 단계별 문제에 있는 10844번 문제이다. \r\n\r\n접근이 조금 어려웠던 문제라 풀이를 정리해보려고 한다.  \r\n\r\n## 접근\r\n\r\n일단 이 문제는 DP문제로 2차원 배열을 DP로 사용해야 한다.\r\n\r\n규칙을 찾기 위해 값을 적어보고, 개수를 세보면 아래와 같다.  \r\n(N : 자리수, index : 맨 마지막에오는 숫자)  \r\n```\r\nindex   0 1 2 3 4 5 6 7 8 9\r\nN=1     0 1 1 1 1 1 1 1 1 1  \r\nN=2     1 1 2 2 2 2 2 2 2 1\r\nN=3     1 3 3 4 4 4 4 4 3 2\r\n\r\nex)\r\nN=2 -> (10), (21), (32, 12), (43,23), (54,34), (65,45), (76,56), (87,67), (98,78), (89)\r\n```\r\ndp[N][index] = dp[N-1][index-1] + dp[N-1][index+1]인 점화식을 얻을 수 있다.\r\n\r\n단, 여기서 중요한 점은 index가 0일 경우는 +1 한 값이 허용되고  \r\n9일 경우는 -1 한 경우만 적용되기 때문에 예외 처리를 해줘야 한다.  \r\n\r\n마지막으로 점화식을 정리해보면\r\n```\r\n1) index가 1일 경우\r\ndp[N][index] = dp[N-1][index+1]\r\n\r\n2) index가 1~8일 경우\r\ndp[N][index] = dp[N-1][index-1] + dp[N-1][index+1]\r\n\r\n3) index가 9일 경우\r\ndp[N][index] = dp[N-1][index-1]\r\n\r\n```\r\n\r\n3가지 경우에 따라 분기처리를 하면 된다.\r\n\r\n# Top-down 방식\r\n\r\n## 구현코드\r\n\r\n```java\r\npackage package14;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class num10844 {\r\n\tstatic Long[][] dp;\r\n\tstatic int N;\r\n\tfinal static long MOD = 1000000000;\r\n\t\r\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tN = Integer.parseInt(br.readLine());\r\n\t\tdp = new Long[N+1][10];\r\n\t\t// #1\r\n\t\tfor(int i = 0; i < 10; i++) {\r\n\t\t\tdp[1][i] = 1L;\r\n\t\t}\r\n\r\n\t\tlong result = 0;\r\n\t\t\r\n\t\tfor(int i = 1; i <= 9; i++) {\r\n\t\t\tresult += recur(N, i);\r\n\t\t}\r\n\t\tSystem.out.println(result % MOD);\r\n\t}\r\n\t\r\n\tstatic long recur(int digit, int val) {\t\t\r\n\t\t\r\n\t\tif(digit == 1) {\r\n\t\t\treturn dp[digit][val];\r\n\t\t}\r\n\t\t// #2\r\n\t\tif(dp[digit][val] == null) {\r\n\t\t\tif(val == 0) {\r\n\t\t\t\tdp[digit][val] = recur(digit - 1 ,1);\r\n\t\t\t}\r\n\t\t\telse if(val== 9) {\r\n\t\t\t\tdp[digit][val] = recur(digit - 1, 8);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tdp[digit][val] = recur(digit - 1, val - 1) + recur(digit - 1, val + 1);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn dp[digit][val] % MOD;\r\n\t}\r\n}\r\n\r\n\r\n```\r\n\r\n## 코드설명\r\n 1) N=1인 값들은 값을 초기값으로 값을 넣어준다.\r\n 2) 점화식과 동일하게 상황에 따라 맞는 값을 재귀로 호출한다.\r\n\r\n# Bottom-up 방식\r\n\r\n## 구현 코드\r\n\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.InputStreamReader;\r\nimport java.io.IOException;\r\n \r\npublic class Main {\r\n\t\r\n\tfinal static long mod = 1000000000;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\t\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tint N = Integer.parseInt(br.readLine());\r\n\t\t\r\n\t\tlong[][] dp = new long[N + 1][10];\r\n\t\t\r\n\t\tfor(int i = 1; i < 10; i++) {\r\n\t\t\tdp[1][i] = 1; \r\n\t\t}\r\n\t\t\r\n\t\t// 두 번째 자릿수부터 N까지 탐색 \r\n\t\tfor(int i = 2; i <= N; i++) {\r\n\t\t\t\r\n\t\t\tfor(int j = 0; j < 10; j++) {\r\n\t\t\t\t\r\n\t\t\t\tif(j == 0) {\r\n\t\t\t\t\tdp[i][0] = dp[i - 1][1] % mod;\r\n\t\t\t\t}\r\n\t\t\t\telse if (j == 9) {\r\n\t\t\t\t\tdp[i][9] = dp[i - 1][8] % mod;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tdp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j + 1]) % mod;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tlong result = 0;\r\n\t\t\r\n\t\tfor(int i = 0; i < 10; i++) {\r\n\t\t\tresult += dp[N][i];\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(result % mod);\r\n\t}\r\n \r\n}\r\n```\r\n\r\n## 코드설명\r\n - Top-down방식과 동일한데 재귀 부분을 for문으로 두번째 자리부터 N까지 탐색한다.\r\n\r\n\r\n# \r\n<hr>\r\n\r\n아직 DP문제를 많이 풀어보지 않아서 그런지 점화식 만들어 내는 과정이 어렵다... ㅜㅜㅜㅜㅜ  \r\n익숙해질 때까지 열심히 풀어야겠다 (승질 그만내고 ㅎㅎ)","excerpt":"백준 DP 단계별 문제에 있는 10844번 문제이다.  접근이 조금 어려웠던 문제라 풀이를 정리해보려고 한다.   접근 일단 이 문제는 DP문제로 2차원 배열을 DP로 사용해야 한다. 규칙을 찾기 위해 값을 적어보고, 개수를 세보면 아래와 같다. (…","fields":{"slug":"/backjoon10844/"},"frontmatter":{"date":"Dec 03, 2020","title":"백준 10844번 - 쉬운 계단수 풀이","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"알고리즘 문제를 풀면서 많이 하는 실수를 정리할 필요성을 느꼈다.  \r\n본 포스트는 주의해야 할 실수가 생길 때 마다 update할 예정이다.\r\n\r\n# 백트래킹\r\n > 재귀함수 빠져나오면 상태 값 원래대로 돌려줘야 함.\r\n\r\n# 최단거리\r\n > 값 넣어줄 때, 입력값 -1 해서 받아야 함 (배열 index로 사용하기 때문)","excerpt":"알고리즘 문제를 풀면서 많이 하는 실수를 정리할 필요성을 느꼈다. 본 포스트는 주의해야 할 실수가 생길 때 마다 update할 예정이다. 백트래킹 재귀함수 빠져나오면 상태 값 원래대로 돌려줘야 함. 최단거리 값 넣어줄 때, 입력값 -1 해서 받아야 …","fields":{"slug":"/algoMistake/"},"frontmatter":{"date":"Nov 25, 2020","title":"알고리즘 풀 때 많이하는 실수","tags":["Algorithm"],"update":"Jan 25, 2021"}}},{"node":{"rawMarkdownBody":"\r\n# Comparable\r\n > 클래스의 기본 정렬 기준을 설정하는 인터페이스\r\n\r\n\r\n## 1) 특징\r\n - Comparable 인터페이스 상속 후, compareTo 메소드 오버라이딩\r\n - compareTo메소드 리턴 값은 음수, 0, 양수가 될 수 있다. **음수가 리턴되면 인자의 순서가 아래로 이동**\r\n - 자바에서 제공되는 정렬이 가능한 클래스는 모두 Comparable 클래스로 구현되어 있음\r\n \r\n## 2) 구현 코드\r\n\r\n# Comparator\r\n > 기본 정렬과 다르게 정렬하고 싶을 때 이용하는 클래스\r\n## 1) 특징\r\n - 보통 구현 되어있는 sort함수의 2번째 인자로 Comparator 타입을 받아(익명함수) compare 메소드 오버라이딩을 통해 배열 정렬 순서 재정의\r\n - 보통 한번 사용하고 사용하지 않기 때문에 익명객체로 만듬\r\n\r\n## 2) 구현 코드\r\n\r\n# 관련 백준 문제\r\n - 11650, 11651, 1181, 10814","excerpt":"Comparable 클래스의 기본 정렬 기준을 설정하는 인터페이스 1) 특징 Comparable 인터페이스 상속 후, compareTo 메소드 오버라이딩 compareTo메소드 리턴 값은 음수, 0, 양수가 될 수 있다. 음수가 리턴되면 인자의 순서…","fields":{"slug":"/javaComparableComparator/"},"frontmatter":{"date":"Nov 24, 2020","title":"JAVA Comparable, Comparator 사용","tags":["JAVA"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n이전부터 자주 헷갈렸던 순열, 조합, 부분집합의 개념 정리와 JAVA를 사용해 구현하는 방법을 정리해 보려고 한다.  \r\n\r\n1) 대표적인 구현 방법  \r\n2) 각, 방법의 특징    \r\n\r\n두가지 사항으로 정리한다.  \r\n\r\n# 순열\r\n\r\n  - n개의 원소 중, r개를 일렬로 나열하는 수열  \r\n  - 중복 X / 순서 고려\r\n\r\n## 1. next_permutation\r\n\r\n### 1) 특징\r\n - 이게 이해하기 제일 어려웠다.... (나만 어렵나...ㅜㅜ)\r\n - 무작위 순열의 다음 순열을 구해내는 알고리즘\r\n - 시작 조건 : 오름차순 / 종료 조건 : 내림차순\r\n```\r\n  순서\r\n  1.Find largest index i such that array[i − 1] < array[i].\r\n  (If no such i exists, then this is already the last permutation.)\r\n\r\n  2.Find largest index j such that j ≥ i and array[j] > array[i − 1].\r\n\r\n  3.Swap array[j] and array[i − 1].\r\n\r\n  4.Reverse the suffix starting at array[i].\r\n```\r\n\r\n### 2) 구현 코드\r\n```java\r\npublic class num1 {\r\n    public static void main(String[] args) {\r\n    \tint[] list = new int[]{5,4,3};\r\n    \t// #1 시작 조건에 맞게 list 오름차순 정렬 (시작조건)\r\n    \tArrays.sort(list);\r\n    \tpermutation(list);\r\n    }\r\n    // #2 처음 list값 print 후, 다음 순열 찾음\r\n    public static void permutation(int[] list) {\r\n        int[] curArray = list;\r\n        while (true) {\r\n        \tprintArray(curArray);\r\n        \tcurArray = nextPermutation(curArray);\r\n            if (curArray == null) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    \r\n    public static int[] nextPermutation(int[] list) {\r\n    \t  // #3 수열의 바로 앞 값 보다 큰 값 중 가장 큰 index 찾는다. \r\n        // (가장 적은 차이로 순서를 바꾸기 위해서 가장 큰 index를 찾음) \r\n        int i = list.length -1;\r\n        while(i>0 && list[i-1] >= list[i])\r\n        \ti--;\r\n        \r\n        // #6 list가 내림차순으로 정렬되어 있으면 순열을 끝까지 찾은 것 (종료조건)\r\n        if(i<=0)\r\n        \treturn null;\r\n        \r\n        int j = list.length -1;\r\n        // #4 다음 수열의 특징 : 이전 순열보다 값이 큼\r\n        // -> list[i-1] < list[j] 값을 찾고, 값을 바꿔준다.\r\n        while(list[j] <= list[i-1])\r\n        \tj--;\r\n        \r\n        int temp = list[i-1];\r\n        list[i - 1] = list[j];\r\n        list[j] = temp;\r\n        // #5 a[i] 이후 부분을 오름차순으로 셋팅 \r\n        j= list.length-1;\r\n        while (i < j) {\r\n            temp = list[i];\r\n            list[i] = list[j];\r\n            list[j] = temp;\r\n            i++;\r\n            j--;\r\n        }\r\n        \r\n        return list;\r\n    }\r\n    \r\n    public static void printArray(int[] array) {\r\n    \tfor(int i=0;i<array.length;i++)\r\n    \t\tSystem.out.print(array[i] + \" \");\r\n    \tSystem.out.println();\r\n    }\r\n    \r\n}\r\n\r\n```\r\n### 3) 코드 설명\r\n\r\n1. 시작 조건에 맞게 list 오름차순 정렬 (시작조건)\r\n2. 처음 list값 print 후, 다음 순열 찾음\r\n3. 수열의 바로 앞 값 보다 큰 값 중 가장 큰 index 찾는다.  \r\n  (가장 적은 차이로 순서를 바꾸기 위해서 가장 큰 index를 찾음)\r\n4. 다음 수열의 특징 : 이전 순열보다 값이 큼 -> list[i-1] < list[j] 값을 찾고, 값을 바꿔준다.\r\n5. a[i] 이후 부분을 오름차순으로 셋팅 \r\n6. list가 내림차순으로 정렬되어 있으면 순열을 끝까지 찾은 것 (종료조건)\r\n\r\n### 4) 코드 출력값\r\n```\r\n3 4 5 \r\n3 5 4 \r\n4 3 5 \r\n4 5 3 \r\n5 3 4 \r\n5 4 3 \r\n\r\n```\r\n\r\n## 2. Swap\r\n\r\n### 1) 특징\r\n - 순열의 순서가 보장되지 않는다. (사전식 X)\r\n\r\n\r\n### 2) 구현 코드\r\n```java\r\npublic class Main {\r\n  public static void main(String[] args) {\r\n  \tint[] arr = {1,2,3};\r\n  \tpermutation(arr,0,3,3);\r\n  \tSystem.out.println(Arrays.toString(arr));\r\n  }\r\n\r\n  static void permutation(int[] arr, int depth, int n, int r) {\r\n  \tif (depth == r) {\r\n  \t\tarrPrint(arr,r);\r\n  \t\treturn;\r\n  \t}\r\n  \tfor (int i=depth; i<n; i++) {\r\n      // #1\r\n  \t\tswap(arr, depth, i);\r\n      // #2\r\n  \t\tpermutation(arr, depth + 1, n, r);\r\n      // #3\r\n     \tswap(arr, depth, i);\r\n  \t}\r\n  }\r\n\r\n  static void arrPrint(int[] arr, int r) {\r\n    for (int i=0 ; i<r; i++)\r\n    \tSystem.out.print(arr[i] + \" \");\r\n    System.out.println();\r\n  }\r\n\r\n  static void swap(int[] arr, int depth, int i) {\r\n    int temp = arr[depth];\r\n    arr[depth] = arr[i];\r\n    arr[i] = temp;\r\n  }\r\n}\r\n```\r\n### 3) 코드 설명\r\n\r\n1. 배열의 첫번째 값부터 하나씩 바꾸면서 swap\r\n2. depth를 기준(Inex)으로 depth보다 작은 인데스 값들은 고정, depth보다 큰 값들을 가지고 swap\r\n3. 재귀함수가 종료조건에 의해 return되면 swap을 한번 더 해줘서 이전 상태 유지\r\n\r\n\r\n### 4) 코드 출력값\r\n```\r\n1 2 3 \r\n1 3 2 \r\n2 1 3 \r\n2 3 1 \r\n3 2 1 \r\n3 1 2 \r\n[1, 2, 3]\r\n```\r\n\r\n## 3. Visit Index 사용\r\n\r\n### 1) 특징\r\n - DFS, 재귀 함수\r\n\r\n\r\n### 2) 구현 코드\r\n\r\n```java\r\npublic class Main {\r\n\tpublic static void main(String[] args) {\r\n\t    int n = 3;\r\n\t    int[] arr = {1, 2, 3};\r\n      // #1\r\n\t    int[] output = new int[n];\r\n\t    boolean[] visited = new boolean[n];\r\n\t    perm(arr, output, visited, 0, n, 2);\r\n\t    System.out.println();\r\n\t}\r\n\r\n\tstatic void perm(int[] arr, int[] output, boolean[] visited, int depth, int n, int r) {\r\n\t    if (depth == r) {\r\n\t        print(output, r);\r\n\t        return;\r\n\t    }\r\n\r\n\t    for (int i = 0; i < n; i++) {\r\n\t        if (visited[i] != true) {\r\n\t            visited[i] = true;\r\n              output[depth] = arr[i];\r\n              // #2\r\n\t            perm(arr, output, visited, depth + 1, n, r);\r\n              // #3\r\n\t            visited[i] = false;\r\n\t        }\r\n\t    }\r\n\t}\r\n\r\n\tstatic void print(int[] arr, int r) {\r\n\t    for (int i = 0; i < r; i++)\r\n\t        System.out.print(arr[i] + \" \");\r\n\t    System.out.println();\r\n\t}\r\n\t\r\n}\r\n\r\n```\r\n### 3) 코드 설명\r\n1. output : 코드 출력 값 / visited : 방문 여부 체크\r\n2. depth -> output 길이라고 생각\r\n3. 방문 여부 false로 체크 -> 모든 인덱스 방문\r\n   \r\n\r\n### 4) 코드 출력값 \r\n```\r\n1 2 \r\n1 3 \r\n2 1 \r\n2 3 \r\n3 1 \r\n3 2 \r\n```\r\n\r\n## 관련 백준 문제\r\n> n과m 시리즈 0 ~ 12\r\n\r\n# Reference\r\n[BaaaaaaaarkingDog님 블로그](https://blog.encrypted.gg/945?category=773649)  \r\n[뱀귤님 블로그](https://bcp0109.tistory.com/entry/%EC%88%9C%EC%97%B4-Permutation-Java?category=848939)  \r\n[junhok82님 블로그](https://velog.io/@junhok82/>Java%EB%A1%9C-%EC%88%9C%EC%97%B4Permutation-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0>)  \r\n[Crocus님 블로그](https://www.crocus.co.kr/1240)","excerpt":"이전부터 자주 헷갈렸던 순열, 조합, 부분집합의 개념 정리와 JAVA를 사용해 구현하는 방법을 정리해 보려고 한다.   대표적인 구현 방법   각, 방법의 특징     두가지 사항으로 정리한다.   순열 n개의 원소 중, r개를 일렬로 나열하는 수열…","fields":{"slug":"/permutation/"},"frontmatter":{"date":"Nov 23, 2020","title":"순열 정리, 구현","tags":["Algorithm"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}},"staticQueryHashes":["2027115977","694178885"]}