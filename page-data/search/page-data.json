{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\r\nIng...\r\n\r\n# 위상 정렬\r\n> 방향 그래프의 모든 노드를 **방향성에 거스르지 않도록 순서대로 나열**하는 것\r\n\r\n## Tip!!\r\n1. **사이클이 존재하면 위상 정렬이 불가능**하다.\r\n2. 그래프에서 **방문 조건이 주어질 때 사용!!**\r\n3. 시간 복잡도 **O(V+E)**이다.\r\n   (모든 노드를 확인하면서, 해당 노드에서 출발하는 간선을 차례대로 제거하기 때문)","excerpt":"Ing... 위상 정렬 방향 그래프의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열하는 것 Tip!! 사이클이 존재하면 위상 정렬이 불가능하다. 그래프에서 방문 조건이 주어질 때 사용!! 시간 복잡도 O(V+E)이다.\n(모든 노드를 확인하면서,…","fields":{"slug":"/topologicalSort/"},"frontmatter":{"date":"Feb 05, 2021","title":"위상정렬 정리","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n# 신장 트리(Spnning Tree)\r\n> 하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프\r\n\r\n# 최소 신장 트리(Minimum Spanning Tree)\r\n> 트리의 간선마다 가중치가 있을 때, **간선의 가중치 합이 최소**인 트리\r\n\r\n신장 트리의 최소비용을 구하는 크루스칼 알고리즘, 프림 알고리즘 2가지 알고리즘에 대해 정리한다.\r\n\r\n## 크루스칼 알고리즘\r\n---\r\n> 간선 선택 기반의 알고리즘으로, 탐욕적인 방법을 이용, 간선을 하나씩 선택해서 MST를 찾는 알고리즘입니다.\r\n\r\n### 특징\r\n---\r\n1. 그리디 알고리즘의 일종 -> 작은 간선부터 훑기 때문에  \r\n2. 시간 복잡도 : **O(ElogE)**  \r\n   -> 가중치 별로 정렬 : O(ElogE) + 정점이 같은 컴포넌트에 속해있는지 확인(Union Find) : 약 O(1) = **O(ElogE)**  \r\n\r\n\r\n### 구현 방법\r\n---\r\n\r\n```\r\n1. 간선을 비용에 따라 오름차순으로 정리하고, 정점을 초기화한다\r\n2. 간선을 하나씩 확인하며 간선이 싸이클을 발생시키지 않으면 간선을 포함시킨다.\r\n3. 간선을 V-1개 뽑았을 때, 이루는 그래프가 MST이다.\r\n```\r\n\r\n## 백준 1197 - 최소 스패닝 트리\r\n\r\n---\r\n\r\n![1197pb1](1197pb1.PNG)\r\n![1197pb2.PNG](1197pb2.PNG)\r\n\r\n---\r\n\r\n### 풀이\r\n---\r\n\r\n1. 간선 클래스를 만들어 우선순위 큐로 저장한다.\r\n2. union find를 사용해 싸이클 검사와 거리를 더해준다.\r\n\r\n---\r\n\r\n```java\r\npackage package29;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.PriorityQueue;\r\nimport java.util.StringTokenizer;\r\n\r\npublic class num1197 {\r\n\tstatic int V, E, result=0, cnt=0;\r\n\tstatic int[] parent;\r\n\tstatic PriorityQueue<Edge> pq = new PriorityQueue<Edge>();\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tString[] VE = br.readLine().split(\" \");\r\n\t\tV = stoi(VE[0]);\r\n\t\tE = stoi(VE[1]);\r\n\t\t\r\n\t\tparent = new int[V+1];\r\n\t\t\r\n\t\tfor(int i=0; i<V+1; i++) {\r\n            parent[i] = i;\r\n        }\r\n\t\t\r\n\t    for(int i=0; i<E; i++) {\r\n\t    \tStringTokenizer st = new StringTokenizer(br.readLine());\r\n\t    \tpq.add(new Edge(stoi(st.nextToken()),stoi(st.nextToken()),stoi(st.nextToken())));\r\n\t    }\r\n\t\t\r\n\t    for(int i=0; i<E; i++) {\r\n\t    \tEdge temp = pq.poll();\r\n\t    \t\r\n\t    \tint a = temp.s;\r\n\t    \tint b = temp.e;\r\n\t    \tif(!union(a, b))\r\n\t    \t\tcontinue;\r\n\t    \tresult+= temp.w;\r\n\t    \tcnt++;\r\n\t    \tif(cnt == V-1)\r\n\t    \t\tbreak;\r\n\t    }\r\n\t    System.out.println(result);\r\n\t}\r\n\t\r\n\tstatic class Edge implements Comparable<Edge>{\r\n\t\tint s, e, w;\r\n\t\tEdge(int s, int e, int w){\r\n\t\t\tthis.s = s;\r\n\t\t\tthis.e = e;\r\n\t\t\tthis.w = w;\r\n\t\t}\r\n\t\t@Override\r\n\t\tpublic int compareTo(Edge o) {\r\n\t\t\treturn o.w >= this.w ? -1: 1;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static int find_parent(int num) {\r\n\t\tif(parent[num] != num)\r\n\t\t\treturn parent[num] = find_parent(parent[num]);\r\n\t\treturn parent[num];\r\n\t}\r\n\r\n\tpublic static boolean union(int a, int b) {\r\n\t\ta = find_parent(a);\r\n\t\tb = find_parent(b);\r\n\t\t\r\n\t\tif(a==b) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse if(a < b)\r\n\t\t\tparent[b] = a;\r\n\t\telse\r\n\t\t\tparent[a] = b;\r\n\t\treturn true;\r\n\t}\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\t\r\n}\r\n\r\n```\r\n\r\n## 백준 4386 - 별자리 만들기\r\n\r\n---\r\n\r\n![4386pb1](4386pb1.PNG)\r\n![4386pb2](4386pb2.PNG)\r\n\r\n---\r\n\r\n### 풀이\r\n---\r\n\r\n정점의 x좌표와 y좌표를 저장할 수 있는 클래스를 만들어 사용했다.\r\n\r\n위의 두문제는 가중치가 주어졌지만, 4386문제는 가중치를 두 점사이 거리로 계산해서 넣어야 한다.\r\n\r\n---\r\n\r\n```java\r\npackage package29;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.PriorityQueue;\r\nimport java.util.StringTokenizer;\r\n\r\npublic class num4386 {\r\n\tstatic int N, cnt=0;\r\n\tstatic double result = 0;\r\n\tstatic int[] parent;\r\n\tstatic PriorityQueue<Edge> pq = new PriorityQueue<Edge>();\r\n\tstatic Vertex[] v;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tN = stoi(br.readLine());\r\n\t\t\r\n\t\tparent = new int[N+1];\r\n\t\tv = new Vertex[N+1];\r\n\t\tfor(int i=1; i<=N+1; i++) {\r\n            parent[i] = i;\r\n        }\r\n\t\t\r\n\t    for(int i=1; i<=N; i++) {\r\n\t    \tStringTokenizer st = new StringTokenizer(br.readLine(),\" \");\r\n\t    \tv[i] = new Vertex(stod(st.nextToken()), stod(st.nextToken()));\r\n\t    }\r\n\t    \r\n\t    for(int i=1; i<=N; i++) {\r\n\t    \tfor(int j=i+1; j<=N; j++) {\r\n\t    \t\tpq.add(new Edge(i, j, getDistance(v[i].x, v[j].x, v[i].y, v[j].y)));\r\n\t    \t}\r\n\t    }\r\n\t    \r\n\t    for(int i=0; i<pq.size(); i++) {\r\n\t    \tEdge temp = pq.poll();\r\n\t    \t\r\n\t    \tint a = temp.s;\r\n\t    \tint b = temp.e;\r\n\t    \tif(!union(a, b))\r\n\t    \t\tcontinue;\r\n\t    \tresult+= temp.w;\r\n\t    \tcnt++;\r\n\t    \tif(cnt == N-1)\r\n\t    \t\tbreak;\r\n\t    }\r\n\t    System.out.println(String.format(\"%.2f\", result));\r\n\t}\r\n\t\r\n\tstatic class Vertex{\r\n\t\tdouble x, y;\r\n\t\tVertex(double x, double y){\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t}\r\n\t}\r\n\t\r\n\tstatic class Edge implements Comparable<Edge>{\r\n\t\tint s, e;\r\n\t\tdouble w;\r\n\t\tEdge(int s, int e, double w){\r\n\t\t\tthis.s = s;\r\n\t\t\tthis.e = e;\r\n\t\t\tthis.w = w;\r\n\t\t}\r\n\t\t@Override\r\n\t\tpublic int compareTo(Edge o) {\r\n\t\t\treturn o.w >= this.w ? -1: 1;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static int find_parent(int num) {\r\n\t\tif(parent[num] != num)\r\n\t\t\treturn parent[num] = find_parent(parent[num]);\r\n\t\treturn parent[num];\r\n\t}\r\n\r\n\tpublic static boolean union(int a, int b) {\r\n\t\ta = find_parent(a);\r\n\t\tb = find_parent(b);\r\n\t\t\r\n\t\tif(a==b) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse if(a < b)\r\n\t\t\tparent[b] = a;\r\n\t\telse\r\n\t\t\tparent[a] = b;\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tpublic static double getDistance(double x1, double x2, double y1, double y2) {\r\n\t\treturn Math.sqrt(Math.pow(Math.abs(x1 - x2), 2) + Math.pow(Math.abs(y1 - y2), 2));\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\t\r\n\tpublic static double stod(String string) {\r\n\t\treturn Double.parseDouble(string);\r\n\t}\r\n\t\r\n}\r\n\r\n\r\n```\r\n\r\n## 백준 1647 - 도시 분할 계획\r\n\r\n---\r\n\r\n![1647pb1](1647pb1.PNG)\r\n![1647pb2](1647pb2.PNG)\r\n\r\n---\r\n\r\n### 풀이\r\n---\r\n\r\n도시를 2개로 나눈다고 했으니 크루스칼 알고리즘이 끝나는 조건을 N-2로 작성해야 한다.\r\n\r\n---\r\n\r\n```java\r\npackage MST;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.PriorityQueue;\r\nimport java.util.StringTokenizer;\r\n\r\npublic class num1647 {\r\n\tstatic int N, M, result=0, cnt=0;\r\n\tstatic int[] parent;\r\n\tstatic PriorityQueue<Edge> pq = new PriorityQueue<Edge>();\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tStringTokenizer st;\r\n\t\t\r\n\t\tst = new StringTokenizer(br.readLine());\r\n\t\tN = stoi(st.nextToken());\r\n\t\tM = stoi(st.nextToken());\r\n\t\r\n\t\tparent = new int[N+1];\r\n\t\tfor(int i=1; i<=N; i++) {\r\n            parent[i] = i;\r\n        }\r\n\t\t\r\n\t\tfor(int i=0; i<M; i++) {\r\n\t\t\tst = new StringTokenizer(br.readLine());\r\n\t\t\tint s = stoi(st.nextToken()), e = stoi(st.nextToken()), w = stoi(st.nextToken());\r\n\t\t\tpq.add(new Edge(s,e,w));\r\n\t\t}\r\n\t\t\r\n\t\twhile(!pq.isEmpty()) {\r\n\t\t\tEdge temp = pq.poll();\r\n\t\t\t\r\n\t\t\tint a = temp.s;\r\n\t\t\tint b = temp.e;\r\n\t\t\tif(!union(a, b))\r\n\t\t\t\tcontinue;\r\n\t\t\tresult += temp.w;\r\n\t\t\tcnt++;\r\n\t\t\tif(cnt == N-2)\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tSystem.out.println(result);\r\n\t}\r\n\t\r\n\tstatic class Edge implements Comparable<Edge> {\r\n\t\tint s, e, w;\r\n\t\tEdge(int s, int e, int w) {\r\n\t\t\tthis.s = s;\r\n\t\t\tthis.e = e;\r\n\t\t\tthis.w = w;\r\n\t\t}\r\n\t\t\r\n\r\n\t\t@Override\r\n\t\tpublic int compareTo(Edge o) {\r\n\t\t\treturn o.w >= this.w ? -1 : 1;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static int find_parent(int num) {\r\n\t\tif(parent[num] != num)\r\n\t\t\treturn parent[num] = find_parent(parent[num]);\r\n\t\treturn parent[num];\r\n\t}\r\n\t\r\n\tpublic static boolean union(int a, int b) {\r\n\t\ta = find_parent(a);\r\n\t\tb = find_parent(b);\r\n\t\t\r\n\t\tif(a==b)\r\n\t\t\treturn false;\r\n\t\tif(a < b)\r\n\t\t\tparent[b] = a;\r\n\t\telse\r\n\t\t\tparent[a] = b;\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\r\n}\r\n\r\n```\r\n\r\n## 백준 1774 - 우주신과의 교감\r\n\r\n---\r\n\r\n// TODO : 문제사진\r\n\r\n---\r\n\r\n### 풀이\r\n---\r\n\r\n---\r\n\r\n```java\r\n\r\n```\r\n\r\n## 백준 2887 - 행성 터널\r\n\r\n---\r\n\r\n// TODO : 문제사진\r\n\r\n---\r\n\r\n### 풀이\r\n---\r\n\r\n이 문제가 조금 어려웠다.\r\n\r\n---\r\n\r\n```java\r\n\r\n```\r\n\r\n## 백준 17472 - 다리 만들기2\r\n\r\n---\r\n\r\n// TODO : 문제사진\r\n\r\n---\r\n\r\n### 풀이\r\n---\r\n\r\n---\r\n\r\n```java\r\n\r\n```\r\n\r\n\r\n## 프림 알고리즘\r\n---\r\n> 정점 선택 기반의 알고리즘으로, 하나의 정점에서 연결된 간선들 중에 최소 간선 비용을 가진 정점을 하나씩 선택하면서 MST를 찾는 알고리즘\r\n\r\n### 구현 방법\r\n---\r\n\r\n```\r\n1. 임의의 정점 하나를 선택해서 시작\r\n2. 선택한 정점과 인접하는 정점들 중에 최소비용의 간선을 가지는 정점을 선택\r\n3. 모든 정점이 선택될 때 까지 반복\r\n\r\n```\r\n\r\n---\r\n\r\n## 주절주절\r\n\r\n크루스칼 알고리즘과 프림 알고리즘에 대해 알아보았다. 대부분 최소 신장 트리문제는 크루스칼 알고리즘을 통해 대부분 해결 가능하기 때문에 백준 단계별 문제에 있는 MST문제는 모두 크루스칼 알고리즘을 사용해서 문제를 풀었다.\r\n\r\n# Reference\r\n이것이 취업을 위한 코딩테스트다 - 나동빈  \r\n[라이님 블로그](https://m.blog.naver.com/kks227/220799105543)  \r\n[갓킹독님 블로그](https://blog.encrypted.gg/915?category=773649)  \r\n[주남2님 블로그](https://ju-nam2.tistory.com/112)  \r\n[두 점 사이의 거리, 좌표평면위의 두 점 사이의 거리](https://mathbang.net/408)  \r\n[Java - 반올림해서 소수점 n번째 자리까지 출력 - chacha님 블로그](https://codechacha.com/ko/java-round-a-number-to-decimal-point/)  ","excerpt":"신장 트리(Spnning Tree) 하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프 최소 신장 트리(Minimum Spanning Tree) 트리의 간선마다 가중치가 있을 때, 간선의 가중치 합이 최소인 트리 신장…","fields":{"slug":"/MST/"},"frontmatter":{"date":"Feb 04, 2021","title":"최소 신장 트리 정리","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n# 슬라이딩 윈도우\r\n\r\n투포인터 알고리즘과 비슷하지만 슬라이딩 윈도우는 **어느 순간에도 그 구간의 넓이가 동일하다**\r\n\r\n한 줄 요약해보면  \r\n -> 사용하지 않는 값을 삭제하거나 갱신하는 기법이다.\r\n## 백준 2096번 - 내려가기\r\n---\r\n\r\n![2096pb1](2096pb1.PNG)\r\n![2096pb2](2096pb2.PNG)\r\n\r\n---\r\n\r\n### 풀이\r\n\r\n이 문제는 슬라이딩 윈도우 + DP문제다. \r\n\r\n문제를 보면 메모리 제한이 있다.\r\n\r\n계단의 최대값과 최솟값을 저장하는데 이전의 값들만 저장하고 있으면 된다.\r\n\r\n---\r\n\r\n```java\r\npackage slidingWindow;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.Arrays;\r\n\r\npublic class num2096 {\r\n\tstatic int N, MAX, MIN;\r\n\tstatic int[] tempMaxDp, tempMinDp, maxDp, minDp;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tN = stoi(br.readLine());\r\n\t\ttempMaxDp = new int[3]; tempMinDp = new int[3]; maxDp = new int[3]; minDp = new int[3];\r\n\t\t\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tString[] step = br.readLine().split(\" \");\r\n\t\t\tfor(int j=0; j<3; j++) {\r\n\t\t\t\ttempMinDp[j] = tempMaxDp[j] = stoi(step[j]);\r\n\t\t\t\ttempMaxDp[j] += Math.max(maxDp[1] , j == 1 ? Math.max(maxDp[0], maxDp[2]) : maxDp[j]);\r\n\t\t\t\ttempMinDp[j] += Math.min(minDp[1] , j == 1 ? Math.min(minDp[0], minDp[2]) : minDp[j]);\r\n\t\t\t\tMAX = j==0 ? tempMaxDp[j] : MAX > tempMaxDp[j] ? MAX : tempMaxDp[j];\r\n\t\t\t\tMIN = j==0 ? tempMinDp[j] : MIN < tempMinDp[j] ? MIN : tempMinDp[j];\r\n\t\t\t}\r\n\t\t\tarrayCopy(maxDp, tempMaxDp);\r\n\t\t\tarrayCopy(minDp, tempMinDp);\r\n\t\t\t\r\n\t\t}\r\n\t\tSystem.out.println(MAX + \" \" + MIN);\r\n\t}\r\n\t\r\n\tpublic static void arrayCopy(int[] to, int[] from) {\r\n\t\tfor(int i=0; i<3; i++) {\r\n\t\t\tto[i] = from[i];\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\r\n}\r\n\r\n```\r\n\r\n\r\n## 백준 11003번 - 최솟값 찾기\r\n---\r\n\r\n![11003번](11003pb1.PNG)\r\n![11003번](11003pb2.PNG)\r\n\r\n---\r\n\r\n### 풀이\r\n\r\n문제를 보면 범위가 심상치 않다.....ㅋㅋㅋ\r\n\r\n문제가 좀 어려워서 노트로 작성하면서 정리했다.\r\n\r\n![11003번sol](11003sol.PNG)\r\n\r\n---\r\n\r\n```java\r\npackage slidingWindow;\r\n\r\nimport java.io.*;\r\nimport java.util.*;\r\n\r\npublic class num11003 {\r\n    public static void main(String[] args) throws Exception {\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\r\n        Deque<Integer> deque = new LinkedList<>();\r\n        StringTokenizer st = new StringTokenizer(br.readLine(), \" \");\r\n        \r\n        int N = stoi(st.nextToken());\r\n        int L = stoi(st.nextToken());\r\n        \r\n        int[] arr = new int[N];\r\n        st = new StringTokenizer(br.readLine(), \" \");\r\n        \r\n        \r\n        StringBuilder sb = new StringBuilder();\r\n        for (int i = 0; i < N; i++) {\r\n        \tarr[i] = stoi(st.nextToken());\r\n            if (!deque.isEmpty() && deque.getFirst() <= i - L) {\r\n            \tdeque.removeFirst();\r\n            }\r\n            while (!deque.isEmpty() && arr[deque.getLast()] > arr[i]) {\r\n            \tdeque.removeLast();\r\n            }\r\n            deque.addLast(i);\r\n            sb.append(arr[deque.peekFirst()] + \" \");\r\n        }\r\n        bw.write(sb.toString());\r\n\t\tbw.flush();\r\n\t\tbw.close();\r\n    }\r\n    \r\n    public static int stoi(String string) {\r\n    \treturn Integer.parseInt(string);\r\n    }\r\n}\r\n```\r\n\r\n## 백준 3078번 - 좋은 친구\r\n---\r\n\r\n![3078pb1](3078pb1.PNG)\r\n![3078pb2](3078pb2.PNG)\r\n\r\n---\r\n\r\n이전 문제를 풀었다면 어렵지 않게 풀 수 있다.\r\n\r\ncnt범위 때문에 long으로 설정해야 한다.\r\n\r\ncnt 때문에 책상 부술뻔.... 후.....하...후...하...\r\n\r\n---\r\n\r\n```java\r\npackage slidingWindow;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.LinkedList;\r\nimport java.util.Queue;\r\nimport java.util.StringTokenizer;\r\n\r\npublic class num3078 {\r\n\tstatic int N, K;\r\n\tstatic long cnt=0;\r\n\tstatic Queue[] qarr;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\r\n\t\tN = stoi(st.nextToken());\r\n\t\tK = stoi(st.nextToken());\r\n\t\t\r\n\t\tqarr = new Queue[21];\r\n\t\tfor(int i=0; i<=20; i++) {\r\n\t\t\tqarr[i] = new LinkedList<Integer>();\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tint nowLen = br.readLine().length();\r\n\t\t\t\r\n\t\t\tif(qarr[nowLen].isEmpty()) {\r\n\t\t\t\tqarr[nowLen].offer(i);\r\n\t\t\t}else {\r\n\t\t\t\twhile ((i - (int) qarr[nowLen].peek()) > K) {\r\n\t\t\t\t\tqarr[nowLen].poll();\r\n\t\t\t\t\tif (qarr[nowLen].isEmpty()) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tcnt += qarr[nowLen].size();\r\n\t\t\t\tqarr[nowLen].offer(i);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(cnt);\r\n\t}\r\n\t\r\n\tstatic int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\r\n}\r\n\r\n```\r\n\r\n# Reference\r\n[라이님 블로그](https://m.blog.naver.com/kks227/220795165570)","excerpt":"슬라이딩 윈도우 투포인터 알고리즘과 비슷하지만 슬라이딩 윈도우는 어느 순간에도 그 구간의 넓이가 동일하다 한 줄 요약해보면  -> 사용하지 않는 값을 삭제하거나 갱신하는 기법이다. 백준 2096번 - 내려가기 \n 풀이 이 문제는 슬라이딩 윈도우 + …","fields":{"slug":"/slidingWindow/"},"frontmatter":{"date":"Feb 03, 2021","title":"슬라이딩 윈도우 정리","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n# 구간합 배열\r\n> 전처리를 통해 모든 부분합을 O(1)으로 구할 수 있는 방법\r\n\r\n\r\n```\r\n1. 원래 배열 이외에 pSum배열을 추가로 하나 만들어 준다. \r\n2. pSum[x] 배열에는 앞에서 부터 x개 원소의 합을 저장한다.\r\n  -> pSum[i+1] = pSum[i] + A[i]\r\n\r\n```\r\n\r\n## 백준 11659 - 구간 합 구하기4\r\n\r\n---\r\n\r\n![11659](11659pb1.PNG)\r\n\r\n---\r\n\r\n### 풀이\r\n\r\npSum[i+1] - pSum[j]를 해주면 된다.\r\n\r\n---\r\n\r\n```java\r\npackage sumOfInterval;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class num11659 {\r\n\tstatic int N, M;\r\n\tstatic int[] arr, pSum;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\tString[] NM = br.readLine().split(\" \");\r\n\t\t\r\n\t\tN = stoi(NM[0]);\r\n\t\tM = stoi(NM[1]);\r\n\t\t\r\n\t\tarr = new int[N];\r\n\t\tpSum = new int[N+1];\r\n\t\t\r\n\t\tString[] arrData = br.readLine().split(\" \");\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tarr[i] = stoi(arrData[i]);\r\n\t\t\tpSum[i+1] = arr[i] + pSum[i];\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<M; i++) {\r\n\t\t\tString[] AB = br.readLine().split(\" \");\r\n\t\t\tint a = stoi(AB[0])-1;\r\n\t\t\tint b = stoi(AB[1])-1;\r\n\t\t\t\r\n\t\t\tsb.append(pSum[b+1] - pSum[a] + \"\\n\");\r\n\t\t}\r\n\t\tSystem.out.println(sb);\r\n\t}\r\n\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n}\r\n\r\n```\r\n\r\n## 백준 11660 - 구간 합 구하기5\r\n\r\n---\r\n\r\n![11660](11660pb1.PNG)\r\n![11660](11660pb2.PNG)\r\n![11660](11660pb3.PNG)\r\n\r\n---\r\n\r\n### 풀이\r\n\r\n이전 문제와 비슷한데 2차원 배열을 사용해 pSum을 저장한다.\r\n\r\n빼줄 때 범위 설정에 주의한다.\r\n\r\n---\r\n\r\n```java\r\npackage sumOfInterval;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class num11660 {\r\n\tstatic int N, M, x1, x2, y1, y2;\r\n\tstatic int[][] map, pSum;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException{\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\r\n\t\tString[] NM = br.readLine().split(\" \");\r\n\t\tN = stoi(NM[0]);\r\n\t\tM = stoi(NM[1]);\r\n\t\tmap = new int[N+1][N+1];\r\n\t\tpSum = new int[N+2][N+2];\r\n\t\t\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tString[] row = br.readLine().split(\" \");\r\n\t\t\tfor(int j=0; j<N; j++) {\r\n\t\t\t\tmap[i][j] = stoi(row[j]);\r\n\t\t\t\tpSum[i+1][j+1] = pSum[i+1][j] + pSum[i][j+1] - pSum[i][j] + map[i][j];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=1; i<=M; i++) {\r\n\t\t\tString[] point = br.readLine().split(\" \");\r\n\t\t\tx1 = stoi(point[0]);\r\n\t\t\ty1 = stoi(point[1]);\r\n\t\t\tx2 = stoi(point[2]);\r\n\t\t\ty2 = stoi(point[3]);\r\n\t\t\t\r\n\t\t\tsb.append(pSum[x2][y2] - pSum[x1-1][y2] - pSum[x2][y1-1] + pSum[x1-1][y1-1] + \"\\n\");\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(sb.toString());\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n}\r\n\r\n```\r\n\r\n## 백준 10211 - Maximum Subarray\r\n\r\n---\r\n\r\n![10211](10211pb1.PNG)\r\n![10211](10211pb2.PNG)\r\n\r\n---\r\n\r\n### 풀이\r\n---\r\n```\r\n1\r\n2\r\n-7 5\r\n```\r\n\r\n별 생각 없이 풀다가 위 CASE에 걸리는 걸 알았다.\r\n\r\n**전까지 합이 음수고, 새롭게 들어온 값이 양수라면 새롭게 들어온 값부터 더해준 값이 최대값이다.**\r\n\r\n위 문장에 대한 처리를 해야한다.\r\n\r\n---\r\n\r\n```java\r\npackage sumOfInterval;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class num10211 {\r\n\tstatic int N, X, MAX;\r\n\tstatic int[] arr, pSum;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\r\n\t\tN = stoi(br.readLine());\r\n\t\t\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tMAX = Integer.MIN_VALUE;\r\n\t\t\tX = stoi(br.readLine());\r\n\t\t\tString[] arrData = br.readLine().split(\" \");\r\n\t\t\tarr = new int[X];\r\n\t\t\tpSum = new int[X+1];\r\n\t\t\t\r\n\t\t\tfor(int j=0; j<X; j++) {\r\n\t\t\t\tarr[j] = stoi(arrData[j]);\r\n\t\t\t\tpSum[j+1] = Math.max(pSum[j], 0) + arr[j];\r\n\t\t\t\tMAX = MAX > pSum[j+1] ? MAX : pSum[j+1];\r\n\t\t\t}\r\n\t\t\tsb.append(MAX+\"\\n\");\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(sb.toString());\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n}\r\n\r\n```\r\n\r\n## 백준 10986 - 나머지 합\r\n\r\n---\r\n\r\n![10986](10986pb1.PNG)\r\n![10986](10986pb2.PNG)\r\n\r\n---\r\n\r\n### 풀이\r\n\r\n이 문제는 발상의 전환이 필요하다.\r\n\r\npSum[j] % M 와 pSum[i] % M 나머지가 같으면 나누어 떨어지는 구간이다.  \r\n -> M으로 나눴을 때 나머지를 저장하는 누적합 배열을 만든다.  \r\n -> 나머지의 개수를 저장하는 배열을 하나 더 만들어서 나머지에 대한 개수를 저장한다.  \r\n -> 나머지의 순서에 상관없이 2개씩 뽑는 개수를 모두 더한다.   \r\n\r\n---\r\n\r\n```java\r\npackage sumOfInterval;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class num10986 {\r\n\tstatic long N, M, ans;\r\n\tstatic long[] cnt, pSum;\r\n\tstatic final int MAX = 1000000 + 1;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tString[] NM = br.readLine().split(\" \");\r\n\t\t\r\n\t\tN = stol(NM[0]);\r\n\t\tM = stol(NM[1]);\r\n\t\tcnt = new long[(int)M];\r\n\t\tpSum = new long[(int)N+1];\r\n\t\t\r\n\t\tString[] arrData = br.readLine().split(\" \");\r\n\t\tfor(int i=1; i<=N; i++) {\r\n\t\t\tlong num = stol(arrData[i-1]);\r\n\t\t\tpSum[i] = (pSum[i - 1] + num) % M;\r\n\t\t\tcnt[(int) pSum[i]]++;\r\n\t\t\tif(pSum[i] == 0) ans++;\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i = 0 ; i < M ; ++i) {\r\n\t\t\tans += cnt[i] * (cnt[i] - 1) / 2;\r\n\t\t}\r\n\t\tSystem.out.println(ans);\r\n\t}\r\n\tpublic static long stol(String string) {\r\n\t\treturn Long.parseLong(string);\r\n\t}\r\n\r\n}\r\n\r\n```\r\n\r\n# Reference\r\n[라이님 블로그](https://m.blog.naver.com/kks227/220787178657)  ","excerpt":"구간합 배열 전처리를 통해 모든 부분합을 O(1)으로 구할 수 있는 방법 백준 11659 - 구간 합 구하기4  풀이 pSumi+1 - pSumj를 해주면 된다. 백준 11660 - 구간 합 구하기5 \n\n 풀이 이전 문제와 비슷한데 2차원 배열을 사…","fields":{"slug":"/prefixSum/"},"frontmatter":{"date":"Feb 02, 2021","title":"구간합(Prefix Sum) 배열","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n백준 단계별 문제 - 투포인터에 있는 1644번 문제를 풀다 소수 구하는 알고리즘이 생각이 안나서 정리 해둘 겸 포스팅한다.\r\n\r\n# 에라토스테네스의 체란?\r\n \r\n> 소수가 되는 수의 배수를 지우면 남는 건 소수가 된다\r\n\r\n요런 알고리즘이다.\r\n\r\n![위키 이미지](era.gif)\r\n\r\n## 백준 1644 - 소수의 연속 합\r\n---\r\n\r\n```\r\n1. 에라토스테네스의 체로 소수 구하는 방법을 활용해 소수를 구한다.\r\n2. 투포인터 알고리즘을 활용해 연속 합 확인\r\n```\r\n\r\n![1644pb1](1644pb1.PNG)\r\n![1644pb2](1644pb2.PNG)\r\n\r\n\r\n---\r\n\r\n```java\r\npackage package25;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\n\r\npublic class num1644 {\r\n\tstatic int N, sum = 0, s = 0, e = 0, count = 0;\r\n\tstatic boolean primeCheckArr[];\r\n\tstatic ArrayList<Integer> primeList;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tN = stoi(br.readLine());\r\n\t\tprimeCheckArr = new boolean[N+1];        \r\n        primeList = new ArrayList<Integer>();\r\n        \r\n        getPrimeNumber();\r\n        \r\n        getCountResult();\r\n        \r\n        System.out.println(count);\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic static void getCountResult() {\r\n\t\twhile(true) {\r\n\t\t\tif(sum>=N) sum-=primeList.get(s++);\r\n\t\t\telse if(e == primeList.size()) break;\r\n\t\t\telse sum+=primeList.get(e++);\r\n\t\t\tif(sum == N) count++;\t\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static void getPrimeNumber() {\r\n\t\tprimeCheckArr[0] = primeCheckArr[1] = true;  \r\n\t\t\r\n        for(int i=2; i*i<=N; i++){\r\n            if(!primeCheckArr[i]) {\r\n            \tfor(int j=i*i; j<=N; j+=i)\r\n            \t\tprimeCheckArr[j]=true;                \r\n            }\r\n        }\r\n        \r\n        for(int i=1; i<=N;i++){\r\n        \tif(!primeCheckArr[i]) primeList.add(i); \r\n        }\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\r\n}\r\n```\r\n\r\n---\r\n추가로 소수를 구하는 부분의 2중 포면을 살펴보면 \r\n\r\n```java\r\nfor(int i=2; i*i<=N; i++){\r\n    if(!primeCheckArr[i]) {\r\n    \tfor(int j=i*i; j<=N; j+=i)\r\n    \t\tprimeCheckArr[j]=true;                \r\n    }\r\n}\r\n```\r\n\r\n특정한 소수의 제곱근 까지만 구하면 된다\r\n -> 약수가 아닌경우는 수가 대칭을 이루기 때문\r\n\r\n# Reference\r\n\r\n[위키 백과](https://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4)  ","excerpt":"백준 단계별 문제 - 투포인터에 있는 1644번 문제를 풀다 소수 구하는 알고리즘이 생각이 안나서 정리 해둘 겸 포스팅한다. 에라토스테네스의 체란? 소수가 되는 수의 배수를 지우면 남는 건 소수가 된다 요런 알고리즘이다. 위키 이미지 백준 1644 …","fields":{"slug":"/primeNumber/"},"frontmatter":{"date":"Feb 01, 2021","title":"소수 구하기 - 에라토스테네스의 체","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n# 투 포인터 알고리즘\r\n---\r\n\r\n> 리스트에 순차적으로 접근해야 할 때 2개의 점의 위치를 기록하면서 처리하는 알고리즘을 의미한다.  \r\n\r\n -> **2개의 점을 무조건 증가시키는 방향으로 변화하면서 횟수 계산**\r\n\r\nTip!!  \r\n -> 연속된 값을 이용해 풀어나가는 문제에 한정적으로 사용해야 한다.\r\n (정렬을 통해 연속성을 줄 수 있다.)\r\n\r\n## 백준 2470 - 두 용액\r\n---\r\n\r\n![2470pb1](2470pb1.PNG)\r\n![2470pb2](2470pb2.PNG)\r\n\r\n---\r\n소스를 간략히 설명해보면\r\n\r\n1. end점을 마지막, start점을 처음값을 가르키게 설정한다.\r\n\r\n2. 입력받은 값을 정렬\r\n\r\n3. sum값이 0보다 크면 end점의 index를 -1해주고, 0보다 작으면 start값을 +1해준다.\r\n   (두 점이 가운데로 모이면서 진행된다.)\r\n\r\n---\r\n\r\n```java\r\npackage package25;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.Arrays;\r\n\r\npublic class num2470 {\r\n\tstatic int N, s = 0, e, sum = 0, min = Integer.MAX_VALUE;\r\n\tstatic int[] arr, result;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tN = stoi(br.readLine());\r\n\t\te = N-1;\r\n\t\tarr = new int[N];\r\n\t\tresult = new int[2];\r\n\t\t\r\n\t\tString[] inputData = br.readLine().split(\" \");\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tarr[i] = stoi(inputData[i]);\r\n\t\t}\r\n\t\tArrays.sort(arr);\r\n\t\t\r\n\t\tgetResult();\r\n\t\t\r\n\t\tSystem.out.println(result[0] + \" \" + result[1]);\r\n\t}\r\n\t\r\n\tpublic static void getResult() {\r\n\t\twhile(s < e) {\r\n\t\t\tsum = arr[s] + arr[e];\r\n\t\t\tif(min > Math.abs(sum)) {\r\n\t\t\t\tmin = Math.abs(sum);\r\n\t\t\t\tresult[0] = arr[s];\r\n\t\t\t\tresult[1] = arr[e];\r\n\t\t\t}\r\n\t\t\tif(sum > 0) e--;\r\n\t\t\telse s++;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n}\r\n\r\n```\r\n\r\n## 백준 1806 - 부분 합\r\n---\r\n\r\n![1806pb1](1806pb1.PNG)\r\n![1806pb2](1806pb2.PNG)\r\n\r\n---\r\n\r\n연속 된 수들의 부분합이니 정렬 할 필요는 없다.\r\n\r\n입력받은 S값 보다 작으면 end점을 늘려주고 S값 보다 크면 S점을 늘려준다.\r\n\r\n---\r\n\r\n```java\r\npackage package25;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class num1806 {\r\n\tstatic int INF = Integer.MAX_VALUE;\r\n\tstatic int N, S, result=INF, sum = 0, s = 0, e = 0;\r\n\tstatic int[] arr;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tString[] NS = br.readLine().split(\" \");\r\n\t\tN = stoi(NS[0]);\r\n\t\tS = stoi(NS[1]);\r\n\t\tarr = new int[N];\r\n\t\t\r\n\t\tString[] inputArr = br.readLine().split(\" \");\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tarr[i] = stoi(inputArr[i]);\r\n\t\t}\r\n\t\t\r\n\t\tcalcCount();\r\n\t\t\r\n\t\tresult = result == INF ? 0 : result;\r\n\t\tSystem.out.println(result);\r\n\t}\r\n\t\r\n\tpublic static void calcCount() {\r\n\t\twhile(true) {\r\n\t\t\tif(sum >= S) {\r\n\t\t\t\tsum-=arr[s++];\r\n\t\t\t\tresult = Math.min(result, (e-s)+1);\r\n\t\t\t}else if(e == N) break;\r\n\t\t\telse sum+=arr[e++];\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n}\r\n\r\n```\r\n\r\n## 백준 1450 - 냅색 문제\r\n\r\n이 문제가 어려웠다.\r\n\r\n이 친구는 **Meet in the 알고리즘**을 사용한다.\r\n\r\n### Meet in the 알고리즘이란?\r\n\r\n> 구간을 반으로 나눈다.\r\n\r\n범위를 2개로 나누면  \r\n -> O(2^n)의 시간복잡도가 O(2^(N/2)) 시간으로 줄어든다.\r\n\r\n---\r\n\r\n![1450pb1](1450pb1.PNG)\r\n![1450pb2](1450pb2.PNG)\r\n\r\n---\r\n\r\n앞쪽과 뒤쪽으로 범위를 나눈다. 양쪽 구간에서 가능한 모든 합을 구해다 정렬하고 \r\n\r\n한쪽 값들을 순회하면서 다른 구간를 탐색하면서 모든 합을 확인하고 C값보다 작거나 같은 값이 몇개인지 이분 탐색을 사용해 찾는다.\r\n\r\n배열의 index값을 사용하기 때문에 count계산할 때 +1을 해주거나, 입력 받을 때 배열값을 장난쳐놔야 한다.\r\n\r\n---\r\n\r\n```java\r\npackage package25;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\n\r\npublic class num1450 {\r\n\tstatic int N, C, count =0, index;\r\n\tstatic int[] arr;\r\n\tstatic ArrayList<Integer> left, right;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tString[] NC = br.readLine().split(\" \");\r\n\t\tN = stoi(NC[0]);\r\n\t\tC = stoi(NC[1]);\r\n\t\tarr = new int[N];\r\n\t\t\r\n\t\tString[] arrData = br.readLine().split(\" \");\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tarr[i] = stoi(arrData[i]);\r\n\t\t}\r\n\t\t\r\n\t\tleft = new ArrayList<Integer>();\r\n\t\tright = new ArrayList<Integer>();\r\n\t\t\r\n\t\tcalcPart(0,N/2,0,left);\r\n\t\tcalcPart(N/2+1,N-1,0,right);\r\n\t\t\r\n\t\tCollections.sort(right);\r\n\t\t\r\n\t\tfor (int i = 0; i < left.size(); i++) {\r\n            index = 0;\r\n            binarySearch(0, right.size() - 1, left.get(i));\r\n            count += index +1;\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(count);\r\n\t}\r\n\t\r\n    static void binarySearch(int start, int end, int val) {\r\n        if (start > end) {\r\n            return;\r\n        }\r\n\r\n        int mid = (start + end) / 2;\r\n\r\n        if (right.get(mid) + val <= C) {\r\n            index = mid;\r\n            binarySearch(mid + 1, end, val);\r\n        } else {\r\n            binarySearch(start, mid - 1, val);\r\n        }\r\n    }\r\n\r\n\tpublic static void calcPart(int s, int e, int sum, ArrayList<Integer> list) {\r\n\t\tif (sum > C) return;\r\n\t\tif (s > e) {\r\n\t\t\tlist.add(sum);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tcalcPart(s + 1, e, sum, list);\r\n\t\tcalcPart(s + 1, e, sum + arr[s], list);\r\n\t}\r\n\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n}\r\n\r\n```\r\n\r\n1450번 문제 풀면서 배열 index때문에 삽질을 너무 오래했다 ㅜㅜ\r\n\r\nmeet in the middle 알고리즘은 정리 한번 하고 문제 좀 더 풀어봐야 겠다.\r\n\r\n\r\n# Reference \r\n[라이님 블로그](https://m.blog.naver.com/kks227/220795165570)  \r\n[meet in the middle 알고리즘 - 반으로 쪼갠다. - chogahui05님 블로그](https://blog.naver.com/chogahui05/221374387858)  \r\n이것이 코딩테스트다 - 나동빈","excerpt":"투 포인터 알고리즘 리스트에 순차적으로 접근해야 할 때 2개의 점의 위치를 기록하면서 처리하는 알고리즘을 의미한다.    -> 2개의 점을 무조건 증가시키는 방향으로 변화하면서 횟수 계산 Tip!!  -> 연속된 값을 이용해 풀어나가는 문제에 한정적…","fields":{"slug":"/twoPoint/"},"frontmatter":{"date":"Feb 01, 2021","title":"투포인터 알고리즘","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n머리 식힐 겸 재밌어 보이는 문제 찾다가 풀어봤다.\r\n\r\n## 문제\r\n\r\n![15686pb1](15686pb1.PNG)\r\n![15686pb2](15686pb2.PNG)\r\n![15686pb3](15686pb3.PNG)\r\n![15686pb4](15686pb4.PNG)\r\n\r\n## 풀이\r\n\r\n풀이는 다음과 같다.\r\n```\r\n1. 조합으로 치킨 집 구함\r\n2. 치킨 집에서 집까지 거리를 찾는다.\r\n3. 구한 거리의 합이 현재 가지고 있는 최솟값보다 작으면 교체\r\n```\r\n\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\n\r\npublic class Main {\r\n\tstatic int N, M, result = Integer.MAX_VALUE;\r\n\tstatic ArrayList<House> house;\r\n\tstatic ArrayList<Chicken> chicken;\r\n\tstatic int[] houseLen;\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tString[] NM = br.readLine().split(\" \");\r\n\t\tN = stoi(NM[0]);\r\n\t\tM = stoi(NM[1]);\r\n\t\tboolean[] visited = new boolean[14];\r\n\t\thouse = new ArrayList<House>();\r\n\t\tchicken = new ArrayList<Chicken>();\r\n\t\t\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tString[] inputData = br.readLine().split(\" \");\r\n\t\t\tfor(int j=0; j<N; j++) {\r\n\t\t\t\tint num = stoi(inputData[j]);\r\n\t\t\t\tif(num == 0) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}else if(num == 1) {\r\n\t\t\t\t\thouse.add(new House(i,j));\r\n\t\t\t\t}else {\r\n\t\t\t\t\tchicken.add(new Chicken(i,j));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\thouseLen = new int[house.size()];\r\n\t\tcombination(visited, 0, chicken.size(), M);\r\n\t\tSystem.out.println(result);\r\n\t\t\r\n\t}\r\n\tpublic static void combination(boolean[] visited, int start, int n, int r) {\r\n\t\tif(r==0) {\r\n\t\t\tint len = 0;\r\n\t\t\tint index = 0;\r\n\t\t\tArrayList<Chicken> ncr = new ArrayList<Chicken>();\r\n\t\t\tfor(int i=0; i<visited.length; i++) {\r\n\t\t\t\tif(visited[i]==true) {\r\n\t\t\t\t\tncr.add(chicken.get(i));\r\n\t\t\t\t\tindex++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlen = calcMinLen(ncr);\r\n\t\t\tresult = result < len ? result : len;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfor(int i=start; i<n; i++) {\r\n\t\t\tvisited[i] = true;\r\n\t\t\tcombination(visited, i+1, n, r-1);\r\n\t\t\tvisited[i] = false;\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic static int calcMinLen(ArrayList<Chicken> c) {\r\n\t\tint minLen = 0;\r\n\t\tArrays.fill(houseLen, Integer.MAX_VALUE);\r\n\t\tfor(int i=0; i<c.size(); i++) {\r\n\t\t\tChicken now = c.get(i);\r\n\t\t\tfor(int k=0; k<house.size(); k++) {\r\n\t\t\t\tint houseNowLen = Math.abs(now.x - house.get(k).x) + Math.abs(now.y - house.get(k).y);\r\n\t\t\t\thouseLen[k] = houseLen[k] < houseNowLen ? houseLen[k] : houseNowLen;\r\n\t\t\t}\r\n//\t\t\tSystem.out.println(now.x + \" \" + now.y);\r\n\t\t}\r\n\t\tfor(int i=0; i<houseLen.length; i++) {\r\n\t\t\tminLen += houseLen[i];\r\n//\t\t\tSystem.out.println(houseLen[i]);\r\n\t\t}\r\n//\t\tSystem.out.println(minLen);\r\n\t\t\r\n\t\treturn minLen;\r\n\t}\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\r\n\tstatic class Chicken{\r\n\t\tint x, y;\r\n\t\tChicken(int x, int y){\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t}\r\n\t}\r\n\tstatic class House{\r\n\t\tint x, y;\r\n\t\tHouse(int x, int y){\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n```\r\n\r\n주석 해놓은 부분 주석풀고 실행해보면 과정 살펴볼 수 있다.\r\n\r\n상어들로 장난치는 문제들도 있는데 아침 공부 시작할 때 풀어보면 좋을 것 같다. \r\n\r\n끗","excerpt":"머리 식힐 겸 재밌어 보이는 문제 찾다가 풀어봤다. 문제 \n\n\n 풀이 풀이는 다음과 같다. 주석 해놓은 부분 주석풀고 실행해보면 과정 살펴볼 수 있다. 상어들로 장난치는 문제들도 있는데 아침 공부 시작할 때 풀어보면 좋을 것 같다.  끗","fields":{"slug":"/backjoon15686/"},"frontmatter":{"date":"Jan 29, 2021","title":"백준 15686 - 치킨 배달","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n# 서로소 집합 자료구조란?\r\n---\r\n\r\n> 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조\r\n\r\nUnion-Find Algorithm 은 그래프내 셀프루프 (self-loop : 자기자신을 가리키는 간선)을 포함하면 안되고 **무방향그래프에서 사이클 찾는데 유용**\r\n\r\n**Union, find 2개의 연산**이 있다.\r\n\r\n\r\n## 전제 조건\r\n---\r\n\r\n> 같은 집합에 포함되어 있는 정점들끼리는 이미 간선으로 연결 된 것이고, 다른 집합의 정점과는 서로 연결되지 않았다는 것을 기반한다.\r\n\r\n## 1. Union 연산\r\n---\r\n> 2개의 원소가 포함된 집함을 하나의 집합으로 합치는 연산\r\n\r\n- Union연산은 간선으로 표현된다.\r\n  (실제로는 트리 구조)\r\n\r\n## 2. Find 연산\r\n---\r\n\r\n> 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산\r\n\r\n- 경로 압축 기법을 적용해 시간 복잡도를 개선한다. \r\n- 경로압축이란? \r\n  - 여기선 find함수를 재귀적으로 호출한 뒤에 부모 테이블 값을 갱신하는 기법을 말함\r\n\r\n## 시간 복잡도\r\n---\r\n\r\n노드의 개수 : V , 최대 V-1개의 union 연산과 M개의 find연산이 가능할 때  \r\n -> O(V + M(1+log~2-M/V~V))  \r\n (O(1)이라고 생각하면 된다고 한다.)\r\n\r\n## 구현\r\n---\r\n```\r\n1. 초기값 자기 자신을 원소로 가지고 있게 설정\r\n2. 간선을 확인하며 두 노드의 루트 노드를 확인.\r\n   2-1. 루트 노드가 서로 다르면 두 노드에 대하여 union 연산을 수행\r\n   2-2. 루트 노드가 같다면 사이클이 발생\r\n3. 그래프에 포함되어 있는 모든 간선에 대하여 과정을 반복\r\n```\r\n\r\n## Tip!!\r\n> 유니온파인드는 상황에 따라 **여러가지 정보 추가 가능**\r\n\r\n# 백준 1717번\r\n---\r\n\r\n![1717pb1](1717pb1.PNG)\r\n![1717pb2](1717pb2.PNG)\r\n\r\n\r\n---\r\n\r\n위에서 설명했던 그대로 Union함수와 Find함수를 구현했다.\r\n\r\n---\r\n\r\n```java\r\npackage package28;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class num1717 {\r\n\tstatic int N, M;\r\n\tstatic int[] parent;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\tString[] NM = br.readLine().split(\" \");\r\n\t\t\r\n\t\tN = stoi(NM[0]);\r\n\t\tM = stoi(NM[1]);\r\n\t\tparent = new int[N];\r\n\t\t\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tparent[i] = i;\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<M; i++) {\r\n\t\t\tString[] inputData = br.readLine().split(\" \");\r\n\t\t\t\r\n\t\t\tint action = stoi(inputData[0]);\r\n\t\t\tint a = stoi(inputData[1])-1;\r\n\t\t\tint b = stoi(inputData[2])-1;\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tif(action == 0) {\r\n\t\t\t\tunion(a,b);\r\n\t\t\t}else {\r\n\t\t\t\tsb.append(find_parent(a) == find_parent(b) ? \"YES\" : \"NO\");\r\n\t\t\t\tsb.append(\"\\n\");\r\n\t\t\t}\r\n\t\t}\r\n\t\tSystem.out.println(sb);\r\n\t}\r\n\t\r\n\tpublic static int find_parent(int num) {\r\n\t\tif(parent[num] != num)\r\n\t\t\tparent[num] = find_parent(parent[num]);\r\n\t\treturn parent[num];\r\n\t}\r\n\t\r\n\tpublic static void union(int a, int b) {\r\n\t\tint aParent = find_parent(a);\r\n\t\tint bParent = find_parent(b);\r\n\t\tif(aParent<bParent)\r\n\t\t\tparent[b] = a;\r\n\t\telse\r\n\t\t\tparent[a] = b;\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\r\n}\r\n\r\n```\r\n\r\n\r\n# 백준 1976번\r\n---\r\n\r\n![1976pb1](1976pb1.PNG)\r\n![1976pb2](1976pb2.PNG)\r\n\r\n\r\n---\r\n\r\n1717번 문제와 거의 동일하다.\r\n\r\n마지막에 입력받은 값들이 하나의 부모노드를 가지고 있는지 알아보면 된다.\r\n\r\n---\r\n\r\n```java\r\npackage package28;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.StringTokenizer;\r\n\r\npublic class num1976 {\r\n\tstatic int N, M;\r\n\tstatic int[] parent;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tN = stoi(br.readLine());\r\n\t\tM = stoi(br.readLine());\r\n\t\tparent = new int[N+1];\r\n\t\t\r\n\t\tfor(int i=1; i<=N; i++) {\r\n\t\t\tparent[i] = i;\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=1; i<=N; i++) {\r\n\t\t\tString[] inputData = br.readLine().split(\" \");\r\n\t\t\tfor(int j=0; j<N; j++) {\r\n\t\t\t\tint num = stoi(inputData[j]);\r\n\t\t\t\tif(num == 1) {\r\n\t\t\t\t\tunion(i, j+1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tString[] map = br.readLine().split(\" \");\r\n\t\tboolean resultIndex = true;\r\n\t\tint index = parent[stoi(map[0])];\r\n\t\t\r\n\t\tfor(int i=1; i<map.length; i++) {\r\n\t\t\tif(index != parent[stoi(map[i])])\r\n\t\t\t\tresultIndex = false;\r\n\t\t}\r\n\t\tSystem.out.println(resultIndex == true ? \"YES\" : \"NO\");\r\n\t}\r\n\t\r\n\tpublic static int find_parent(int num) {\r\n\t\tif(parent[num] == num)\r\n\t\t\treturn num;\r\n\t\treturn parent[num] = find_parent(parent[num]);\r\n\t}\r\n\t\r\n\tpublic static void union(int a, int b) {\r\n\t\ta = find_parent(a);\r\n\t\tb = find_parent(b);\r\n\t\tif (a != b) {\r\n            if (a < b) {\r\n                parent[b] = a;\r\n            } else {\r\n                parent[a] = b;\r\n            }\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n}\r\n\r\n```\r\n\r\n# 백준 4195번\r\n---\r\n\r\n![4195pb1](4195pb1.PNG)\r\n![4195pb2](4195pb2.PNG)\r\n\r\n\r\n---\r\n\r\n이문제는 위의 문제들과 다르게 입력값이 문자열로 들어온다.\r\n\r\nHashMap을 사용해서 문자열마다 index를 할당해주는 방식으로 구현했다.\r\n\r\n---\r\n\r\n```java\r\npackage package28;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.Arrays;\r\nimport java.util.HashMap;\r\n\r\npublic class num4195 {\r\n\tstatic int N, F, index;\r\n\tstatic HashMap<String, Integer> map;\r\n\tstatic int[] parent;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\tN = stoi(br.readLine());\r\n\t\t\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tmap = new HashMap<String, Integer>();\r\n\t\t\tindex = 1;\r\n\t\t\t\r\n\t\t\tF = stoi(br.readLine());\r\n\t\t\tparent = new int[2*F+1];\r\n\t\t\tArrays.fill(parent, -1);\r\n\t\t\t\r\n\t\t\tfor(int j=0; j<F; j++) {\r\n\t\t\t\tString[] inputData = br.readLine().split(\" \");\r\n\t\t\t\tint v1 = getMapValue(inputData[0]);\r\n\t\t\t\tint v2 = getMapValue(inputData[1]);\r\n\t\t\t\tint result = -union(v1,v2);\r\n\t\t\t\tsb.append(result+\"\\n\");\r\n\t\t\t}\r\n\t\t}\r\n\t\tSystem.out.println(sb.toString());\r\n\t}\r\n\t\r\n\tpublic static int find_parent(int num) {\r\n\t\tif(parent[num] < 0)\r\n\t\t\treturn num;\r\n\t\treturn parent[num] = find_parent(parent[num]);\r\n\t}\r\n\t\r\n\tpublic static int union(int a, int b) {\r\n\t\ta = find_parent(a);\r\n\t\tb = find_parent(b);\r\n\t\tif (a != b) {\r\n            if (a < b) {\r\n            \tparent[a] += parent[b];\r\n                parent[b] = a;\r\n            } else {\r\n            \tparent[b] += parent[a];\r\n                parent[a] = b;\r\n            }\r\n\t\t}\r\n\t\treturn parent[a] < 0 ? parent[a] : parent[b];\r\n\t}\r\n\t\r\n\tpublic static int getMapValue(String string) {\r\n\t\tif(!map.containsKey(string)) {\r\n\t\t\tmap.put(string, index);\r\n\t\t\tindex++;\r\n\t\t}\r\n\t\treturn map.get(string);\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n}\r\n\r\n```\r\n\r\n# 백준 20040번\r\n---\r\n\r\n![20045pb1](20045pb1.PNG)\r\n![20045pb2](20045pb2.PNG)\r\n![20045pb3](20045pb3.PNG)\r\n\r\n\r\n---\r\n\r\n이문제는 첫번째, 두번째 문제와 비슷한데  \r\n사이클이 존재하면 사이클이 걸린 입력순서를 출력해주는 문제다.\r\n\r\n\r\n---\r\n\r\n```java\r\npackage package28;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.Arrays;\r\nimport java.util.StringTokenizer;\r\n\r\npublic class num20040 {\r\n\tstatic int N, M;\r\n\tstatic int[] parent;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tStringTokenizer st;\r\n\t\t\r\n\t\tint index = 0;\r\n\t\tst = new StringTokenizer(br.readLine());\r\n\t\tN = stoi(st.nextToken());\r\n\t\tM = stoi(st.nextToken());\r\n\t\tparent = new int[N+1];\r\n\t\tfor(int i =0; i<=N; i++) {\r\n\t\t\tparent[i] = i;\r\n\t\t}\r\n\t\tfor(int i=0; i<M; i++) {\r\n\t\t\tst = new StringTokenizer(br.readLine());\r\n\t\t\tint v1 = stoi(st.nextToken());\r\n\t\t\tint v2 = stoi(st.nextToken());\r\n\t\t\tif(!union(v1,v2)) {\r\n\t\t\t\tindex = i+1;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tSystem.out.println(index);\r\n\t}\r\n\t\r\n\tpublic static boolean union(int a, int b) {\r\n\t\ta = find_parent(a);\r\n\t\tb = find_parent(b);\r\n\t\tif(a==b)\r\n\t\t\treturn false;\r\n\t\tif(a!=b) {\r\n\t\t\tif(a < b) {\r\n\t\t\t\tparent[b] = a;\r\n\t\t\t}else {\r\n\t\t\t\tparent[a] = b;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tpublic static int find_parent(int num) {\r\n\t\tif(parent[num] == num)\r\n\t\t\treturn num;\r\n\t\treturn parent[num] = find_parent(parent[num]);\r\n\t}\r\n\t\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n}\r\n\r\n```\r\n\r\n블로그와 책을 읽고 유니온 파인드 개념을 정리해보았다.  \r\n\r\n유니온 파인드는 **최소신장트리**에 이용된다고  한다.  \r\n궁금하니 빠른 시일내로 공부해야겠다 ㅋㅋ    \r\n\r\n# Referece\r\n[라이님 블로그](https://m.blog.naver.com/kks227/220791837179)  \r\n[잭팟53님 블로그](https://jackpot53.tistory.com/)  \r\n이것이 취업을 위한 코딩 테스트다 - 나동빈  ","excerpt":"서로소 집합 자료구조란? 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조 Union-Find Algorithm 은 그래프내 셀프루프 (self-loop : 자기자신을 가리키는 간선)을 포함하면 안되고 무방향그래프에서 사이클 찾…","fields":{"slug":"/unionFind/"},"frontmatter":{"date":"Jan 29, 2021","title":"Union Find 정리","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n트리를 정리해보자 ㅎㅎ\r\n\r\n## 특징\r\n```\r\n1. 연결 그래프\r\n2. 방향을 무시하였을 때, 싸이클이 존재하지 않는다.\r\n3. 트리의 간선개수는 정점 개수보다 1작다.\r\n```\r\n\r\n트리의 서브트리는 절대로 영역이 겹치지 않음 -> **분할정복**, **DP**로 장난을 잘 칠 줄 알아야 한다.\r\n\r\n## 순회 방법\r\n\r\n트리의 순회 방법은 3가지다.\r\n```\r\n1. 전위 순회 (root -> left -> right) \r\n2. 중위 순회 (left -> root -> right)\r\n3. 후위 순회 (left -> right -> root)\r\n```\r\n보통 BFS, DFS로 구현한다.\r\n\r\n## [백준 11725] - 트리의 부모찾기 \r\n\r\n![11725pb1](11725pb1.PNG)\r\n![11725pb2](11725pb2.PNG)\r\n\r\n### 풀이\r\n---\r\n\r\nBFS, DFS를 사용해 탐색하는 방식으로 구현했다.\r\n\r\n---\r\n```java\r\npackage package27;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\nimport java.util.LinkedList;\r\nimport java.util.Queue;\r\n\r\npublic class num11725 {\r\n\tstatic int N;\r\n\tstatic ArrayList<ArrayList<Integer>> tree;\r\n\tstatic StringBuilder sb;\r\n\tstatic int[] result;\r\n\tstatic boolean[] visited;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\ttree = new ArrayList<ArrayList<Integer>>();\r\n\t\tsb = new StringBuilder();\r\n\t\t\r\n\t\tint N = stoi(br.readLine());\r\n\t\tresult = new int[N+1];\r\n\t\tvisited = new boolean[N+1];\r\n\t\tfor(int i=0; i<=N; i++) {\r\n\t\t\ttree.add(new ArrayList<Integer>());\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<N-1; i++) {\r\n\t\t\tString[] edge = br.readLine().split(\" \");\r\n\t\t\tint node1 = stoi(edge[0]);\r\n\t\t\tint node2 = stoi(edge[1]);\r\n\r\n\t\t\ttree.get(node1).add(node2);\r\n\t\t\ttree.get(node2).add(node1);\r\n\t\t}\r\n\t\t\r\n//\t\tdfs(1);\r\n\t\tbfs();\r\n\t\t\r\n\t\tfor(int i=2; i<=N; i++) {\r\n\t\t\tSystem.out.println(result[i]);\r\n\t\t}\r\n\t}\r\n\t\r\n    private static void dfs(int num){\r\n        if(visited[num]){\r\n            return;\r\n        }\r\n        visited[num] =true;\r\n        for (int node: tree.get(num)) {\r\n            if(!visited[node]){\r\n                result[node] = num;\r\n                dfs(num);\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\t\r\n\tpublic static void bfs() {\r\n\t\tQueue<Integer> queue = new LinkedList<Integer>();\r\n\t\tfor(int value : tree.get(1)) {\r\n\t\t\tresult[value] = 1;\r\n\t\t\tqueue.add(value);\r\n\t\t}\r\n\t\t\r\n\t\twhile(!queue.isEmpty()) {\r\n\t\t\tint node = queue.remove();\r\n\t\t\t\r\n\t\t\tfor(int value : tree.get(node)) {\r\n\t\t\t\tif(result[value] == 0) {\r\n\t\t\t\t\tresult[value] = node;\r\n\t\t\t\t\tqueue.add(value);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n}\r\n\r\n```\r\n\r\n\r\n## [백준 4803] - 트리\r\n\r\n![4803pb1](4803pb1.PNG)\r\n![4803pb2](4803pb2.PNG)\r\n\r\n### 풀이\r\n\r\n아.... 이거 풀다가 책상 부실뻔 했다. 너무 헤맸다... ㅜㅜ\r\n\r\n일단 문제에 T는 트리의 개수다.\r\n\r\ndfs로 입력받은 노드 모두 탐색하고, cycle이 존재하면 no tree로 출력하게 짰는데 계속 틀렸다고 나왔다.  ㅎㅎ 정답을 알려줘\r\n\r\n열받아서 [마포 코딩박님 블로그](https://mapocodingpark.blogspot.com/2020/05/4803.html) dfs 부분을 참고해서 코드 작성했다.\r\n\r\n일단 정답은 맞췄다고 나오는데 \r\n\r\n```\r\n입력값 \r\n7 4\r\n1 2\r\n2 3\r\n3 1\r\n6 7\r\n0 0\r\n출력값 \r\nCase 1: A forest of 3 trees.\r\n```\r\n\r\n이렇게 나오는데 이거 틀린거 아님? cycle 있으면 트리 없다고 나와야 하는거 아닌가 아시는 분 알려주세요ㅜㅜㅜㅜㅜ\r\n\r\n아 짜증나 ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ 화 좀 식히고 나중에 생각나면 다시 봐야겠다...\r\n\r\n```java\r\npackage package27;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\n\r\npublic class num4803 {\r\n\tstatic int N, M, count, caseIndex = 0;\r\n\tstatic StringBuilder sb;\r\n\tstatic BufferedReader br; \r\n\tstatic ArrayList<Integer>[] graph;\r\n\tstatic boolean[] visited;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tsb = new StringBuilder();\r\n\t\t\r\n\t\twhile(true) {\r\n\t\t\tString[] NM = br.readLine().split(\" \");\r\n\t\t\t\r\n\t\t\tN = stoi(NM[0]);\r\n\t\t\tM = stoi(NM[1]);\r\n\t\t\tgraph = new ArrayList[N+1];\r\n\t\t\tvisited = new boolean[N+1];\r\n\t\t\t\r\n\t\t\tif(N==0 && M==0) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tresetData();\r\n\t\t\t\r\n\t\t\tinputTreeData();\r\n\t\t\t\r\n\t\t\tcheckTree();\r\n\t\t}\r\n\t\tSystem.out.println(sb);\r\n\t}\r\n\t\r\n\tpublic static void inputTreeData() throws IOException {\r\n\t\tfor(int i=0; i<M; i++) {\r\n\t\t\tString[] Edge = br.readLine().split(\" \");\r\n\t\t\tint v1 = stoi(Edge[0]), v2 = stoi(Edge[1]);\r\n\t\t\t\r\n\t\t\tgraph[v1].add(v2);\r\n\t\t\tgraph[v2].add(v1);\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static void checkTree() {\r\n\r\n\t\tfor(int i=1; i<=N; i++) {\r\n\t\t\tif(!visited[i]) {\r\n\t\t\t\tif(dfs(i, 0))\r\n\t\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif(count == 1) {\r\n\t\t\tsb.append(\"Case \"+caseIndex+\": There is one tree.\\n\");\r\n\t\t}else if(count==0){\r\n\t\t\tsb.append(\"Case \"+caseIndex+\": No trees.\\n\");\r\n\t\t}else {\r\n\t\t\tsb.append(\"Case \"+caseIndex+\": A forest of \"+count+\" trees.\\n\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static boolean dfs(int num, int prev) {\r\n\t\tvisited[num] = true;\r\n\t\t\r\n\t\tfor(int node : graph[num]) {\r\n\t\t\tif (node == prev) continue;\r\n\t\t\tif (visited[node]) return false;\r\n\t\t\tif (dfs(node, num) == false) return false;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tpublic static void resetData() {\r\n\t\tfor(int i=0; i<=N; i++) {\r\n\t\t\tgraph[i] = new ArrayList<Integer>();\r\n\t\t\tvisited[i] = false;\r\n\t\t}\r\n\t\tcount = 0;\r\n\t\tcaseIndex++;\r\n\t}\r\n\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n}\r\n\r\n```\r\n\r\n## [백준 1967] - 트리의 지름\r\n\r\n처음에 문제 접근하는 법을 잘못해서 좀 헤맸다.\r\n\r\n트리의 지름을 구하는 방법은 다음과 같다.\r\n\r\n```\r\n1. 트리의 임의의 정점(x)에서 가장 먼 정점(y)을 찾는다.\r\n2. 가장 먼 정점(y) 에서 가장 먼 정점(z)을 찾는다.\r\n => 지름은 y - z 까지의 거리다.\r\n```\r\n\r\n증명이 궁금하면 [전명우님 블로그 - 트리의 지름 구하기](https://blog.myungwoo.kr/112) 에 쉽게 설명한 글이 있다.  \r\n -> 한줄 요약 : 어떤 한 점에서 가장 먼 점이 지름에 무조건 포함된다 (포함 안되는 경우를 증명)\r\n\r\n![1967문제1](1967pb1.PNG)\r\n![1967문제2](1967pb2.PNG)\r\n\r\n```java\r\n\r\npackage package27;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\n\r\npublic class num1967 {\r\n\tstatic int N, result = 0, start;\r\n\tstatic ArrayList<ArrayList<Edge>> Vertex;\r\n\tstatic boolean[] visited;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tN = stoi(br.readLine());\r\n\t\tVertex = new ArrayList<ArrayList<Edge>>();\r\n\t\t\r\n\t\tfor(int i=0; i<=N; i++) {\r\n\t\t\tVertex.add(new ArrayList<Edge>());\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=1; i<N; i++) {\r\n\t\t\tString[] inputData = br.readLine().split(\" \");\r\n\t\t\tint node1 = stoi(inputData[0]);\r\n\t\t\tint node2 = stoi(inputData[1]);\r\n\t\t\tint w = stoi(inputData[2]);\r\n\t\t\t\r\n\t\t\tVertex.get(node1).add(new Edge(node2, w));\r\n\t\t\tVertex.get(node2).add(new Edge(node1, w));\r\n\t\t}\r\n\t\t\r\n\t\tvisited = new boolean[N+1];\r\n\t\tvisited[1] = true;\r\n\t\tdfs(0, 1);\r\n\t\t\r\n\t\tvisited = new boolean[N+1];\r\n\t\tvisited[start] = true;\r\n\t\tdfs(0, start);\r\n\t\t\r\n\t\tSystem.out.println(result);\r\n\t}\r\n\t\r\n\tpublic static int dfs(int len, int now) {\r\n\t\tif (result < len) {\r\n\t\t\tresult = len;\r\n\t\t\tstart = now;\r\n\t\t}\r\n\t\tSystem.out.println(now);\r\n\r\n        for (Edge node: Vertex.get(now)) {\r\n            if(!visited[node.e]){\r\n            \tvisited[node.e] = true;\r\n            \tdfs(len + node.w, node.e);\r\n            }\r\n        }\r\n        return result;\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\t\r\n\tstatic class Edge{\r\n\t\tint e, w;\r\n\t\tEdge(int e,int w){\r\n\t\t\tthis.e = e;\r\n\t\t\tthis.w = w;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n```\r\n\r\n[트리의 지름 - 백준1167](https://www.acmicpc.net/problem/1167)번 비슷한 문제다.  \r\n\r\n\r\n\r\n## [백준 2250] - 트리의 높이와 너비\r\n\r\n이문제 풀면서 많이 헤맸다ㅋㅋㅋㅋㅋㅋㅋ \r\n\r\n배열 만들어서 깊이마다 맨 오른쪽 값을 맨 왼쪽 값 빼면 될 것 같다는 생각을 했는데.....\r\n\r\n양심고백을 조금 해보면 오늘 삽질을 너무 많이 해서 고민 많이 안해보고 정답 해결 방법부터 찾아봤다.\r\n\r\n[쾌락코딩님 블로그 - 백준2250번 문제(트리의 높이와 너비) with Java](https://wooooooak.github.io/algorithm/2018/12/05/%EB%B0%B1%EC%A4%802250%EB%AC%B8%EC%A0%9C/)글을 참고했다.\r\n\r\n문제의 포인트는 3가지다.\r\n\r\n```\r\n1. 문제에서 루트가 정해져 있지 않다\r\n   -> 루트를 확인할 수 있는 뭔가 방법이 필요\r\n2. 트리의 높이마다 가장 오른쪽 값, 가장 왼쪽값 저장\r\n   -> 오른쪽 - 왼쪽 + 1\r\n3. 중위 순회로 순회\r\n   -> 그림보면 왼쪽 - 루트 - 오른쪽 순으로 index가 표시되있음\r\n```\r\n\r\n![2250pb1](2250pb1.PNG)\r\n![2250pb2](2250pb2.PNG)\r\n![2250pb3](2250pb3.PNG)\r\n\r\n### 풀이\r\n\r\n```java\r\npackage package27;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class num2250 {\r\n\tstatic int N, maxWidth, maxDepth, root, vCount = 1;\r\n\tstatic Node[] tree;\r\n\t\r\n\tstatic int[] depthLeft;\r\n\tstatic int[] depthRight;\r\n\tstatic BufferedReader br;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tN = stoi(br.readLine());\r\n\t\t\r\n\t\tinit();\r\n\t\t\r\n\t\tinputTreeData();\r\n\t\t\r\n\t\tsearchRootIndex();\r\n\t\t\r\n\t\tinOrder(root, 1);\r\n\t\t\r\n\t\tprintResult();\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic static void init() {\r\n\t\ttree = new Node[N+1];\r\n\t\tdepthLeft = new int[N+1];\r\n\t\tdepthRight = new int[N+1];\r\n\t\t\r\n\t\tfor(int i=0; i<=N; i++) {\r\n\t\t\ttree[i] = new Node(-1, -1, -1);\r\n\t\t\tdepthLeft[i] = N+1;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static void inputTreeData() throws IOException {\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tString[] inputData = br.readLine().split(\" \");\r\n\t\t\t\r\n\t\t\tint num = stoi(inputData[0]);\r\n\t\t\tint left = stoi(inputData[1]);\r\n\t\t\tint right = stoi(inputData[2]);\r\n\t\t\t\r\n\t\t\ttree[num].left = left;\r\n            tree[num].right = right;\r\n            if(left != -1)\r\n                tree[left].parent = num;\r\n            \r\n            if(right != -1)\r\n                tree[right].parent = num;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static void searchRootIndex() {\r\n\t\tfor(int i=1; i <= N; i++) {\r\n\t\t\tif(tree[i].parent == -1) {\r\n\t\t\t\troot = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static void inOrder(int parentIndex, int depth) {\r\n        Node root = tree[parentIndex];\r\n        if(maxDepth < depth) maxDepth = depth;\r\n        if(root.left != -1) {\r\n            inOrder(root.left, depth + 1);\r\n        }\r\n        \r\n        depthLeft[depth] = Math.min(depthLeft[depth], vCount);\r\n        depthRight[depth] = vCount++;\r\n        \r\n        if(root.right != -1) {\r\n            inOrder(root.right, depth + 1);\r\n        }\r\n\t}\r\n\t\r\n\tpublic static void printResult() {\r\n        int index = 1;\r\n        int maxWitdh = depthRight[1] - depthLeft[1] + 1;\r\n        for(int i=2; i <= maxDepth; i++) {\r\n            int tmp = depthRight[i] - depthLeft[i] +1;\r\n            if(maxWitdh < tmp) {\r\n            \tindex = i;\r\n            \tmaxWitdh = tmp;\r\n            }\r\n        }\r\n        \r\n        System.out.println(index + \" \" + maxWitdh);\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\t\r\n\tstatic class Node{\r\n\t\tint parent, value, left, right;\r\n\t\tNode(int value, int left, int right){\r\n\t\t\tthis.parent = -1;\r\n\t\t\tthis.value = value;\r\n\t\t\tthis.left = left;\r\n\t\t\tthis.right = right;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n```\r\n\r\n## 정리\r\n\r\n사실 트리는 학교 알고리즘 시간에 다뤄봐서 정리하는데 오래걸리지 않을 줄 알았는데 생각보다 오래걸렸다 ㅜㅜㅜㅜ 문제도 많이 풀어봐야 할 듯.... \r\n\r\n정.말.알.고.리.즘.문.제.풀.이.는.너.무.재.밌.다.하.하.하.하.하.하.하.하.하.하.하.하.하\r\n\r\n오늘 정리한 문제들은 dfs, bfs로 탐색하는 문제들이었다.\r\n\r\n\r\n아래 사진같은 유형의 문제들도 있던데.....\r\n![finish](finish.PNG)\r\n빠른 시일내로 4문제 풀어봐야겠다. (조금 무서워 보인다ㅋ)\r\n\r\n# Reference\r\n[라이님 블로그](https://m.blog.naver.com/kks227/220788265724)  \r\n[전명우님 블로그](https://blog.myungwoo.kr/112)  \r\n[쾌락코딩님 블로그 - 백준2250번 문제(트리의 높이와 너비) with Java](https://wooooooak.github.io/algorithm/2018/12/05/%EB%B0%B1%EC%A4%802250%EB%AC%B8%EC%A0%9C/)  \r\n[마포 코딩박님 블로그](https://mapocodingpark.blogspot.com/2020/05/4803.html)  ","excerpt":"트리를 정리해보자 ㅎㅎ 특징 트리의 서브트리는 절대로 영역이 겹치지 않음 -> 분할정복, DP로 장난을 잘 칠 줄 알아야 한다. 순회 방법 트리의 순회 방법은 3가지다. 보통 BFS, DFS로 구현한다. 백준 11725 - 트리의 부모찾기 \n 풀이 …","fields":{"slug":"/tree/"},"frontmatter":{"date":"Jan 28, 2021","title":"트리","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n백준 11779, 11780, 1738번 문제를 통해 최단경로의 경로출력을 정리해보려고 한다.\r\n\r\n---\r\n\r\n# 백준 11779 - 다익스트라\r\n\r\n![11779문제 사진1](11779pb1.PNG)\r\n![11779문제 사진2](11779pb2.PNG)\r\n\r\n---\r\n\r\n소스를 간략히 설명하면\r\n\r\n다익스트라 알고리즘에 값이 조건에 맞아 갱신될 때 배열의 값에 이전 노드를 저장한다.\r\n\r\n첫 노드부터 순서대로 출력하기 위해 stack을 사용했다.\r\n\r\n---\r\n\r\n```java\r\npackage pakcage26;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\nimport java.util.PriorityQueue;\r\nimport java.util.Stack;\r\n\r\npublic class num11779 {\r\n\tstatic int N, M, count=2,INF = Integer.MAX_VALUE;\r\n\tstatic ArrayList<ArrayList<Edge>> Vertex;\r\n\tstatic int[] dist, pre;\r\n\tstatic boolean[] visited;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\r\n\t\tN = stoi(br.readLine());\r\n\t\tM = stoi(br.readLine());\r\n\t\tVertex = new ArrayList<ArrayList<Edge>>();\r\n\t\tdist = new int[N];\r\n\t\tpre = new int[N];\r\n\t\tvisited = new boolean[N];\r\n\t\t\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tVertex.add(new ArrayList<Edge>());\r\n\t\t\tdist[i] = INF;\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<M; i++) {\r\n\t\t\tString[] uvw = br.readLine().split(\" \");\r\n\t\t\tint u = stoi(uvw[0])-1;\r\n\t\t\tint v = stoi(uvw[1])-1;\r\n\t\t\tint w = stoi(uvw[2]);\r\n\t\t\tVertex.get(u).add(new Edge(v,w));\r\n\t\t}\r\n\t\tString[] point = br.readLine().split(\" \");\r\n\t\tint start = stoi(point[0])-1;\r\n\t\tint end = stoi(point[1])-1;\r\n\t\tdijkstra(start, end);\r\n\t\t\r\n\t\tlong answer =dist[end];\r\n\r\n\t\tStack<Integer> st = new Stack<Integer>();\r\n\t\tst.add(end);\r\n\t\t\r\n\t\twhile (pre[end] != start) {\r\n\t\t\tst.add(pre[end]);\r\n\t\t\tend = pre[end];\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\t\r\n\t\tst.add(start);\r\n\t\t\r\n\t\tSystem.out.println(answer);\r\n\t\tSystem.out.println(count);\r\n\t\twhile (!st.isEmpty()) {\r\n\t\t\tSystem.out.print(st.pop()+1 + \" \");\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic static void dijkstra(int start, int end) {\r\n\t\tdist[start] = 0;\r\n\t\tPriorityQueue<Edge> q = new PriorityQueue<Edge>();\r\n\t\tq.add(new Edge(start, 0));\r\n\t\t\r\n\t\twhile(!q.isEmpty()) {\r\n\t\t\tEdge now = q.remove();\r\n\t\t\tif(!visited[now.e]) {\r\n\t\t\t\tvisited[now.e] = true;\r\n\t\t\t\tfor(Edge next : Vertex.get(now.e)) {\r\n\t\t\t\t\tif(!visited[next.e] && dist[next.e] >= dist[now.e] + next.w) {\r\n\t\t\t\t\t\tdist[next.e] = dist[now.e] + next.w;\r\n\t\t\t\t\t\tq.add(new Edge(next.e, dist[next.e]));\r\n\t\t\t\t\t\tpre[next.e] = now.e;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\t\r\n\tstatic class Edge implements Comparable<Edge>{\r\n\t\tint e, w;\r\n\t\tEdge(int e, int w){\r\n\t\t\tthis.e = e;\r\n\t\t\tthis.w = w;\r\n\t\t}\r\n\t\t@Override\r\n\t\tpublic int compareTo(Edge o){\r\n\t\t\treturn w - o.w;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n# 백준 11780 - 플로이드\r\n---\r\n![11780문제 사진1](11780pb1.PNG)\r\n![11780문제 사진2](11780pb2.PNG)\r\n![11780문제 사진2](11780pb3.PNG)\r\n---\r\nnext배열은 a(정점) -> b(정점) 일 때, 출발 정점(a)의 값을 가지고 있다.\r\n\r\n플로이드 알고리즘은 i -> k -> j 의 거리가 짧을 경우 최단거리(dist배열)을 갱신해준다.  \r\n\r\n동일하게 최단거리가 짧은 경우 출발 노드(next배열)을 k로 바꿔서 갱신해준다.\r\n\r\n---\r\n```java\r\npackage pakcage26;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.Stack;\r\n\r\npublic class num11780 {\r\n\tstatic int N, M, INF = 100000000;\r\n\tstatic int[][] dist, next;\r\n\tstatic boolean[][] visited;\r\n\tstatic Stack<Integer> stack;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\r\n\t\t\r\n\t\tN = stoi(br.readLine());\r\n\t\tM = stoi(br.readLine());\r\n\t\tdist = new int[N][N];\r\n\t\tnext = new int[N][N];\r\n\t\t\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tfor(int j=0; j<N; j++) {\r\n\t\t\t\tdist[i][j] = i == j ? 0 : INF;\r\n\t\t\t\tnext[i][j] = INF;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\t\t\r\n\t\tfor(int i=0; i<M; i++) {\r\n\t\t\tString[] abc = br.readLine().split(\" \");\r\n\t\t\tint a = stoi(abc[0])-1;\r\n\t\t\tint b = stoi(abc[1])-1;\r\n\t\t\tint c = stoi(abc[2]);\r\n\t\t\t\r\n\t\t\tdist[a][b] = Math.min(dist[a][b], c);\r\n\t\t\tnext[a][b] = a;\r\n\t\t}\r\n\t\t\r\n\t\tfloyd();\r\n\t\t\r\n\t\tprintPath();\r\n\t}\r\n\t\r\n\tpublic static void floyd() {\r\n\t\tfor(int k = 0; k<N; k++) {\r\n\t\t\tfor(int i = 0; i<N; i++) {\r\n\t\t\t\tfor(int j=0; j<N; j++) {\r\n\t\t\t\t\tif(dist[i][j] > dist[i][k] + dist[k][j]) {\r\n\t\t\t\t\t\tdist[i][j] = dist[i][k] +dist[k][j];\r\n\t\t\t\t\t\tnext[i][j] = next[k][j];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static void printPath() {\r\n\t\tfor(int[] a : dist) {\r\n\t\t\tfor(int b: a) {\r\n\t\t\t\tSystem.out.print(b + \" \");\r\n\t\t\t}\r\n\t\t\tSystem.out.println();\r\n\t\t}\r\n\t\t\r\n        for(int i=0; i<N; i++) {\r\n            for(int j=0; j<N; j++) {\r\n                if(next[i][j]==INF)\r\n                    System.out.println(0);\r\n\r\n                else {\r\n                \tstack = new Stack<>();\r\n                    int pre = j;\r\n                    stack.push(j);\r\n                    while(i != next[i][pre]) {\r\n                        pre = next[i][pre];\r\n                        stack.push(pre);\r\n                    }\r\n                    System.out.print((stack.size()+1)+\" \");\r\n                    System.out.print(i+1+\" \");\r\n                    while(!stack.empty())\r\n                        System.out.print(stack.pop()+1+\" \");\r\n                    System.out.println();\r\n                }\r\n            }\r\n        }\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\t\r\n}\r\n```\r\n\r\n# 벨만포드 - 백준 1738\r\n\r\n---\r\n\r\n![1738문제1](1738pb1.PNG)\r\n![1738문제2](1738pb1.PNG)\r\n\r\n---\r\n일차원 배열을 선언해 이전 경로의 값을 가지고 있는다.\r\n\r\n기존의 벨만 포드 알고리즘과는 달리 음의 싸이클이 있으면 끝이 아니라,  \r\n음의 싸이클에 도착점으로 도달 가능해야 답이 -1이다.\r\n\r\n```\r\n4 4\r\n1 4 3\r\n2 3 1\r\n3 2 1\r\n4 2 1\r\n```\r\n위의 테스트 케이스를 통과해야 정답이다.\r\n\r\n이거 때문에 삽질 좀 했다 ㅜㅜ\r\n\r\n---\r\n\r\n```java\r\npackage MinPath;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\nimport java.util.Stack;\r\n\r\npublic class num1738 {\r\n\tstatic int N, M, INF = 987654321, INF2=-987654321;\r\n\tstatic ArrayList<ArrayList<Edge>> Vertex;\r\n\tstatic int[] preVertex;\r\n\tstatic long[] dist;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tString[] NM = br.readLine().split(\" \");\r\n\t\t\r\n\t\tN = stoi(NM[0]);\r\n\t\tM = stoi(NM[1]);\r\n\t\t\r\n\t\tdist = new long[N];\r\n\t\tVertex = new ArrayList<ArrayList<Edge>>();\r\n\t\tpreVertex = new int[N];\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tVertex.add(new ArrayList<Edge>());\r\n\t\t\tdist[i] = INF;\r\n\t\t\tpreVertex[i] = -1;\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<M; i++) {\r\n\t\t\tString[] uvw = br.readLine().split(\" \");\r\n\t\t\tint u = stoi(uvw[0])-1;\r\n\t\t\tint v = stoi(uvw[1])-1;\r\n\t\t\tint w = stoi(uvw[2]);\r\n\t\t\tVertex.get(u).add(new Edge(v, -w));\r\n\t\t}\r\n\t\t\r\n\t\tbellmanFord();\r\n\t\t\r\n\t\tprintPath();\r\n\t}\r\n\t\r\n\tpublic static void bellmanFord() {\r\n\t\tdist[0] = 0;\r\n\t\tpreVertex[0] = 0;\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tfor(int j=0; j<N; j++) {\r\n\t\t\t\tfor(Edge edge : Vertex.get(j)) {\r\n\t\t\t\t\tint next = edge.e, weight = edge.w;\r\n\t\t\t\t\tif(dist[j]!=INF && dist[next] > dist[j] + weight) {\r\n\t\t\t\t\t\tdist[next] = (dist[j] + weight);\r\n\t\t\t\t\t\tpreVertex[next] = j;\r\n\t\t\t\t\t\tif(i == N-1) {\r\n\t\t\t\t\t\t\tdist[next] = INF2;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static void printPath() {\r\n\t\tStack<Integer> stack = new Stack<Integer>();\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\tif(dist[N-1] == INF || dist[N-1] == INF2)\r\n\t\t\tsb.append(\"-1\");\r\n\t\telse{\r\n\t\t\tfor (int i = N-1 ; i != 0; i = preVertex[i]) {\r\n\t\t\t\tif(dist[i] == INF2) {\r\n\t\t\t\t\tSystem.out.println(-1);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tstack.push(i);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tstack.push(0);\r\n\t        for (int i = stack.size(); i > 0; --i)\r\n\t        {\r\n\t            sb.append(stack.pop()+1+\" \");\r\n\t        }\r\n\t\t}\r\n\t\tSystem.out.println(sb);\r\n\t}\r\n\t\r\n\tstatic class Edge{\r\n\t\tint e, w;\r\n\t\tEdge(int e, int w){\r\n\t\t\tthis.e = e;\r\n\t\t\tthis.w = w;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\r\n}\r\n```\r\n\r\n# 정리\r\n\r\n---\r\n\r\n세가지 알고리즘 모두 최단거리를 추적하면서  \r\n**경로를 저장할 공간을 만들어서 저장하는 방식**이다.\r\n\r\n# Reference\r\n---\r\n[갓킹독님 블로그](https://blog.encrypted.gg/category/%EA%B0%95%EC%A2%8C/%EC%8B%A4%EC%A0%84%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98?page=1)  \r\n[라이님 블로그](https://m.blog.naver.com/PostList.nhn?blogId=kks227)  \r\n","excerpt":"백준 11779, 11780, 1738번 문제를 통해 최단경로의 경로출력을 정리해보려고 한다. 백준 11779 - 다익스트라 \n 소스를 간략히 설명하면 다익스트라 알고리즘에 값이 조건에 맞아 갱신될 때 배열의 값에 이전 노드를 저장한다. 첫 노드부터…","fields":{"slug":"/shortestDistance_2/"},"frontmatter":{"date":"Jan 25, 2021","title":"최단거리 경로복원","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n정리 안해두면 까먹을거 같아서 기억력을 조금이라도 향상시키기 위해 정리해둔다.\r\n\r\n자, 최단거리 알고리즘을 이해하기 위해 그래프를 간략히 살펴보면\r\n\r\n---\r\n\r\n# 그래프란? \r\n\r\n---\r\n\r\n그래프는 **정점(Vertex)** 와 **간선(Edge)** 을 모아놓은 자료구조다.\r\n\r\n그래프라는 친구는 보통 간선에 가중치를 가진다.\r\n\r\n## 구현 방법\r\n---\r\n1. 인접 행렬\r\n2. 인접 리스트\r\n\r\n# 다익스트라 알고리즘\r\n---\r\n\r\n최단 거리 알고리즘은 기본적으로 **그리디 알고리즘** 으로 분류된다.  \r\n -> **매번 가장 비용이 적은 노드** 를 선택하는 과정을 반복하기 때문이다.\r\n\r\n## 전제조건\r\n---\r\n\r\n1. 시작 노드 - 시작 노드 사이 거리는 0이다.\r\n2. 모든 간선은 양의 가중치를 가진다.\r\n\r\n## 특징\r\n---\r\n\r\n1. 구현 방법은 2가지\r\n\r\n## 1. 직관적인 방법 - O(V^2)\r\n---\r\n1. 각 노드에 대한 최단 거리를 담는 1차원 리스트 선언\r\n2. 방문하지 않은 노드 중에서 거리가 가장 짧은 노드 선택  \r\n(거리가 같으면 일반적으로 번호가 작은 노드)\r\n3. 거리가 더 짧으면 값 갱신\r\n\r\n### 최단거리 - 백준 1753\r\n---\r\n![1753문제](1753pb.PNG)\r\n![1753문제](1753pb2.PNG)\r\n\r\n```java\r\npackage package24;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\npublic class num1753 {\r\n\tstatic int INF = Integer.MAX_VALUE;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tString[] inputVE = br.readLine().split(\" \");\r\n\t\tint V = stoi(inputVE[0]);\r\n\t\tint E = stoi(inputVE[1]);\r\n\t\tint K = stoi(br.readLine())-1;\r\n\t\t\r\n\t\tList<Edge>[] graph = new ArrayList[V];\r\n        for (int i = 0; i < V; i++) \r\n        \tgraph[i] = new ArrayList<>();\r\n\t\tint[] distance = new int[V];\r\n\t\tboolean[] visited = new boolean[V];\r\n\t\t\r\n\t\tfor(int i=0; i<V; i++) {\r\n\t\t\tdistance[i] = INF; \r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<E; i++) {\r\n\t\t\tString[] uvw = br.readLine().split(\" \");\r\n\t\t\tint u = stoi(uvw[0])-1;\r\n\t\t\tint v = stoi(uvw[1])-1;\r\n\t\t\tint w = stoi(uvw[2]);\r\n\t\t\tgraph[u].add(new Edge(v,w));\r\n\t\t}\r\n\t\tdijkstra(graph, visited, distance, V, E, K);\r\n\t\t\r\n\t\tfor(int value : distance) {\r\n\t\t\tif(INF == value)\r\n\t\t\t\tSystem.out.println(\"INF\");\r\n\t\t\telse\r\n\t\t\t\tSystem.out.println(value);\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static void dijkstra(List<Edge>[] graph, boolean[] visited, int[] distance, int V, int E, int K) {\r\n\t\tdistance[K] = 0;\r\n\t\tfor(int i=0; i<V; i++) {\r\n\t\t\tint minIndex = getSmallestNodeNotVisited(visited, distance, V);\r\n            for (Edge next : graph[minIndex]) {\r\n                if(!visited[next.v] && distance[next.v] > distance[minIndex] + next.weight) {\r\n                \tdistance[next.v] = distance[minIndex] + next.weight;\r\n                }\r\n            }\r\n\r\n\t\t\tvisited[minIndex] = true;\r\n\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic static int getSmallestNodeNotVisited(boolean[] visited, int[] distance, int V) {\r\n\t\tint min = INF;\r\n\t\tint minIndex = 0;\r\n\t\tfor(int i=0; i<V; i++) {\r\n\t\t\tif(visited[i] == false && distance[i]<min) {\r\n\t\t\t\tmin = distance[i];\r\n\t\t\t\tminIndex = i;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn minIndex;\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n}\r\n\r\nclass Edge {\r\n    int v, weight;\r\n\r\n    public Edge(int v, int weight) {\r\n        this.v = v;\r\n        this.weight = weight;\r\n    }\r\n    \r\n}\r\n\r\n```\r\n---\r\n\r\n소스를 간략히 설명하면  \r\n노드 arrayList를 만들고 Edge는 클래스로 만들어서 넣어주는 방법으로 구현했다.  \r\n(배열로만 구현하면 메모리 초과난다.)\r\n\r\n매번 최단거리가 가장 짧은 노드를 찾기 위해 O(V) 만큼 탐색하기 때문에 비효율적이다.  \r\n -> Priority Queue 활용\r\n\r\n---\r\n\r\n## 2. Priority Queue 활용 - O(ElogV)\r\n\r\n---\r\n\r\n최단 거리 -> **최소 힙**을 사용한다.\r\n\r\n```\r\n1. 각 노드에 대한 최단 거리를 담는 1차원 리스트 선언\r\n2. 우선순위 큐을 사용해 거리가 짧은 정점부터 Queue에 넣어 줌.(처음 시작 값 : 0)  \r\n3. 큐가 값이 없을 때까지 반복  \r\n    3-1) 큐에서 값을 하나 꺼냄 (Vertex 선택)  \r\n\t3-2) visited 값 true 설정  \r\n4. 다음 Vertex의 최단거리가 현재Vertex 최단 거리 + 다음 Vertex 가중치보다 크면   \r\n\t(다음 Vertex가 사용되지 않았을 때)  \r\n\t4-1) 값 갱신  \r\n\t4-2) 우선순위 큐에 값 추가  \r\n```\r\n\r\n요약하면\r\n```\r\n1. 아직 방문하지 않은 정점 중 거리가 짧은 정점을 하나 선택해 방문\r\n2. 해당 정점에 인접하고 아직 방문하지 않은 정점의 최단거리 갱신\r\n```\r\n\r\nTip!!  \r\n**JAVA PriorityQueue 는 기본적으로 minHeap이다.**\r\n\r\n\r\n```java\r\n// 최소 힙\r\nPriorityQueue<Integer> minHeap = new PriorityQueue<Integer>();\r\n\r\n// 최대 힙\r\nPriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(Comparator.reverseOrder());\r\n\r\n// 최대 힙 version2\r\nPriorityQueue<Integer> maxHeap = PriorityQueue<>(new Comparator<Integer>(){\r\n\t@Override\r\n\tpublic int compare(Integer i1, Integer i2) {\r\n\t\treturn i2-i1;\r\n\t}\r\n});\r\n```\r\n\r\n### 최단거리 - 백준 1504\r\n\r\n---\r\n\r\n![1504문제](1504pb1.PNG)\r\n![1504문제2](1504pb2.PNG)\r\n\r\n---\r\n\r\n문제를 보면 정점 2개를 방문해야 한다는 조건이 있다. 정점을 각각 V1, V2라고 한다면 \r\n 1. 1 -> V1 -> V2 -> N\r\n 2. 1 -> V2 -> V1 -> N\r\n\r\n두가지 경우에 대해 구간별로 최소값을 구한 후, 더하면 된다.\r\n\r\n---\r\n\r\n```java\r\npackage package24;\r\n\r\nimport java.io.*;\r\nimport java.util.*;\r\n\r\npublic class num1504 {\r\n\tstatic int N,E,v1,v2,result;\r\n\tstatic ArrayList<ArrayList<Edge>> Vertex;\r\n\tstatic int[] distance;\r\n\tstatic boolean[] visited;\r\n\tstatic int INF = 200000000;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tString[] NE = br.readLine().split(\" \");\r\n\t\tN = stoi(NE[0]);\r\n\t\tE = stoi(NE[1]);\r\n\t\tdistance = new int[N+1];\r\n\t\tvisited = new boolean[N+1];\r\n\t\tVertex = new ArrayList<>();\r\n\t\t\r\n\t\tfor(int i=0; i<=N; i++) {\r\n\t\t\tVertex.add(new ArrayList<>());\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<E; i++) {\r\n\t\t\tString[] abc = br.readLine().split(\" \");\r\n\t\t\tint a = stoi(abc[0]);\r\n\t\t\tint b = stoi(abc[1]);\r\n\t\t\tint c = stoi(abc[2]);\r\n\t\t\t\r\n\t\t\tVertex.get(a).add(new Edge(b,c));\r\n\t\t\tVertex.get(b).add(new Edge(a,c));\r\n\t\t}\r\n\t\tString[] v1v2 = br.readLine().split(\" \");\r\n\t\tv1 = stoi(v1v2[0]);\r\n\t\tv2 = stoi(v1v2[1]);\r\n\t\t\r\n\t\tresult = solve();\r\n\t\tSystem.out.println(result);\r\n\t}\r\n\r\n\tpublic static int solve() {\r\n\t\tint case1=0, case2=0;\r\n\t\t\r\n\t\tcase1 = dijkstra(1,v1) + dijkstra(v1,v2) + dijkstra(v2,N);\r\n\t\tcase2 = dijkstra(1,v2) + dijkstra(v2,v1) + dijkstra(v1,N);\r\n\r\n\t\treturn (case1 >= INF && case2 >= INF) ? -1 : Math.min(case1, case2);\r\n\t}\r\n\t\r\n\tpublic static int dijkstra(int start, int end) {\r\n\t\tArrays.fill(distance, INF);\r\n\t\tArrays.fill(visited, false);\r\n\t\t\r\n\t\tPriorityQueue<Edge> queue = new PriorityQueue<Edge>();\r\n\t\tqueue.add(new Edge(start,0));\r\n\t\tdistance[start] = 0;\r\n\t\t\r\n\t\twhile(!queue.isEmpty()) {\r\n\t\t\tEdge now = queue.remove();\r\n\t\t\tint nowNode = now.e;\r\n\t\t\tif(!visited[nowNode]) {\r\n\t\t\t\tvisited[nowNode] = true;\r\n\t\t\t\t\r\n\t\t\t\tfor(Edge next : Vertex.get(nowNode)) {\r\n\t\t\t\t\tif(!visited[next.e] && distance[next.e] > distance[nowNode] + next.weight) {\r\n\t\t\t\t\t\tdistance[next.e] = distance[nowNode] + next.weight;\r\n\t\t\t\t\t\tqueue.add(new Edge(next.e, distance[next.e]));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn distance[end];\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\t\r\n\tstatic class Edge implements Comparable<Edge>{\r\n\t\tint e, weight;\r\n\t\tEdge(int e, int weight){\r\n\t\t\tthis.e = e;\r\n\t\t\tthis.weight = weight;\r\n\t\t}\r\n\t\t\r\n\t\t@Override\r\n\t\tpublic int compareTo(Edge o){\r\n\t\t\treturn weight - o.weight;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n\r\n\r\n# 벨만-포드 알고리즘\r\n---\r\n\r\n## 특징\r\n---\r\n\r\n1. 시간 복잡도 - O(VE)\r\n2. 다익스트라 알고리즘보다 느리지만 음의 가중치를 가진 경로의 최단거리를 구할 수 있다.\r\n\r\n## 전제 조건\r\n---\r\n1. **같은 정점을 2번 지날일은 없기 때문에** 간선의 최대 개수는 **V-1**이다.\r\n2. 음수 사이클이 없는 최단 경로를 구해야 한다.\r\n\r\n> 존재하는 모든 간선을 돌아보면서 간선이 통할 수도 있는 거리를 갱신하는 것\r\n\r\n## 백준 11657\r\n---\r\n![11607문제1](11657pb1.PNG)\r\n![11607문제2](11657pb2.PNG)\r\n![11607문제3](11657pb3.PNG)\r\n\r\n```java\r\npackage package24;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\n\r\npublic class num11657 {\r\n\tstatic int N, M;\r\n\tstatic ArrayList<ArrayList<Edge>> Vertex;\r\n\tstatic long[] dist;\r\n\tstatic int INF = Integer.MAX_VALUE;\r\n\tstatic boolean minusCycle=false;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\r\n\t\tString[] inputNM = br.readLine().split(\" \");\r\n\t\tN = stoi(inputNM[0]);\r\n\t\tM = stoi(inputNM[1]);\r\n\t\t\r\n\t\tdist = new long[N];\r\n\t\tVertex = new ArrayList<ArrayList<Edge>>();\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tVertex.add(new ArrayList<Edge>());\r\n\t\t\tdist[i] = INF;\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<M; i++) {\r\n\t\t\tString[] ABC = br.readLine().split(\" \");\r\n\t\t\tint A = stoi(ABC[0])-1;\r\n\t\t\tint B = stoi(ABC[1])-1;\r\n\t\t\tint C = stoi(ABC[2]);\r\n\t\t\t\r\n\t\t\tVertex.get(A).add(new Edge(B,C));\r\n\t\t}\r\n\t\tbellman();\r\n\t\t\r\n\t\tif(minusCycle)\r\n\t\t\tsb.append(\"-1\\n\");\r\n\t\telse {\r\n\t\t\tfor(int i=1; i<N; i++) {\r\n\t\t\t\tsb.append(dist[i] != INF ? dist[i] : -1);\r\n\t\t\t\tsb.append(\"\\n\");\r\n\t\t\t}\r\n\t\t}\r\n\t\tSystem.out.println(sb.toString());\r\n\t\t\r\n\t}\r\n\tpublic static void bellman() {\r\n\t\tdist[0] = 0;\r\n\t\t\r\n\t    for(int i=0; i<N; i++){ \r\n\t        for(int j=0; j<N; j++){\r\n\t            for(Edge edge: Vertex.get(j)){\r\n\t                int next = edge.e, w = edge.w;\r\n\t                if(dist[j] != INF && dist[next] > dist[j] + w){\r\n\t                    dist[next] = dist[j] + w;\r\n\t                    if(i == N-1) minusCycle = true;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t}\r\n\t\r\n\tstatic class Edge {\r\n\t\tint e, w;\r\n\t\tEdge(int e, int w) {\r\n\t\t\tthis.e = e;\r\n\t\t\tthis.w = w;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n}\r\n```\r\n\r\n---\r\n\r\n코드를 간단히 설명해보면\r\n\r\n존재하는 모든 간선을 돌아보면서 이 간선을 통할 수도 있는 최단경로들의 거리를 갱신한다.\r\n같은 정점을 2번 방문하는 경우는 없다는 전제가 있으므로 V-1까지 확인한다\r\n만약, 음의 사이클이 존재한다면 -> V-1 이후 최단거리가 갱신된다. \r\n위의 소스에선 V까지 루프의 마지막에 최단거리가 갱신되는지 확인한다.\r\n\r\n\r\n이 문제는 조금 주의할 점이 있다. \r\n\r\n최소 가중치가 -10000이라 언더플로우가 생길 수 있기 때문에 **dist를 long[]으로 설정해야 한다.**  \r\n\r\n---\r\n\r\n# 플로이드 알고리즘 \r\n---\r\n## 특징\r\n---\r\n\r\n1. 다익스트라, 벨만 포드 알고리즘 : 하나의 시작점에 대한 최단 거리\r\n2. 플로이드 워셜 알고리즘 : **모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야 하는 경우**  \r\n3. 시간 복잡도 : O(V^3)  \r\n\t-> 노드의 개수 O(V) * **현재 노드를 거쳐가는 모든 경로O(V^2)** -> **O(V^3)**\r\n4. **DP형태** -> 점화식에 맞게 2차원 리스트를 갱신하기 때문\r\n\r\n**Tip!!**  \r\n상황에 따라 자기 자신으로 이동 가능하면 dis[i][j] = 0 / 불가능하면 dis[i][j] = INF\r\n\r\n- 가장 바깥쪽 for문은 경유할 정점\r\n- 가운데 for문은 출발 정점\r\n- 가장 안쪽 for문은 도착 정점\r\n\r\n---\r\n\r\n## 백준 11404\r\n\r\n```java\r\npackage package24;\r\n\r\nimport java.io.*;\r\n\r\npublic class num11404 {\r\n\tstatic int N, M, INF = 100000000;\r\n\tstatic int[][] dis;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\r\n\t\tN = stoi(br.readLine());\r\n\t\tM = stoi(br.readLine());\r\n\t\t\r\n\t\tdis = new int[N][N];\r\n\t\t\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tfor(int j=0; j<N; j++) {\r\n\t\t\t\tdis[i][j] = i == j ? 0 : INF;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<M; i++) {\r\n\t\t\tString[] abc = br.readLine().split(\" \");\r\n\t\t\tint a = stoi(abc[0])-1;\r\n\t\t\tint b = stoi(abc[1])-1;\r\n\t\t\tint c = stoi(abc[2]);\r\n\t\t\t\r\n\t\t\tdis[a][b] = Math.min(dis[a][b], c);\r\n\t\t}\r\n\t\t\r\n\t\tfor(int k=0; k<N; k++) {\r\n\t\t\tfor(int i=0; i<N; i++) {\r\n\t\t\t\tfor(int j=0; j<N; j++) {\r\n\t\t\t\t\tdis[i][j] = Math.min(dis[i][j], dis[i][k] +dis[k][j]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n        for (int i = 0; i < N; i++) {\r\n            for (int j = 0; j < N; j++) {\r\n            \tdis[i][j] = dis[i][j] == INF ? 0 : dis[i][j];\r\n                sb.append(dis[i][j] + \" \");\r\n            }\r\n            sb.append(\"\\n\");\r\n        }\r\n \r\n        bw.write(sb.toString());\r\n        bw.flush();\r\n        bw.close();\r\n        br.close();\r\n\t}\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n# 정리\r\n---\r\n\r\n이렇게 최단거리 알고리즘 3가지를 알아보았다.  \r\n\r\n사용하는 경우를 정리해보면  \r\n```\r\n1. 다익스트라 알고리즘[우선순위 큐] -> 한 지점에서 다른 지점까지 최단거리 구하는 문제  \r\n2. 벨만 포드 알고리즘 -> 음의 가중치를 가진 최단거리 구하는 문제  \r\n3. 플로이드 와샬 알고리즘 -> 모든 경로의 최단거리 구하는 문제\r\n``` \r\n로 정리할 수 있다.\r\n\r\n\r\n생각보다 어려워서 정리하는데 시간이 오래걸렸다.  \r\n다음 글은 최단경로의 경로출력에 대해 정리해 볼 예정이다.\r\n\r\n추가로 [라이님 블로그](https://blog.naver.com/kks227/220796029558) 요기 있는 추가문제 하나씩 풀어봐야겠다.\r\n\r\n\r\n# Reference\r\n---\r\n[라이님 블로그](https://blog.naver.com/kks227/220796029558)  \r\n[갓킹독님 블로그](https://blog.encrypted.gg/917?category=773649)  \r\n[Crocus님 블로그](https://www.crocus.co.kr/546?category=209527)  \r\n[백준 질문하기 - 출력초과 문제 해결이 되었는데 이유를 모르겠습니다](https://www.acmicpc.net/board/view/55270)  \r\n이것이 코딩테스트다 - 나동빈\r\n\r\n\r\n","excerpt":"정리 안해두면 까먹을거 같아서 기억력을 조금이라도 향상시키기 위해 정리해둔다. 자, 최단거리 알고리즘을 이해하기 위해 그래프를 간략히 살펴보면 그래프란? 그래프는 정점(Vertex) 와 간선(Edge) 을 모아놓은 자료구조다. 그래프라는 친구는 보통…","fields":{"slug":"/shortestDistance_1/"},"frontmatter":{"date":"Jan 23, 2021","title":"최단거리 알고리즘","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n백준 이분 탐색 문제를 풀다 Parametric Search에 대해 알게 되었고, 정리 할 필요성을 느껴서 포스팅한다.\r\n\r\n일단 **이분탐색**은 탐색 기법으로 **원하는 탐색 범위를 두 부분으로 분할**해서 찾는 방식이다  \r\n -> O(logN)의 시간 복잡도를 가지고 있다.\r\n\r\n**파라매트릭 서치**는 **최적화 문제(문제 상황을 만족하는 특정한 값 - ex) 최소값, 최대값)을 결정문제로 바꾸어 푸는 것**을 말한다.  \r\n\r\n백준 2110번 문제가 쉽게 이해하기 좋은 문제인 것 같다.\r\n\r\n![문제사진](pro1.PNG)\r\n![문제사진2](pro2.PNG)\r\n\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.Arrays;\r\n\r\npublic class Main {\r\n\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tString[] inputNK = br.readLine().split(\" \");\r\n\t\tint N = Integer.parseInt(inputNK[0]);\r\n\t\tlong K = Long.parseLong(inputNK[1]);\r\n\t\tlong max = 0;\r\n\t\t\r\n\t\tlong[] houseArr = new long[N];\r\n\t\t\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\thouseArr[i] = Long.parseLong(br.readLine());\r\n\t\t\tmax = max > houseArr[i] ? max : houseArr[i];\r\n\t\t}\r\n\t\tArrays.sort(houseArr);\r\n\t\t\r\n\t\tmax = Psearch(houseArr, K, max);\r\n\t\tSystem.out.println(max);\r\n\t}\r\n\t\r\n\tpublic static long Psearch(long[] houseArr, long K, long max) {\r\n\t\tlong start = 1;\r\n\t\tlong end = max;\r\n\t\tlong ans = 0;\r\n\t\t\r\n\t\twhile(start<=end) {\r\n\t\t\tlong mid = (start+end)/2;\r\n\t\t\t\r\n\t\t\tif(checkHouse(houseArr, mid, K)) {\r\n\t\t\t\tstart = mid+1;\r\n\t\t\t\tans = ans > mid ? ans : mid;\r\n\t\t\t}else {\r\n\t\t\t\tend = mid-1;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn ans;\r\n\t}\r\n\t\r\n\tpublic static boolean checkHouse(long[] houseArr, long mid, long K) {\r\n\t\tlong temp = houseArr[0];\r\n\t\tlong index = 0;\r\n\t\tfor(int i = 1; i<houseArr.length; i++) {\r\n\t\t\tif(houseArr[i]-temp >= mid) {\r\n\t\t\t\tindex++;\r\n\t\t\t\ttemp=houseArr[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif(index >=K-1)\r\n\t\t\treturn true;\r\n\t\telse\r\n\t\t\treturn false;\r\n\t}\r\n\r\n}\r\n\r\n```\r\n\r\n이 문제의 포인트는  \r\n1. 공유기 사이 거리를 정한 후, 정한 거리 이상의 간격으로 집에 설치 가능한지 확인\r\n    - 설치 가능 -> 더 큰 거리값 확인\r\n    - 설치 불가능 -> 작은 거리값을 확인  \r\n\r\n\r\n추가로 백준 12015번 문제를 풀어보는 것을 추천한다.\r\ndp를 활용해 가장 긴 증가하는 부분 수열 구할 수 있는데 이분탐색을 사용하면 O(logN)으로 구할 수 있다.\r\n\r\n\r\n \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","excerpt":"백준 이분 탐색 문제를 풀다 Parametric Search에 대해 알게 되었고, 정리 할 필요성을 느껴서 포스팅한다. 일단 이분탐색은 탐색 기법으로 원하는 탐색 범위를 두 부분으로 분할해서 찾는 방식이다  -> O(logN)의 시간 복잡도를 가지고…","fields":{"slug":"/ParametricSearch/"},"frontmatter":{"date":"Jan 17, 2021","title":"이분탐색, 파라매트릭 서치(Parametric Search)","tags":["Algorithm","Parametric Search"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n백준 단계별 문제 - 우선순위 큐 마지막 문제다.  \r\n\r\n풀다가 조금 헷갈린 부분이 있어 정리하고자 포스팅한다.  \r\n\r\n# 문제\r\n![문제사진](problem1.PNG)\r\n![문제사진2](problem2.PNG)\r\n\r\n일단 문제에 처음 접근할 땐, 우선순위 큐를 사용해 저장하고 중간 값을 계속 뽑아와 StringBuilder에 넣어주는 방식으로 구현했다.  \r\n\r\n```java\r\npackage package21;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.PriorityQueue;\r\nimport java.util.Stack;\r\n\r\npublic class num1655 {\r\n\r\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tPriorityQueue<Integer> q = new PriorityQueue<>();\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\r\n\t\tint T = Integer.parseInt(br.readLine());\r\n\t\t\r\n\t\tfor(int i=0; i<T; i++) {\r\n\t\t\tint value = Integer.parseInt(br.readLine());\r\n\t\t\tq.offer(value);\r\n\t\t\tint len = q.size()/2 + q.size()%2;\r\n\t\t\tStack<Integer> s = new Stack<>();\r\n\t\t\tfor(int j=0;j<len;j++) {\r\n\t\t\t\ts.push(q.remove());\r\n\t\t\t}\r\n\t\t\tif(!s.isEmpty())\r\n\t\t\t\tsb.append(s.peek()+\"\\n\");\r\n\t\t\twhile(!s.isEmpty()) {\r\n\t\t\t\tq.offer(s.pop());\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\tSystem.out.println(sb);\r\n\t}\r\n\r\n}\r\n```\r\n![시간초과](no.PNG)\r\n\r\n역시 시간초과.....\r\n\r\n## 풀이 1\r\nstack대신 우선순위큐를 하나 더 써서 구현해보려고 생각하였고, 이 부분에서 삽질을 조금 하였다.  \r\n\r\n포인트는 4가지다.\r\n1. Max Heap(최대 값이 가장 앞에 위치)과 Min Heap(최소 값이 가장 앞에 위치) 사용   \r\n2. 중간 값을 저장(초기 값 = 맨 처음에 입력받은 값)  \r\n   중간 값 보다 작은 값은 Max Heap / 큰 값은 Min Heap\r\n3. 큰값을 저장하는 min heap이 길이가 2이상 길면 중앙 값 바꿈  \r\n    -> 작은 값을 저장하는 max heap에 중간 값 저장  \r\n    -> 큰 값을 저장하는 min heap에서 가장 작은 값을 중간값으로 바꿈  \r\n4. 작은 값을 저장하는 max heap이 길이가 1이상 길면 중앙 값 바꿈  \r\n   (길이가 짝수이면 작은수가 중간 값이니 길이= 1 )  \r\n   -> 큰 값을 저장하는 min heap에 중간 값 저장  \r\n   -> 작은 값을 저장하는 max heap에서 가장 큰 값을 중간값으로 바꿈  \r\n\r\n```java\r\npackage package21;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.Comparator;\r\nimport java.util.PriorityQueue;\r\nimport java.util.Queue;\r\n\r\npublic class num1655v2 {\r\n\r\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\tQueue<Integer> min = new PriorityQueue<>();\r\n\t\tQueue<Integer> max = new PriorityQueue<>(new Comparator<Integer>() {\r\n\t\t\t@Override\r\n\t\t\tpublic int compare(Integer o1, Integer o2) {\r\n\t\t\t\treturn o2.compareTo(o1);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t});\r\n\t\t\r\n\t\tint T = Integer.parseInt(br.readLine());\r\n\t\t\r\n\t\tint index=0;\r\n\t\t\r\n\t\tfor(int i = 0; i<T; i++) {\r\n\t\t\tint num = Integer.parseInt(br.readLine());\r\n\t\t\tif(i==0) {\r\n\t\t\t\tindex = num;\r\n\t\t\t\tsb.append(num+\"\\n\");\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif(num<=index) {\r\n\t\t\t\t// 작은 값이면 max heap에 저장\r\n\t\t\t\tmax.offer(num);\r\n\t\t\t\tif(max.size()-min.size()>=1) {\r\n\t\t\t\t\tmin.offer(index);\r\n\t\t\t\t\tindex = max.poll();\r\n\t\t\t\t}\r\n\t\t\t}else {\r\n\t\t\t\t// 큰 값이면  min heap에 저장\r\n\t\t\t\tmin.offer(num);\r\n\t\t\t\tif(min.size() - max.size() >=2) {\r\n\t\t\t\t\tmax.offer(index);\r\n\t\t\t\t\tindex = min.poll();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tsb.append(index+\"\\n\");\r\n\t\t}\r\n\t\tSystem.out.println(sb);\r\n\t}\r\n\r\n}\r\n```\r\n\r\n후... 큰 값을 min heap 저장, 작은 값을 max heap 저장, 중간값은 index로 빼놓는게 포인트인데 코드 짜다보니 헷갈려서 헤맸다.\r\n\r\n\r\n\r\n추가) 다른 사람들은 코드를 어떻게 짰는지 구글링 해봤는데 조금 재밌게 푼 코드가 있어서 추가로 풀어봤다.\r\n\r\n## 풀이2\r\n1. 중간 값은 항상 max heap의 가장 앞의 값으로 유지\r\n2. 크기가 같으면 max heap에 값 추가\r\n   (입력한 값이 min heap의 최소값보다 크면 값 swap)\r\n3. 크기가 다르면 min heap에 값 추가\r\n   (입력한 값이 max heap의 최대값보다 작으면 값 swap)\r\n\r\n이 코드는 입력값 : 521578 을 넣어서 직접 노트에 풀어보는게 이해하는데 도움됐다.\r\n```java\r\npackage package21;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.Comparator;\r\nimport java.util.PriorityQueue;\r\nimport java.util.Queue;\r\n\r\npublic class num1655v3 {\r\n\r\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\tQueue<Integer> min = new PriorityQueue<>();\r\n\t\tQueue<Integer> max = new PriorityQueue<>(new Comparator<Integer>() {\r\n\t\t\t@Override\r\n\t\t\tpublic int compare(Integer o1, Integer o2) {\r\n\t\t\t\treturn o2.compareTo(o1);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t});\r\n\t\t\r\n\t\tint T = Integer.parseInt(br.readLine());\r\n\t\t\r\n\t\tint index=0;\r\n\t\t\r\n\t\tfor(int i = 0; i<T; i++) {\r\n\t\t\tint num = Integer.parseInt(br.readLine());\r\n\t\t\tif(max.size() == min.size()) {\r\n\t\t\t\tmax.offer(num);\r\n\t\t\t\tif(!min.isEmpty() && max.peek() > min.peek()) {\r\n\t\t\t\t\tmin.offer(max.poll());\r\n\t\t\t\t\tmax.offer(min.poll());\r\n\t\t\t\t}\r\n\t\t\t}else {\r\n\t\t\t\tmin.offer(num);\r\n\t\t\t\tif(max.peek() > min.peek()) {\r\n\t\t\t\t\tmin.offer(max.poll());\r\n\t\t\t\t\tmax.offer(min.poll());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tsb.append(max.peek()+\"\\n\");\r\n\t\t}\r\n\t\tSystem.out.println(sb);\r\n\t}\r\n}\r\n\r\n```\r\n\r\n우선순위 큐는 이렇게 마무리!!\r\n\r\n# Update) 2021-01-14\r\n백준 2981번이 비슷한 유형이라 풀고 추가로 update 한다.\r\n# 백준 2981\r\n![문제사진3](problem3.PNG)\r\n![문제사진4](problem4.PNG)\r\n\r\n\r\n```java\r\npackage priorityQueue;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.Comparator;\r\nimport java.util.PriorityQueue;\r\nimport java.util.Queue;\r\n\r\npublic class num2696 {\r\n\r\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\tQueue<Integer> minHeap = new PriorityQueue<>();\r\n\t\tQueue<Integer> maxHeap = new PriorityQueue<>(new Comparator<Integer>() {\r\n\t\t\t@Override\r\n\t\t\tpublic int compare(Integer o1, Integer o2) {\r\n\t\t\t\treturn o2.compareTo(o1);\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\tint T = Integer.parseInt(br.readLine());\r\n\t\t\r\n\t\tfor(int i=0; i<T; i++) {\r\n\t\t\tint count = Integer.parseInt(br.readLine());\r\n\t\t\tString[] inputData = br.readLine().split(\" \");\r\n\t\t\tsb.append(count/2+count%2 + \"\\n\");\r\n\t\t\tint index = 0;\r\n\t\t\tint jindex = 0;\r\n\t\t\tfor(int j=0; j<count; j++) {\r\n\t\t\t\tif(j%10==0 && j>9) {\r\n\t\t\t\t\tinputData = br.readLine().split(\" \");\r\n\t\t\t\t\tif(j%20==0) {\r\n\t\t\t\t\t\tsb.append(\"\\n\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tjindex=0;\r\n\t\t\t\t}\r\n\t\t\t\tint num = Integer.parseInt(inputData[jindex]);\r\n\t\t\t\tif(jindex==0 && j==0) {\r\n\t\t\t\t\tjindex++;\r\n\t\t\t\t\tindex = num;\r\n\t\t\t\t\tsb.append(num + \" \");\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif(num <= index) {\r\n\t\t\t\t\tmaxHeap.offer(num);\r\n\t\t\t\t\tif(maxHeap.size() - minHeap.size()>=1) {\r\n\t\t\t\t\t\tminHeap.offer(index);\r\n\t\t\t\t\t\tindex = maxHeap.poll();\r\n\t\t\t\t\t}\r\n\t\t\t\t}else {\r\n\t\t\t\t\tminHeap.offer(num);\r\n\t\t\t\t\tif(minHeap.size() - maxHeap.size()>=2) {\r\n\t\t\t\t\t\tmaxHeap.offer(index);\r\n\t\t\t\t\t\tindex = minHeap.poll();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(jindex%2==0) {\r\n\t\t\t\t\tsb.append(index + \" \");\r\n\t\t\t\t}\r\n\t\t\t\tjindex++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tsb.append(\"\\n\");\r\n\t\t\tminHeap.clear();\r\n\t\t\tmaxHeap.clear();\r\n\t\t}\r\n\t\tSystem.out.println(sb);\r\n\t}\r\n\r\n}\r\n\r\n```\r\n\r\n이 문제는 한 줄에 10개씩 들어온다는게 포인트다. 10개씩 장난쳐줘야 한다.\r\n\r\n정말 끝","excerpt":"백준 단계별 문제 - 우선순위 큐 마지막 문제다.   풀다가 조금 헷갈린 부분이 있어 정리하고자 포스팅한다.   문제 \n 일단 문제에 처음 접근할 땐, 우선순위 큐를 사용해 저장하고 중간 값을 계속 뽑아와 StringBuilder에 넣어주는 방식으로…","fields":{"slug":"/backjoon1655/"},"frontmatter":{"date":"Jan 13, 2021","title":"백준 1655 - 가운데를 말해요 풀이","tags":["Algorithm","BackJoon"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n문제를 풀다 조금 재밌는 부분이 생겨 정리한다.\r\n\r\n![문제사진](problem1.PNG)\r\n![문제사진2](problem2.PNG)\r\n\r\n백준 문제를 풀 때 한가지 팁은 문제가 낮은 정답비율이면  \r\n입출력이나 시간복잡도를 확인하는게 좋은거같다.  \r\n -> ㄹㅇ 꿀팁이다.  \r\n\r\n일단 뭔가 최대공약수로 장난치는 문제인 느낌을 받아서 규칙을 찾아보았다.\r\n\r\n```\r\narr[1] % M + r = arr[2] % M + r = arr[3] % M + r\r\n -> 요런 식이 나온다. 조금 장난쳐보면\r\n\r\narr[3] % M + r - arr[2] % M - r = arr[2] % M + r - arr[1] % M - r\r\n\r\n(arr[3] - arr[2]) % M = (arr[2] - arr[1]) % M\r\n\r\n(arr[n] - arr[n-1]) % M\r\n```\r\n\r\nㅋ 찾았다.\r\n\r\n```java\r\npackage package16;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class num2981 {\r\n\r\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tint N = Integer.parseInt(br.readLine());\r\n\t\tint[] arr = new int[N];\r\n\t\tint arrGcdValue = 0;\r\n\t\t\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tarr[i] = Integer.parseInt(br.readLine());\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=1; i<N; i++) {\r\n\t\t\tarrGcdValue = gcd(arrGcdValue, Math.abs(arr[i] - arr[i-1]));\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=2; i<=arrGcdValue; i++) {\r\n\t\t\tif(arrGcdValue % i == 0)\r\n\t\t\t\tSystem.out.print(i + \" \");\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static int gcd(int a, int b) {\r\n\t\treturn a % b == 0 ? b : gcd(b, a % b);\r\n\t}\r\n\r\n}\r\n```\r\n아 조금 주의할 점, arr[n] - arr[n-1]값이 음수일 수 있어서 절대값으로 받아야 한다.\r\n\r\n오늘은 뭔가 낚이지 않은 기분이다. 👌하핳","excerpt":"문제를 풀다 조금 재밌는 부분이 생겨 정리한다. \n 백준 문제를 풀 때 한가지 팁은 문제가 낮은 정답비율이면 입출력이나 시간복잡도를 확인하는게 좋은거같다.  -> ㄹㅇ 꿀팁이다.   일단 뭔가 최대공약수로 장난치는 문제인 느낌을 받아서 규칙을 찾아보…","fields":{"slug":"/backjoon2981/"},"frontmatter":{"date":"Jan 09, 2021","title":"백준 2981 - 검문 풀이","tags":["Algorithm","BackJoon"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n풀이를 보고 바로 이해하지 못하고 헷갈린 부분이 있어서 정리한다.\r\n\r\n![문제사진](problem.PNG)\r\n\r\n# LCS란?\r\n공통적으로 가지고 있는 부분 문자열 중, 가장 긴 문자열(최장 공통 부분 수열)\r\n\r\n## 규칙찾기\r\n\r\n점화식을 찾아내기 전에 문제에 나온 예제 입력값을 통해 규칙을 찾아보면\r\n\r\n```\r\nindex   C A P C A K\r\nA       0 1 1 1 1 1\r\nC       1 1 1 2 2 2\r\nA       1 2 2 2 3 3\r\nY       1 2 2 2 3 3\r\nK       1 2 2 2 3 4\r\nP       1 2 3 3 3 4\r\n```\r\n\r\n## 접근\r\n\r\n문제의 경우는 2가지로 나눌 수 있다.\r\n\r\n 1) 두 문자열에 같은 문자가 추가되는 경우\r\n    - ex) ACAYKP**A** , CAPCAK**A**\r\n 2) 두 문자열에 다른 문자가 추가되는 경우\r\n    - ex) ACAYKP**B** , CAPCAK**C**\r\n\r\n## 점화식\r\n두 가지 경우를 각각 점화식으로 나타내 보면\r\n```\r\n 1) dp[i][j] = dp[i-1][j-1] + 1\r\n 2) dp[i][j] = Max(arr[i][j-1], arr[i-1][j])\r\n```\r\n\r\n점화식을 찾아냈으면 코드작성은 쉽다.\r\n\r\n## 코드\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class num9251 {\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tString[] str1 = br.readLine().split(\"\");\r\n\t\tString[] str2 = br.readLine().split(\"\");\r\n\t\t\r\n\t\tint N = str1.length;\r\n\t\tint M = str2.length;\r\n\t\tint[][] arr = new int[N+1][M+1];\r\n\t\t\r\n\t\tfor(int i=1;i<=N;i++) {\r\n\t\t\tfor(int j=1;j<=M;j++) {\r\n\t\t\t\tif(str1[i-1].equals(str2[j-1])) {\r\n\t\t\t\t\tarr[i][j] = arr[i-1][j-1] +1;\r\n\t\t\t\t}else {\r\n\t\t\t\t\tarr[i][j] = Math.max(arr[i][j-1],arr[i-1][j]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tSystem.out.println(arr[N][M]);\r\n\t}\r\n}\r\n```","excerpt":"풀이를 보고 바로 이해하지 못하고 헷갈린 부분이 있어서 정리한다.  LCS란? 공통적으로 가지고 있는 부분 문자열 중, 가장 긴 문자열(최장 공통 부분 수열) 규칙찾기 점화식을 찾아내기 전에 문제에 나온 예제 입력값을 통해 규칙을 찾아보면 접근 문제…","fields":{"slug":"/backjoon9251/"},"frontmatter":{"date":"Dec 28, 2020","title":"백준 9251 - LCS 풀이","tags":["Algorithm","BackJoon"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n기술 면접을 준비하면서 면접에 자주 나오는 문항들을 정리해보려고 한다.\r\n\r\n본 포스트는 취업 준비를 하면서 부족한 부분을 지속해서 업데이트할 예정이다.\r\n\r\n# 시작하기전에\r\n - 1) 수행한 프로젝트, 준비한 사항은 **분명하고 간결하게** 설명 가능해야 한다.\r\n - 2) 쫄지말자, 당당하게\r\n - 3) 답변을 추상적이게 하지 말고, **구체적으로 아는 쪽으로 답변**\r\n\r\n\r\n# 목차\r\n\r\n# Part1. CS\r\n\r\n\r\n### 1. 객체 지향 프로그래밍\r\n\r\n```\r\n1. 정의\r\n  프로그램을 수많은 '객체'라는 기본 단위로 나누고 이 객체들의 상호작용으로 서술\r\n  - 객체란, 하나의 역할을 수행하는 '메소드와 변수(데이터)'\r\n\r\n2. 특징\r\n - 인간 중심적 프로그래밍 패러다임\r\n - 프로그램 설계 방법론이자 개념의 일종\r\n - 현실 세계 사물 -> 객체\r\n - 어플리케이션 특징(객체의 상호작용) -> 프로그래밍(=추상화)\r\n\r\n3. 장점\r\n - 코드 재사용 용이\r\n - 유지 보수 쉬움\r\n - 강한 응집력과 약한 결합력을 가진다\r\n - (응집력 : 기능을 수행하기 위해 얼마만큼의 연관된 책임과 아이디어가 뭉친 정도)\r\n - (결합력 : 프로그램의 요소가 다른 것과 얼마나 연결되어 있는지, 의존적인지)\r\n\r\n4. 단점\r\n - 설계시 많은 시간 필요\r\n - 객체들간의 통신시 오버헤드 발생해서 처리속도가 상대적으로 느림\r\n```\r\n\r\n **1. 객체 지향 프로그래밍이 뭔가요?**  \r\n    - 프로그램 설계 방법론입니다. 현실 세계의 사물을 추상화하여 객체를 만들고, 객체간의 상호작용을 통해 시스템을 구성하는 프로그래밍 방법입니다.  \r\n    특징으로는 추상화, 캡슐화, 상속, 다형성이 있습니다\r\n    장점으로는 코드 재사용이 용이, 유지보수가 쉬움, 강한 응집력과 약한 결합력을 가지는 것이 있고,  \r\n    단점으로는 설계시 많은 시간이 필요하고, 객체들간의 통신시 오버헤드가 발생해 처리속도가 상대적으로 느립니다.\r\n\r\n**1-1. 객체지향에서 말하는 추상화가 뭔가요?**  \r\n    - 객체에서 공통된 속성과 행위를 뽑아내는 것을 말합니다.  \r\n\r\n\r\n**1-2. 객체지향에서 말하는 캡슐화가 뭔가요?**  \r\n    - 변수와 함수를 하나의 단위로 묶는 것을 의미합니다. 추가로 자바에서는 접근 제어자를 통해 정보 은닉 기능을 제공합니다. 정보 은닉은, 프로그램의 세부 구현을 외부로 드러내지 않도록 감추는 것을 말합니다.  \r\n\r\n\r\n**1-3. 객체지향에서 말하는 상속이 뭔가요?**  \r\n    - 기존 클래스를 활용하여 새로운 클래스를 작성하는 것을 말합니다. 상속의 장점은 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램 생산성과 유지보수에 기여합니다.    \r\n\r\n\r\n**1-4. 객체지향에서 말하는 다형성이 뭔가요?**  \r\n    - 다향한 형태로 나타날 수 있는 특성을 말합니다.  \r\n\r\n**1-5. 객체지향에서 말하는 응집력과 결합력이 뭔가요?**  \r\n    - 응집력은 기능을 수행하기 위해 얼마만큼의 책임과 아이디어가 뭉쳐있는지 나타내는 정도입니다.  \r\n    - 결합력은 다른 요소와 얼마나 의존적인지 나타내는 정도입니다.\r\n\r\n**2. 객체와 인스턴스가 뭔가요?**  \r\n    - 인스턴스는 객체를 실체화한 것입니다. 즉, 프로그램 코드 상에서 자료형이 임의의 클래스로 선언된 클래스를 객체라 하고, 코드 컴파일 후 프로그램이 실행될 때 해당 객체가 메모리에 적재되면 인스턴스라 합니다. \r\n\r\n**3. 객체 지향 프로그래밍과 절차지향 프로그래밍을 설명해주세요**\r\n    - 절차지향 프로그래밍이란 '프로그램이 무슨일을 하는가'의 관점으로 바라본 프로그래밍 기법이고,\r\n    - 객체지향 프로그래밍은 '어떤 대상을 모델링하는가'의 관점으로 바라본 프로그래밍 기법입니다.\r\n    - 즉, 절차지향 프로그래밍은 프로그램의 순서와 흐름을 먼저 세우고 필요한 자료구조와 함수들을 설계하는 방식이고, 객체지향 프로그래밍은 반대로 자료구조와 이를 중심으로 한 모듈들을 먼저 설계한 다음에 이들의 실행순서와 흐름을 짜는 방식이다.\r\n\r\n### 2. RESTful API\r\n\r\n```\r\n1. 정의\r\n - 소프트웨어 아키텍처의 한 형식으로 자원을 정의하고 자원에 대한 주소를 지정하는 방법  \r\n\r\n2. 특징\r\n - 지정한 주소를 HTTP Method를 통해 자원을 처리한다.\r\n - REST의 6가지 기본 원칙을 성실히 지킨 서비스 디자인을 RESTful하다라고 표현\r\n\r\n3. 장점\r\n - 기존 웹 인프라를 그대로 사용할 수 있다.\r\n - 쉽고, 빠르다\r\n - 세부적인 표현 문구를 JSON, XML등 다양한 언어를 이용하여 작성할 수 있다.\r\n\r\n4. 단점\r\n - 메소드 형태가 제한적이다.\r\n - 표준 규약이 없다.\r\n - HTTP 통신 모델에 대해서만 지원합니다.\r\n```\r\n\r\n**1. API란 무엇인가요?**  \r\n    - API란, 응용 프로그램에서 사용할 수 있도록 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻합니다.  \r\n\r\n**2. REST API란 무엇인가요?**  \r\n    - 자원이 있는 곳을 URI로 정의하고, 자원을 이용하는 방법을 HTTP Method를 통해 자원을 처리하는 것을 말합니다.  \r\n\r\n**3. RESTful 하게 API를 디자인 한다는 것은 무엇을 의미하는가?**  \r\n    - REST API의 6가지 기본 원칙을 성실히 지킨 서비스를 RESTful하다라고 표현합니다.  \r\n\r\n### 3. TDD\r\n\r\n```\r\n1. 정의\r\n - 테스트 주도 개발\r\n - (개발 테스트 단위가 함수단위로 매우 작아서 작성하는 거의 모든 함수가 테스트에 포함된다.)\r\n\r\n2. 관련 용어\r\n 1) BDD : 시나리오 기반으로 테스트 케이스 작성\r\n  - Given -> When -> Then\r\n  - 어떤 상태 (Given) -> 어떤 상태 변화를 가했을 때(When) -> 기대하는 상태로 완료(Then)\r\n\r\n3. 장점\r\n - 피드백이 많아진다.\r\n - (테스트를 통과하는 것으로 개발이 잘 진행되는지 자주 확인가능해진다.)\r\n - 코드 복잡도가 낮아진다.\r\n\r\n4. 단점\r\n - 개발시간이 길어진다.\r\n```\r\n\r\n**1. TDD에 대해 설명해주세요**\r\n\r\n**2. BDD에 대해 아시나요?**\r\n\r\n**3. 좋은 코드에 대해 어떻게 생각하시나요? (내생각)**  \r\n    - 저는 좋은 코드를 판단하는 기준으로 **가독성, 효율성**이 가장 중요하다고 생각합니다.  \r\n   Coding Convention을 잘 지키고 일관성있게 작성되며, 문제상황에서 필요한 요구사항을 적절히 충족하고 효율적으로 해결하는 코드가 좋은 코드라고 생각합니다.\r\n\r\n\r\n\r\n### 4. GIT\r\n\r\n```\r\n1. 정의\r\n - 버전 관리 시스템\r\n\r\n2. 장점\r\n - 여러명이 동시에 작업하는 병렬 개발이 가능하다.\r\n - 분산 버전관리이기 때문에 인터넷이 연결되지 않은 곳에서도 개발을 진행할 수 있다.\r\n - 체계적인 개발이 가능해진다.\r\n```\r\n\r\n**1. Git의 장점에 대해 설명해주세요**\r\n    - 여러명이 동시 작업하는 병렬 개발이 가능하고, 분산 버전관리기 때문에 인터넷이 연결되지 않은 곳에서도 개발을 진행할 수 있는 것이 장점입니다.\r\n\r\n## Part 1-2 자료구조\r\n\r\n### 1. Array / LinkedList\r\n\r\n### 2. Stack / Queue\r\n\r\n**1. Stack에 대해 설명해주세요**  \r\n    - 선형 자료구조의 일종으로 Firt In Last Out (FILO)구조를 가집니다.\r\n\r\n\r\n**2. Queue에 대해 설명해주세요**  \r\n    - 선형 자료구조의 일종으로 First In First Out (FIFO)구조를 가집니다.\r\n\r\n\r\n### 3. Tree\r\n```\r\n 1. Binary Tree(이진트리)\r\n\r\n 2. BST(Binary Search Tree)\r\n\r\n 3. Binary Heap\r\n\r\n 4. Red Black Tree\r\n\r\n 5. Graph\r\n\r\n```\r\n**1. Tree에 대해 설명해주세요**  \r\n    - 비선형 자료구조이다. 트리는 계층적 관계(Hierarchical Relationship)을 표현하는 자료구조이다. \r\n\r\n**2. 이진트리(Binary Tree)에 대해 설명해주세요.**\r\n\r\n## Part 1-3 알고리즘\r\n\r\n## Part 1-4 네트워크\r\n\r\n### 1. HTTP Method\r\n\r\n\r\n### 2. TCP/UDP\r\n\r\n\r\n\r\n### 3. HTTP/HTTPS\r\n\r\n\r\n### 4. 웹 통신의 흐름\r\n\r\n\r\n## Part 1-5 운영체제\r\n\r\n### 1. 프로세스/스레드\r\n\r\n\r\n\r\n\r\n### 2. 멀티스레드/멀티 프로세스\r\n\r\n\r\n### 3. 동기/비동기\r\n\r\n\r\n**1.재귀 호출의 단점은?**  \r\n    - 재귀 호출 시, 함수를 반복해서 호출해야 하는데, 매번 호출할 때마다 시간과 스택 공간에서 오버헤드 발생.\r\n\r\n\r\n## Part 1-6 데이터 베이스\r\n\r\n### 1. 데이터 베이스 사용하는 이유\r\n\r\n\r\n### 2. 정규화\r\n\r\n\r\n### 3. 트랜잭션\r\n\r\n### 4. NoSQL\r\n\r\n\r\n## Part 1-7 디자인 패턴\r\n\r\n### 디자인 패턴이란?\r\n> 프로그램 개발 시에 자주 생기는 에로 상황에 대한 일반적이고 재사용 가능한 추상화된 해결책이다.\r\n\r\n\r\n### 1. MVC 패턴이란?\r\n\r\n```\r\n1. 정의 - Model-View-Controller의 약자로, 개발할 때 3가지 형태로 나눠 개발하는 방법론\r\n\r\n2. 특징\r\n - Model : 어플리케이션이 무엇을 할 지 정의\r\n - View : 어플리케이션 화면에 무엇을 보여줄지\r\n - Controller : 어플리케이션이 어떻게 처리할지\r\n   -> Model, View가 무엇을 해야 할 지를 알고 통제\r\n\r\n3. 관련 용어\r\n - Service\r\n\r\n4. 장점\r\n -\r\n\r\n5. 단점\r\n```\r\n\r\n## Part 1-8 보안\r\n\r\n# Part2. Language\r\n\r\n## 1. JAVA\r\n\r\n1. JVM이란?\r\n   - 자바가상머신의 약자를 줄여서 부르는 용어입니다. **프로그램을 실행하기 위해 물리적 머신과 유사한 머신을 소프트웨어로 구현**한 것을 말합니다.\r\n\r\n2. GC이란?\r\n   - \r\n\r\n## 2. JavaScript\r\n > 프로그래밍 언어로 브라우저가 가진 기능을 코드로 제어\r\n > (이벤트를 제어하기 위함)\r\n\r\n### 2.1 NodeJS\r\n > 자바스크립트의 언어와 환경이 분리 필요\r\n -> 웹서버를 동작하기 위한 도구로 구글의 V8 Engine기반 **NodeJS** 탄생!!\r\n\r\n## 3. C\r\n\r\n1. C에서는 메모리를 어떻게 할당하는가?\r\n    - d\r\n\r\n# Part3. FrontEnd\r\n**프레임 워크와 플랫폼의 차이가 뭔가요?**\r\n\r\n**Cookie, Session Storage, LocalStorage의 차이점을 말해주세요**\r\n\r\n\r\n**UI(User Interface)란?**\r\n   - 사용자와 시스템의 접점\r\n\r\n\r\n## 1. Vitual DOM\r\n\r\n## 2. React.js\r\n\r\n\r\n## 3. Vue.js\r\n\r\n\r\n# Part4. BackEnd\r\n\r\n## 1. Spring\r\n\r\n## 2. Express\r\n\r\n# Part5. Project\r\n\r\n\r\n## IoT\r\n\r\n### 1. MQTT\r\n\r\n","excerpt":"기술 면접을 준비하면서 면접에 자주 나오는 문항들을 정리해보려고 한다. 본 포스트는 취업 준비를 하면서 부족한 부분을 지속해서 업데이트할 예정이다. 시작하기전에 수행한 프로젝트, 준비한 사항은 분명하고 간결하게 설명 가능해야 한다. 쫄지말자, 당당하…","fields":{"slug":"/techInterview/"},"frontmatter":{"date":"Dec 28, 2020","title":"개발 기술 면접 준비","tags":["면접"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\nAWS EC2를 사용해서 구현해야 할 일이 생겨서 간만에 사용하다 잘 안되서 기록해둔다.\r\n\r\n1. AWS EC2 인스턴스 생성\r\n\r\n2. vscode extensions에서 ftp-simple을 설치해준다.\r\n\r\n3. F1을 눌러 ftp-simple : Config - FTP connection setting 실행.  \r\n 다음 사진과 같이 설정해준다.\r\n\r\n![설정 json](./201205_jsoncapture.PNG \"json파일\")\r\n\r\n1. F1 눌러 Remote directory open to workspace 실행하면 된다.\r\n","excerpt":"AWS EC2를 사용해서 구현해야 할 일이 생겨서 간만에 사용하다 잘 안되서 기록해둔다. AWS EC2 인스턴스 생성 vscode extensions에서 ftp-simple을 설치해준다. F1을 눌러 ftp-simple : Config - FTP c…","fields":{"slug":"/vscode_connect_aws/"},"frontmatter":{"date":"Dec 05, 2020","title":"AWS EC2 Visual Studio Code로 사용하기","tags":["AWS"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n백준 DP 단계별 문제에 있는 10844번 문제이다. \r\n\r\n접근이 조금 어려웠던 문제라 풀이를 정리해보려고 한다.  \r\n\r\n## 접근\r\n\r\n일단 이 문제는 DP문제로 2차원 배열을 DP로 사용해야 한다.\r\n\r\n규칙을 찾기 위해 값을 적어보고, 개수를 세보면 아래와 같다.  \r\n(N : 자리수, index : 맨 마지막에오는 숫자)  \r\n```\r\nindex   0 1 2 3 4 5 6 7 8 9\r\nN=1     0 1 1 1 1 1 1 1 1 1  \r\nN=2     1 1 2 2 2 2 2 2 2 1\r\nN=3     1 3 3 4 4 4 4 4 3 2\r\n\r\nex)\r\nN=2 -> (10), (21), (32, 12), (43,23), (54,34), (65,45), (76,56), (87,67), (98,78), (89)\r\n```\r\ndp[N][index] = dp[N-1][index-1] + dp[N-1][index+1]인 점화식을 얻을 수 있다.\r\n\r\n단, 여기서 중요한 점은 index가 0일 경우는 +1 한 값이 허용되고  \r\n9일 경우는 -1 한 경우만 적용되기 때문에 예외 처리를 해줘야 한다.  \r\n\r\n마지막으로 점화식을 정리해보면\r\n```\r\n1) index가 1일 경우\r\ndp[N][index] = dp[N-1][index+1]\r\n\r\n2) index가 1~8일 경우\r\ndp[N][index] = dp[N-1][index-1] + dp[N-1][index+1]\r\n\r\n3) index가 9일 경우\r\ndp[N][index] = dp[N-1][index-1]\r\n\r\n```\r\n\r\n3가지 경우에 따라 분기처리를 하면 된다.\r\n\r\n# Top-down 방식\r\n\r\n## 구현코드\r\n\r\n```java\r\npackage package14;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class num10844 {\r\n\tstatic Long[][] dp;\r\n\tstatic int N;\r\n\tfinal static long MOD = 1000000000;\r\n\t\r\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tN = Integer.parseInt(br.readLine());\r\n\t\tdp = new Long[N+1][10];\r\n\t\t// #1\r\n\t\tfor(int i = 0; i < 10; i++) {\r\n\t\t\tdp[1][i] = 1L;\r\n\t\t}\r\n\r\n\t\tlong result = 0;\r\n\t\t\r\n\t\tfor(int i = 1; i <= 9; i++) {\r\n\t\t\tresult += recur(N, i);\r\n\t\t}\r\n\t\tSystem.out.println(result % MOD);\r\n\t}\r\n\t\r\n\tstatic long recur(int digit, int val) {\t\t\r\n\t\t\r\n\t\tif(digit == 1) {\r\n\t\t\treturn dp[digit][val];\r\n\t\t}\r\n\t\t// #2\r\n\t\tif(dp[digit][val] == null) {\r\n\t\t\tif(val == 0) {\r\n\t\t\t\tdp[digit][val] = recur(digit - 1 ,1);\r\n\t\t\t}\r\n\t\t\telse if(val== 9) {\r\n\t\t\t\tdp[digit][val] = recur(digit - 1, 8);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tdp[digit][val] = recur(digit - 1, val - 1) + recur(digit - 1, val + 1);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn dp[digit][val] % MOD;\r\n\t}\r\n}\r\n\r\n\r\n```\r\n\r\n## 코드설명\r\n 1) N=1인 값들은 값을 초기값으로 값을 넣어준다.\r\n 2) 점화식과 동일하게 상황에 따라 맞는 값을 재귀로 호출한다.\r\n\r\n# Botton-up 방식\r\n\r\n## 구현 코드\r\n\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.InputStreamReader;\r\nimport java.io.IOException;\r\n \r\npublic class Main {\r\n\t\r\n\tfinal static long mod = 1000000000;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\t\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tint N = Integer.parseInt(br.readLine());\r\n\t\t\r\n\t\tlong[][] dp = new long[N + 1][10];\r\n\t\t\r\n\t\tfor(int i = 1; i < 10; i++) {\r\n\t\t\tdp[1][i] = 1; \r\n\t\t}\r\n\t\t\r\n\t\t// 두 번째 자릿수부터 N까지 탐색 \r\n\t\tfor(int i = 2; i <= N; i++) {\r\n\t\t\t\r\n\t\t\tfor(int j = 0; j < 10; j++) {\r\n\t\t\t\t\r\n\t\t\t\tif(j == 0) {\r\n\t\t\t\t\tdp[i][0] = dp[i - 1][1] % mod;\r\n\t\t\t\t}\r\n\t\t\t\telse if (j == 9) {\r\n\t\t\t\t\tdp[i][9] = dp[i - 1][8] % mod;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tdp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j + 1]) % mod;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tlong result = 0;\r\n\t\t\r\n\t\tfor(int i = 0; i < 10; i++) {\r\n\t\t\tresult += dp[N][i];\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(result % mod);\r\n\t}\r\n \r\n}\r\n```\r\n\r\n## 코드설명\r\n - Top-down방식과 동일한데 재귀 부분을 for문으로 두번째 자리부터 N까지 탐색한다.\r\n\r\n\r\n# \r\n<hr>\r\n\r\n아직 DP문제를 많이 풀어보지 않아서 그런지 점화식 만들어 내는 과정이 어렵다... ㅜㅜㅜㅜㅜ  \r\n익숙해질 때까지 열심히 풀어야겠다 (승질 그만내고 ㅎㅎ)","excerpt":"백준 DP 단계별 문제에 있는 10844번 문제이다.  접근이 조금 어려웠던 문제라 풀이를 정리해보려고 한다.   접근 일단 이 문제는 DP문제로 2차원 배열을 DP로 사용해야 한다. 규칙을 찾기 위해 값을 적어보고, 개수를 세보면 아래와 같다. (…","fields":{"slug":"/backjoon10844/"},"frontmatter":{"date":"Dec 03, 2020","title":"백준 10844번 - 쉬운 계단수 풀이","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"알고리즘 문제를 풀면서 많이 하는 실수를 정리할 필요성을 느꼈다.  \r\n본 포스트는 주의해야 할 실수가 생길 때 마다 update할 예정이다.\r\n\r\n# 백트래킹\r\n > 재귀함수 빠져나오면 상태 값 원래대로 돌려줘야 함.\r\n\r\n# 최단거리\r\n > 값 넣어줄 때, 입력값 -1 해서 받아야 함 (배열 index로 사용하기 때문)","excerpt":"알고리즘 문제를 풀면서 많이 하는 실수를 정리할 필요성을 느꼈다. 본 포스트는 주의해야 할 실수가 생길 때 마다 update할 예정이다. 백트래킹 재귀함수 빠져나오면 상태 값 원래대로 돌려줘야 함. 최단거리 값 넣어줄 때, 입력값 -1 해서 받아야 …","fields":{"slug":"/algoMistake/"},"frontmatter":{"date":"Nov 25, 2020","title":"알고리즘 풀 때 많이하는 실수","tags":["Algorithm"],"update":"Jan 25, 2021"}}},{"node":{"rawMarkdownBody":"\r\n# Comparable\r\n > 클래스의 기본 정렬 기준을 설정하는 인터페이스\r\n\r\n\r\n## 1) 특징\r\n - Comparable 인터페이스 상속 후, compareTo 메소드 오버라이딩\r\n - compareTo메소드 리턴 값은 음수, 0, 양수가 될 수 있다. **음수가 리턴되면 인자의 순서가 아래로 이동**\r\n - 자바에서 제공되는 정렬이 가능한 클래스는 모두 Comparable 클래스로 구현되어 있음\r\n \r\n## 2) 구현 코드\r\n\r\n# Comparator\r\n > 기본 정렬과 다르게 정렬하고 싶을 때 이용하는 클래스\r\n## 1) 특징\r\n - 보통 구현 되어있는 sort함수의 2번째 인자로 Comparator 타입을 받아(익명함수) compare 메소드 오버라이딩을 통해 배열 정렬 순서 재정의\r\n - 보통 한번 사용하고 사용하지 않기 때문에 익명객체로 만듬\r\n\r\n## 2) 구현 코드\r\n\r\n# 관련 백준 문제\r\n - 11650, 11651, 1181, 10814","excerpt":"Comparable 클래스의 기본 정렬 기준을 설정하는 인터페이스 1) 특징 Comparable 인터페이스 상속 후, compareTo 메소드 오버라이딩 compareTo메소드 리턴 값은 음수, 0, 양수가 될 수 있다. 음수가 리턴되면 인자의 순서…","fields":{"slug":"/javaComparableComparator/"},"frontmatter":{"date":"Nov 24, 2020","title":"JAVA Comparable, Comparator 사용","tags":["JAVA"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n이전부터 자주 헷갈렸던 순열, 조합, 부분집합의 개념 정리와 JAVA를 사용해 구현하는 방법을 정리해 보려고 한다.  \n\n1) 대표적인 구현 방법  \n2) 각, 방법의 특징    \n\n두가지 사항으로 정리한다.  \n\n# 순열\n\n  - n개의 원소 중, r개를 일렬로 나열하는 수열  \n  - 중복 X / 순서 고려\n\n## 1. next_permutation\n\n### 1) 특징\n - 이게 이해하기 제일 어려웠다.... (나만 어렵나...ㅜㅜ)\n - 무작위 순열의 다음 순열을 구해내는 알고리즘\n - 시작 조건 : 오름차순 / 종료 조건 : 내림차순\n```\n  순서\n  1.Find largest index i such that array[i − 1] < array[i].\n  (If no such i exists, then this is already the last permutation.)\n\n  2.Find largest index j such that j ≥ i and array[j] > array[i − 1].\n\n  3.Swap array[j] and array[i − 1].\n\n  4.Reverse the suffix starting at array[i].\n```\n\n### 2) 구현 코드\n```java\npublic class num1 {\n    public static void main(String[] args) {\n    \tint[] list = new int[]{5,4,3};\n    \t// #1 시작 조건에 맞게 list 오름차순 정렬 (시작조건)\n    \tArrays.sort(list);\n    \tpermutation(list);\n    }\n    // #2 처음 list값 print 후, 다음 순열 찾음\n    public static void permutation(int[] list) {\n        int[] curArray = list;\n        while (true) {\n        \tprintArray(curArray);\n        \tcurArray = nextPermutation(curArray);\n            if (curArray == null) {\n                break;\n            }\n        }\n    }\n    \n    public static int[] nextPermutation(int[] list) {\n    \t  // #3 수열의 바로 앞 값 보다 큰 값 중 가장 큰 index 찾는다. \n        // (가장 적은 차이로 순서를 바꾸기 위해서 가장 큰 index를 찾음) \n        int i = list.length -1;\n        while(i>0 && list[i-1] >= list[i])\n        \ti--;\n        \n        // #6 list가 내림차순으로 정렬되어 있으면 순열을 끝까지 찾은 것 (종료조건)\n        if(i<=0)\n        \treturn null;\n        \n        int j = list.length -1;\n        // #4 다음 수열의 특징 : 이전 순열보다 값이 큼\n        // -> list[i-1] < list[j] 값을 찾고, 값을 바꿔준다.\n        while(list[j] <= list[i-1])\n        \tj--;\n        \n        int temp = list[i-1];\n        list[i - 1] = list[j];\n        list[j] = temp;\n        // #5 a[i] 이후 부분을 오름차순으로 셋팅 \n        j= list.length-1;\n        while (i < j) {\n            temp = list[i];\n            list[i] = list[j];\n            list[j] = temp;\n            i++;\n            j--;\n        }\n        \n        return list;\n    }\n    \n    public static void printArray(int[] array) {\n    \tfor(int i=0;i<array.length;i++)\n    \t\tSystem.out.print(array[i] + \" \");\n    \tSystem.out.println();\n    }\n    \n}\n\n```\n### 3) 코드 설명\n\n1. 시작 조건에 맞게 list 오름차순 정렬 (시작조건)\n2. 처음 list값 print 후, 다음 순열 찾음\n3. 수열의 바로 앞 값 보다 큰 값 중 가장 큰 index 찾는다.  \n  (가장 적은 차이로 순서를 바꾸기 위해서 가장 큰 index를 찾음)\n4. 다음 수열의 특징 : 이전 순열보다 값이 큼 -> list[i-1] < list[j] 값을 찾고, 값을 바꿔준다.\n5. a[i] 이후 부분을 오름차순으로 셋팅 \n6. list가 내림차순으로 정렬되어 있으면 순열을 끝까지 찾은 것 (종료조건)\n\n### 4) 코드 출력값\n```\n3 4 5 \n3 5 4 \n4 3 5 \n4 5 3 \n5 3 4 \n5 4 3 \n\n```\n\n## 2. Swap\n\n### 1) 특징\n - 순열의 순서가 보장되지 않는다. (사전식 X)\n\n\n### 2) 구현 코드\n```java\npublic class Main {\n  public static void main(String[] args) {\n  \tint[] arr = {1,2,3};\n  \tpermutation(arr,0,3,3);\n  \tSystem.out.println(Arrays.toString(arr));\n  }\n\n  static void permutation(int[] arr, int depth, int n, int r) {\n  \tif (depth == r) {\n  \t\tarrPrint(arr,r);\n  \t\treturn;\n  \t}\n  \tfor (int i=depth; i<n; i++) {\n      // #1\n  \t\tswap(arr, depth, i);\n      // #2\n  \t\tpermutation(arr, depth + 1, n, r);\n      // #3\n     \tswap(arr, depth, i);\n  \t}\n  }\n\n  static void arrPrint(int[] arr, int r) {\n    for (int i=0 ; i<r; i++)\n    \tSystem.out.print(arr[i] + \" \");\n    System.out.println();\n  }\n\n  static void swap(int[] arr, int depth, int i) {\n    int temp = arr[depth];\n    arr[depth] = arr[i];\n    arr[i] = temp;\n  }\n}\n```\n### 3) 코드 설명\n\n1. 배열의 첫번째 값부터 하나씩 바꾸면서 swap\n2. depth를 기준(Inex)으로 depth보다 작은 인데스 값들은 고정, depth보다 큰 값들을 가지고 swap\n3. 재귀함수가 종료조건에 의해 return되면 swap을 한번 더 해줘서 이전 상태 유지\n\n\n### 4) 코드 출력값\n```\n1 2 3 \n1 3 2 \n2 1 3 \n2 3 1 \n3 2 1 \n3 1 2 \n[1, 2, 3]\n```\n\n## 3. Visit Index 사용\n\n### 1) 특징\n - DFS, 재귀 함수\n\n\n### 2) 구현 코드\n\n```java\npublic class Main {\n\tpublic static void main(String[] args) {\n\t    int n = 3;\n\t    int[] arr = {1, 2, 3};\n      // #1\n\t    int[] output = new int[n];\n\t    boolean[] visited = new boolean[n];\n\t    perm(arr, output, visited, 0, n, 2);\n\t    System.out.println();\n\t}\n\n\tstatic void perm(int[] arr, int[] output, boolean[] visited, int depth, int n, int r) {\n\t    if (depth == r) {\n\t        print(output, r);\n\t        return;\n\t    }\n\n\t    for (int i = 0; i < n; i++) {\n\t        if (visited[i] != true) {\n\t            visited[i] = true;\n              output[depth] = arr[i];\n              // #2\n\t            perm(arr, output, visited, depth + 1, n, r);\n              // #3\n\t            visited[i] = false;\n\t        }\n\t    }\n\t}\n\n\tstatic void print(int[] arr, int r) {\n\t    for (int i = 0; i < r; i++)\n\t        System.out.print(arr[i] + \" \");\n\t    System.out.println();\n\t}\n\t\n}\n\n```\n### 3) 코드 설명\n1. output : 코드 출력 값 / visited : 방문 여부 체크\n2. depth -> output 길이라고 생각\n3. 방문 여부 false로 체크 -> 모든 인덱스 방문\n   \n\n### 4) 코드 출력값 \n```\n1 2 \n1 3 \n2 1 \n2 3 \n3 1 \n3 2 \n```\n\n## 관련 백준 문제\n> n과m 시리즈 0 ~ 12\n\n# Reference\n[BaaaaaaaarkingDog님 블로그](https://blog.encrypted.gg/945?category=773649)  \n[뱀귤님 블로그](https://bcp0109.tistory.com/entry/%EC%88%9C%EC%97%B4-Permutation-Java?category=848939)  \n[junhok82님 블로그](https://velog.io/@junhok82/>Java%EB%A1%9C-%EC%88%9C%EC%97%B4Permutation-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0>)  \n[Crocus님 블로그](https://www.crocus.co.kr/1240)","excerpt":"이전부터 자주 헷갈렸던 순열, 조합, 부분집합의 개념 정리와 JAVA를 사용해 구현하는 방법을 정리해 보려고 한다.   대표적인 구현 방법   각, 방법의 특징     두가지 사항으로 정리한다.   순열 n개의 원소 중, r개를 일렬로 나열하는 수열…","fields":{"slug":"/permutation/"},"frontmatter":{"date":"Nov 23, 2020","title":"순열 정리, 구현","tags":["Algorithm"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}},"staticQueryHashes":["2027115977","694178885"]}