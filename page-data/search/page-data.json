{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\r\n기술 면접을 준비하면서 면접에 자주 나오는 문항들을 내 말로 정리할 필요성을 느꼈다.  \r\n본 포스트는 취업 준비를 하면서 부족한 부분을 지속해서 업데이트할 예정이다.\r\n\r\n# 시작하기전에\r\n - 1) 수행한 프로젝트, 준비한 사항은 **분명하고 간결하게** 설명 가능해야 한다.\r\n - 2) 쫄지말자, 당당하게\r\n - 3) 답변을 추상적이게 하지 말고, **구체적으로 아는 쪽으로 답변**\r\n\r\n\r\n# 목차\r\n\r\n# Part1. CS\r\n\r\n\r\n### 1. 객체 지향 프로그래밍\r\n\r\n```\r\n1. 정의\r\n  프로그램을 수많은 '객체'라는 기본 단위로 나누고 이 객체들의 상호작용으로 서술\r\n  - 객체란, 하나의 역할을 수행하는 '메소드와 변수(데이터)'\r\n\r\n2. 특징\r\n - 인간 중심적 프로그래밍 패러다임\r\n - 프로그램 설계 방법론이자 개념의 일종\r\n - 현실 세계 사물 -> 객체\r\n - 어플리케이션 특징(객체의 상호작용) -> 프로그래밍(=추상화)\r\n\r\n3. 장점\r\n - 코드 재사용 용이\r\n - 유지 보수 쉬움\r\n - 강한 응집력과 약한 결합력을 가진다\r\n - (응집력 : 기능을 수행하기 위해 얼마만큼의 연관된 책임과 아이디어가 뭉쳐있는지를 나타내는 정도)\r\n - (결합력 : 프로그램의 요소가 다른 것과 얼마나 연결되어 있는지, 의존적인지)\r\n\r\n4. 단점\r\n - 설계시 많은 시간 필요\r\n - 객체들간의 통신시 오버헤드 발생해서 처리속도가 상대적으로 느림\r\n```\r\n\r\n **1. 객체 지향 프로그래밍이 뭔가요?**  \r\n    - 프로그램 설계 방법론입니다. 현실 세계의 사물을 추상화하여 객체를 만들고, 객체간의 상호작용을 통해 시스템을 구성하는 프로그래밍 방법입니다.  \r\n    특징으로는 추상화, 캡슐화, 상속, 다형성이 있습니다\r\n    장점으로는 코드 재사용이 용이, 유지보수가 쉬움, 강한 응집력과 약한 결합력을 가지는 것이 있고,  \r\n    단점으로는 설계시 많은 시간이 필요하고, 객체들간의 통신시 오버헤드가 발생해 처리속도가 상대적으로 느립니다.\r\n\r\n**1-1. 객체지향에서 말하는 추상화가 뭔가요?**  \r\n    - 객체에서 공통된 속성과 행위를 뽑아내는 것을 말합니다.  \r\n\r\n\r\n**1-2. 객체지향에서 말하는 캡슐화가 뭔가요?**  \r\n    - 변수와 함수를 하나의 단위로 묶는 것을 의미합니다. 추가로 자바에서는 접근 제어자를 통해 정보 은닉 기능을 제공합니다. 정보 은닉은, 프로그램의 세부 구현을 외부로 드러내지 않도록 감추는 것을 말합니다.  \r\n\r\n\r\n**1-3. 객체지향에서 말하는 상속이 뭔가요?**  \r\n    - 기존 클래스를 활용하여 새로운 클래스를 작성하는 것을 말합니다. 상속의 장점은 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램 생산성과 유지보수에 기여합니다.    \r\n\r\n\r\n**1-4. 객체지향에서 말하는 다형성이 뭔가요?**  \r\n    - 다향한 형태로 나타날 수 있는 특성을 말합니다.  \r\n\r\n**1-5. 객체지향에서 말하는 응집력과 결합력이 뭔가요?**  \r\n    - 응집력은 기능을 수행하기 위해 얼마만큼의 책임과 아이디어가 뭉쳐있는지 나타내는 정도입니다.\r\n    - 결합력은 다른 요소와 얼마나 의존적인지 나타내는 정도입니다.\r\n\r\n **2. 객체와 인스턴스가 뭔가요?**  \r\n    - 인스턴스는 객체를 실체화한 것입니다. 즉, 프로그램 코드 상에서 자료형이 임의의 클래스로 선언된 클래스를 객체라 하고, 코드 컴파일 후, 프로그램이 실행될 때 해당 객체가 메모리에 적재되면 인스턴스라 합니다. \r\n\r\n### 2. RESTful API\r\n\r\n```\r\n1. 정의\r\n - 소프트웨어 아키텍처의 한 형식으로 자원을 정의하고 자원에 대한 주소를 지정하는 방법  \r\n\r\n2. 특징\r\n - 지정한 주소를 HTTP Method를 통해 자원을 처리한다.\r\n - REST의 6가지 기본 원칙을 성실히 지킨 서비스 디자인을 RESTful하다라고 표현\r\n\r\n3. 장점\r\n - 기존 웹 인프라를 그대로 사용할 수 있다.\r\n - 쉽고, 빠르다\r\n - 세부적인 표현 문구를 JSON, XML등 다양한 언어를 이용하여 작성할 수 있다.\r\n\r\n4. 단점\r\n - 메소드 형태가 제한적이다.\r\n - 표준 규약이 없다.\r\n - HTTP 통신 모델에 대해서만 지원합니다.\r\n```\r\n\r\n**1. API란 무엇인가요?**\r\n - API란, 응용 프로그램에서 사용할 수 있도록 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻합니다. \r\n\r\n**2. REST API란 무엇인가요?**\r\n - 자원이 있는 곳을 URI로 정의하고, 자원을 이용하는 방법을 HTTP Method를 통해 자원을 처리하는 것을 말합니다.\r\n\r\n**3. RESTful 하게 API를 디자인 한다는 것은 무엇을 의미하는가?**\r\n - REST API의 6가지 기본 원칙을 성실히 지킨 서비스를 RESTful하다라고 표현합니다.\r\n\r\n### 3. TDD\r\n\r\n```\r\n1. 정의\r\n - 테스트 주도 개발\r\n - (개발 테스트 단위가 함수단위로 매우 작아서 작성하는 거의 모든 함수가 테스트에 포함된다.)\r\n\r\n\r\n2. 관련 용어\r\n 1) BDD : 시나리오 기반으로 테스트 케이스 작성\r\n  - Given -> When -> Then\r\n  - 어떤 상태 (Given) -> 어떤 상태 변화를 가했을 때(When) -> 기대하는 상태로 완료되어야 한다.(Then)\r\n\r\n3. 장점\r\n - 피드백이 많아진다.\r\n - (테스트를 통과하는 것으로 개발이 잘 진행되는지 자주 확인가능해진다.)\r\n - 코드 복잡도가 낮아진다.\r\n\r\n4. 단점\r\n - 개발시간이 길어진다.\r\n```\r\n\r\n**1. TDD에 대해 설명해주세요**\r\n\r\n**2. BDD에 대해 아시나요?**\r\n\r\n**3. 좋은 코드에 대해 어떻게 생각하시나요? (내생각)**\r\n    - 저는 좋은 코드를 판단하는 기준으로 **가독성, 효율성**이 가장 중요하다고 생각합니다. \r\n    - 가독성 부분은 개발자마다 프로그래밍 수준이 다르므로 기준이 다를 수 있겠지만, Coding Convention을 잘 지키고 일관성있게 작성된 코드를 가독성이 좋다고 할 수 있는 것 같고, 문제상황에서 필요한 요구사항을 적절히 충족하며, 효율적으로 해결하는 코드가 좋은 코드라고 생각합니다.\r\n\r\n\r\n\r\n### 4. GIT\r\n\r\n```\r\n1. 정의\r\n - 버전 관리 시스템\r\n\r\n2. 장점\r\n - 여러명이 동시에 작업하는 병렬 개발이 가능하다.\r\n - 분산 버전관리이기 때문에 인터넷이 연결되지 않은 곳에서도 개발을 진행할 수 있다.\r\n - 체계적인 개발이 가능해진다.\r\n```\r\n\r\n**1. Git의 장점에 대해 설명해주세요**\r\n - 여러명이 동시 작업하는 병렬 개발이 가능하고, 분산 버전관리기 때문에 인터넷이 연결되지 않은 곳에서도 개발을 진행할 수 있는 것이 장점입니다.\r\n\r\n## Part 1-2 자료구조\r\n\r\n### 1. Array / LinkedList\r\n\r\n```\r\n1. 정의\r\n -\r\n\r\n2. 특징\r\n -\r\n\r\n3. 장점\r\n -\r\n\r\n4. 단점\r\n -\r\n```\r\n\r\n### 2. Stack / Queue\r\n\r\n** 1. Stack에 대해 설명해주세요 **\r\n    - 선형 자료구조의 일종으로 Last In First Out (LIFO)구조를 가집니다.\r\n\r\n\r\n** 2. Queue에 대해 설명해주세요 **\r\n    - 선형 자료구조의 일종으로 First In First Out (FIFO)구조를 가집니다.\r\n\r\n\r\n### 3. Tree\r\n```\r\n 1. Binary Tree(이진트리)\r\n\r\n 2. BST(Binary Search Tree)\r\n\r\n 3. Binary Heap\r\n\r\n 4. Red Black Tree\r\n\r\n 5. Graph\r\n\r\n```\r\n** 1. Tree에 대해 설명해주세요 **\r\n    - 비선형 자료구조이다. 트리는 계층적 관계(Hierarchical Relationship)을 표현하는 자료구조이다. \r\n\r\n** 2. 이진트리(Binary Tree)에 대해 설명해주세요.\r\n\r\n## Part 1-3 알고리즘\r\n\r\n## Part 1-4 네트워크\r\n\r\n### 1. HTTP Method\r\n\r\n\r\n### 2. TCP/UDP\r\n\r\n\r\n\r\n### 3. HTTP/HTTPS\r\n\r\n\r\n### 4. 웹 통신의 흐름\r\n\r\n\r\n## Part 1-5 운영체제\r\n\r\n### 1. 프로세스/스레드\r\n\r\n\r\n\r\n\r\n### 2. 멀티스레드/멀티 프로세스\r\n\r\n\r\n### 3. 동기/비동기\r\n\r\n\r\n재귀 호출의 단점은?\r\n-> 재귀 호출 시, 함수를 반복해서 호출해야 하는데, 매번 호출할 때마다 시간과 스택 공간에서 오버헤드 발생.\r\n\r\n\r\n## Part 1-6 데이터 베이스\r\n\r\n### 1. 데이터 베이스 사용하는 이유\r\n\r\n\r\n### 2. 정규화\r\n\r\n\r\n### 3. 트랜잭션\r\n\r\n### 4. NoSQL\r\n\r\n\r\n## Part 1-7 디자인 패턴\r\n\r\n### 1. MVC 패턴이란?\r\n\r\n```\r\n1. 정의 - Model-View-Controller의 약자로, 개발할 때 3가지 형태로 나눠 개발하는 방법론\r\n\r\n2. 특징\r\n - Model : 어플리케이션이 무엇을 할 지 정의\r\n - View : 어플리케이션 화면에 무엇을 보여줄지\r\n - Controller : 어플리케이션이 어떻게 처리할지\r\n   -> Model, View가 무엇을 해야 할 지를 알고 통제\r\n\r\n3. 관련 용어\r\n - Service\r\n\r\n4. 장점\r\n -\r\n\r\n5. 단점\r\n```\r\n\r\n## Part 1-8 보안\r\n\r\n# Part2. Language\r\n\r\n## 1. JAVA\r\n\r\n1. JVM이란?\r\n   - 자바가상머신의 약자를 줄여서 부르는 용어입니다. **프로그램을 실행하기 위해 물리적 머신과 유사한 머신을 소프트웨어로 구현**한 것을 말합니다.\r\n\r\n2. GC이란?\r\n   - \r\n\r\n## 2. JavaScript\r\n > 프로그래밍 언어로 브라우저가 가진 기능을 코드로 제어\r\n > (이벤트를 제어하기 위함)\r\n\r\n### 2.1 NodeJS\r\n > 자바스크립트의 언어와 환경이 분리 필요\r\n -> 웹서버를 동작하기 위한 도구로 구글의 V8 Engine기반 **NodeJS** 탄생!!\r\n\r\n## 3. C\r\n\r\n1. C에서는 메모리를 어떻게 할당하는가?\r\n    - d\r\n\r\n# Part3. FrontEnd\r\n**프레임 워크와 플랫폼의 차이가 뭔가요?**\r\n\r\n**Cookie, Session Storage, LocalStorage의 차이점을 말해주세요**\r\n\r\n\r\n**UI(User Interface)란?**\r\n   - 사용자와 시스템의 접점\r\n## 1. Vitual DOM\r\n\r\n## 2. React.js\r\n\r\n\r\n## 3. Vue.js\r\n\r\n\r\n# Part4. BackEnd\r\n\r\n## 1. Spring\r\n\r\n## 2. Express\r\n\r\n# Part5. Project\r\n\r\n\r\n## IoT\r\n\r\n### 1. MQTT\r\n\r\n\r\n# 기술 직무 추가 질문\r\n\r\n\r\n","excerpt":"기술 면접을 준비하면서 면접에 자주 나오는 문항들을 내 말로 정리할 필요성을 느꼈다. 본 포스트는 취업 준비를 하면서 부족한 부분을 지속해서 업데이트할 예정이다. 시작하기전에 수행한 프로젝트, 준비한 사항은 분명하고 간결하게 설명 가능해야 한다. 쫄…","fields":{"slug":"/techInterview/"},"frontmatter":{"date":"Dec 28, 2020","title":"개발 기술 면접 준비","tags":["면접"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n풀이를 보고 바로 이해하지 못하고 헷갈린 부분이 있어서 정리한다.\r\n\r\n![문제사진](problem.PNG)\r\n\r\n# LCS란?\r\n공통적으로 가지고 있는 부분 문자열 중, 가장 긴 문자열(최장 공통 부분 수열)\r\n\r\n## 규칙찾기\r\n\r\n점화식을 찾아내기 전에 문제에 나온 예제 입력값을 통해 규칙을 찾아보면\r\n\r\n```\r\nindex   C A P C A K\r\nA       0 1 1 1 1 1\r\nC       1 1 1 2 2 2\r\nA       1 2 2 2 3 3\r\nY       1 2 2 2 3 3\r\nK       1 2 2 2 3 4\r\nP       1 2 3 3 3 4\r\n```\r\n\r\n## 접근\r\n\r\n문제의 경우는 2가지로 나눌 수 있다.\r\n\r\n 1) 두 문자열에 같은 문자가 추가되는 경우\r\n    - ex) ACAYKP**A** , CAPCAK**A**\r\n 2) 두 문자열에 다른 문자가 추가되는 경우\r\n    - ex) ACAYKP**B** , CAPCAK**C**\r\n\r\n## 점화식\r\n두 가지 경우를 각각 점화식으로 나타내 보면\r\n```\r\n 1) dp[i][j] = dp[i-1][j-1] + 1\r\n 2) dp[i][j] = Max(arr[i][j-1], arr[i-1][j])\r\n```\r\n\r\n점화식을 찾아냈으면 코드작성은 쉽다.\r\n\r\n## 코드\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class num9251 {\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tString[] str1 = br.readLine().split(\"\");\r\n\t\tString[] str2 = br.readLine().split(\"\");\r\n\t\t\r\n\t\tint N = str1.length;\r\n\t\tint M = str2.length;\r\n\t\tint[][] arr = new int[N+1][M+1];\r\n\t\t\r\n\t\tfor(int i=1;i<=N;i++) {\r\n\t\t\tfor(int j=1;j<=M;j++) {\r\n\t\t\t\tif(str1[i-1].equals(str2[j-1])) {\r\n\t\t\t\t\tarr[i][j] = arr[i-1][j-1] +1;\r\n\t\t\t\t}else {\r\n\t\t\t\t\tarr[i][j] = Math.max(arr[i][j-1],arr[i-1][j]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tSystem.out.println(arr[N][M]);\r\n\t}\r\n}\r\n```","excerpt":"풀이를 보고 바로 이해하지 못하고 헷갈린 부분이 있어서 정리한다.  LCS란? 공통적으로 가지고 있는 부분 문자열 중, 가장 긴 문자열(최장 공통 부분 수열) 규칙찾기 점화식을 찾아내기 전에 문제에 나온 예제 입력값을 통해 규칙을 찾아보면 접근 문제…","fields":{"slug":"/backjoon9251/"},"frontmatter":{"date":"Dec 28, 2020","title":"백준 9251 - LCS 풀이","tags":["Algorithm","BackJoon"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\nAWS EC2를 사용해서 구현해야 할 일이 생겨서 간만에 사용하다 잘 안되서 기록해둔다.\r\n\r\n1. AWS EC2 인스턴스 생성\r\n\r\n2. vscode extensions에서 ftp-simple을 설치해준다.\r\n\r\n3. F1을 눌러 ftp-simple : Config - FTP connection setting 실행.  \r\n 다음 사진과 같이 설정해준다.\r\n\r\n![설정 json](./201205_jsoncapture.PNG \"json파일\")\r\n\r\n1. F1 눌러 Remote directory open to workspace 실행하면 된다.\r\n","excerpt":"AWS EC2를 사용해서 구현해야 할 일이 생겨서 간만에 사용하다 잘 안되서 기록해둔다. AWS EC2 인스턴스 생성 vscode extensions에서 ftp-simple을 설치해준다. F1을 눌러 ftp-simple : Config - FTP c…","fields":{"slug":"/vscode_connect_aws/"},"frontmatter":{"date":"Dec 05, 2020","title":"AWS EC2 Visual Studio Code로 사용하기","tags":["AWS"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n백준 DP 단계별 문제에 있는 10844번 문제이다. \r\n\r\n접근이 조금 어려웠던 문제라 풀이를 정리해보려고 한다.  \r\n\r\n## 접근\r\n\r\n일단 이 문제는 DP문제로 2차원 배열을 DP로 사용해야 한다.\r\n\r\n규칙을 찾기 위해 값을 적어보고, 개수를 세보면 아래와 같다.  \r\n(N : 자리수, index : 맨 마지막에오는 숫자)  \r\n```\r\nindex   0 1 2 3 4 5 6 7 8 9\r\nN=1     0 1 1 1 1 1 1 1 1 1  \r\nN=2     1 1 2 2 2 2 2 2 2 1\r\nN=3     1 3 3 4 4 4 4 4 3 2\r\n\r\nex)\r\nN=2 -> (10), (21), (32, 12), (43,23), (54,34), (65,45), (76,56), (87,67), (98,78), (89)\r\n```\r\ndp[N][index] = dp[N-1][index-1] + dp[N-1][index+1]인 점화식을 얻을 수 있다.\r\n\r\n단, 여기서 중요한 점은 index가 0일 경우는 +1 한 값이 허용되고  \r\n9일 경우는 -1 한 경우만 적용되기 때문에 예외 처리를 해줘야 한다.  \r\n\r\n마지막으로 점화식을 정리해보면\r\n```\r\n1) index가 1일 경우\r\ndp[N][index] = dp[N-1][index+1]\r\n\r\n2) index가 1~8일 경우\r\ndp[N][index] = dp[N-1][index-1] + dp[N-1][index+1]\r\n\r\n3) index가 9일 경우\r\ndp[N][index] = dp[N-1][index-1]\r\n\r\n```\r\n\r\n3가지 경우에 따라 분기처리를 하면 된다.\r\n\r\n# Top-down 방식\r\n\r\n## 구현코드\r\n\r\n```java\r\npackage package14;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class num10844 {\r\n\tstatic Long[][] dp;\r\n\tstatic int N;\r\n\tfinal static long MOD = 1000000000;\r\n\t\r\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tN = Integer.parseInt(br.readLine());\r\n\t\tdp = new Long[N+1][10];\r\n\t\t// #1\r\n\t\tfor(int i = 0; i < 10; i++) {\r\n\t\t\tdp[1][i] = 1L;\r\n\t\t}\r\n\r\n\t\tlong result = 0;\r\n\t\t\r\n\t\tfor(int i = 1; i <= 9; i++) {\r\n\t\t\tresult += recur(N, i);\r\n\t\t}\r\n\t\tSystem.out.println(result % MOD);\r\n\t}\r\n\t\r\n\tstatic long recur(int digit, int val) {\t\t\r\n\t\t\r\n\t\tif(digit == 1) {\r\n\t\t\treturn dp[digit][val];\r\n\t\t}\r\n\t\t// #2\r\n\t\tif(dp[digit][val] == null) {\r\n\t\t\tif(val == 0) {\r\n\t\t\t\tdp[digit][val] = recur(digit - 1 ,1);\r\n\t\t\t}\r\n\t\t\telse if(val== 9) {\r\n\t\t\t\tdp[digit][val] = recur(digit - 1, 8);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tdp[digit][val] = recur(digit - 1, val - 1) + recur(digit - 1, val + 1);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn dp[digit][val] % MOD;\r\n\t}\r\n}\r\n\r\n\r\n```\r\n\r\n## 코드설명\r\n 1) N=1인 값들은 값을 초기값으로 값을 넣어준다.\r\n 2) 점화식과 동일하게 상황에 따라 맞는 값을 재귀로 호출한다.\r\n\r\n# Botton-up 방식\r\n\r\n## 구현 코드\r\n\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.InputStreamReader;\r\nimport java.io.IOException;\r\n \r\npublic class Main {\r\n\t\r\n\tfinal static long mod = 1000000000;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\t\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tint N = Integer.parseInt(br.readLine());\r\n\t\t\r\n\t\tlong[][] dp = new long[N + 1][10];\r\n\t\t\r\n\t\tfor(int i = 1; i < 10; i++) {\r\n\t\t\tdp[1][i] = 1; \r\n\t\t}\r\n\t\t\r\n\t\t// 두 번째 자릿수부터 N까지 탐색 \r\n\t\tfor(int i = 2; i <= N; i++) {\r\n\t\t\t\r\n\t\t\tfor(int j = 0; j < 10; j++) {\r\n\t\t\t\t\r\n\t\t\t\tif(j == 0) {\r\n\t\t\t\t\tdp[i][0] = dp[i - 1][1] % mod;\r\n\t\t\t\t}\r\n\t\t\t\telse if (j == 9) {\r\n\t\t\t\t\tdp[i][9] = dp[i - 1][8] % mod;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tdp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j + 1]) % mod;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tlong result = 0;\r\n\t\t\r\n\t\tfor(int i = 0; i < 10; i++) {\r\n\t\t\tresult += dp[N][i];\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(result % mod);\r\n\t}\r\n \r\n}\r\n```\r\n\r\n## 코드설명\r\n - Top-down방식과 동일한데 재귀 부분을 for문으로 두번째 자리부터 N까지 탐색한다.\r\n\r\n\r\n# \r\n<hr>\r\n\r\n아직 DP문제를 많이 풀어보지 않아서 그런지 점화식 만들어 내는 과정이 어렵다... ㅜㅜㅜㅜㅜ  \r\n익숙해질 때까지 열심히 풀어야겠다 (승질 그만내고 ㅎㅎ)","excerpt":"백준 DP 단계별 문제에 있는 10844번 문제이다.  접근이 조금 어려웠던 문제라 풀이를 정리해보려고 한다.   접근 일단 이 문제는 DP문제로 2차원 배열을 DP로 사용해야 한다. 규칙을 찾기 위해 값을 적어보고, 개수를 세보면 아래와 같다. (…","fields":{"slug":"/backjoon10844/"},"frontmatter":{"date":"Dec 03, 2020","title":"백준 10844번 - 쉬운 계단수 풀이","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"알고리즘 문제를 풀면서 많이 하는 실수를 정리할 필요성을 느꼈다.  \r\n본 포스트는 주의해야 할 실수가 생길 때 마다 update할 예정이다.\r\n\r\n# 백트래킹\r\n > 재귀함수 빠져나오면 상태 값 원래대로 돌려줘야 함.","excerpt":"알고리즘 문제를 풀면서 많이 하는 실수를 정리할 필요성을 느꼈다. 본 포스트는 주의해야 할 실수가 생길 때 마다 update할 예정이다. 백트래킹 재귀함수 빠져나오면 상태 값 원래대로 돌려줘야 함.","fields":{"slug":"/algoMistake/"},"frontmatter":{"date":"Nov 25, 2020","title":"알고리즘 풀 때 많이하는 실수","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n# Comparable\r\n > 클래스의 기본 정렬 기준을 설정하는 인터페이스\r\n\r\n\r\n## 1) 특징\r\n - Comparable 인터페이스 상속 후, compareTo 메소드 오버라이딩\r\n - compareTo메소드 리턴 값은 음수, 0, 양수가 될 수 있다. 음수가 리턴되면 인자의 순서가 아래로 이동\r\n - 자바에서 제공되는 정렬이 가능한 클래스는 모두 Comparable 클래스로 구현되어 있음\r\n \r\n## 2) 구현 코드\r\n\r\n# Comparator\r\n > 기본 정렬과 다르게 정렬하고 싶을 때 이용하는 클래스\r\n## 1) 특징\r\n - 보통 구현 되어있는 sort함수의 2번째 인자로 Comparator 타입을 받아(익명함수) compare 메소드 오버라이딩을 통해 배열 정렬 순서 재정의\r\n - 보통 한번 사용하고 사용하지 않기 때문에 익명객체로 만듬\r\n\r\n## 2) 구현 코드\r\n\r\n# 관련 백준 문제\r\n - 11650, 11651, 1181, 10814","excerpt":"Comparable 클래스의 기본 정렬 기준을 설정하는 인터페이스 1) 특징 Comparable 인터페이스 상속 후, compareTo 메소드 오버라이딩 compareTo메소드 리턴 값은 음수, 0, 양수가 될 수 있다. 음수가 리턴되면 인자의 순서…","fields":{"slug":"/javaComparableComparator/"},"frontmatter":{"date":"Nov 24, 2020","title":"JAVA Comparable, Comparator 사용","tags":["JAVA"],"update":"Dec 04, 2020"}}},{"node":{"rawMarkdownBody":"\n이전부터 자주 헷갈렸던 순열, 조합, 부분집합의 개념 정리와 JAVA를 사용해 구현하는 방법을 정리해 보려고 한다.  \n\n1) 대표적인 구현 방법  \n2) 각, 방법의 특징    \n\n두가지 사항으로 정리한다.  \n\n# 순열\n\n  - n개의 원소 중, r개를 일렬로 나열하는 수열  \n  - 중복 X / 순서 고려\n\n## 1. next_permutation\n\n### 1) 특징\n - 이게 이해하기 제일 어려웠다.... (나만 어렵나...ㅜㅜ)\n - 무작위 순열의 다음 순열을 구해내는 알고리즘\n - 시작 조건 : 오름차순 / 종료 조건 : 내림차순\n```\n  순서\n  1.Find largest index i such that array[i − 1] < array[i].\n  (If no such i exists, then this is already the last permutation.)\n\n  2.Find largest index j such that j ≥ i and array[j] > array[i − 1].\n\n  3.Swap array[j] and array[i − 1].\n\n  4.Reverse the suffix starting at array[i].\n```\n\n### 2) 구현 코드\n```java\npublic class num1 {\n    public static void main(String[] args) {\n    \tint[] list = new int[]{5,4,3};\n    \t// #1 시작 조건에 맞게 list 오름차순 정렬 (시작조건)\n    \tArrays.sort(list);\n    \tpermutation(list);\n    }\n    // #2 처음 list값 print 후, 다음 순열 찾음\n    public static void permutation(int[] list) {\n        int[] curArray = list;\n        while (true) {\n        \tprintArray(curArray);\n        \tcurArray = nextPermutation(curArray);\n            if (curArray == null) {\n                break;\n            }\n        }\n    }\n    \n    public static int[] nextPermutation(int[] list) {\n    \t  // #3 수열의 바로 앞 값 보다 큰 값 중 가장 큰 index 찾는다. \n        // (가장 적은 차이로 순서를 바꾸기 위해서 가장 큰 index를 찾음) \n        int i = list.length -1;\n        while(i>0 && list[i-1] >= list[i])\n        \ti--;\n        \n        // #6 list가 내림차순으로 정렬되어 있으면 순열을 끝까지 찾은 것 (종료조건)\n        if(i<=0)\n        \treturn null;\n        \n        int j = list.length -1;\n        // #4 다음 수열의 특징 : 이전 순열보다 값이 큼\n        // -> list[i-1] < list[j] 값을 찾고, 값을 바꿔준다.\n        while(list[j] <= list[i-1])\n        \tj--;\n        \n        int temp = list[i-1];\n        list[i - 1] = list[j];\n        list[j] = temp;\n        // #5 a[i] 이후 부분을 오름차순으로 셋팅 \n        j= list.length-1;\n        while (i < j) {\n            temp = list[i];\n            list[i] = list[j];\n            list[j] = temp;\n            i++;\n            j--;\n        }\n        \n        return list;\n    }\n    \n    public static void printArray(int[] array) {\n    \tfor(int i=0;i<array.length;i++)\n    \t\tSystem.out.print(array[i] + \" \");\n    \tSystem.out.println();\n    }\n    \n}\n\n```\n### 3) 코드 설명\n\n1. 시작 조건에 맞게 list 오름차순 정렬 (시작조건)\n2. 처음 list값 print 후, 다음 순열 찾음\n3. 수열의 바로 앞 값 보다 큰 값 중 가장 큰 index 찾는다.  \n  (가장 적은 차이로 순서를 바꾸기 위해서 가장 큰 index를 찾음)\n4. 다음 수열의 특징 : 이전 순열보다 값이 큼 -> list[i-1] < list[j] 값을 찾고, 값을 바꿔준다.\n5. a[i] 이후 부분을 오름차순으로 셋팅 \n6. list가 내림차순으로 정렬되어 있으면 순열을 끝까지 찾은 것 (종료조건)\n\n### 4) 코드 출력값\n```\n3 4 5 \n3 5 4 \n4 3 5 \n4 5 3 \n5 3 4 \n5 4 3 \n\n```\n\n## 2. Swap\n\n### 1) 특징\n - 재귀함수, 백트래킹\n - 순열의 순서가 보장되지 않는다. (사전식 X)\n\n\n### 2) 구현 코드\n```java\npublic class Main {\n  public static void main(String[] args) {\n  \tint[] arr = {1,2,3};\n  \tpermutation(arr,0,3,3);\n  \tSystem.out.println(Arrays.toString(arr));\n  }\n\n  static void permutation(int[] arr, int depth, int n, int r) {\n  \tif (depth == r) {\n  \t\tarrPrint(arr,r);\n  \t\treturn;\n  \t}\n  \tfor (int i=depth; i<n; i++) {\n      // #1\n  \t\tswap(arr, depth, i);\n      // #2\n  \t\tpermutation(arr, depth + 1, n, r);\n      // #3\n     \tswap(arr, depth, i);\n  \t}\n  }\n\n  static void arrPrint(int[] arr, int r) {\n    for (int i=0 ; i<r; i++)\n    \tSystem.out.print(arr[i] + \" \");\n    System.out.println();\n  }\n\n  static void swap(int[] arr, int depth, int i) {\n    int temp = arr[depth];\n    arr[depth] = arr[i];\n    arr[i] = temp;\n  }\n}\n```\n### 3) 코드 설명\n\n1. 배열의 첫번째 값부터 하나씩 바꾸면서 swap\n2. depth를 기준(Inex)으로 depth보다 작은 인데스 값들은 고정, depth보다 큰 값들을 가지고 swap\n3. 재귀함수가 종료조건에 의해 return되면 swap을 한번 더 해줘서 이전 상태 유지\n\n\n### 4) 코드 출력값\n```\n1 2 3 \n1 3 2 \n2 1 3 \n2 3 1 \n3 2 1 \n3 1 2 \n[1, 2, 3]\n```\n\n## 3. Visit Index 사용\n\n### 1) 특징\n - DFS, 재귀 함수\n\n\n### 2) 구현 코드\n\n```java\npublic class Main {\n\tpublic static void main(String[] args) {\n\t    int n = 3;\n\t    int[] arr = {1, 2, 3};\n      // #1\n\t    int[] output = new int[n];\n\t    boolean[] visited = new boolean[n];\n\t    perm(arr, output, visited, 0, n, 2);\n\t    System.out.println();\n\t}\n\n\tstatic void perm(int[] arr, int[] output, boolean[] visited, int depth, int n, int r) {\n\t    if (depth == r) {\n\t        print(output, r);\n\t        return;\n\t    }\n\n\t    for (int i = 0; i < n; i++) {\n\t        if (visited[i] != true) {\n\t            visited[i] = true;\n              output[depth] = arr[i];\n              // #2\n\t            perm(arr, output, visited, depth + 1, n, r);\n              // #3\n\t            visited[i] = false;\n\t        }\n\t    }\n\t}\n\n\tstatic void print(int[] arr, int r) {\n\t    for (int i = 0; i < r; i++)\n\t        System.out.print(arr[i] + \" \");\n\t    System.out.println();\n\t}\n\t\n}\n\n```\n### 3) 코드 설명\n1. output : 코드 출력 값 / visited : 방문 여부 체크\n2. depth -> output 길이라고 생각\n3. 방문 여부 false로 체크 -> 모든 인덱스 방문\n   \n\n### 4) 코드 출력값 \n```\n1 2 \n1 3 \n2 1 \n2 3 \n3 1 \n3 2 \n```\n\n## 관련 백준 문제\n> n과m 시리즈 0 ~ 12\n\n# Reference\n[BaaaaaaaarkingDog님 블로그](https://blog.encrypted.gg/945?category=773649)  \n[뱀귤님 블로그](https://bcp0109.tistory.com/entry/%EC%88%9C%EC%97%B4-Permutation-Java?category=848939)  \n[junhok82님 블로그](https://velog.io/@junhok82/>Java%EB%A1%9C-%EC%88%9C%EC%97%B4Permutation-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0>)\n[Crocus님 블로그](https://www.crocus.co.kr/1240)","excerpt":"이전부터 자주 헷갈렸던 순열, 조합, 부분집합의 개념 정리와 JAVA를 사용해 구현하는 방법을 정리해 보려고 한다.   대표적인 구현 방법   각, 방법의 특징     두가지 사항으로 정리한다.   순열 n개의 원소 중, r개를 일렬로 나열하는 수열…","fields":{"slug":"/permutation/"},"frontmatter":{"date":"Nov 23, 2020","title":"순열 정리, 구현","tags":["Algorithm"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}},"staticQueryHashes":["2027115977","694178885"]}