{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n# Side Effects(Refs) & More Hooks\n\n## Side Effects\n\n> 함수가 실행되면서 함수 외부에 존재하는 값이나 상태를 변경시키는 등의 행위  \n> (비동기로 처리되어야 하는 부수적인 효과)\n\nex) 브라우저 스토리지에 값 저장, 타이머, 백엔드 서버에 HTTP 요청 등\n\n## UseEffect()\n\n> Side Effect 처리를 위해 필요\n\n```javascript\nuseEffect(() => {}, [dependencies]);\n```\n\n```text\nuseEffect함수는 2개의 매개 변수를 받음\n1. 콜백함수,\n2. 값이 변할 경우 콜백함수를 실행시키고 싶은 변수\n -> 빈 배열이면 Component가 처음 마운트 되고 렌더링 될 때만 실행\n -> 콜백함수 내부에서 사용하는 모든 변수는 배열에 추가되어야 한다\n```\n\n- 첫번째 인자인 callback의 return 값으로 함수 반환 -> **cleanUp 함수**\n- clean up 함수는 1번째 인자값으로 받은 함수(사이드 이펙트 함수)가 실행되기 전에 실행  \n  (최초 실행시 동작x)\n\n### Debouncing\n\n> 연이어 호출되는 함수들 중 마지막 함수(또는 제일 처음)만 호출되도록 하는 것\n\n```javascript\nuseEffect(() => {\n  const identifier = setTimeout(() => {\n    setFormIsValid(enteredEmail.includes('@') && enteredPassword.trim().length > 6);\n  }, 500);\n\n  // cleanUp 함수\n  return () => {\n    clearTimeout(identifier);\n  };\n}, [enteredEmail, enteredPassword]);\n```\n\nex) Form 태그 하위 요소 입력값 검증, AJAX 요청\n\n### Throttling\n\n> 마지막 함수가 호출된 후 일정 시간이 지나기 전에 다시 호출되지 않도록 하는 것\n\nex) scroll 동작 시\n\nTip!!\n\n- Debouncing, Throttling -> lodash 활용 가능\n\n## useReducer()\n\n> 복잡한 state를 관리할 때 사용\n> 다른 state기반으로 한 state를 업데이트 할 때 사용 (하나의 state로 병합)\n\n일반적인 경우, 데이타 변경이 잦은 경우 -> useState사용\n\n```javascript\nconst [state, dispatchFn] = useReducer(reducerFn, initialState, initFn);\n```\n\n```\n첫번째 인자 reducer 함수\n두번째 인자 initial State\n세번째 인자 초기 state를 계산하는 함수\n\nreducer함수는 1) 현재 상태, 2) 액션 객체 를 파라미터로 받아와 새로운 상태를 반환해주는 함수\n\n보통 dispatch함수의 액션 Type은 대문자로 명칭을 정해준다.\n```\n\n## Context API\n\n> 어떤 컴포넌트에서라도 직접 다른 컴포넌트에 전달할 수 있게 해준다.\n> props chain을 없앨 수 있음\n\n앱 전체나 여러 컴포넌트에 영향을 주는 state 관리에 적합\n(자주 바뀌는 경우 적합하지 않음)\n\n```React\nimport React from 'react';\n\nconst AuthContext = React.createContext({\n  iosLoggedIn: false,\n});\n\nexport default AuthContext;\n```\n\nReact.createContext로 반환되는 값은 컴포넌트나 컴포넌트를 포함한 객체\n\n만든 컴포넌트를 전역적인 위치에서 감싸준다.\n\n```React\n// App.js\nfunction App() {\n  // ...\n\n  return (\n    <AuthContext.Provider\n      value={{\n        isLoggedIn: isLoggedIn,\n      }}\n    >\n    <Header>\n    <Main>\n    </AuthContext.Provider>\n  );\n}\n```\n\n값을 받아오는 방법은 2가지\n\nConsumer , react hooks 사용\n\n1. 사용하는 곳에서 Consumer 컴포넌트로 감싸 값을 가져옴\n\n```React\nconst Main = (props) => {\n    return (\n        <AuthContext.Consumer>\n            {(ctx) => {\n                return (\n                    {ctx.isLoggedIn && (\n                        <li>\n                            <a href=\"/\">Users</a>\n                        </li>\n                    )}\n                );\n            }}\n        </AuthContext.Consumer>\n    );\n};\n```\n\n2. useContext()\n\n```React\nconst Main = (props) => {\n    const ctx = useContext(AuthContext);\n\n    return (\n        {ctx.isLoggedIn && (\n            <li>\n                <a href=\"/\">Users</a>\n            </li>\n        )}\n    );\n};\n```\n\nstate, state를 수정하는 로직을 모아서 사용 가능\n\n```React\n// auth-context.js\nimport React, { useState, useEffect } from 'react';\n\n// 선언을 해주면 IDE 자동 완성 가능\nconst AuthContext = React.createContext({\n    iosLoggedIn: false,\n    onLogout: () => {},\n    onLogin: () => {},\n});\n\nexport const AuthContextProvider = (props) => {\n    const [isLoggedIn, setIsLoggedIn] = useState(false);\n\n    useEffect(() => {\n        const storedUserLoggedInInformation = localStorage.getItem('isLoggedIn');\n\n        if (storedUserLoggedInInformation === true) {\n            setIsLoggedIn(true);\n        }\n    }, []);\n\n    const logoutHandler = () => {\n        localStorage.setItem('isLoggedIn', true);\n        setIsLoggedIn(false);\n    };\n\n    const loginHandler = () => {\n        localStorage.removeItem('isLoggedIn');\n        setIsLoggedIn(true);\n    };\n\n    return (\n        <AuthContext.Provider value={{ isLoggedIn: isLoggedIn, onLogout: logoutHandler, onLogin: loginHandler }}>\n            {props.children}\n        </AuthContext.Provider>\n    );\n};\n\nexport default AuthContext;\n\n\n// index.js\nroot.render(\n    <AuthContextProvider>\n        <App />\n    </AuthContextProvider>,\n);\n\n// App.js\nimport React, { useContext } from 'react';\n\nfunction App() {\n    const ctx = useContext(AuthContext);\n\n    return (\n        <React.Fragment>\n            <MainHeader onLogout={ctx.onlogout} />\n            <main>\n                {!ctx.isLoggedIn && <Login />}\n                {ctx.isLoggedIn && <Home />}\n            </main>\n        </React.Fragment>\n    );\n}\n\nexport default App;\n```\n\n## Rules of Hooks\n\n1. 리액트 훅을 호출 시 1) 컴포넌트 함수, 2) 커스텀 훅에서만 사용\n2. 리액트 훅은 최상위 부분에서 호출\n\n![](ReactHooksRules.png)\n\n## Forward Refs\n\nReact.forwardRef\n\n> 부모 컴포넌트에서 하위 컴포넌트로 ref전달\n\nuseImperativeHandle\n\n> ref를 사용하는 부모 측에서 커스터마이징된 메서드를 사용 가능\n\nex) focusing, scrolling\n\n```javascript\nuseImperativeHandle(ref, createHandle, [deps]);\n```\n\nref : 프로퍼티를 부여할 ref\ncreateHandle : 객체를 리턴하는 함수. 해당 객체에 추가하고 싶은 프로퍼티를 정의\n\n```React\n// Login.js\nconst login = (props) => {\n    const emailInputRef = useRef();\n    const passwordInputRef = useRef();\n    ...\n\n    const submitHandler = (event) => {\n        event.preventDefault();\n\n        if (formIsValid) {\n            authCtx.onLogin(emailState.value, passwordState.value);\n        } else if (!emailIsValid) {\n            emailInputRef.current.focus();\n        } else {\n            passwordInputRef.current.focus();\n        }\n    };\n\nreturn (\n        <form onSubmit={submitHandler}>\n            <Input\n                ref={emailInputRef}\n                id=\"email\"\n                label=\"E-Mail\"\n                type=\"email\"\n                isValid={emailIsValid}\n                value={emailState.value}\n                onChange={emailChangeHandler}\n                onBlur={validateEmailHandler}\n            />\n            <Input\n                ref={passwordInputRef}\n                id=\"password\"\n                label=\"Password\"\n                type=\"password\"\n                isValid={passwordIsValid}\n                value={passwordState.value}\n                onChange={passwordChangeHandler}\n                onBlur={validatePasswordHandler}\n            />\n            <div className={classes.actions}>\n                <Button type=\"submit\" className={classesbtn}>\n                    Login\n                </Button>\n            </div>\n        </form>\n    );\n\n}\n\n// input.js\n// React.forwardRef 메서드로 감싸줌\nconst Input = React.forwardRef((props, ref) => {\n    const inputRef = useRef();\n\n    const activate = () => {\n        inputRef.current.focus();\n    };\n\n    // 1) ref객체 , 2) 기능 트리거 될 함수 객체 리턴하는 익명 함수\n    useImperativeHandle(ref, () => {\n        return {\n            focus: activate,\n        };\n    });\n\n    return (\n        <div className={`${classes.control} ${props.isValid === false ? classes.invalid : ''}`}>\n            <label htmlFor={props.id}>{props.label}</label>\n            <input\n                ref={inputRef}\n                type={props.type}\n                id={props.id}\n                value={props.value}\n                onChange={props.onChange}\n                onBlur={props.onBlur}\n            />\n        </div>\n    );\n});\n```\n\n# React memoization\n\nComponent의 props, state, 부모 컴포넌트 렌더링에 따라 다시 실행 되는데 성능상의 이슈로 인해 리렌더가 일어나지 않도록 최적화 해주는 방법\n\nReact에서 컴포넌트가 렌더링 하는 규칙에는 크게 3가지\n\n1. state/props 변경 시\n2. forceUpdate() 실행 시\n3. 부모 컴포넌트가 렌더링 되었을 때\n\n## React.Memo()\n\n> 같은 props를 받을 때 같은 결과를 렌더링한다면 React.memo를 사용하여 불필요한 컴포넌트 렌더링을 방지\n\n다음 렌더링이 일어날 때 props가 같은 경우 성능향상\n\n```React\n// 1\nconst Header = React.memo(() => {\n  return ()\n})\n\n// 2\nexport default React.memo(Header);\n\n```\n\n- 컴포넌트를 감싸서 사용\n- 비교 방식을 커스텀하고 싶으면 두번째 인자로 **비교하는 함수 추가**\n\nReact.memo()를 사용하지 말아야 할 때\n\n- 렌더링 될 때 props가 다른 경우가 대부분인 컴포넌트일 경우  \n  -> 메모제이션 기법의 이점을 얻기\n- 클래스 기반의 컴포넌트 일 경우\n  -> **PureComponent**, shouldComponentUpdate() 메서드를 구현해 사용하는 것이 적절\n\n## useMemo()\n\n> 함수에 의해 나온 결과값을 메모리에 저장해서 컴포넌트가 반복적으로 렌더링 되어도 이미 가져온 결과값을 메모리에서 꺼내와 재사용\n\nReact.memo가 props, state에 의해 re-render를 관리한다면  \nuseMemo는 함수의 결과 값을 memoizing하여 연산을 관리한다\n\n```React\n  const sortedList = useMemo(() => {\n    return items.sort((a, b) => a - b);\n  }, [items]);\n  console.log(\"DemoList RUNNING\");\n```\n\n## useCallback()\n\n> 특정 함수를 새로 만들지 않고 재사용하고 싶을때 사용\n\n```React\nconst changeTitleHandler = useCallback(() => {\n    setListTitle('New Title');\n}, []);\n```\n\ndependency 배열에는 useEffect와 동일하게 어떤값이 변경되면 다시 생성할지에 대한 값들이 들어감\n\nuseEffect내부에 함수를 사용할 경우, 디펜던시 배열에 함수를 추가하면 무한 루프가 발생  \n-> 즉, useCallback 함수는 useEffect내부에서 사용하는 함수를 useCallback으로 감싸 동일한 객체를 사용할 수 있도록 사용\n\n## useState, useReducer\n\n> 컴포넌트가 초기화 될 때만 갱신된다.\n\n성능 측정은 Dev tools Profiling 탭을 통해 가능하다.\n\n# Class Component\n\nFunction Component : 일반 컴포넌트와 달리 state, 라이플 사이클 기능 제거  \n -> 일반 클래스형 함수보다 빠르다\n\nReact life cycle은 [React document](https://ko.reactjs.org/docs/react-component.html) 참고\n\n| function                               | state                  | 기능                             |\n| -------------------------------------- | ---------------------- | -------------------------------- |\n| useEffect(..., [])                     | componentDidMount()    | 초기화 될 때마다 실행            |\n| useEffect(..., [someValue])            | ComponentDidUpdate()   | State가 없데이트 될 때 마다 실행 |\n| useEffect(() => r{eturn () => {}}, []) | componentWillUnmount() | 컴포넌트가 실행되기 전에 실행    |\n\n대체적으로 함수형으로 작성한게 this. 구문도 없애주고 깔끔한 코드를 작성할 수 있게 해주지만 에러를 잡아주는 부분은 클래스 컴포넌트로만 잡아줄 수 있다.\n\n## Error boundary\n\n```React\n// ErrorBoundary.js\nimport { Component } from 'react';\n\nclass ErrorBoundary extends Component {\n  constructor() {\n    super();\n    this.state = { hasError: false };\n  }\n\n  componentDidCatch(error) {\n    console.log(error);\n    this.setState({ hasError: true });\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <p>에러 발생</p>;\n    }\n    return this.props.children;\n  }\n}\n\nexport default ErrorBoundary;\n```\n\n이런 식으로 componentDidCatch를 사용하는 ErrorBoundary 컴포넌트를 만들어 탐지하고 싶은 컴포넌트에 감싸서 사용한다\n\n# Forms, Http Request & Custom Hooks\n\n## Http Request\n\nReact에서 Http 요청을 하기 위한 2가지 방법\n\n1. axios\n2. fetch\n\n비동기 처리를 위해 async, await 구문을 사용한다.\n\n## Custom Hooks\n\n> 로직 재사용(공유)을 위해 Hook 만들어 사용\n\n- 함수의 이름은 **use**로 시작한다.\n- Custom Hook을 통해 만들어진 상태는 각각의 컴포넌트마다 따로 상태 관리\n\n// FIXME: 실제 사용 예시\n\n## Form\n\n# Tip!!\n\n태그의 속성들을 객체로 만들어 속성값을 한번에 넘겨서 사용하면 깔끔한 코드 작성 가능\n\n```React\n// Component\nreturn = (\n    ...\n\n    <Input\n        label=\"Amount\"\n        input={{\n            id: 'amount_' + props.id,\n            type: 'number',\n            min: '1',\n            max: '5',\n            step: '1',\n            defaultValue: '1',\n        }}\n    />\n\n    ...\n)\n// input.js\nconst Input = (props) => {\n    return (\n        <div>\n            <label htmlFor={props.input.id}>{props.label}</label>\n            <input {...props.input} />\n        </div>\n    );\n};\n\nexport default Input;\n\n\n```\n\nreducer 함수 작성 시 배열값을 추가할 때 concat으로 값을 추가하면 새로운 객체로 값을 생성해서 이전 상태를 바꾸지 않고 처리 가능\n\n---\n\nReact는 함수 내 상태를 업데이트하는 여러개의 함수가 있어도\n**하나의 동기화 프로세스에서 같이 실행**한다\n\n# Reference\n\n- [Udemy]\n- [React: 제어 컴포넌트와 비제어 컴포넌트의 차이점\n  ](https://velog.io/@yukyung/React-%EC%A0%9C%EC%96%B4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%99%80-%EB%B9%84%EC%A0%9C%EC%96%B4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90-%ED%86%BA%EC%95%84%EB%B3%B4%EA%B8%B0)\n- [React.memo() 현명하게 사용하기 - TOAST UI](https://ui.toast.com/weekly-pick/ko_20190731)\n- [[React] useImperativeHandle의 장점](https://developer-alle.tistory.com/372)\n","excerpt":"Side Effects(Refs) & More Hooks Side Effects 함수가 실행되면서 함수 외부에 존재하는 값이나 상태를 변경시키는 등의 행위 (비동기로 처리되어야 하는 부수적인 효과) ex) 브라우저 스토리지에 값 저장, 타이머, 백엔…","fields":{"slug":"/reactStudy_2/"},"frontmatter":{"date":"Aug 24, 2022","title":"React 핵심 기능2","tags":["React"],"update":"Aug 31, 2022"}}},{"node":{"rawMarkdownBody":"\n# 웹 어플리케이션\n\n## 웹 서버\n\n- 정적 리소스 제공 (HTML, CSS, JS, 이미지, 영상)\n\n## 웹 어플리케이션 서버 (WAS)\n\n- 쓰레드 풀 - 필요한 쓰레드 보관, 관리 (Tomcat 최대 200개 기본 설정)\n- 멀티 쓰레드 지원\n- 멀티 쓰레드 환경이기 때문에 싱클톤 객체(Servlet, Bean) 주의해서 사용\n\n## 서블릿\n\n> HTTP 요청 메시지를 편리하게 사용 할 수 있도록 **HTTP 요청 메세지 파싱**\n\n- 서블릿 객체는 싱글톤으로 관리\n- 공유 변수 사용 주의\n- 동시 요청을 위한 멀티 쓰레드 처리 지원\n\n## 멀티 쓰레드\n\n- 쓰레드 풀에서 쓰레드를 꺼내서 사용 후 반납\n- 미리 생성되어 있어 비용 절약, 응답시간 빠름\n- 생성 가능한 쓰레드의 최대치가 있음, 기존 요청 안전하게 처리 가능\n- 성능 테스트 - 아파치 ab, 제이미터, nGrinder\n\n# Servlet\n\n```java\n// 임시 저장소 기능\nrequest.setAttribute(name, value);\nrequest.getAttribute(name);\n\n// 세션 관리\nrequest.getSession(create: true);\n\n```\n\n## Request\n\n### Get, Post(Form데이터)\n\n조회 메서드\n\n```java\n// HttpServletRequest request\n\nString username = request.getParameter(\"username\");               //단일 파라미터 조회\nEnumeration<String> parameterNames = request.getParameterNames(); //파라미터 이름들 모두 조회\nMap<String, String[]> parameterMap = request.getParameterMap();   //파라미터를 Map 으로 조회\nString[] usernames = request.getParameterValues(\"username\");      //복수 파라미터 조회\n```\n\nPOST HTML Form 형식은 헤더에 content-type application/x-www-form-urlencoded 이 포함\n\n### HTTP body\n\n- InputStream 사용해 Byte 단위로 읽을 수 있음\n- json데이터를 읽기위해 **jackson**사용\n\n```java\nServletInputStream inputStream = request.getInputStream();\nString messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);\n\nJsonData data= objectMapper.readValue(messageBody, JsonData.class);\n```\n\n## Response\n\n> 반환 형태를 지정해 응답할 수 있음\n\n```java\n// Header 설정\nresponse.setHeader(\"content-type\", \"application/json\");\n// Encoding type 설정\nresponse.setCharacterEncoding(\"utf-8\");\n\nJsonData data = new JsonData();\ndata.setUsername(\"kim\");\ndata.setAge(20);\n\nString result = objectMapper.writeValueAsString(data);\nresponse.getWriter().write(result);\n```\n\n# MVC\n\n- DB에서 값을 꺼내올 때 **동시성 문제**로 인해 실무에선 ConcurrentHashMap, AtomicLong 사용을 고려\n\n## FrontController Pattern\n\n> 클라이언트 요청들을 처리하는 서블릿을 두고 요청에 맞는 컨트롤러를 찾아 호출 -> 공통 처리 가능\n\n## DispatcherServlet\n\n![](dispatcherServlet.png)\n\n### 1. 핸들러\n\n> 웹 요청을 실제로 처리하는 객체\n\n### 2. 어댑터\n\n> 핸들러마다 각각 그 핸들러를 처리하는 객체\n\n### 3. 핸들러 매핑\n\n> 요청 URI과 알맞는 핸들러 객체를 Dispatcher Servlet에 리턴\n\n### 4. 핸들러 어댑터\n\n> 핸들러 객체를 가지고 어댑터를 찾는 과정  \n> 2개 이상의 인터페이스에 스펙이 맞지 않을 때, 중간에 이 스펙을 맞도록 변환해주는 역할을 하는 객체\n\n### 핸들러와 어댑터가 필요한 이유\n\n- 핸들러 어댑터는 다양한 요청에 맞춰 ModelAndView객체로 응답  \n  ex) 리턴 타입 변경, 매개변수 변경\n- 다양한 형태의 핸들러 처리를 위해 ex) Controller Interface, @Controller 처리를 위한 핸들러 어댑터 필요\n- 비즈니스 개발 로직에만 집중하여 편하게 원하는 형태로 컨트롤러를 정의 가능\n\n## RequestMapping\n\n우선순위가 가장 높은 핸들러 매핑, 어댑터  \n -> RequestMappingHandlerMapping, RequestMappingAdaptorMapping\n\n```java\n@Controller     // Spring bean에 등록\n@RequestMapping // 요청 정보 매핑\n```\n\n- @RequestMapping은 클래스 레벨, 메서드 데벨로 나눠서 분리, 조합 가능\n\n```java\n@RequestMapping(\"/map/\"); // 클래스 레벨\n@RequestMapping(\"kr\");    // 메서드 레벨 -> /map/kr\n```\n\n**-> @GetMapping, @PostMapping** 으로 활용 가능!\n\n# Log\n\n사용 방법\n\n```java\nprivate Logger log = LoggerFactory.getLogger(getClass());\n@Slf4j // Lombok 사용 가능\n\nlog.trace(\"{}\", data); // 로그 출력 레벨에 따라 실행 x\n```\n\n# Spring MVC HTTP 요청, 응답 처리\n\n## HTTP 메서드 매핑\n\n```java\n@RestController // HTTP Message Body에 바로 입력\n@Controller     // 반환 값이 'String'이면 뷰이름으로 인식, 뷰를 찾고 렌더링\n@RequestMapping // method 속성으로 HTTP 메서드를 지정하지 않으면 HTTP 메서드와 무관하게 호출\n\n@GetMapping({path})       // 축약 가능\n@GetMapping(value = {path})\n@PostMapping({path})\n@PutMapping({path})\n@DeleteMapping({path})\n@PatchMapping({path})\n```\n\n## PathVariable(경로 변수)\n\n```java\n@GetMapping(\"/mapping/users/{id}/name/{name}\")\npublic String mappingPath(@PathVariable String id, @PathVariable String name) {\n    return \"ok\";\n}\n```\n\n리소스 경로 내 변수 사용 가능\n\n## 조건 매핑\n\n> HTTP 메서드를 매핑해주는 어노테이션에 파라미터 추가해 조건 매핑 가능\n\n```java\n@PostMapping(value = \"/api\", produces = \"text/html\")\n```\n\n| 조건     | 내용              | 형식                                        |\n| -------- | ----------------- | ------------------------------------------- |\n| params   | 파마미터          | params = \"mode=debug\"                       |\n| headers  | 특정 헤더         | headers = \"mode=debug\"                      |\n| produces | Acept 헤더        | produces = MediaType.APPLICATION_JSON_VALUE |\n| consumes | Content-Type 헤더 | consumes = MediaType.TEXT_HTML_VALUE        |\n\n## @RequestParam\n\n> url이 매핑 된 함수의 인자값으로 @RequestParam 추가\n\n```java\n@RequestMapping(\"/users\")\npublic String requestParam(\n  @RequestParam(\"username\") String username,\n  @RequestParam String phone,\n  int age,\n  @requestParam(required = true, defaultValue = \"aaa@aaa.com\") String email\n  // @RequestParam Map<String, Object> paramMap\n){\n  ...\n}\n```\n\n- 파라미터 이름이 변수 이름과 같으면 () 생략 가능\n- String, int 등 단순 타입이면 @RequestParam 생략 가능\n- 생략할 경우 required=false적용\n- Map, MultiValueMap으로 parameter를 한번에 받을 수 있음\n\n## @ModelAttribute\n\n> 요청 파라미터를 받아 객체 생성 (Model 객체에 자동으로 들어간다)\n\n- 생략 가능 (기본 단순 타입 제외한 값이 입력값인 경우 자동 적용)\n- 객체 프로퍼티 찾음 -> setter호출 해 입력값 바인딩\n- BindException 처리 필요\n\n## Text 데이터 처리\n\n```java\n@PostMapping(\"/request\")\npublic HttpEntity<String> requestBody(HttpEntity<String> httpEntity) {\n// public HttpEntity<String> requestBody(@RequestBody String httpbody) {\n  ...\n}\n```\n\n### HttpEntity\n\n- HTTP header, body 정보 조회\n- 요청 파라미터 조회 기능 관계 x (@RequestParam, @ModelAttribute)\n\n### RequestEntity\n\n> HttpMethod, url 정보 추가\n\n### ResponseEntity\n\n> HTTP 상태코드 설정 가능(조건문에 따라 분기처리)\n\n- @RequestBody, @ResponseBody 어노테이션으로도 제공\n- @RequestBody 파라미터에, @ResponseBody는 Mapping 되는 곳 or 클래스에 어노테이션 달아줌\n- @RestController or @ResponsesBody를 클래스 레벨 적용시 해당 컨트롤러의 response에 모두 적용\n- HttpEntity -> 요청 값 받는 Json에는 사용 가능 (Form 사용 불가능)\n\n**Form, HTTP Message Body 데이터를 읽을 때**\n\n- 요청 파라미터 조회 : @RequestParam, @ModelAttribute\n- HTTP 메시지 바디 조회 : @RequestBody\n\n## Json 데이터 처리\n\n처리 방법\n\n1. Json 데이터는 **Jackson 라이브러리 objectMapper**로 객체를 변환해 사용\n2. HttpEntity, @RequestBody 사용\n\n```java\n@PostMapping(\"/request\")\n// public HelloData requestBodyJson(HttpEntity<HelloData> httpEntity) {\npublic HelloData requestBodyJson(@RequestBody HelloData data) {\n  ...\n}\n```\n\n**@RequestBody생략 불가** -> @ModelAttribute이 적용 됨  \nHttp Body가 아닌 요청 파라미터 처리(Form처리)\n\n## Response응답\n\n> 응답시에는 ResponseEntity(HttpEntity), @ResponseBody 사용\n\n```java\n@GetMapping(\"/ResponseEntity\")\npublic ResponseEntity<String> ResponseEntityApi() {\n    return new ResponseEntity<>(\"ok\", HttpStatus.OK);\n}\n\n@ResponseStatus(HttpStatus.OK)\n@ResponseBody\n@GetMapping(\"/ModelAttribute\")\npublic Data ModelAttributeApi() {\n  ...\n}\n```\n\n**조건문에 따라 상태값을 다르게 리턴하려면 ResponseEntity사용**\n\n## Http Message Converter\n\n> 메세지 컨버터가 **클래스 타입, 미디어 타입**을 읽고 처리 방법 선택\n\n요청 : @RequestBody, HttpEntity(RequestEntity)\n응답 : @ResponseBody, HttpEntity(ResponseEntity)\n\n## Mapping Handler Adaptor\n\n![](ArgumentResolver.png)\n\n- RequestMapping하는 어노테이션에 구현되어 있음\n- Argument Resolver는 요청 시 보낸 데이터 처리\n\n- @RequestBody, HttpEntity에 한에서 HTTP 메세지 컨버터로 Body데이터 처리\n\n## Redirect\n\n> RedirectAttributes 객체 사용 (매개변수로 받는다)\n\n```java\n@PostMapping(\"/api\")\npublic String addItem(Item item, RedirectAttributes redirectAttributes) {\n    Item savedItem = itemRepository.save(item);\n\n    redirectAttributes.addAttribute(\"itemId\", savedItem.getId());\n    redirectAttributes.addAttribute(\"status\", true);\n\n    // pathVarible해주고 나머진 쿼리 파라미터 처리\n    return \"redirect:/basic/items/{itemId}\";\n}\n```\n\n기능 : URL 인코딩, pathVarible, 쿼리 파라미터 처리\n\n## Thymeleaf\n\n> 순수 HTML을 그대로 유지하면서 뷰 템플릿 사용 가능 (네츄럴 템플릿)\n\n[Thymeleaf 튜토리얼](https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html)\n\n사용 선언\n\n```html\n<html xmlns:th=\"http://www.thymeleaf.org\"></html>\n```\n\n@{/...} 형식을 사용하면 Thymeleaf가 context path 추가\nex) WAS안에 여러 애플리케이션 배포 시\n\n```java\n@{/basic/items}\n```\n\n# Tip!\n\n요청 데이터 종류 : 1) Get쿼리 파라미터, 2) Post - HTML Form, 3) HTTP message body\n\n응답 데이터 종류 : 1) 정적 리소스, 2) 뷰 템플릿, HTTP Message Body\n\napplication.properties - logging.level.org.apache.coyote.http11=debug  \n -> http 요청 메세지 확인 가능 (부하가 있어 개발 할 때만)\n\nredirect vs forward  \n-> 리다이렉트는 실제 클라이언트(웹 브라우저)에 응답이 나갔다가, 클라이언트가 redirect 경로로 다시 요청  \n(클라이언트가 인지할 수 있고, URL 경로도 실제로 변경)  \n -> 포워드는 서버 내부에서 일어나는 호출이기 때문에 클라이언트가 전혀 인지x\n\nMultiValueMap\n\n> 하나의 키에 여러 값을 받을 수 있다. (HTTP header, 쿼리 파라미터 같이 하나의 키에 여러 값을 받을 때 사용)\n\n```java\nMultiValueMap<String, String> map = new LinkedMultiValueMap();\nmap.add(\"key\", \"value1\");\nmap.add(\"key\", \"value2\");\n\n//[value1,value2]\nList<String> values = map.get(\"key\");\n```\n\n- 코드 짜면서 중복 vs 명확성 중 고민이면 명확성을 따르는게 좋다\n\n# Reference\n\n- [인프런]김영한 스프링 MVC 1 강의\n","excerpt":"웹 어플리케이션 웹 서버 정적 리소스 제공 (HTML, CSS, JS, 이미지, 영상) 웹 어플리케이션 서버 (WAS) 쓰레드 풀 - 필요한 쓰레드 보관, 관리 (Tomcat 최대 200개 기본 설정) 멀티 쓰레드 지원 멀티 쓰레드 환경이기 때문에 …","fields":{"slug":"/SpringStudy_3/"},"frontmatter":{"date":"Aug 18, 2022","title":"스프링 MVC 1 강의 정리 - 김영한","tags":["Spring"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n리액트는 사용자 인터페이스를 구축하는 자바스크립트 라이브러리\n\n# 왜 리액트를 사용하는가\n\nJavascript는 브라우저 내 DOM조작, 이를 통해 화면을 랜더링한다.\n\n리액트는 컴포넌트 기반의 UI 라이브러리로 자바스크립트를 유용하게 이용할 수 있게 도와준다.\n\n리액트는 응용프로그램을 작은 컴포넌트로 분리, 조합해서 사용(선언형 방식)  \n-> 유지보수와 관리 향상\n**복잡한 사용자 인터페이스를 구축하기에 용이하다**\n\n## Routing\n\n> 서드 파티 라이브러리 설치 (React-router)\n\n# Components & Building UIs\n\n> 코드를 Component단위로 분리해 관리하면 **재사용성**, **가독성** 향상\n\n## react vs reactDOM\n\n- react : UI라이브러리\n- reactDOM : 웹사이트에 출력을 도와주는 모델\n\n- React 주요 특징 중 하나는 Virtual DOM을 사용\n\n- DOM(Document Object Model) 이란?\n  > 객체로 문서 구조를 표현하는 방법으로 XML이나 HTML로 작성한다. 웹 브라우저는 DOM을 활용하여 자바스크립트와 css적용\n\n**=> ReactDOM은 브라우저에 대한 리액트 어댑터**\n\n### 페이지가 리로드 되는 과정\n\n1.  데이터를 업데이트하면 전체 UI를 Virtual DOM에 리랜더링 한다.\n2.  이전 Virtual DOM에 있던 내용과 비교\n3.  바뀐 부분만 실제 DOM에 적용\n\n### 주요 특징\n\n- 리액트는 단방향 데이터 플로우를 가지고 있다.\n- 데이터는 항상 일정한 장소에 위치하고, 그 장소에서만 변경 가능!\n- 선언적 접근 방법(state정의 -> 상태 처리)\n- reactDOM은 컴포넌트를 출력(Render)하고, Component는 항상 render, return 해야 함\n- react app은 하나의 component만 rendering (App Component)\n\npublic/index.html <- 여기에 src/index.js 가 붙여주는 방식  \n => Single Page Application\n\nTip!\n\n- import시 js파일은 확장자 생략 가능, css파일은 생략 불가능\n\n### JSX(JavaScript XML)\n\n- return으로 반환되는 Component / JSX는 반드시 root요소를 가진다.\n- css 이름을 적용할 때 - classname으로 이름 지정\n\n### React Naming\n\n- 소문자로 시작하는 요소는 내장된 html요소 -> **Component는 대문자로 시작**\n\n## Components\n\n- 자바스크립트 표현식 작성 시 JSX내부에서 {}로 감싸면 된다.\n- 부모 컴포넌트로 부터 자식 컴포넌트로 값을 전달시 props로 사용\n- 여러개의 컴포넌트를 하나의 컴포넌트로 조합해 사용 -> **합성(Composition)**\n- **Wrapper Component** - 여러 컴포넌트를 감싸는 방식\n- **props.children** 자식 엘리먼트를 출력에 전달 가능\n\n# Working with Events, state & props\n\n- 리액트는 모든 기본 이벤트를 **on으로 시작하는 props**로 나타낸다\n- 모든 이벤트 핸들러는 props값으로 **함수 필요**\n- 이벤트는 모두 DOM 기본 동작에 기반\n- [react 이벤트 종류](https://ko.reactjs.org/docs/events.html)\n\n### onChange vs onInput\n\n> onChange은 모든 입력 입력타입에 같은 이벤트 사용 가능\n\n## State\n\n> 리액트는 원하는 state 설정 => state에 맞게 화면 rendering\n\n- State는 컴포넌트 객체 별로 나뉘어져서 따로 관리된다.\n\n### useState\n\n```javascript\n// useState에서 반환되는 값 1) 상태명, 2) 1에서 정한 상태를 변경하는 함수\nconst [name, setName] = useState(props.name);\n```\n\n### State Update\n\n> 이전 상태에 따라 상태를 업데이트 할 때 아래 처럼 callback 함수로 구현\n\n```javascript\nconst titleChangeHandler = (event) => {\n  setUserInput((prevState) => {\n    return { ...prevState, title: event.target.value };\n  });\n};\n```\n\n## Lifting State Up\n\n> props로 함수를 넘겨 전달 (자식 -> 부모 컴포넌트로 값 전달)\n\n## stateless component\n\n> 데이터 출력만을 위한 컴포넌트(해당 컴포넌트에서 관리하는 state 없음)\n\n# Working with Dynamic Contents\n\nreact 컴포넌트 별로 key값을 지정할 수 있음  \n-> 이렇게 지정하면 업데이트 할 때 특정 위치에 정확히 삽입 가능  \n-> key가 없으면 값을 추가하는 위치를 정확히 인지하지 못해서 rerendering이 일어남 -> 성능상 이슈  \n-> 목록 리스트가 존재하면 key값을 주는게 좋다\n\n## Rendering List\n\n> array 객체의 map함수 이용 동적으로 contents 추가\n\n```javascript\nconst itemfilter = props.items.filter((item) => {\n  return item.date.getFullYear().toString() === selectedDate;\n});\n\n...\n\nreturn (\n  <div>\n    {\n      itemfilter.map((item) => <ExpenseItem key={item.id} title={item.title} amount={item.amount} date={item.date} />);\n    }\n  </div>\n)\n```\n\nfilter함수를 추가해 조건에 따라 contents 반환 할 수 있다.\n\n## Conditional Content\n\n> {} 안에 3항 연산자를 사용해 조견별 component 출력이 가능하다\n\nTip!!\n\n- 하나의 긴 표현식 보다 독립된 조건식을 사용해 더 깔끔한 코드 작성 가능\n\n# Styling Components\n\nComponent에 스타일을 적용하는 방법은 4가지\n\n## 1) 인라인 요소로 css 추가\n\nhtml태그의 style속성을 동적으로 줘서 css변경 가능\n\n```javascript\nlet barFillHeight = '20%';\n\n<div className=\"bar\" style={{ height: barFillHeight, backgroundColor: 'red' }}></div>;\n```\n\n위 방식대로 style을 주면 **인라인 방식**이라 코드 가독성이 떨어짐\n\n## 2) .css파일로 분리\n\n**className을 동적으로 변경**해서 css 적용 가능  \n-> 같은 class name을 사용하는 경우 문제\n\n## 3) Styled Components\n\n> 서드 파티 라이브러리, 고유한 범위를 가진 스타일로 미리 스타일이 지정된 컴포넌트로 지정 가능\n\n```javascript\nconst FormControl = styled.div`\n  margin: 0.5rem 0;\n  & label {\n    font-weight: bold;\n    display: block;\n    margin-bottom: 0.5rem;\n    color: ${(props) => (props.invalid ? 'red' : 'black')};\n  }s\n`;\n```\n\n- styled를 import해 객체를 만들어 사능\n- HTML의 모든 태그가 정의되어 있음\n- props를 전달해 동적으로 변환 가능\n- 미디어 쿼리 적용 가능\n\n## 4) CSS Module\n\nreact css module 사용\n\n```javascript\nimport styles from \"./Button.module.css\";\n\n...\n\nconst Button = (props) => {\n  return (\n    <button type={props.type} className={styles.button} onClick={props.onClick}>\n      {props.children}\n    </button>\n  );\n};\n\n```\n\n- **컴포넌트 이름*클래스 이름*해시 값**으로 동적으로 클래스명이 생긴다.\n\n[babel-plugin-react-css-modules](https://github.com/gajus/babel-plugin-react-css-modules)\n\n# Fragments, Portals & Refs\n\n## Fragments\n\n> 리액트는 HTML태그를 트리 구조로 생성하기 때문에 루트 태그가 반드시 필요\n\n빈 div태그로 감싸는 방법 -> 많은 태그들이 생기면서 성능상에도 좋지 않을 수 있음  \n **=> <React.Fragment>** 사용\n\n- 1. Wrapper 태그 생성\n\n```javascript\nconst Wrapper = (props) => {\n  return props.chilren;\n};\n```\n\n- 2. React.Fragment 사용 - 빈 Wrapper 렌더링\n\n```javascript\n<React.Fragment>\n\n</React.Fragment>\n\n<>\n\n</>\n```\n\n## Portals & Refs\n\n### Portals\n\n> 메인 DOM 외부에 앨리먼트 일부를 그리기 위한 기능\n> (앨리먼트를 다른 돔으로 옮겨 CSS 상속 구조에 영향 받지 않음)\n\nex) 모달, 사이드 드로워\n\n```javascript\nimport ReactDOM from \"react-dom\";\n\n...\nreturn\n<React.Fargment>\n  // createPortal 함수 사용\n  // 1. 렌더링 되는 리액트 노드 (JSX 주의)\n  // 2. 렌더링 되어야 하는 실제 DOM 컨테이너 (실제 HTML DOM요소 - Browser API 사용)\n  ReactDOM.createPortal(<Backdrop />, document.getElementById('backdrop-root'))\n</React.Fargment>\n```\n\n### Refs\n\n> 다른 DOM요소에 접근해 사용 가능\n\ninput같은 경우 키 입력마다 state를 변경하는 것은 비 효율적  \n**-> useRef사용**\n\n```javascript\nconst inputData = useRef();\n```\n\n- 모든 훅과 마찬가지로 함수형 컴포넌트에만 사용 가능\n- 사용하고 싶은 태그로 가서 ref 속성 추가\n- 어떤 HTML요소라도 하나에 연결 가능\n- 반환값으로 **객체 전달** -> {변수}.current.value 값 사용\n\n#### Refs값을 재설정 하는 방법\n\n1. Ref 변수를 직접 변경\n\n2. stateHandler함수로 state 변경\n\n> 단순히 값을 변경하는 것으로 **Ref 변수를 직접 변경하는 것을 추천**\n\n#### 제어 컴포넌트 vs 비제어 컴포넌트\n\n> React에 의해 값이 제어되는 입력 폼 엘리먼트 “제어 컴포넌트 (controlled component)“ ex) input, textarea, select\n\n```javascript\n// 제어 가능한 컴포넌트 -> 항상 최신값으로 유지\n<input type=\"text\" value={title || ''} onChange={titleChangeHandler} />\n// 비 제어 컴포넌트 -> 필드에서 값을 트리거해 값 사용\n<input id=\"age\" type=\"number\" ref={ageInputRef} />\n```\n\n제어 가능한 컴포넌트 -> 항상 최신값으로 유지  \n비 제어 컴포넌트 -> 필드에서 값을 트리거해 값 사용\n\n| 기능                         | 제어 컴포넌트 | 비제어 컴포넌트 |\n| ---------------------------- | ------------- | --------------- |\n| 일회성 정보 제출             | O             | O               |\n| 제출 시 값 검증              | O             | O               |\n| 실시간 필드 값 검사          | O             | X               |\n| 조건부로 제출 버튼 비 활성화 | O             | X               |\n| 실시간 입력 형식 적용        | O             | X               |\n| 동적 입력                    | O             | X               |\n\n# Tip!!\n\n## npm error 날 경우\n\n```bash\n$ npm cache clean --force\n$ rm -rf node_modules package-lock.json\n$ npm install\n```\n\n## 객체에 Number 저장\n\n간혹가다 숫자로 객체를 생성하려다가 문자열로 생성되는 경우가 있는데  \n+를 붙여줘 형변환이 일어나게 저장하면 문제 해결 가능\n\n```javascript\nconst data = {\n  name : name,\n  age : +age\n  date : date\n}\n```\n\n## 함수에 언더스코어(\\_)를 붙여서 만듬\n\n-> 이유는, 리액트는 자체 기능이 많기 때문에 리액트 자체기능과 구분하기 위해서\n\n# Reference\n\n- [Udemy - React 완벽 가이드 with Redux, Next.js, TypeScript](https://www.udemy.com/course/best-react/learn/lecture/28517643#overview)\n- [React: 제어 컴포넌트와 비제어 컴포넌트의 차이점](https://velog.io/@yukyung/React-제어-컴포넌트와-비제어-컴포넌트의-차이점-톺아보기)\n- [Controlled and uncontrolled form inputs in React don't have to be complicated](https://goshacmd.com/controlled-vs-uncontrolled-inputs-react/)\n- [https://dev.to/dylanju/useref-3j37](https://dev.to/dylanju/useref-3j37)\n","excerpt":"리액트는 사용자 인터페이스를 구축하는 자바스크립트 라이브러리 왜 리액트를 사용하는가 Javascript는 브라우저 내 DOM조작, 이를 통해 화면을 랜더링한다. 리액트는 컴포넌트 기반의 UI 라이브러리로 자바스크립트를 유용하게 이용할 수 있게 도와준…","fields":{"slug":"/reactStudy_1/"},"frontmatter":{"date":"Aug 15, 2022","title":"React 핵심 기능","tags":["React"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# JAR vs WAR\n\n> JAVA jar툴을 이용해 생성된 압축 파일이며 **어플리케이션을 배포하고 동작시킬 수 있도록 관련된 파일(리소스, 설정파일)을 패키징**\n\n## JAR(Java Archive)\n\n- JAVA 어플리케이션이 동작할 수 있도록 자바 프로젝트를 압축한 파일\n- Class (JAVA리소스, 속성 파일), 라이브러리 파일을 포함(ZIP 파일 포맷으로 압축)\n- **JRE(JAVA Runtime Environment)만 있어도 실행 가능**\n- (BOOT-INF, META-INF, org) // 원하는 구조로 JAR 파일 구성 가능\n- 내장 서버 사용에 최적화\n- 명령줄에서 JAR실행 가능\n\n## WAR(Web Application Archive) .\n\n- 웹 관련 자원을 포함함 (JSP, Servlet, JAR, Class, XML, HTML, Javascript)\n- 실행시켜주기 위해서 웹서버(WEB) 또는 웹컨테이너(WAS)가 필요\n- **외부 WAS사용하는 경우 사용**\n- **JAR파일의 일종**으로 웹 애플리케이션 전체를 패키징 하기 위한 JAR 파일\n- 외장 서버 사용에 최적화\n- (WEB-INF, META-INF, org)\n\n**Sprinag boot 표준 JAR**\n\n# Reference\n\n- [java-jar-war-packaging - BAELDUNG](https://www.baeldung.com/java-jar-war-packaging)\n- [Springboot docs](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#appendix.executable-jar)\n","excerpt":"JAR vs WAR JAVA jar툴을 이용해 생성된 압축 파일이며 어플리케이션을 배포하고 동작시킬 수 있도록 관련된 파일(리소스, 설정파일)을 패키징 JAR(Java Archive) JAVA 어플리케이션이 동작할 수 있도록 자바 프로젝트를 압축한 …","fields":{"slug":"/JARWAR/"},"frontmatter":{"date":"Jul 13, 2022","title":"JAR vs WAR","tags":["Spring"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# Spring\n\n> 스프링의 가장 큰 핵심은 **좋은 객체지향 어플리케이션 개발**에 도움\n\n## 1. 객체 지향 설계\n\n### 역할(인터페이스)과 책임(구현체) 분리\n\n- 구현체를 **실행 시점에 유연하게 변경가능**  \n  => 클라이언트 변경 없이 서버 구현기능 변경\n- 의존관계 주입(DI), 제어의 역전(IoC)\n\n### 좋은 객체지향 설계의 5가지 원칙\n\n#### SRP: 단일 책임 원칙(single responsibility principle)\n\n- 한 클래스는 하나의 책임\n- **변경 / 변경이 있을 때 파급효과가 적어야 함**\n\n#### OCP: 개방-폐쇄 원칙 (Open/closed principle)\n\n- 역할과 책임 분리\n- 인터페이스를 구현한 클래스(구현체)로 기능 구현\n- 객체 생성, 연관관계 생성, 설정자가 필요\n\n#### LSP: 리스코프 치환 원칙 (Liskov substitution principle)\n\n- 컴파일에 성공하는 것을 넘어서 기능까지 만족해야 한다.\n\n#### ISP: 인터페이스 분리 원칙 (Interface segregation principle)\n\n- 특정 클라이언트를 위한 여러개의 인터페이스가 범용 인터페이스 보다 낫다\n\n#### DIP: 의존관계 역전 원칙 (Dependency inversion principle)\n\n- 추상화에 의존해야하고 구체화에는 의존하면 안된다\n- (Interface 에만 의존해야 한다.)\n\n## 관심사 분리\n\n구현 객체에서 직접 추상화된 객체 의존을 선택하게 되면 DIP에 위반된다.  \n -> **구현 객체와 추상화된 객체를 연결하는 설정 클래스**로 관리한다. -> AppConfig  \n => 이렇게 하면 **구성 영역**과 **사용 영역**으로 분리하는 효과를 가진다.\n\n## 2. IoC, DI, Container\n\n### 제어의 역전 (IoC)\n\n> 프로그램이 **객체의 생성**관리\n\n### DI\n\n> 실행 시점(런타임)에 외부에서 구현 객체를 생성해 의존관계 설정  \n>  -> **동적으로 객체 의존관계 변경 가능**\n\n### 프레임워크 vs 라이브러리\n\n- 프레임워크 : 프로그램이 코드 제어 및 실행\n- 라이브러리 : 내가 작성한 코드가 제어의 흐름 담당\n\n### DI Container\n\n> 객체 생성, 관리, 의존관계 연결\n\n## 3. Container, Bean\n\n### **ApplicationContext** 스프링 컨테이너(Interface)\n\n```java\nAnnotationConfigApplicationContext ac =\n  new AnnotationConfigApplicationContext(AppConfig.class) // 매개변수로 구성 정보 지정\n```\n\n- XMl / Annotation 기반으로 스프링 컨테이너 생성 가능\n- 스프링 컨테이너를 생성할 땐 **구성 정보**를 지정해줘야 한다\n- Bean은 key-value형태로 저장이되고, **항상 다른 이름을 사용**해야 한다.\n- MessageSource(국제화), EnviromentCapable(로컬, 개발, 운영 구분)\n- ApplicationEventPublisher(이벤트 발행, 구독 모델 지원)\n- ResourceLoader(파일, 클래스패스 리소스 조회)\n\n### **bean 조회**\n\n> 빈을 조회할 때 부모타입으로 조회하면, **자식 타입도 함께 조회**\n\n```Java\nString[] beanDefinitionNames = ac.getBeanDefinitionNames(); // 모든 빈 조회\n\nfor (String beanDefinitionName : beanDefinitionNames) {\n  BeanDefinition beanDefinition = ac.getBeanDefinition(beanDefinitionName);\n  // ROLE_APPLICATION : 사용자 정의 빈\n  // ROLE_INFRASTRUCTURE : 스프링 내부 빈\n  if (beanDefinition.getRole() == BeanDefinition.ROLE_APPLICATION) {\n    Object bean = ac.getBean(beanDefinitionName);  // 빈 이름으로 빈 객체 조회\n    // ac.getBean(빈이름, 타입)                    // 빈 이름과 타입으로 빈 객체(인스턴스)를 조회\n    System.out.println(\"name=\" + beanDefinitionName +\n    \" object=\" + bean);\n  }\n}\n```\n\n**BeanFactory**\n\n- 스프링 컨테이너 최상위 인터페이스\n- 빈 관리, 조회하는 역할\n- getBean제공\n\n## 스프링 빈 설정 메타 정보 - BeanDefinition\n\n> 역할 / 구현 개념 분리 => **스프링 컨테이너는 이 메타 정보를 기반으로 빈 생성**\n\n<details>\n<summary><b>BeanDefinition 정보 (Toggle)</b></summary>\n<div markdown=\"1\">       \nBeanClassName: 생성할 빈의 클래스 명(자바 설정 처럼 팩토리 역할의 빈을 사용하면 없음)</br>\nfactoryBeanName: 팩토리 역할의 빈을 사용할 경우 이름, 예) appConfig </br> \nfactoryMethodName: 빈을 생성할 팩토리 메서드 지정, 예) memberService  </br>\nScope: 싱글톤(기본값)  </br>\nlazyInit: 스프링 컨테이너를 생성할 때 빈을 생성하는 것이 아니라, 실제 빈을 사용할 때 까지 최대한 생성을 지연처리 하는지 여부  </br>\nInitMethodName: 빈을 생성하고, 의존관계를 적용한 뒤에 호출되는 초기화 메서드 명  </br>\nDestroyMethodName: 빈의 생명주기가 끝나서 제거하기 직전에 호출되는 메서드 명 Constructor arguments, Properties: 의존관계 주입에서 사용한다.  </br>\n - (자바 설정 처럼 팩토리 역할의 빈을 사용하면 없음)  </br>\n</div>\n</details>\n\n스프링이 **다양한 형태의 설정 정보를 추상화해서 사용**\n\n## 4. Singleton Container\n\n> 클래스 객체가 1개만 생기는 디자인 패턴\n\n-> **private 생성자를 사용해 임의로 new키워드 사용 방지**\n\n대부분 싱클톤패턴을 사용한다.  \n(HTTP Request LifeCycle, HTTP Session LifeCycle에 Bean LifeCycle 맞추는 경우같이 아주 특별한 경우에만 싱글톤을 사용하지 않음)\n\n싱글톤 객체를 **생성, 관리**하는 기능을 **싱글톤 레지스트리**라 한다\n\n### Singleton 방식 주의점!!\n\n> 여러 클라이언트가 같은 객체를 공유하기 때문에 **상태를 유지하게** 설계하면 안된다.\n\n- 특정 클라이언트에 **의존적인 필드**가 있으면 안된다.\n- 값을 **변경할 수 있는 필드**가 있으면 안된다.\n- 가급적 **읽기만 가능하게**\n- 필드 대신에 자바에서 **공유할 수 없는 지역변수, 파라미터, ThreadLocal** 등을 사용\n- 스프링 빈 항상 **무상태(stateless)**로 설계\n\n### Configuration 어노테이션\n\n> Configuration 어노테이션은 빈의 **싱글톤을 보장**해준다.\n> (Bean만 사용해도 등록은 되지만, 싱글톤x)\n\n## 5. Component Scan\n\n> 설정 정보가 없어도 자동으로 Bean 등록 -> **Autowired** 어노테이션으로 의존성 주입\n\nComponent Scan은 @Component가 붙은 모든 클래스를 빈으로 등록\n\n- 기본 전략 : 기본이름은 클래스 명을 사용하되 **맨 앞글자만 소문자로 사용**  \n  ex) UserImpl 클래스 -> userImpl\n- 직접 지정 : 지정하고 싶은 이름을 @Component 매개변수에 등록\n\n### ComponentScan 옵션\n\n- basePackages : 패키지로 시작위치 지정\n- basePackageClasses : 클래스 위치로 지정\n- includeFilters : 추가 지정\n- excludeFilters : 제외할 대상 지정\n\n### 부가기능이 있는 어노테이션\n\n@Controller : 스프링 MVC 컨트롤러  \n@Repository : 데이터 접근 계층 인식 - 데이터 계층 예외 -> 스프링 예외로 변환  \n@Configuration : 스프링 설정 정보 인식 / 싱글톤 유지  \n@Service : 특별한 처리 x - 개발자들이 비즈니스 로직 구분하기 위한 용도\n\n<details>\n<summary><b>FilterType 정보 (Toggle)</b></summary>\n<div markdown=\"1\">       \nANNOTATION: 기본값, 애노테이션 인식 ex) org.example.SomeAnnotation</br>\nASSIGNABLE_TYPE: 지정한 타입과 자식 타입 인식 ex) org.example.SomeClass</br>\nASPECTJ: AspectJ 패턴 사용 </br>\nex) org.example..*Service+ </br>\nREGEX: 정규 표현식 </br>\nex) org\\.example\\.Default.* </br>\nCUSTOM: TypeFilter 이라는 인터페이스를 구현해서 처리 ex) org.example.MyTypeFilter </br>\n\n<div markdown=\"java\">\n  includeFilters = @Filter(type = FilterType.ANNOTATION, classes = MyIncludeComponent.class)\n</div>\n</div>\n</details>\n\n## 6. 의존 관계\n\n### 의존관계 주입\n\n#### 1. 생성자 주입\n\n> 생성자 호출 시점에 한번 호출, **불변, 필수**\n\n#### 2. 수정자 주입 (setter)\n\n> **선택, 변경** 가능성이 있는 의존관계에서 사용\n\n#### 3. 필드 주입\n\n#### 4. 일반 메서드 주입\n\n### 옵션 처리\n\n> Bean이 없어도 동작해야 할 때\n\n@Autowired(required=false) : 자동 주입할 대상이 없으면 수정자 메서드 호출 안됨  \n@Nullable : null  \nOptional<> : Optional.empty\n\n### 생성자 주입의 장점\n\n- 대부분 의존관계는 애플리케이션 종료시까지 변경이 없음.\n- 객체를 불변하게 설정해, 개발자가 실수로 객체를 변경할 경우 방지\n\n**Tip!!**\n\n- 생성자가 하나만 있으면 @Autowired 생략 가능\n- Lombok 라이브러리 @RequiredArgsConstructor 사용 -> final붙은 필드 모아서 생성자 자동 생성\n\n```java\n@Controller\n@RequestMapping(\"/items\")\n@RequiredArgsConstructor\npublic class BasicItemController {\n\n  private final ItemRepository itemRepository;\n\n  // 생략 가능\n  // @Autowired\n  // public BasicItemController(ItemRepository itemRepository) {\n  //     this.itemRepository = itemRepository;\n  // }\n}\n```\n\n### 조회 대상 빈이 2개 이상일 경우 해결 방법\n\n#### 1) @Autowired 필드 명 매칭\n\n> Autowired 타입 매칭 시도 -> 여러빈 있을 경우 -> 필드이름 -> 파라미터 이름 순으로 추가 매칭\n\n#### 2) @Quilifier -> @Quilifier끼리 매칭 -> 빈 이름 매칭\n\n```java\n@Component\n@Qualifier(\"{부르고 싶은 구분자}\")\npublic class RateDiscountPolicy implements DiscountPolicy {\n  ...\n}\n```\n\n```java\n@Autowired\npublic OrderServiceImpl(MemberRepository memberRepository,\n  @Qualifier(\"{부르고 싶은 구분자}\") DiscountPolicy discountPolicy) {\n  this.memberRepository = memberRepository;\n  this.discountPolicy = discountPolicy;\n}\n```\n\n1. @Qualifier 매칭\n2. 빈 이름 매칭\n3. NoSuchBeanDefinitionException 예외 발생\n\n#### 3) @Primary\n\nex) 메인 DB Connection / 서브 DB Connection -> 이런 경우 코드 가독성 향상 가능!\n\n**@Qualifier > @Primary 순으로 적용된다.**\n\n#### Tip!!\n\nQualifier는 문자라 컴파일 시 타입 체크가 안됨 -> **어노테이션**을 사용해 조금 더 깔끔하게 코드 관리 가능!\n\n### 모든 빈을 조회할 경우\n\n> 전략 패턴 매우 쉽게 구현 가능\n\n```java\n@Test\nvoid findAllBean() {\n  ApplicationContext ac = new AnnotationConfigApplicationContext(AutoAppConfig.class, DiscountService.class);\n  DiscountService discountService = ac.getBean(DiscountService.class);\n\n  Member member = new Member(1L, \"userA\", Grade.VIP);\n\n  int discountPrice = discountService.discount(member, 10000, \"fixDiscountPolicy\");\n\n  assertThat(discountService).isInstanceOf(DiscountService.class);\n  assertThat(discountPrice).isEqualTo(1000);\n}\n\nstatic class DiscountService {\n  private final Map<String, DiscountPolicy> policyMap;\n\n  public DiscountService(Map<String, DiscountPolicy> policyMap){\n      this.policyMap = policyMap;\n  }\n\n  public int discount(Member member, int price, String discountCode) {\n      DiscountPolicy discountPolicy = policyMap.get(discountCode);\n      return discountPolicy.discount(member, price);\n  }\n}\n```\n\n### 자동 주입 빈 vs 수동 주입 빈\n\n업무 로직 빈 : 비즈니스 요구 사항  \n기술 지원 빈 : 공통 관심사(AOP), DB연결, 로그 처리\n\n기술 지원 빈은 **수가 적고, 어플리케이션에 광범위하게 영향**을 준다.  \n-> **수동 빈으로 명확하게 들어내는 것이 좋다.**  \n(스프링 부트가 자동으로 등록하는 빈 제외)\n\n스프링 다형성을 활용할 때 (전략 패턴)  \n -> 한번에 설정 정보를 보기 위해 수동 빈이 보기 좋을때 있다.\n\n## 7. Bean LifeCycle Callback\n\n> 어플리케이션을 시작 시점, 종료시점에 **초기화 및 종료** 작업이 필요한 경우  \n>  ex) DB Connection pool, Network Socket\n\n빈은 간단히 보면\n객체 생성 -> 의존관계 주입\n을 가진다.\n\n**스프링 빈 이벤트 라이프 사이클**  \n스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입 -> **초기화 콜백** -> 사용 -> **소멸전 콜백** -> 스프링 종료\n\n간단한 경우 생성자에서 초기화해주는게 좋지만, 유지보수 관점에서 보면 **생성과 초기화는 분리하는게 좋다.**\n\n크게 3가지 방법으로 빈 생명주기 콜백 지원\n\n1. 인터페이스(InitializingBean, DisposableBean)\n2. 설정 정보에 초기화 메서드, 종료 메서드 지정\n3. @PostConstruct, @PreDestroy 어노테이션\n\n2,3 번 방법 사용 -> 스프링 빈이 스프링 코드에 의존하지 않는다.\n\n### 설정 정보에 초기화 메서드, 종료 메서드 지정\n\n```java\n@Configuration\nstatic class LifeCycleConfig {\n    @Bean(initMethod = \"init\", destroyMethod = \"close\") // 초기화, 종료 메서드 지정\n    public NetworkClient networkClient() {\n      NetworkClient networkClient = new NetworkClient();\n      networkClient.setUrl(\"http://hello-spring.dev\");\n      return networkClient;\n    }\n}\n```\n\n- 메서드 이름 자유롭게 줄 수 있다.\n- **코드 고칠 수 없는 외부 라이브러리** 초기화, 종료 메서드 적용\n- destroyMethod 에 값을 지정해주지 않으면 close, shutdown같은 이름의 종료 메서드 추론하여 동작\n  => 사용하지 않으려면 destroyMethod=\"\" 같이 빈 공백 지정해서 사용\n\n### @PostConstruct, @PreDestroy\n\n> 초기화 및 종료 하고싶은 메서드에 어노테이션을 단다.\n\n- 외부라이브러리 사용 불가능\n\n일반적인 경우엔 @PostConstruct, @PreDestroy사용 / 외부 라이브러리 경우 @Bean 사용\n\n## 8. Bean scope\n\n> 빈이 존재할 수 있는 범위\n\n- Singleton : 기본 스코프, 스프링 컨테이너 시작 ~ 종료까지 유지되는 스코프 (기본)\n- Prototype : 빈의 생성, 의존관계 주입까지만 관여\n\nPrototype Bean 의존 관계 주입, 초기화까지 처리 -> 빈 관리 책임은 클라이언트에 있다.  \n(@PostConstruct, @PreDestroy같은 종료메서드 호출되지 않는다.) .\n\n### Singleton, Prototype 같이 쓸 경우 문제점\n\n> getBean을 통해 Bean을 주입하면 스프링 컨테이너에 종속적인 코드가 되서 새로운 빈이 생기지 않음\n\nDL(의존관계 조회(탐색)) -> **ObjectProvider** (ObjectFactory 상속) .\n\n- 스트림 처리같은 편의 기능 제공, 별도의 라이브러리 필요x\n\n- 웹관련 스코프\n  - request : 웹 요청 ~ 종료\n  - session : 웹 세션이 생성 ~ 종료\n  - application : 서블릿 컨텍스트와 같은 범위로 유지되는 스코프\n  - websocket : 웹 소켓과 동일한 생명주기를 가지는 스코프\n\n### Tip!!\n\n- Spring-boot-web을 사용하면 AnnotationConfigServletWebServerApplicationContext 기반으로 애플리케이션 구동\n\nrequest scope 가진 빈 -> 실제 고객 요청이 와야 생성\n\n### 해결 방법 1)\n\n> ObjectProvider 사용\\*\\* -> bean생성을 getObject를 실행하는 시점까지 생성 지연\n\n### 해결 방법 2)\n\n> 프록시 사용\n\n```java\n@Scope(value = \"request\", proxyMode = ScopedProxyMode.TARGET_CLASS)\n```\n\nScope에 proxy설정을 하면 컨테이너는 **CGLIB** 라이브러리를 사용해 **프록시 객체 생성**  \n -> 진짜 빈을 요청하는 위임 로직 **(객체 조회를 필요 시점까지 지연 처리가 핵심)**  \n -> 실제 싱글톤 객체와 다르게 동작하기 때문에 주의해서 사용!\n\n# Test Tip!!\n\n- Assertions 객체는 상단에 선언하고 사용하는게 좋다.\n","excerpt":"Spring 스프링의 가장 큰 핵심은 좋은 객체지향 어플리케이션 개발에 도움 1. 객체 지향 설계 역할(인터페이스)과 책임(구현체) 분리 구현체를 실행 시점에 유연하게 변경가능 => 클라이언트 변경 없이 서버 구현기능 변경 의존관계 주입(DI), 제…","fields":{"slug":"/SpringStudy_2/"},"frontmatter":{"date":"Mar 01, 2022","title":"스프링 핵심 원리 강의 정리 - 김영한","tags":["Spring"],"update":"May 01, 2022"}}},{"node":{"rawMarkdownBody":"\n# Spring\n\n**Maven / Gradle** - 프로젝트 의존성 관리 도구\n\nController에서 리턴 값으로 문자를 반환 시 viewResolver 화면을 찾아서 처리한다.\n\n**resources:templates/ +{ViewName}+ .html**  \n해당 경로를 기본적으로 읽는다.\n\n## build\n\n```markdown\n1. .gradlew build\n2. cd build/libs\n3. jar파일 실행\n```\n\n## API\n\n> @RequestBody 어노테이션 사용\n\n- viewResolver 대신 HttpMessageConverter 동작\n- 기본 문자 처리 : StringHttpMessageConverter\n- 기본 객체 처리 : MappingJackson2HttpMessageConverter  \n  ++ 응답을 위한 여러 HttpMessageConverter가 포함되어 있다.\n\n1. HTTP Header\n2. 서버의 반환 정보\n   => HttpMessageConverter가 선택된다.\n\n## 일반적인 웹 어플리케이션 구조\n\n```text\n컨트롤러 -> 서비스 -> 레포지토리 -> db\n            도메인\n```\n\nController : MVC 컨트롤러  \nService : 비즈니스 로직  \nRepository : DB접근, 도메인 객체 저장 및 관리  \nDomain : 비즈니스 도메인 객체\n\n## 테스트 케이스 작성\n\n> Junit\n\n## DI(의존성 주입)\n\n> Service에서 직접 객체를 선언해 사용하지 않고 외부에서 객체를 만들어 전달해 사용\n\n- 컴포넌트 스캔과 자동 의존관계 설정 -> 스프링 부트 어노테이션  \n  ex) Controller, Repository, Service, Autowired\n\n```\n@Autowired를 통한 DI는 helloConroller , memberService 등과 같이\n스프링이 관리하는 객체에서만 동작한다.\n```\n\n- Bean객체는 Singleton으로 관리\n- DI에는 필드 주입, setter 주입(수정자를 통한 주입), 생성자 주입 3가지 방법  \n  (의존관계가 실행중에 동적으로 변하는 경우는 거의 없으므로 생성자 주입을 권장한다.)\n- 정형화 되지 않거나, **상황에 따라 구현 클래스 변경**하는 경우 설정(@Configuration)을 통해 스프링 빈 등록\n\n**생성자 주입**\n\n```Java\n@Controller\npublic class MemberController {\n    private final MemberService memberService;\n\n    @Autowired\n    public MemberController(MemberService memberService) {\n        this.memberService = memberService;\n    }\n}\n```\n\n## 생성자 주입의 장점\n\n- 의존관계 설정이 되지 않으면 객체 생성 불가  \n   -> **컴파일 타임에 인지 가능, NPE(Null Point Exception) 방지**\n- 필드 final 변수로 사용  \n   -> **런타임에 객체 불변성 보장**\n- 테스트 코드작성 용이  \n   -> **스프링에서 순환참조 확인가능**\n\n## H2\n\nh2 설치 하면 처음엔 파일을 읽는데 서버로 읽게 경로를 수정해준다.  \njdbc:h2:tcp://localhost/~/test\n\n## Test\n\n- Test 코드 작성 시, 편의에 따라 필드주입 사용 (의존관계가 별로 중요하지 않을 경우)\n- **@Transaction** : DB Transaction을 시작하고 롤백해줘서 DB에 영향을 주지 않는다.\n- **@SpringBootTest** : Spring Container, Test 함께 실행\n\n# 스프링 DB 접근 기술\n\n## 1. 순수 Jdpc\n\n## 2. JdbcTemplate\n\n- 순수 Jdpc를 Template Method패턴으로 반복코드 제거 (sql은 직접 작성)\n\n## 3. JPA\n\n- 반복 코드 제거 (SQL까지) -> 개발 생산성 향상\n- SQL과 데이터 중심의 설계 -> 객체 중심의 설계로 패러다임을 전환\n\n## 사용\n\n- dependency, application.properties 추가\n\n### application.properties\n\n```markdown\nshow-sql : JPA가 생성하는 SQL을 출력한다.\nddl-auto : 테이블을 자동으로 생성하는 기능 제공\n-> none / create(entity정보를 바탕으로 테이블 생성)\n```\n\n# AOP(Aspect Oriented Programming)\n\n- 특정 로직을 공통적으로 적용해야 하는 경우  \n  ex) 시간 체크\n- 공통 관심 사항 vs 핵심 관심 사항 분리\n\n# Tip!!\n\n## IntelliJ\n\n- Preferences - gradle 에서 Build and run 옵션 Intellij로 변경하면 빨라진다.\n\n## Spring\n\n1. null 반환 대신 Optional로 감싸서 반환해라  \n   -> **클라이언트에서 해당 값 사용**,  \n   -> Optional 함수 사용 가능 // ifPresent\n\n2. 동시성 문제 때문에 long, map 대신 다른 변수 사용한다.\n\n3. Test 전체 실행 시, 순서 보장이 안된다.  \n   -> Test case를 작성 시 **순서에 영향 받지 않아야 한다.**  \n   -> **@AfterEach**, **@BeforeEach** : Test가 끝날 때 마다 실행시켜주는 Call back method\n\n4. Service naming -> 비즈니스 로직에 맞게  \n   Repository naming -> 조금 더 개발자스럽게\n\n5. HashMap 대신 실무에서는 동시성 문제가 고려해 **ConcurrentHashMap, AtomicLong** 사용 고려\n\n## 문제 상황 해결\n\n애플리 케이션을 실행시켜 주면 중간에 이상한 로그들이 보였는데\n![](debug.png)\n\nspring-boot-starter로 프로젝트는 dependency들을 해결하기 위해 많은 class를 가지고 있으며,  \n이를 자동으로 해결해 주는 것을 autoconfiguration이라고 한다.\n\nstarter에서 classpath내의 class들을 훑으며 프로젝트에 필요한 클래스 등을 판별하는데,  \n프로젝트에 필요한 클래스라면 matched를, 프로젝트에 필요 없는 클래스라면 did not match  \n알려주는 로그  \n(문제 x)\n","excerpt":"Spring Maven / Gradle - 프로젝트 의존성 관리 도구 Controller에서 리턴 값으로 문자를 반환 시 viewResolver 화면을 찾아서 처리한다. resources:templates/ +{ViewName}+ .html 해당 경…","fields":{"slug":"/SpringStudy_1/"},"frontmatter":{"date":"Feb 02, 2022","title":"스프링 입문 강의 정리 - 김영한","tags":["Spring"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n오랜만에 포스팅이다.\n\n이전 글에서 정리 하기로 했던 부분은 프론트 관련 내용은 천천히 정리하고....\n\n코드를 짜면서 고민이 많이 들었던 부분부터 생각정리 해보려고 한다.\n\n개발자는 독자(동료, 미래의 나)가 있는 글(코드)을 작성하는데 \n\n독자가 있는 만큼 읽기 좋은 코드로 작성해야 한다.\n\n사람이 짜니 항상 똑같을 수는 없겠지만 어느정도 가이드는 필요하니 생각정리 해보자\n\n# 분기 처리\n\n## 1. 여러 조건 처리시 배열 활용\n\n**Java**\n\n1) asList / contains 사용  \n```Java\nString[] fruits = [\"apple\", \"orange\", \"banana\"];\nSystem.out.println(Arrays.asList(fruits).contains(\"apple\")); // true\n```\n\n2) equals 사용 \n```Java\nString[] arr = [\"apple\", \"orange\", \"banana\"];\nfor(String s : arr){\n  if(s.equals(\"apple\")){\n    return true;\n  }\n  return false;\n}\n```\n\n**Javascript**  \n\n```javascript\nvar fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];\n// console.log( fruits.includes('Banana') ); \nconsole.log( fruits.indexOf('Banana') >= 0 ); \n// includes 함수는 IE에서 동작하지 않으니 indexOf 함수를 사용\n```\n\n**Python**  \n```python\nfruits = ['Apple', 'Banana', 'Orange']\nprint('Apple' in fruits)\n```\n\n## 2. 조기 리턴 사용\n\n예외 상황에 대해 먼저 빠져나가게 하는 것\n\n[if only VS if else - 개발요정님 블로그](http://blog.cowkite.com/blog/2102231449/)  \n추가로 잘 정리한 글이 있어서 링크 남긴다.\n\n## 3. 조건식이 직접 관련된 부분 간소화\n\n```java\nfloat speed = 5.0f;\nif (is_dash()) {\n  speed = 10.0f;\n}\n\nint position += direction * speed;\n```\n\n```java\nfloat speed() { \n  return is_dash() ? SPEED_DASH : SPEED_NORMAL;\n}\n\nint postion += direction * speed();\n```\n\n1번 코드와 2번코드의 다른 점은  \n\n열거형 변수를 사용하면서 의미있는 함수명을 사용하여 읽기 편하다.\n\n개인적으로는 함수에 조금 더 의미있는 이름을 사용하고 변수에 값을 할당하는 방법 더 좋다고 생각한다.\n\n회사에서 주로 사용하는 언어는 php 7버전을 사용해 추가로 적어보면\n\nphp는 열거형 변수(enum)을 8.0 이후부터 지원한다.\n\n비슷하게 사용하기 위해 class로 선언하는 방법이 있다.\n\n# 중첩문\n\nfor문보단 for-each사용\n\n\n# 함수\n\n1. 서술적인 함수 이름 사용\n\n2. 작게 만들어라\n\n3. error 처리 시 try-catch문 활용\n\n# 주석\n\n**의도, 경고, 중요한 히스토리 정보**를 담아야 할 경우 사용\n\n## 특별한 의미를 가지고 있는 주석\n```\n1) TODO : 좀더 최적화시키고 리팩토링 가능할 때, 작성하지 못한 코드나 구현하지 못한 코드\n2) FIXME : 문제가 있는것이 확실하지만, 그걸 지금 당장 그것을 수정할 필요는 없을 때.\n3) XXX : 해당 부분에 대해서는 더 생각해볼 필요성이 있을 때. \n          해당 부분에 질문이 생길 때. \n          코드에서 문제가 일어날만한 부분을 강조 표기할때.\n          완벽하게 정확히 구현되지 않은 부분이 있을 때.\n          나중에 고쳐야만하는 부분일 때.\n```\n\n[깨끗한 코드에 대한 대가들의 의견 - 토니잡스님 블로그](https://deepwelloper.tistory.com/entry/Clean-Code-%EA%B9%A8%EB%81%97%ED%95%9C-%EC%BD%94%EB%93%9C%EC%97%90-%EB%8C%80%ED%95%9C-%EB%8C%80%EA%B0%80%EB%93%A4%EC%9D%98-%EC%9D%98%EA%B2%AC)\n읽고 생각해보면 좋은 말이 많다.... ㅎㅎ\n\n---\n\n시중에 깨끗한 코드를 위한 서적도 많고, 구글링 하면 잘 정리한 글도 많은데\n\n중요하게 생각하는 몇가지를 정리해봤다.\n(정리하고 나니 쓸대없는 짓 한거같기도.. ㅋㅋㅋㅋ)\n\n대부분의 블로그 글이 클린코드란 책을 정리한 글이 많았는데\n\n조금 이해가 가지 않는 부분들이 있어서 책을 한번 보고 추가로 정리를 해야할 것 같다\n\n이슈는 항상 넘쳐나니 개발은 빠르게 해야하지만 읽기 좋은 코드를 작성하기 위한 방법은\n\n개발을 업으로 삼고 있는 사람들에겐 항상 고민해야 할 문제다.\n\n날코딩을 하려하는 나를 다시 한번 혼내자ㅋㅎ","excerpt":"오랜만에 포스팅이다. 이전 글에서 정리 하기로 했던 부분은 프론트 관련 내용은 천천히 정리하고.... 코드를 짜면서 고민이 많이 들었던 부분부터 생각정리 해보려고 한다. 개발자는 독자(동료, 미래의 나)가 있는 글(코드)을 작성하는데  독자가 있는 …","fields":{"slug":"/cleancode/"},"frontmatter":{"date":"Jan 02, 2022","title":"좋은 코드를 위한 생각정리","tags":["CleanCode"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n회사일 적응한다, 컨디션 조절한다, 열심히한다 라는 핑계를 대며 공부를 소홀히 했다.\n\n적응은 어느정도 했으니 정신차리고 공부좀 하자 ㅋ\n\n최근 화면단 작업을 많이 했는데 정리해야 겠다라고 생각한 부분부터 정리해보려고 한다.\n\n1. Location 객체\n2. Javascript 특징\n3. 이벤트 동작 과정, 중단 방법\n4. Ajax과 XHR(XMLHttpRequest)\n5. 정규 표현식\n6. 웹스토리지\n7. Chrome 개발자 도구 활용 방법\n8. MPA와 SPA, SSR과 CSR, SEO\n\n가볍게 location 객체부터 정리해보자\n\n## 브라우저 객체란?\n---\n> 브라우저에 내장된 객체 - 계층형 구조 \n\n\n![](local1.PNG)\n\n가장 상위에는 window 객체가 있으며  \n하위 객체로는 document, screen, location, history, navigator 5개의 객체가 있다.\n\n## Location 객체\n---\n> 사용자 브라우저와 관련된 속성과 메서드를 제공하는 객체\n\n**주소 표시줄에 있는 부분을 가져올 수 있다.**\n\n기능 개발을 하다보면 URL에 따라 분기 처리를 해야 하는 경우가 있는데  \n이 때 **location객체**를 사용하면 유용하다.\n\n| 프로퍼티 | 설명 | 예시\n|------|---|---|\nhash | 주소값에 붙어있는 anchor값 반환 | #haha\nhost | URL의 도메인과 포트 반환 | www.example.com:8080 \nhostname | URL의 도메인 반환 | www.example.com \nhref | URL 반환 | http://www.example.com:8080/search?q=devmo#test\norgin | 프로토콜 + URL의 도메인 + 포트 | http://www.example.com:8080 \npathname | URL 경로 반환 | /search \nprotocol | 프로토콜 반환 | http \nsearch | Query String (URL에 붙은 매개변수) | ?t=20210727\n\n요렇게 주소 표시줄의 정보를 가지고와 화면 분기처리를 할 수 있다!!! \n\n주의할 점으로 프로퍼티에 따라 포함되는 값이 다르니 주의하며 사용해야 한다","excerpt":"회사일 적응한다, 컨디션 조절한다, 열심히한다 라는 핑계를 대며 공부를 소홀히 했다. 적응은 어느정도 했으니 정신차리고 공부좀 하자 ㅋ 최근 화면단 작업을 많이 했는데 정리해야 겠다라고 생각한 부분부터 정리해보려고 한다. Location 객체 Jav…","fields":{"slug":"/frontTips_1/"},"frontmatter":{"date":"Aug 08, 2021","title":"Location 객체 정리","tags":["Javascript"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# Rsync(Remote sync)\n---\n> 파일과 디렉토리를 로컬 및 원격으로 동기화(복사) 하는데 사용\n\n## 특징\n---\n\n- 네트워크 대역폭을 최소화하는 델타 인코딩 알고리즘을 사용해 변경이 일어난 부분만 전송  \n  -> **빠르고 효율적으로 동기화 가능!**  \n- 설치\n```bash\n$ yum install rsync # CentOS\n$ apt-get install rsync # Ubuntu\n```\n\n- [rsync 홈페이지](https://rsync.samba.org/documentation.html)\n\n## 장점\n---\n\n- Cli툴로 쉘스크립트 프로그램 개발 가능 (cron으로 활용 가능)\n- 데이터를 압축하여 송/수신하기 때문에 빠르고 효율적\n- **link, 파일 소유자, 권한등 파일의 부가 정보를 함께 복사가능**\n- remote 업데이트를 이용하여 차이가 있는 파일만 복사한다. \n\n## 동기화 알고리즘\n---\n\n### 1. 파일 전송결정\n> 파일의 크기와 수정시간을 비교하는 것으로 파일을 전송할지 말지 결정한다.\n\n파일의 크기와 수정시간을 비교하는 것을, 아주 작은 cpu자원을 소모하지만 실수가 발생할 수 있다\n -> **checksum** 옵션 사용\n\n### 2. 전송할 파일 부분 결정\n\n1) 파일을 고정크기를 가지는 청크(Chunk)로 나눈다음에 checksum을 계산한다.\n2) 다를 경우 해당부분 chunk만 복사한다\n\nchunk파일의 체크섬을 비교하는 방식은 파일의 앞부분이 수정되서 정보가 밀리면 모든 청크와 checksum이 밀릴 것이다.\n -> **Rolling hash** 사용!\n\n#### 참고자료\n[위키트리](https://en.wikipedia.org/wiki/Rolling_hash)  \n[Quora답변](https://www.quora.com/What-is-a-rolling-hash-and-when-is-it-useful)  \n\n## 옵션\n---\n\n```\n-v : 진행 상황을 상세하게 보여줌\n-r : 지정한 디렉토리의 하위 디렉토리까지 재귀적으로 실행\n-l : 소프트 링크 보존\n-H : 하드 링크 보존\n-h : -human-readable 읽을 수 있는 형식으로 출력 번호를 출력합니다.\n-p : 버전 속성 보존\n-o : 소유 속성 보존(루트)\n-g : 그룹 속성 보존\n-t : 타임스탬프 보존\n-D : 디바이스 파일 보존(루트)\n-z : 데이터 압축 전송\n-b : 낡은 파일은 ~가 붙음\n-u : 추가된 파일만 전송 새 파일은 갱신하지 않음\n-a : 아카이브 모드. rlptgoD를 자동 지정\n-c : 서버와 클라이언트의 파일 크기를 세밀히 체크\n-e ssh(rsh) : 전송 암호화\n\n--stats : 결과를 보고\n--delete : 서버에 없는 파일은 클라이언트에서도 삭제\n# 데이터 백업시 사용하지 않는 것이 좋다.\n--progress : 전송시 진행상황을 보여줌\n--existing : 추가된 파일은 전송하지 않고 갱신된 파일만 전송\n--exclude=PATTERN : 패턴에 제외할 파일, 디렉토리 유형을 써주면 동기화하지 않는다.\n```\n\n\n## Rsync 사용 예시\n---\n\n### 기본 사용법\n```bash\n$ rsync [option] [source] [destination]\n```\n\n### 1. 로컬로 디렉토리 복사 또는 동기화\n> rsync -zvh\n\n![](local1.PNG)\n![](local2.PNG)\n\n\n### 2. 로컬로 파일 복사 또는 동기화\n> rsync -zavh\n\n### 3. 원격으로 파일 복사 또는 동기화\n> 원격 Pull\n```bash\n$ rsync {options}  <User_Name>@<Remote-Host>:<Source-File-Dir>  <Destination>\n```\n> 원격 Push\n```bash\n$ rsync  <Options>  <Source-Files-Dir>   <User_Name>@<Remote-Host>:<Destination>\n```\n\n[17가지 예제 - linuxtechi.com](https://www.linuxtechi.com/rsync-command-examples-linux/)\n\n# Reference\n---\n\n[rsync - 용훈님 블로그](https://m.blog.naver.com/PostView.nhn?blogId=asdf2017&logNo=221491533057&proxyReferer=https:%2F%2Fwww.google.com%2F)  \n[Rsync 10가지 사용 예제들](https://www.joinc.co.kr/w/Site/Tip/Rsync)  \n[TWpower's Tech Blog](https://twpower.github.io/153-copy-file-or-directory-using-rsync-command)  ","excerpt":"Rsync(Remote sync) 파일과 디렉토리를 로컬 및 원격으로 동기화(복사) 하는데 사용 특징 네트워크 대역폭을 최소화하는 델타 인코딩 알고리즘을 사용해 변경이 일어난 부분만 전송 -> 빠르고 효율적으로 동기화 가능!   설치 rsync 홈페…","fields":{"slug":"/Rsync/"},"frontmatter":{"date":"May 05, 2021","title":"Rsync 정리","tags":["Rsync"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n개발 프로젝트를 진행하면 코드를 관리하기 위해  \n보통 **코드 형상관리**, **코드리뷰**, **배포방법**에 대해 고민한다. 오늘은 코드 형상관리 툴에 대해 정리해보자\n\n# 코드베이스란?\n---\n > 특정 시스템, 어플리케이션, 컴포넌트 따위를 빌드할 때 사용되는 소스코드의 전체집합, 그것을 담은 저장소 \n\n형상 관리 툴로 가장 대중적으로 많이 쓰이는 도구는 **git, svn**이 있다.\n\n보통 git을 가장 많이 사용하고 추가로 개발을 하며\n\nbranch를 어떻게 관리할지 고민하는데\n\ngit-flow, github-flow, gitlab-flow 브랜치 전략이 가장 대중적인 방법이다.\n\n## 1. Git-flow\n\n![](gitflow.png)\n\ngit-flow를 설명할 때 가장 많이 보이는 그림이다.  \n\n사진을 보면 5개의 브랜치가 있는데 브랜치를 정리해보면\n\n```\nmaster : 배포할 수 있는 브랜치\ndevelop : 개발 브랜치\nfeature : 기능별 개발 브랜치\nhotfixes : 버그를 수정하는 브랜치\nrelease : 배포 전 테스트를 통해 버그를 찾아내는 브랜치\n```\n\n진행과정을 살펴보면\n```\n1. 기능 개발을 위해 feature 브랜치를 생성 후 작업\n2. develop 브랜치에 merge\n3. 배포 전 테스트를 위해 release 브랜치 생성\n4. 테스트 완료 시, 배포를 위해 master 브랜치로 merge 후 태그를 달고 배포\n+ master branch에서 버그 발생 시, hotfix 브랜치 생성 \n  -> hotfix에서 작업한 내용은 master와 develop에 merge된다.\n```\n\n## 2. Github-flow\n---\n> 자동화 개념이 들어가 있는게 핵심!\n\n![](github-flow.PNG)\n\n가장 쉽고, 접하기 쉬운 브랜치 전략이라고 생각한다.   \n(혼자 개발할 때는 pull request가 없지만 ㅋ)\n\ngithub flow는 master 브랜치가 핵심이다. \n\nmaster 브랜치는 **항상 최신 상태, 안정적인 상태이다.**\n\ngithub flow를 잘 사용하기 위한 몇가지 특징을 정리해보면\n\n- 커밋 메세지를 명확히 작성한다.\n- pull request, role은 엄격해야한다.\n- CI가 필수!\n\n## 3. Gitlab-flow\n---\n\n![](gitlab-flow.PNG)\n\ngit-flow와 github flow의 중간버전 느낌이다.\n\nproduction 브랜치가 있는데 이 브랜치는 배포를 위한 브랜치이다.\n\n음... 더 알아 볼수록 짬뽕 시킨 것 같으므로 요런게 있다는 것만 알고 넘어가자 ㅋ\n\n# 정리\n---\n\n3가지 브랜치 전략을 알아보았는데 \n\n세가지 모두 효율적인 소스 관리, 좋은 배포를 위한 고민이다.\n\n어쨋든 가장 중요한건 **개발팀 상황에 맞게 구성원과 전략을 세우는 것**으로 정리하고 글을 마친다. \n\n# 잡담\n\n혼자 개발하고, 친구들이랑 공모전 준비할 땐 이런 문제를 딱히 고민하지 않았는데  \n회사에서 직접 버그를 수정하고, 간단한 기능개발 하며   \n협업 방법과 코드로 대화하는 것에 대해 계속 고민하게 된다.\n\n# Reference\n[git flow 참고 자료](https://nvie.com/posts/a-successful-git-branching-model/)  \n[github flow 참고 자료(공식 홈페이지)](https://guides.github.com/introduction/flow/)  \n[gitlab flow 참고 자료(공식 홈페이지)](https://about.gitlab.com/topics/version-control/what-is-gitlab-flow/)  ","excerpt":"개발 프로젝트를 진행하면 코드를 관리하기 위해 보통 코드 형상관리, 코드리뷰, 배포방법에 대해 고민한다. 오늘은 코드 형상관리 툴에 대해 정리해보자 코드베이스란? 특정 시스템, 어플리케이션, 컴포넌트 따위를 빌드할 때 사용되는 소스코드의 전체집합, …","fields":{"slug":"/gitflow/"},"frontmatter":{"date":"Apr 20, 2021","title":"git branch 전략","tags":["git"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\nGit 명령어 정리\n\n# Git, Git flow 명령어\n\n### Git commit \n\n```bash\n$ git commit -m \"{commit message}\"\n```\n\n### Git Branch 생성 및 checkout\n\n```bash\n$ git checkout -b \n```\n\n### Git Branch 삭제\n\n```bash\n$ git branch -d {브런치 명}\n```\n\n### Git Branch 확인\n\n```bash\n$ git branch\n\n$ git branch -v\n```\n\n### Git Branch 상태 확인\n\n```bash\n$ git branch --merged\n```\n > 이미 Merge한 브랜치 목록을 확인한다.\n\n### Git log 확인\n\n```bash\n$ git log --oneline --graph\n```\n\n### 태그 목록 조회\n```bash\n$ git tag -l\n````\n\n### 태그 checkout\n```bash\ngit checkout tags/<tag_name>\n```\n\n### 태그 checkout\n```bash\ngit checkout tags/<tag_name> -b <branch_name>>\n```\n\n\n\n추가로 기억해야 할 명령어는 계속 정리할 예정이다.\n\n[Git Tips!](https://github.com/mingrammer/git-tips#20%EA%B0%9C-%EB%82%B4%EC%99%B8%EC%9D%98-%EB%AA%85%EB%A0%B9%EC%96%B4%EB%A1%9C-git-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0)\n","excerpt":"Git 명령어 정리 Git, Git flow 명령어 Git commit Git Branch 생성 및 checkout Git Branch 삭제 Git Branch 확인 Git Branch 상태 확인 이미 Merge한 브랜치 목록을 확인한다. Git l…","fields":{"slug":"/gitCommand/"},"frontmatter":{"date":"Apr 20, 2021","title":"git flow 및 git cli 명령어 정리","tags":["git"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n\ncodeigniter3를 공부해보자\n\n# codeigniter3\n\n# 1. CI 동작\n\n![data flow image](dataFlow.PNG)\n\n1. index.php CI가 동작하기 위한 기반 리소스 초기화\n2. Router 모듈 동작 결정\n   2.1) 캐시 파일 존재 -> 캐시 파일 전송\n3. Security 모듈이 Controller로 이동하기 전에 필터링\n4. Controller 사용자 요청 처리\n5. View 모듈 렌더링 -> 전송 (캐시 추가)\n\n## CI URL\n\n새그먼트 기반 URL 사용\n\n```\nexample.com/news/article/my_article\n{호스트 주소}/{호출될 Controller}/{클래스 안의 호출될 Function}/{변수}\n```\n\n<!-- TODO : nginx index.php 제거 방법 -->\n\n# 2. MVC\n\n1. Model : 데이터구조 표현, 모델 클래스는 데이터 함수 포함\n2. View : 사용자에게 보여질 화면\n3. Controller : Model과 View사이 동작\n\n![](phpMVCpattrenEx.gif)\n\n<!-- TODO : 파일 구조 설명 -->\n\n## Controller\n> URL과 상호작용하는 클래스 파일\n\n#### 특징\n - 클래스 명은 항상 **대문자로 시작**\n\n### 추가로 알아야 될 사항\n\n#### 1. Controller에 나오는 _의 의미\n> Controller에서 _를 함수 이름 앞에 작성하면 **Routing**되지 않는다. (private한 메소드가 된다.)\n\n\n#### 2. $this, self, -> 차이\n<!-- TODO : 정리해야 한다. -->\n\n[참고 블로그](https://m.blog.naver.com/PostView.nhn?blogId=vefe&logNo=221454883593&proxyReferer=https:%2F%2Fwww.google.com%2F)\n\n#### 3. _remap() 함수\n> 함수요청 재매핑\n\n\n```php\npublic function _remap($method, $params = array()) {\n   $method = 'process_'.$method;\n   if (method_exists($this, $method)) {\n      return call_user_func_array(array($this, $method), $params);\n   }\n   show_404();\n}\n```\n\n\n**컨트롤러가 _remap()함수 가지고 있으면 무조건 호출된다**\n\n#### 4. _output() 함수\n> \n\n<!-- TODO : VIEW, Output 클래스 내용 정리하고 다시보자 -->\n\n**추가로 알아야 될 사항은 내용은 내용을 조금 더 추가 할 예정이다.**\n\n## Route\n> application/config/routes.php에 작성\n<!-- TODO : 생활코딩 강의 -> ref문서 정리 -->\n\n## View\n> 화면에 출력되는 부분\n\n## Model\n> Model은 데이터를 가져오는 로직을 메소드로 정의, Controller를 통해 사용된다.\n\n### 데이터 베이스 설정\n\n> Application/config/database.php 파일을 수정\n\n파일 속성\n```\nhostname : 데이터베이스 서버의 주소 (localhost는 PHP와 같은 머신을 의미)\nusername : 데이터베이스 사용자의 이름\npassword : 데이터베이스 비밀번호\ndatabase : 데이터베이스 명\ndbdriver : 데이터베이스의 종류로 지원되는 드라이브의 목록은 system/database/drivers 디렉토리명을 참고한다.\n```\n\n### 데이터 베이스 라이브러리 로드\n\nPHP에서 MySQL을 사용하기 위해 mysqli를 설치한다\n\n```bash\n$ sudo apt-get install php-mysqli\n```\n\n데이터 베이스 라이브러리 로드 방법은 2가지가 있다.\n\n```\n1. application/config/autoload.php 파일의 $autoload['libraries'] 배열에 'database'를 추가한다. \n2. controller 내에서 $this->load->database()를 호출한다.\n```\n\n### Model 파일 생성 규칙\n - **application/models/{모델 명_model}.php** 형식으로 생성\n - 파일은 **CI_Model 클래스 상속**\n - 클래스 명은 **대문자로 시작**\n\n### Model load\n\n1. Model load\n> $this->load->model('소문자로된 모델 클래스 명');  \n\nex)\n```\n$this->load->model('topic_model');\n```\n\n1. Model call\n> 모델 클래스 명 -> 메소드 명\n\nex)\n```\n$topics = $this -> topic_model -> gets();\n```\n\n### Model 내 쿼리 사용\n> $this->db 이용!\n\n- 사용 예제 \n  \n```php\n$query - $this->db->query('SELECT name, title, email FROM my_table')\n\nforeach($query->result() as $row) {\n   echo $row->title;\n   echo $row->name;\n   echo $row->email;\n}\n\necho 'Total Results: ' . $query->num_rows();\n```\n\n#### 결과 불러오기\n> **객체 배열 리턴**한다.\n\n1. 다중 결과(객체)\n   - result()\n2. 다중 결과(배열)\n   - result_array()\n3. 단일 결과(객체)\n   - row()\n4. 단일 결과(배열)\n   - row_array()\n\n<!-- TODO : 표준 입력 예제, 쿼리 빌더 -->\n<!-- http://www.ciboard.co.kr/user_guide/kr/database/examples.html#standard-insert -->\n\n<!-- TODO : Active Record vs JPA 비교 -->\n\n## Tip!!\n\n```bash\nif (!-e $request_filename ) {\n\trewrite ^(.*)$ /index.php last;\n}\n```\nfile이 존재하지 않으면, index.php로 이동\n\n### ?> 닫는 태그를 생략하는 경우\n\nPHP 구문은 기본적으로 \n```php\n<?php\n  ...\n?>\n```\n위와 같이 구성된다. 문장의 종료는 반드시 **세미 콜론**이 찍혀야 한다.\n\n하지만 php코드를 보면 닫는 코드인 ?> 을 생략한 구문이 있다. 이상하게 코드는 잘 동작한다.\n\n그 이유를 알아보면 순수 PHP코드로만 이루어진 코드는 닫는 태그를 생략하는 것이 더 유리하다고 한다.\n\n왜냐하면 닫는 태그인 ?> 앞 뒤에 공백이나 Enter가 실수로 들어가는 경우가 많기 때문이다.\n\n이런 상황에는 의도하지 않은 에러가 날 수 있고, 디버깅 하기 힘듬\n\n하지만 **HTML 코드와 같이 사용할 경우에는 반드시 사용해야 한다.**\n\n\n# 3. Library, Helper\n\n## Helper\n> 자주 사용하는 로직을 재활용 할 수 있게 만드는 Library\n\n**Library vs Helper**  \n> Helper : 일반적인 함수로 만들어짐 / Library : 객체로 만들어짐\n\n1. 기본적인 로드 방법\n```php\n$this->load->helper('헬퍼 이름')\n```\n\n2. 복수의 헬퍼를 로드하기 위한 방법\n```php\n$this->load->helper(array('헬퍼1의 이름', '헬퍼2의 이름'));\n```\n\n## Tip!!\n헬퍼는 보통 직접적으로 스크립트를 실행하는 경우가 많이 없으므로\n\n```php\n<?php if (! defined('BASEPATH')) exit('No Direct script access allowed');\n```\n구문을 상단에 최상단에 추가하여 스크립트의 실행을 막는다.\n\n## Library\n> 웹개발에서 자주 사용되는 로직을 내장(Core) 라이브러리로 제공하고 있다.\n\n# 4. CI Config\n> 필요에 따라 Application 동작 방법을 변경한다.\n> Application/config/ 디렉토리 아래에 위치\n\n**Tip!!**\n개발환경과 실서비스 환경과 설정을 다르게 위해 index.php의\n```php\ndefine('ENVIRONMENT', 'development');\n```\n두 번째 인자값을 development, testing / production 으로 바꿀 수 있지만\n**dev.php를 하나 더 만들어서 접속 경로를 다르게 하는 방법도 있음**\n\n```\ndevelopment : 개발 환경에서 사용한다. 모든 에러가 출력된다. \ntesting, production : 테스팅이나 실서비스 환경에서 사용된다. 에러가 출력되지 않는다. \n```\n\n## 1. config.php\n> CI에 필요한 기본적인 설정파일 / CI가 동작하는 방식에 대한 다양한 설정 값이 저장되어 있음.\n\n파일을 보면 쿠키, 세션, 보안, 캐시파일/로그파일 저장 위치 같은 것을 확인할 수 있다.\n\n## 2. database.php\n> database에 필요한 설정파일\n\n## 3. autoload.php\n> Helper, Library같은 리소스들을 자동 로드 -> 편의성 증대 / 성능 감소 주의\n\n## 4. hooks.php\n> 사용자가 Core의 기본 실행 흐름을 설정 가능 (자신만의 로직 추가 가능 / config.php에서 설정 해야지 사용 가능)\n\n## 설정 정보 사용\n> config 라이브러리와 config.php 파일은 자동 로딩하기 때문에 별도 작업 필요 없음\n\n```php\n$this->config->item('base_url');\n```\n\n### 사용자 정의 설정\n> $config 배열에 값 추가, 파일을 통한 설정 값 추가 가능(로딩 절차 필요)\n\n```php\n$this->load->config('hsh');\n// file을 통한 설정 load \n$this->config->item('hsh');\n// item 메소드는 설정이 없으면 false 리턴\n```\n\n## 5. CI debugging / log\n\napplication/config/config.php에 보면\n\n```php\n$config['log_threshold'] = 0;\n```\n구문 수정을 통해 log수준을 설정할 수 있다.\n\n```\n0 = 로깅을 비활성화\n1 = 에러로그만 기록\n2 = 디버그 로그도 기록 \n3 = 정보 로그도 기록\n4 = 모든 메시지를 기록\n```\n\ncontroller에서 아래와 같이 사용하면 원하는 log메세지를 추가 할 수 있다.\n\n```php\n// debug 메세지 추가\nlog_message('debug', 'topic 초기화');\n\n// error 메세지 추가\nlog_message('error', 'topic의 값이 없습니다');       \n```\n\n## 6. 파일 처리\n> Upload 클래스의 doupload가 핵심 메소드\n\n현재 다니고 있는 회사에선 file upload는 **Fine-Uploader**를 사용하고  \n**CKEditor**를 사용해서 HTML 코드 없이 글을 작성하는 기능을 구현했다.\n\n## 7. Core 확장\n> CI는 코어 상속, Hook방법을 통해 Core기능 \n\n\n\n\n<!-- ## 8. 세션 / 비밀번호 암호화\n\n## 9. CRI 프로그램\n\n## 10. Queue / Cron\n\n## 11. Caching -->\n\n<!-- \n[쿠키와 세션](https://opentutorials.org/course/62/240\n[Session](https://opentutorials.org/course/697/398)\n[회원가입 & 비밀번호 암호화](https://opentutorials.org/course/697/4278)\n[리다이렉션과 로그인 개선](https://opentutorials.org/course/697/4129)\n[이메일 전송 & 라이브러리 장]()\n[CLI](https://opentutorials.org/course/697/4282)\n[Queue & cron](https://opentutorials.org/course/697/4130)\n[Caching](https://opentutorials.org/course/697/3839)\n -->\n\n## 경로에 index.php 없애기\n\n1. application/config/config.php\n\n```php\n$config['index_page'] = '';\n```\nindex.php를 찾아서 빈 값으로 설정한다\n\n2. index.php가 존재하는 폴더에 .htaccess파일을 추가한다.\n(Permisson은 755로 설정한다.)\n\n**.htaccess 파일**\n```\n<IfModule mod_rewrite.c>\n    RewriteEngine On\n    RewriteCond %{REQUEST_FILENAME} !-f\n    RewriteCond %{REQUEST_FILENAME} !-d\n    RewriteRule ^(.*)$ index.php/$1 [L]\n</IfModule>\n```","excerpt":"codeigniter3를 공부해보자 codeigniter3 1. CI 동작  index.php CI가 동작하기 위한 기반 리소스 초기화 Router 모듈 동작 결정\n2.1) 캐시 파일 존재 -> 캐시 파일 전송 Security 모듈이 Controll…","fields":{"slug":"/phpNginxCI_4/"},"frontmatter":{"date":"Mar 01, 2021","title":"Codeigniter 학습","tags":["Codeigniter"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# 1. SQLite .명령어 정리\n> SQLITE의 특징은 명령어 앞에 마침표(.)를 붙인다.\n\n파일 접속\n```bash\n$ sqlite3 {파일명}\n```\n\n파일 접속 종료\n```bash\n> .quit\n> .exit\n```\n\n테이블 확인\n```bash\n> .tables\n```\n\n테이블 구조 확인\n```bash\n> .schema access_log\n```\n\n헤더(컬럼 명) 함께 출력\n```bash\n> .header on\n```\n\n라인별로 나눠 출력\n```bash\n> .mode line\n```\n\n컬럼별로 나눠 출력\n```bash\n> .mode column\n```\n\n추가 기능 확인\n```bash\n> .help\n```\n\n# 2. 파일 I/0\n> sqlite3는 쿼리 결과를 표준 출력으로 보낸다.\n - \".output\", \".once\" 명령어를 사용하여 변경 가능\n\n\n1) .OUTPUT 명령어 \n > .output에 인수로 파일명 넣으면 해당 파일에 기록 (.output을 사용하면 표준 출력 상태로 되돌아간다)\n\n2) .import 명령어를 사용해 csv데이터를 sqlite 테이블로 가져올 수 있다.\n```bash\nsqlite> .import C:/CVS/aaa.csv aaa\n```\n\n**주의할 점**\n - SQLite3은 기본적으로 UTF-8형식 / 윈도우 엑셀은 CP949형식","excerpt":"1. SQLite .명령어 정리 SQLITE의 특징은 명령어 앞에 마침표(.)를 붙인다. 파일 접속 파일 접속 종료 테이블 확인 테이블 구조 확인 헤더(컬럼 명) 함께 출력 라인별로 나눠 출력 컬럼별로 나눠 출력 추가 기능 확인 2. 파일 I/0 s…","fields":{"slug":"/SQLite/"},"frontmatter":{"date":"Feb 26, 2021","title":"SQLite","tags":["SQLite"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\nphp 문법을 간략히 정리해보자\n\n# 1. 변수\n\nPHP는 아래와 같은 자료형을 사용할 수 있다\n문자열 String  \n정수형 Integer  \n실수형 Float  \n논리형 Boolean  \n배열 Array  \n객체형 Object  \n널 NULL  \n리소스 Resource  \n\n아래의 방법으로 변수의 자료형을 알아내거나, 자료형을 변경할 수 있다.\n\n```php\n// 변수 자료형 알아내기 \nvar_dump({변수 이름});\necho gettype({변수 이름});\n\n// 변수 자료형 변경\nsettype({변수이름},'{자료형}');\n```\n\nPHP의 특징으로 동적으로 변수명 설정이 가능하다.\n\n```php\n<?php\n$title = 'subject';\n$$title = 'PHP tutorial';\necho $subject;\n?>\n```\n\n아래의 구문을 실행하면 실행값이\n```\nPHP tutorial\n```\n이 나온다.\n\n\\$\\$가 두번 표시되어 있는데, $title 의 값으로 변수가 생성된 것을 의미한다.\n\n\n# 2. 연관배열\n\n두번째 특징으로 연관배열이 있다.\n\n## 연관배열\n> 배열의 키 값으로 숫자와 문자 모두 사용\n\n예제를 보면 \n\n값 할당 및 출력 구문\n```php\n<?php\n$grades = array('egoing'=>10, 'k8805'=>6, 'sorialgi'=>80);\n$grades = array('egoing'=>10, 'k8805'=>6, 'sorialgi'=>80);\nforeach($grades as $key => $value){\n    echo \"key: {$key} value:{$value}<br />\";\n}\n?>\n```\n\n결과값\n```php\nkey : sorialgi  value : 80\nkey : k8805     value : 6\nkey : egoing    value : 10  \n```\n\n키값 형태로 사용한다.\n\n# 3. File load\n\n## require, import \n\nphp에는 **1. require** , **2. import** 두가지 방법으로 file호출 가능  \n뒤에 \\_once를 붙여 include\\_once 처럼 사용하면 파일을 로드할 때 단 한번만 로드하면 된다는 의미\n\n기능상 차이는 없는데 error 표시가 다르다.  \n\nrequire가 더 높은 에러 수준으로 error를 알리고, 코드의 실행을 중단시킨다.  \n\n\n**1) 파일 복사**\n> copy(\\$file, \\$newfile)\n\n**2) 파일 삭제**\n> unlink('file.txt');\n\n**3) 파일 읽기**\n> file_get_contents($file);\n\n**4) 파일 저장**\n> file_put_contents($file, 'coding everybody');\n\n**5) file etc**\n> is\\_readable, is\\_writable, file_exists 같은 함수를 통해 파일 확인이 가능하다\n\n**6) 디렉토리**\n```php\n// directory 읽기\n$dir    = './';\n$files1 = scandir($dir);\n\n// directory 만들기\nmkdir(\"1/2/3/4\", 0700, true);\n```\n\n# 4. Class\n\n클래스 선언 및 인스턴스 생성\n```php\nclass MyObject{\n  function __contruct($fname){\n    $this->filename = $fname;\n  }\n}\n\n$obj = new MyObject('file1');\n```\n\nClass내 함수 사용\n```php\nprint_r($obj->func());\n```\n\n# 5. 접근 제어자\n> private, public 키워드를 사용해서 접근을 제어할 수 있다.\n\n# 6. 상속\n> extends 키워드를 사용해 클래스를 상속할 수 있다.\n\n**Tip!!**  \n클래스 안에 static 키워드를 추가한 변수를 만들어주면 모든 인스턴스가 공유하는 변수를 만들어줄 수 있다.\n\n```php\nclass car{\n  private static $count = 0;\n  private $name;\n  function __construct($name){\n    $this->name = $name;\n    self::$count = self::$count+1;\n  }\n}\n```\n\n### 클래스 접근\n\n부모 클래스를 접근할 때는 parent(parent::) 연산자를 사용한다.\n자신의 클래스를 접근할 때는 self(self::) 연산자를 사용한다.\n\n**\\::는 new 지시자로 class를 미리 객체화 시켜놓지 않고 사용하는 시점에서 객체가 생성되고 지정된 메소드가 실행되도록 하는 접근자이다.**\n\n\n# 7. Namespace, use\n> Namespace : 동일한 이름을 가진 class가 존재할 때 구분하여 사용하기 위한 이름\n> use : 키워드를 통해 불러올 수 있다.\n\nJava에서 package와 import 같은 개념이다. \n\n[PSR](https://www.php-fig.org/psr/psr-4/)에서는 아래와 같은 방식으로 사용하는 것을 권장한다\n> \\<NamespaceName>(\\<SubNamespaceNames>)*\\<ClassName>\n\n사용법은\n```php\n<?php\n// 파일명 : greeting_en_ns.php\n\nnamespace language\\en;\nclass Hi{\n  function welcome(){\n      return 'Hello world';\n  }\n}\n```\n상단에 namespace 를 명시해준다.\n\n사용할 땐\n```php\n<?php\nrequire_once 'greeting_en_ns.php';\nuse \\greeting\\en\\Hi as hien\nnew HiEn();\n?>\n```\n\n불러와서 사용해주면 된다.\n\n# 8. 인터페이스\n\n```php\ninterface myInterface{\n  public function promiseMethod(array $param):int;\n}\n```\n\n# 9. abstract\n> 하위 클래스가 반드시 오버라이드하게 강제한다.\n\n강제하고 싶은 메소드 앞에 abstract 키워드를 붙여주면 된다.\n\n# 10. 컴포저\n> PHP의 Package Manager\n\ncomposer.json파일로 관리\n\n[packagist](https://packagist.org/)를 들어가보면 PHP Repository를 검색할 수 있다.\n\nCI3의 composer.json\n\n![](ciComposer.PNG)\n\n추가로 ci는 composer를 사용하려면 config/config.php 부분에 아래 구문을 수정 해야한다.\n\n```php\n$config['composer_autoload'] = '/vendor/autoload.php';\n```\n\n---\n\n위 내용을 바탕으로 간단하게 CI3 + Nginx로 띄운 서버에 id, password 입력 폼을 만들고 정규식으로 값들을 체크하는 코드를 작성해보았다.\n\ncontroller 소스다.\n![](1.PNG)\n\nview 소스다.\n![](2.PNG)\n\n/playground\n![](4.PNG)\n\n/playground/go 로 이동한 결과\n![](3.PNG)\n\n끗","excerpt":"php 문법을 간략히 정리해보자 1. 변수 PHP는 아래와 같은 자료형을 사용할 수 있다\n문자열 String 정수형 Integer 실수형 Float 논리형 Boolean 배열 Array 객체형 Object 널 NULL 리소스 Resource   아래…","fields":{"slug":"/phpNginxCI_3/"},"frontmatter":{"date":"Feb 25, 2021","title":"PHP 기본 문법 정리","tags":["PHP"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"# Nginx\n\n## CGI(Common Gateway Interface) 란?\n> 웹서버와 외부 프로그램(C, PHP, Python 등) 사이에서 정보를 주고받는 방법과 규약\n\n**이 표준에 맞춰 만들어진 것이 CGI 스크립트이다.**\n\n![](cgipic.PNG)\n\n### 관련 용어\n - Web Server : 웹 클라이언트에게 콘텐츠를 제공하는 서버\n - WAS : 서버 단에서 Application을 동작할 수 있도록 지원\n\n### 장점\n - 언어, 플랫폼에 독립적\n - 매우 단순하고 다른 서버 사이드 프로그래밍 언어에 비해 쉽게 수행\n - 라이브러리가 풍부하다\n - 가볍다\n\n### 단점\n - 느리다(요청이 올 때 마다 DB connection을 새로 열어야 한다)\n<!-- TODO : 확인해보자 -->\n - HTTP 요청마다 **새로운 프로세스를 만들어** 서버 메모리를 사용한다 (Fork로 구현되어 있음)\n - 데이터가 메모리에 캐시될 수 없다.\n\n### 추가\n[RPC 3875-1.4 항목](https://tools.ietf.org/html/rfc3875#section-1.4)\n```\n1. CGI 프로그램을 호출하는 WEB 서버 역할\n  1) 전송 단계에서의 인증 및 보안\n  2) CGI 프로그램의 선택\n  3) CGI Request 로 변환\n  4) CGI Response에서의 변환\n2. 호출 프로그램의 지정 방법 (URI)\n3. WEB 서버에서 CGI Request의 해석 방법 (경로 및 프로토콜)\n4. WEB 서버에서 CGI Response에 대한 반환 방법 (경로 및 프로토콜)\n```\n\n## FastCGI란?\n> 하나의 큰 프로세스로 동작한다. 이 프로세스가 계속해서 새로운 요청(Request) 처리(CGI 단점 해결)\n\n![](fastcgip.PNG)\n\n대부분의 웹서버 **(Nginx, IIS, Apache)** 가 FastCGI를 제공한다.\n\n## PHP-FPM(Fast Process Manager)\n> PHP를 FastCGI 모드로 동작하게 해준다.\n\n\n## 1. 역할\n1. 정적 파일을 처리하는 **HTTP 서버**로서의 역할\n\n![](webserver.PNG)\n\n2. 응용 프로그램 서버에 요청을 보내는 **리버스 프록시** 역할\n\n![](reverseProxy.PNG)\n\n프록시는, **클라이언트와 서버 통신 사이에서 통신을 대신!! 해주는 서버를 의미한다.**\n\n### 리버스 프록시란?\n > 클라이언트가 서버에 요청하면, 프록시 서버가 배후 서버(응용프로그램 서버)로부터 데이터를 가져옴\n\n추가로 포워드 프록시는 클라이언트 앞단에서\n**보안을 위해 사용을 제한할 목적**\n\n리버스 프록시는 서버의 앞단에서 요청을 처리  \n**좀 더 안전하게 Request, Response를 관리**\n\n### 리버스 프록시를 쓰는 이유\n > 1. **프록시 서버를 둠으로써 요청을 배분하는 역할**  \n > 2. cli가 직접 App 서버에 요청하면 프로세스 1개가 응답대기 상태가 되어서 요청에 대한 버퍼링이 생긴다  \n > 3. 보안상 이점! -> WAS는 대부분 DB서버와 연결되어 있으므로 WS - WAS가 통신을 통해 클라이언트에게 제공하는 방식\n\n추가로 스위치(로드밸런서)로써 역할도 가능하다.\n> 프로세스 응답 대기를 막고, 요청을 배분하는 역할 \n### Event-driven 방식\n\nThread 기반은 하나의 커넥션당 하나의 쓰레드를 사용\n\nEvent-driven 방식은 Event Handler를 통해 비동기 방식으로 처리해 먼저 처리되는 것부터 로직이 진행된다.\n\n![](threadp.PNG)\n\n![](eventp.PNG)\n\n## 2. 파일 구조\n\n5개 폴더 및 파일을 알아보고 넘어가겠다.\n\n```\nconf.d : nginx.conf에서 불러들일 수 있는 파일을 저장\nfastcgi.conf : FastCGI 환경설정 파일\nnginx.conf : 접속자 수, 동작 프로세스 수 등 퍼포먼스에 관한 설정들\nsites-available : 비활성화된 사이트들의 설정 파일들이 위치한다.\nsites-enabled : 활성화된 사이트들의 설정 파일들이 위치한다. \n```\n\n사실 기본 설정이 이렇다는 거고, 폴더명 같은 경우는 상황에 따라 변경이 가능하다. \n\n## 3. 변수\n\n#### $arg_{PARAMETER}\n> URI의 파라미터 변수의 이름 의미\n#### $host\n> 현재 요청의 호스트 명\n\n#### $uri\n> 현재 요청의 URI (호스트명과 파라미터는 제외된다.)\n\n#### $args\n> URL의 질의 문자열\n\n#### $binary_remote_addr\n> 바이너리 형식의 클라이언트 주소\n\n#### $body_bytes_sent\n> 전송된 바디의 바이트 수\n\n#### $content_length\n> HTTP 요청헤더의 Content-length\n\n#### $content_type\n> HTTP 요청헤더의 Content-type\n\n#### $document_root\n> 현재 요청의 document root 값\n\n#### $http_HEADER\n> HTTP 헤더의 값을 소문자로 한 값(-는 _로 변환된다.)\n\n#### \\$server\\_name / \\$server\\_port / \\$server\\_protocol\n> 각각 name, port, protocol을 의미한다.\n\n#### cookie_{쿠키이름}\n> 해당 쿠키의 값을 얻을 수 있다.\n## 4. 설정\n\n**설정 수정 시 원본을 복사해 보관해 두는 습관 가지자!**\n\n### 설정 파일\n\n설정파일은 크게 4가지로 나뉜다.\n1. nginx.conf : 메인 설정 파일\n2. fcgi.conf : FastCGI 환경 설정파일\n3. sites-enabled : 활성화된 사이트들의 설정 파일 위치\n4. sites-available : 비활성화된 사이트들의 설정 파일 위치\n\n\n두개의 파일을 보며 Nginx 설정에 대해 확인해보자\n> /etc/nginx/nginx.conf  \n> /etc/nginx/sites-available/default\n\n#### /etc/nginx/nginx.conf\n```\nuser www-data;\nworker_processes auto;\npid /run/nginx.pid;\n\nevents {\n        worker_connections 768;\n        # multi_accept on; #기본값:off\n}\n\nhttp {\n        sendfile on;\n        tcp_nopush on;\n        tcp_nodelay on;\n        keepalive_timeout 10; #기본값:75\n        types_hash_max_size 2048;\n        server_tokens off;\n\n        server_names_hash_bucket_size 64; #기본값:32\n        server_names_hash_max_size 2048; #기본값:512\n        # server_name_in_redirect off;\n\n        include /etc/nginx/mime.types;\n        default_type application/octet-stream;\n\n        access_log off; log_not_found off;\n        error_log /var/log/nginx/error.log warn;\n\n        include /etc/nginx/conf.d/*.conf;\n        include /etc/nginx/sites-enabled/*;\n}\n\n```\nnginx.conf 파일은 접속자 수, 동작 프로세스 수 등 퍼포먼스에 대한 기본적인 설정 항목을 포함한다.\n\n크게 3가지 항목으로 나뉜다.\n\n#### 1. 최상단 (Core 모듈)\n\nuser : Nginx 프로세스(워커 프로세스)가 실행되는 권한\n - nginx는 master process, worker process로 동작한다.\n - 실질적으로 **worker process가 실직적인 웹서버 역할** 수행\n - root로 설정되어 있을 경우, 워커 프로세스를 root 권한으로 동작  \n   -> 악의적인 사용자가 제어하게 된다면 보안상 위험  \n   -> 보통 **www-data, www, nginx**와 같이 계정이 하는 일에 대한 대표성 있는 이름 사용  \n    - (default 값 - ubuntu : www-data, 기타 nobody )  \n   -> 이 계정들은 일반 유저의 권한으로 쉘에 접속 할 수 없어야 안전하다.  \n    - ubuntu 에서 계정 생성방법  \n```bash\n$ useradd --shell /usr/sbin/nologin www-data\n```\n\nworker_processes : Nginx 프로세스 실행 가능 수\n - auto일 경우도 있지만, 명시적으로 서버의 코어 수 만큼 할당하는 것이 보통 (더 높게도 가능)\n\npid : Nginx 마스터 프로세스 정보\n\n\n#### 2. events\n주로 네트워크의 동작 방법과 관련된 설정값을 가진다. \n\nworker_connections : 몇개의 접속을 동시에 처리할 것인가\n - worker_processes * worker_connections = **처리 할 수 있는 커넥션의 양**\n - Tip!!\n   - 여러 자료와 퍼포먼스 테스트를 하며 값을 조정해야 한다.\n\n#### 3. http\n> server, location의 루트 블록이라 할 수 있고, 여기서 설정된 값들은 하위 블록들이 상속한다.  \n> http 블록은 여러개를 사용할 수 있지만 관리상의 이유로 한번 사용하는 것이 좋다.\n\n - keepalive_timeout : 클라이언트에서 커넥션을 유지하는 시간을 의미\n - servers token : Nginx 버전 숨길 수 있는 기능 (주석을 제거해 보안 이슈를 방지하는 것이 좋다.)\n - server_names_hash_max_size, server_names_hash_bucket_size : 호스트의 도메인 이름에 대한 공간(너무 낮으면 에러 발생 가능)\n - **log관련 설정**은 각 **호스트 마다 배분**하는 것이 관리하기 편하므로 http block에선 off로 처리한다.\n\n\n#### etc\n - **include 옵션** : 별도의 파일에 설정을 기록해서 설정의 그룹핑, 재활용성을 높이는 방법\n - ex) 리버스 프록시를 각 도메인에 설정한다고 했을 때 헤더 처리 옵션등을 conf.d에 넣어두고 불러온다. (nginx.conf 설정 파일이 깔끔해짐)\n   - 리버스 프록시란? : \n\n#### 4. server / location\n/etc/nginx/sites-available/default에 server, location 블록이 작성되어 있다.\n\nserver 블록 : 하나의 웹사이트를 선언하는데 사용 (가상 호스팅 개념)\nlocation 블록 : server 블록 안에 등장하며 특정 URL을 처리한다.\n\n```\nserver {\n    listen       80;\n    server_name  localhost;\n \n    root   /usr/share/nginx/html;\n    location / {\n        index  index.html index.htm index.php;\n    }\n \n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    location ~ \\.php$ {\n        fastcgi_pass   unix:/var/run/php5-fpm.sock;\n        fastcgi_index  index.php;\n        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;\n        include        fastcgi_params;\n    }\n}\n```\nlocation 블록을 상세히 살펴보면\n\n1. fastcgi_pass : \n2. fastcgi_param : \n\n**설정 파일을 변경하면 nginx에 반영해야 하는데, reload 명령을 이용한다**\n\n## 추가!!\n\n- 보통 가상 호스트 설정 파일의 경우 sites-available 디렉토리 아래 위치  \n- sites-enabled 디렉토리에 심볼릭 링크를 걸어주면서 nginx에서 사용하게 설정\n- 에러 같은 경우 중요한 오류 이외에는 로그로 남기지 않게 설정해서 로그로 인해 디스크 엑세스를 하지 않게 설정한다!\n\n**conf파일 구성은 상황마다 다르다.**\n\n### 로그 파일 위치\n> /var/log/nginx\n\n## Upstream Module\n> NGINX를 일종의 LoadBalancer(부하분산, 속도개선)로 이용할 수 있게 해주는 모듈\n\n- conf파일의 upstream블록을 통해 사용한다. \n- was를 의미하고, nginx는 downstream에 해당한다고 할 수 있다.\n\n**형식**\n```\nupstream 이름 {\n    [ip_hash;]\n    server host 주소:포트 [옵션];\n    .....\n}\n```\n\n**예제**\n```\nupstream backend {\n    ip_hash;\n    server 192.168.125.142:9000 weight=3;\n    server 192.168.125.143:9000;\n    server 192.168.125.144:9000 max_fails=5 fail_timeout=30s;\n    server unix:/var/run/php5-fpm.sock backup;\n}\n```\n\n**옵션**\n```\nip_hash : 같은 방문자로부터 도착한 요청은 항상 같은 업스트림 서버가 처리하게 설정\nweight=n : 업스트림 서버의 비중(2 -> 2배 더 자주 사용)\nmax_fails=n : n으로 지정한 횟수만큼 실패가 일어나면 서버가 죽은 것으로 간주한다.\nfail_timeout=n : max_fails가 지정된 상태에서 이 값이 설정만큼 서버가 응답하지 않으면 죽은 것으로 간주한다.\ndown : 해당 서버를 사용하지 않게 지정한다. ip_hash; 지시어가 설정된 상태에서만 유효하다.\nbackup : 모든 서버가 동작하지 않을 때 backup으로 표시된 서버가 사용되고 그 전까지는 사용되지 않는다.\n```\n\n다음 사진과 같이 사용한다.\n![](upstream.PNG)\n\n## 재작성(rewrite)\n> rewrite 모듈을 통해 URL 재작성\n\n예제\n```\nlocation ~ /tutorials/javascript.html {\n    rewrite ^ http://opentutorials.org/course/48;\n}\n```\n\n리다이렉션을 디버깅 하기 위해선 **error_log 지시자를 server나 location블록 아래에 위치!!**\n\n```\nserver {\n    server_name opentutorials.org\n    error_log /var/log/opentutorials.org.error debug;\n    location ~ /.php$ {\n        error_log /var/log/opentutorials.org.php.error debug;\n    }\n}\n```\n\n위와 같이 사용하면 error log는 debug수준에서 출력 -> 에러 출력 debug레벨 사용\n\nwww를 제거하는 예제\n```\nif ($host ~* ^www\\.(.*)){\n    set $host_without_www $1;\n    rewrite ^/(.*)$ $scheme://$host_without_www/$1 permanent;\n}\n```","excerpt":"Nginx CGI(Common Gateway Interface) 란? 웹서버와 외부 프로그램(C, PHP, Python 등) 사이에서 정보를 주고받는 방법과 규약 이 표준에 맞춰 만들어진 것이 CGI 스크립트이다.  관련 용어 Web Server :…","fields":{"slug":"/phpNginxCI_2/"},"frontmatter":{"date":"Feb 24, 2021","title":"Nginx 학습","tags":["Nginx"],"update":"Mar 01, 2021"}}},{"node":{"rawMarkdownBody":"\n1. PHP + Nginx 개발 환경 설정\n2. Nginx 이해\n3. PHP 언어 사용방법 학습\n4. Codeigniter를 사용한 MVC 구현 방법 학습\n\n# 1. Window / Linux 환경 설정\n\n**아파치와 php7는 라이브러리 충돌 및 오류 때문에 잘 쓰이지 않음**\n\n## Window PHP 환경 설정\n\n1. WNMP 설치\n2. {설치경로}/conf/nginx/nginx.conf - root directory 변경 \n\n## Linux 환경 설정\n\n환경 설정 방법\n\n1. PHP-fpm 실행\n2. nginx 실행\n\n```bash\n$ apt-get install nginx\nNginx 실행 : service nginx start \nNginx 중단 : service nginx stop \nNginx 재시작 : service nginx restart  / nginx 서버 중단 후 재가동\nNginx 리로드 : service nginx reload  / 설정만 다시 적용\nNginx 자동 시작 : service nginx enable \nNginx 상태 : service nginx status\n```\n\n3. php 설치\n\n```bash\n$ apt-get install php-fpm\n```\n\n4. /etc/nginx/sites-available/default 파일 수정\n\n```\n1. index.php 자동 인식하게 설정\nindex index.html index.htm index.nginx-debian.html;\n\n2. 설치한 php fpm에 맞게 수정\nlocation ~ \\.php$ {\n  include snippets/fastcgi-php.conf;\n  fastcgi_pass unix:/var/run/php/php7.2-fpm.sock\n}\n\n3. 원하는 root경로 설정\nroot /{원하는 경로}\n```\n\n간단하게 index.php 파일을 만들어 들어가봤다.\n\n```php\n<?php\n  phpinfo();\n>\n```\n\n![](phpinfo.PNG)\n\n## **Tip!!**  \n설정파일 이상 여부 검사 \n```bash\nnginx -t\n```\nerror log확인 \n```bash\ntail -f /var/log/nginx/error.log  \n```  \n텍스트 모드 부팅 설정 (더 빨라짐)\n```bash\nsudo systemctl set-default multi-user.target\n```\n\n[putty로 virtualbox 연결하기 - 숭숭이님 블로그](https://m.blog.naver.com/skddms/220575084716)  \n[[Vim]vim 설정하기 - heyhyo님 블로그](https://hyoje420.tistory.com/51)  ","excerpt":"PHP + Nginx 개발 환경 설정 Nginx 이해 PHP 언어 사용방법 학습 Codeigniter를 사용한 MVC 구현 방법 학습 1. Window / Linux 환경 설정 아파치와 php7는 라이브러리 충돌 및 오류 때문에 잘 쓰이지 않음 Wi…","fields":{"slug":"/phpNginxCI_1/"},"frontmatter":{"date":"Feb 24, 2021","title":"PHP + Nginx 개발 환경 설정","tags":["PHP"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\nbash 20문제 풀이\n\n## 풀이\n\n1. 현재 자기신의 pc(linux기준)의 cpu모델명, Os 종류 및 버전, kernel 버전을 출력하시오.\n\n```bash\ncat /proc/cpuinfo | egrep  'model name'\ncat /etc/issue\nuname -r\n```\n\n2. 매주 일요일, 새벽4시 30분과 낮12시 30분에, /tmp/* 를 삭제하는 crontab \n예) * * * * * 실행문\n\n```bash\ncat <(crontab -l) <(echo \"30 4,12 * * * rm /tmp/*\") | crontab\ncrontab -l\n```\n\n3. 정수인자 2개를 받아 인자 개수 검증 후 4칙연산별 함수를 구현하여 결과값을 모두 \n\n```bash\nfunction add(){\n\tlet value=$1+$2\n\techo \"$1 + $2 : ${value}\"\n}\n\nfunction minus(){\n\tlet value=$1-$2\n\techo \"$1 - $2 : ${value}\"\n}\n\nfunction multiply(){\n\tlet value=$1*$2\n\techo \"$1 * $2 : ${value}\"\n}\n\nfunction divide(){\n\tlet value=$1/$2\n\techo \"$1 / $2 : ${value}\"\n}\n\nadd $1 $2\nminus $1 $2\nmultiply $1 $2\ndivide $1 $2\n```\n\n4. 2초마다 현재시간을 출력하는 스크립트를 작성하세요.\n\n(3번 실행되도록 작성)\n\n```bash\nnumber=0\n\nwhile [ $number -le 2 ]\ndo\n\tdate\n\t((number++))\n\tsleep 2\ndone\n```\n\n5. 첨부파일 lastlog를 이용하여 한번도 로그인한 적 없는 사용자를 삭제하는 명령어를 문자열로 아래와 같이 출력.\n\n```bash\nwhile read A B C D E F G H I\ndo\n\tif [[ \"$B\" =~ \"**Never\" ]]; then\n\t\techo \"userdel -r \" $A\n\tfi\ndone < lastlog\n```\n\n6. 첨부파일 lastlog를 이용하여 로그인한 적 없는 사용자를 제외하고 년 월 일 시간 사용자계정 순서로 아래와 같이 출력 i\n\n```bash\nwhile read A B C D E F G H I\ndo\n\tif [[ \"$B\" =~ \"pts\" ]]; then\n\t\techo ${I:0:-1} $E $F $G $A\n\tfi\ndone < lastlog\n```\n\n7. 첨부파일 lastlog를 이용하여 ntp와 firenwo user 라인사이에 ‘end of system user’라인 삽입.\n\n```bash\nsed -i'' -r -e \"/ntp/a\\end of system user\" lastlog\ncat lastlog\n```\n\n8. 첨부파일 checkpassword를 이용하여 09:59:57부터 10:21:45까지의 라인만 출력\n\n```bash\ncat checkpassword | awk '/[9]:59:5[7-9]/'\ncat checkpassword | awk '/[10]:[0-1][0-9]:[0-5][0-9]/'\ncat checkpassword | awk '/[10]:2[0-1]:[0-3][0-9]/'\ncat checkpassword | awk '/[10]:21:4[0-5]/'\n```\n\n9.  첨부파일 checkpassword를 이용하여 121.156.118.254를 pop3.mailplug.co.kr로, 14.36.253.67는 office.ip.wiro.kr로 치환하여 출력\n\n```bash\ncat checkpassword | sed 's/121.156.118.254/pop3.mailplug.co.kr/g' | sed 's/14.36.253.67/office.ip.wiro.kr/g' checkpassword\n```\n\n10. 첨부파일 maillog를 이용하여 root@ma10.mailplug.co.kr에서 수신된 메일의 수를 출력\n\n```bash\nindex=0\n\nwhile read line\ndo\n\tif [[ \"$line\" =~ \"from <root@ma10.mailplug.co.kr>\" ]]; then\n\t\tlet value=$index+1\n\t\tindex=$value\n\tfi\ndone < maillog\n\necho $index\n```\n\n11. 첨부파일 maillog를 이용하여 시간별 총 용량만 아래와 같이 출력(bytes)\n\n```bash\nwhile read time byte\ndo\n\techo \"$time $byte\"\ndone < maillog | grep bytes | awk '{print $3\":\"$11}' | awk -F \":\" '{arr[$1]+=$4} END { for (i in arr) {print i \"\\t\" arr[i]}}' | sort | awk '{ if($1~\"(0[0-9])\") {sub(/0/,\"\")} print $1 \"시\\t\" $2}'\n```\n\n12. 첨부파일 conf를 이용하여 ; 로된 주석라인과 공백라인을 제외한 라인 출력\n\n```bash\ncat conf | egrep -v ^[[:space:]]*$ | grep -v \";\"\n```\n\n13. ps 명령어를 이용하여 pid값이 낮은순에서 높은순으로 정렬하여 출력\n\n```bash\nps -ef --sort=+pid \n```\n\n14. 첨부파일 nginx를 이용하여 접근을 한 국가별 카운트와 국가명 출력.\n\n```bash\nwhile read A B C D E F line\ndo\n\tgeoiplookup $F >> ip\ndone < nginx\n\ngrep '' ip | awk '{print $1,$2,$3,$4,$5,$6,$7}' | sort | uniq -c > 14result\ncat 14result\nrm ip\n```\n\n15. 첨부파일 nginx를 이용하여 3번 이상 접근한 국가별 카운트와 국가명 출력\n\n```bash\ncat 14result | awk '{if ($1>3) {print $0}}'\n```\n\n16. 반복문을 이용하여 1M의 용량을 가진 파일부터 10M까지의 총 10개 파일 생성(1M씩 증가)\n\n```bash\nfor time in {01..10}\ndo\n\ttruncate -s ${time}M ./${time}file\ndone\n\nfind ./ -name \"*file\"\n```\n\n17. 16번에서 생성한 파일 중 5M이상의 파일의 생성시간을 2017년 12월 31일로 변경\n\n```bash\nfind ./ -type f -size +5M -exec touch -t \"201712310000\" {} \\;\n```\n\n18. 17번에서 만든 파일 중 2017년 12월 31일 이후에 만들어진 파일을 찾아 해당파일명.new로 변경\n\n```bash\nfind -type f -newermt '2017-12-31' | grep file | xargs rename 's/file/file.new/'\n```\n\n19. 아래 그림을 test.c 파일로 작성 후 result.exe란 파일로 컴파일하여 실행하고 출력값을 test.txt로 저장\n\n```bash\ngcc -o result test.c\n./result > test.txt\necho \"test.txt 파일 내용\"\ncat test.txt\n```\n\n20. 121.156.118.15서버의 오픈 된 포트를 확인 후 해당 포트로 통신이 가능한지 모니터링하는 스크립트를 작성\n\n```bash\nwhile :\ndo\n\tnmap -sT 121.156.118.15\n\tsleep 5\ndone\n```\n\n모든 bash 파일 실행\n\nresult.bash\n```bash\nfor i in {1..19}\ndo\n\tbash $i.bash 5 5\n\techo \" \"\ndone\nrm 01file.new 02file.new 03file.new 04file.new 05file.new 06file 07file 08file 09file 10file\n\nbash 20.bash\n```\n\n## 배운 부분\n\n2번\n - 매주 일요일 부분을 빠트림\n\n6번\n - Window와 Linux는 개행 방식이 다르다.\n\n|window|Unix(Linux 및 Mac)|\n|------|-------|\n| \\r\\n | \\n |\n\n**vscode같은 곳에서 연결해서 사용한다면 관련된 설정 해줘야 한다.**\n\n17번\n - 문제를 보면 5M이상임. -size +4M으로 작성해야 한다.\n\n주의할점\n - dd 명령어 사용 시 input / output에 주의해라!\n - chown 명령어 사용 시 -R 옵션 줄 때 ./* 같이 경로를 정확히 사용 (/ 이렇게 주면 큰일난다.)\n\n중요한 명령어와 개념\n - find, ls, du, awk, sed, free, chown, chmod, 리눅스 권한부분은 상당히 중요!","excerpt":"bash 20문제 풀이 풀이 현재 자기신의 pc(linux기준)의 cpu모델명, Os 종류 및 버전, kernel 버전을 출력하시오. 매주 일요일, 새벽4시 30분과 낮12시 30분에, /tmp/* 를 삭제하는 crontab \n예) * * * * *…","fields":{"slug":"/bashMission/"},"frontmatter":{"date":"Feb 23, 2021","title":"bash 문제 풀이","tags":["Linux"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# #!/bin/bash를 왜 쓸까\n\nbash파일은 주석을 #으로 단다.\n\nbash스크립트 파일 문제 풀면서 별 생각없이 #!/bin/bash 부분이 그냥 표시해주는 부분인 줄 알았는데\n\n\\#!/bin/bash를 꼭 달아줘야 한다고 한다.\n\n\"#!\"는 **Shebang**이라고 부르고, 실행 가능한 쉘 스크립트라는 것을 나타내는 특별한 표시자이다.  \n\n\"#!\" 뒤에 나오는 것은 경로명으로, 스크립트에 들어있는 명령어를 해석할 위치를 나타낸다.  \n**정확히 Full PATH로 작성해야한다.**  \n\n이 명령어 해석기가 주석은 무시하면서 스크립트의 첫번째 줄부터 명령어를 실행시킨다.\n\n\n## 쉘 스크립트의 구조\n\n\n```bash\n#!인터프리터(Interpreter)\n\n#\n# 주석(Comment)\n#\n\n함수명() {\n  명령\n  ...\n}\n\n명령1.. (Command)\n명령2..\n명령3..\n\n흐름제어 (Flow Control)\n\n함수 호출\n```","excerpt":"#!/bin/bash를 왜 쓸까 bash파일은 주석을 #으로 단다. bash스크립트 파일 문제 풀면서 별 생각없이 #!/bin/bash 부분이 그냥 표시해주는 부분인 줄 알았는데 #!/bin/bash를 꼭 달아줘야 한다고 한다. \"#!\"는 Sheba…","fields":{"slug":"/whyBash/"},"frontmatter":{"date":"Feb 23, 2021","title":"쉘 스크립트 첫 줄에 [#!/bin/bash]를 쓰는 이유","tags":["Linux"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n리눅스 자주쓰는 명령어와 중요 개념 정리한다.\n\n# 1. find\n> find [path] [Option] [expression] : 파일이나 디렉터리를 찾고 싶을 때 사용하는 명령어\n\n**Tip!!**\n- 옵션을 통해 다양한 경우의 상황으로 찾기 가능\n- 시간 옵션 뒤에 부여해야 하는 숫자 tip!!\n![linux time 옵션](./findTimeOption.PNG)\n\n## 옵션\n```\n -name : 파일이나 디렉토리 이름\n -iname : 대소문자 구분 없이 이름으로 검색\n -user : 사용자 이름\n -group : 그룹 이름\n -uid : uid로 검색\n -gid : gid로 검색\n -perm : 권한으로 검색\n -type : 파일 유형으로 검색\n    (d : 디렉토리, f : 파일, l : 링크, s : 소켓)\n -atime n : 파일에 접근한 시간(파일을 Open할 때 마다 갱신된다)\n -ctime n : inode의 값(파일 속성, 권한, 크기 등)으로 검색\n -mtime n : 파일이 수정되었을 때 기준으로 검색\n   * time부분을 min으로 사용하면 분으로 검색\n   * 추가로 Suffix를 붙여 정확한 시간 지정 가능\n -empty : 빈 파일 찾기\n -exec : 명령 내릴 수 있는 옵션 / 결과 값 {}, \\;로 끝내야 한다.\n -size n : n블록 길이의 파일\n -inum n : inode\n -maxdepth n : 파일 계층 depth의 최대값 설정\n -mindepth n : 파일 계층 depth의 최소값 설정\n -prune : 값을 찾으면 하위 디렉토리에 들어가서 찾지 않음\n -newer : 뒤에 적힌 파일보다 최근에 변경된 파일 찾음\n```\n\n## 사용 예제\n```bash\n# 수정된지 100일이 지난 파일 목록 출력\n$ find -mtime +100\n\n# php 디렉토리 파일 중, 오늘 생성한 디렉토리를 삭제하시오\n$ find ~/php/* -ctime 0 -type d -exec rm -r {} \\;\n\n# 연결되지 않은 심볼릭 링크 찾는 방법\n$ find -L . -type l\n\n# 현재 디렉토리에서 test로 시작하는 디렉토리만 찾아 삭제\n$ rm -r `find -name 'test*' -type d`\n\n```\n\n\n**Tip!!**\n - 명령어에서 `(backtick)사용 : 스크립트 내에서 명령어를 실행할 경우 이용\n - 2>/dev/null : 명령어 뒤에 추가로 달아주면 권한 없는건 화면에 출력되지 않는다.  \n\n\n\n# 2. grep\n> grep [option] [pattern] [file_name] : 특정 문자열을 파일에서 찾아주는 명령어\n\n- pattren에는 정규 표현식 메타 문자가 들어간다.\n\n**Tip!!**\n- egrep\n- egrep은 grep의 확장판\n- grep이 하나의 문자열을 찾는 것 과는 달리, 여러 개의 문자열을 동시에 찾기 가능  \n- grep에서 활용할 수 있는 메타문자 이외에 추가 정규 표현식 메타문자 사용 가능\n\n+: +앞의 정규표현식이 1회 이상 나타남  \n?: ?앞의 정규표현식이 0회 또는 1회 나타남  \n|: 문자열간의 OR연산자  \n(): 정규표현식을 둘러쌈  \n\n## 옵션\n```\n -b : 검색 결과의 각 행 앞에 블록번호 표시\n -c : 찾아낸 행의 총 개수 출력\n -i : 대소문자 구분 x\n -l : 대소문자 구분 o\n -n : 파일 내에서 행 번호를 함께 출력\n -s : 에러 메세지 외에 표시 x\n -G : 기본 정규식으로 검색\n```\n\n## 사용 예제\n\n```bash\n# 'm'으로 시작하는 모든 파일에서 'hamster'를 포함하는 모든 행을 찾으시오\n$ grep -n hamster m*\n\n# grep을 사용하여 마침표로 시작되는 줄을 찾으시오\n$ grep ^\\. {찾을 파일 / 디렉토리 명}\n\n# NW나 EA가 포함된 행을 출력한다\n$ egrep 'NW|EA' {file 명}\n\n# 숫자 3이 한 번 이상 등장하는 행 출력\n$ egrep '3+' {file 명}\n\n```\n\n\n# 3. awk\n> awk [옵션] \n문서에서 패턴을 검사해 원하는 값 얻는다.\n\n```\n$ awk {-f 파일명} {-F 필드 구분자} {\"패턴\"} {처리할 파일명}\n```\n- pattern 생략 시 **모든 레코드 적용**\n- action 생략 시 **print 적용**\n- pattern과 action에 작성되는 awk program 코드에는 표현식, 변수, 함수 사용 가능\n\n## 옵션\n```\n-F : 필드 구분 문자 지정\n-f : awk program 파일 경로 지정\n-v : awk program에서 사용될 특정 variable값 지정\n```\n\n\n## 사용 예제\n```bash\n# pattern 생략\n$ awk '{print}' ./file.txt\n\n# action 생략\n$ awk '/p/' ./file.txt\n\n# 레코드의 길이가 10 이상인 경우, 세 번째($3), 네 번째($4), 다섯 번째($5) 필드를 출력\n$ awk 'length($0) > 10 { print $3, $4, $5} ' {파일 이름}\n\n\n```\n\n\n# 4. Redirection\n> 명령의 결과를 모니터로 출력하지 않고, 파일로 저장할 수 있다. (리다이렉션을 사용해 출력, 입력 방향 지정 가능)\n\n표준 입출력(Standard I/O)  \n\n|구분|파일 디스크럽터|\n|----|----|\n| 표준 입력 | 0 |\n| 표준 출력 | 1 |\n| 표준 에러 | 2 |\n\n\n|기호|기능|\n|----|----|\n|>/>>| 출력 방향 재지정 |\n|</<<| 입력 방향 재지정 |\n|>| 덮어 쓴다.|\n|>> | 추가된다. |\n\n# 5. vi\n\n- 텍스트 편집기\n- 3가지 모드가 있다.\n  - 입력(내용입력), 명령(편집기능), 콜론(열기, 저장, 추가기능 수행)\n\n\n## 문자열 치환\n>: [범위] / [매칭 문자열] / [치환문자열] / [행범위] \n\n**Tip!!**\n- gg : 최상단으로 커서 옮김\n- 0 : 현재 줄 맨 앞\n- $ : 현재 줄 맨 뒤\n- dd : 라인 삭제\n- u : 복구\n- p : 붙여 넣기\n- yy : 라인 복사\n- :wq : 저장 후 종료\n- .vimrc 파일에 환경설정 가능!\n\n\n# 6. sed(stream deitor) \n> 필터링과 텍스트를 변환하는 스트림 편집기\n\n## 주요기능\n```bash\n# 1. 치환\n# addrass를 address로 바꾼다.\n$ sed 's/addrass/address/' {파일이름}\n\n# tab문자를 enter로 변환\n$ sed 's/\\t/\\ /' {파일이름}\n\n# 2. 삭제\n# 처음 1줄, 2줄을 지운다.\n\n# 공백라인을 삭제하는 명령\n$ sed '/^$/d {파일 이름}\n\n```\n\n[jhnyang님 블로그](https://jhnyang.tistory.com/287)\n\n# 7. ls\n> 현재 폴더의 하위 디렉토리의 리스트 출력\n## 옵션\n\n\n# 8.  사용자 권한 (chmod, chown)\n\n리눅스는 사용자 및 그룹에 기반하여 액세스를 허가하거나 금지한다.\n\n## chown\n> 파일의 소유권 바꾸기 위해 사용\n\n```bash\nchown [OPTION]... [OWNER][:[GROUP]] FILE...\n```\n\n## chmod\n> 파일이나 디렉토리의 모드를 변경\n\n```bash\n$ chmod {옵션} {권한} {파일}\n```\n\n# 9.  tty\n\n- 로그인 한 모든 세션은 각각 고유의 tty를 가지고 있다.\n- 입력과 출력을 처리한다.\n  \n```bash\n$ tty\n\n/dev/pts/0\n```\n\n# 10.  alias  \n> 사용자가 원하는 명령어를 추가하기 위한 명령어\n\n사용 예제\n```\n$ alias la='ls -a'\n$ alias lf='ls -F'\n$ alias lr='ls -R'\n$ alias ri='rm -i'\n$ alias mi='mv -i'\n```\n\n- alias를 입력하면 입력 된 alias를 확인할 수 있다.\n- ~/.bashrc에 정의하면 쉘이 시작할 때 자동으로 정의된다.\n\n\n# 11. history\n> 커맨드 이력 관리 명령어\n\n- ~/.bash_history 에 저장\n\n히스토리 관련 환경변수\n```\nHISTFILE : command 저장 파일\nHISTFILESIZE : 히스토리 파일 최대 크기\nHISTSIZE : 히스토리에 저장 가능한 최대 명령어 개수\n```\n\n**Tip!!**\n\n- history -w {파일 이름}: 별도의 파일로 저장\n- !! : 바로 직전 커맨드 실행\n- !n : history n 번째에 저장된 명령어 실행\n- !{string} : string으로 시작하는 가장 최근 실행한 커맨드 찾아 실행\n- :p : :p를 붙여서 실행 시 커맨드만 출력\n\n\n# 12. jobs / 포그라운드 백그라운드\n\n- jobs : 현재 쉘에서 작업 중지된 상태나 백그라운드로 진행되는 작업 표시\n- bg : 백그라운드 프로세스 확인\n- & : 프로세스를 백그라운드로 실행\n\n\n# 13. ps\n> 현재 실행중인 프로세스 목록과 상태를 보여준다.\n\n# 14. 심볼릭 링크, 하드 링크\n> 하나의 파일에 두개의 이름 사용하게 링크를 연결\n\n사용하는 경우\n - 매우 긴 파일명이 있을 때\n - 경로를 입력하지 않고 파일명만 입력해 사용할 때\n\n+ 서버(nginx)가 바라보는 경로설정 같은 경우에도 사용한다.\n\n## 차이점\n\n|하드 링크|심볼릭 링크|\n|----|----|\n| 파일에만 링크 가능 | 파일 또는 디렉토리에 링크 할 수 있음 |\n| 존재하지 않는 파일 링크 불가능 | 존재하지 않는 파일에 대해 링크 가능 |\n| 같은 파일 시스템에서만 가능 | 다른 파일 시스템에서 가능 |\n\n\n# 15. du / df\n\n## du\n> 디렉토리 사용량 확인\n\n### 옵션\n```\n-a : 모든 파일들의 기본정보를 보여준다.\n-b : 표시단위를 기본 KB 대신 Byte로 한다.\n-k : 표시단위를 KB 단위로 한다.\n-h : 파일들의 용량단위가 보기좋게 정리되어 보여준다.\n-c : 모든 파일들의 디스크 사용정보를 보여주고 나서 합계를 보여준다.\n-s : 총 사용량만 표시\n-x : 체크하는 경로안에 다른 시스템이 있으면 생략\n```\n\n## df\n> 디스크의 사용가능한 용량 확인\n\n# 16. dd\n> 파일을 변환하고 복사하는 명령어\n\n```\n$ dd if={입력} of={출력} bs={바이트} count={반복}\n\nibs = bytes     #한번에 bytes 바이트씩 읽는다.\nobs = bytes     #한번에 bytes 바이트씩 쓴다.\nskip = n        #n*ibs 바이트만큼 무시하고 읽는다.\nseek = n        #n*obs 바이트만큼 무시하고 쓴다.\n```\n\n# 17. cat\n> cat {옵션} 파일명\n\n파일 내용 출력\n\n# 18. cron\n> unix 운영체제에서 어떤 작업을 특정 시간에 실행시키기 위한 데몬\n\ncron 작업을 설정하는 파일을 crontab이라고 부른다.\n\n형식\n```\n* * * * * {명령어}\n\n분/시/일/월/요일 \n``` \n\n추가 기호\n```\n , : 복수개의 시간 지정\n * : 모든 시간 지정\n - : 시간의 범위 지정\n / : 시간 간격을 지정\n```\n\n크론 조회\n```bash\n$ crontab -l\n```\n\n크론 접근 권한 설정은 관련된 파일로 명시해준다.\n- /etc/cron.allow\n- /etc/cron.deny\n- /etc/con.d/cron.deny\n\n\n# 19. cut\n> cut {option} {file}\n\n파일에서 필드 추출, 필드는 구분자로 구분 가능\n\n옵션\n```\n -c : 잘라낼 곳의 위치 지정. (콤마나 하이픈으로 범위 설정 가능)\n -f : 잘라낼 필드 설정\n -d : 필드 구분 문자 지정\n```\n\n# 20. tar / gzip\n\ntar : gzip 명령이 포함된 압축 툴\ngzip : 파일 압축 명령어\n\n# 21. wc\n> wc {옵션} {파일}\n각각의 파일에 대한 줄(line), 단어(word), 문자(char), 바이트(byte) 수를 알려준다.\n\n## 옵션\n```\n-c : byte 수를 알려준다.\n-m : 문자 수를 알려준다.\n-l : 줄 수를 알려준다.\n-L : 가장 긴 줄의 길이를 알려준다.\n```\n\n# 22. Tree\n\ntree 명령어는 기본적으로 존재하는 명령어가 아니므로 apt이나 yum을 이용해 설치한다.\n\n```bash\n$ tree --help\n```\n명령어로 트리의 옵션을 볼 수 있다.\n![tree 옵션](./treeOption.PNG)\n\ntree 명령어의 실행 화면이다.\n\n![tree 실행 화면](./treeResult.PNG)\n\n# 23. Rsync\n\n","excerpt":"리눅스 자주쓰는 명령어와 중요 개념 정리한다. 1. find find path Option expression : 파일이나 디렉터리를 찾고 싶을 때 사용하는 명령어 Tip!! 옵션을 통해 다양한 경우의 상황으로 찾기 가능 시간 옵션 뒤에 부여해야 하…","fields":{"slug":"/linuxStudy/"},"frontmatter":{"date":"Feb 22, 2021","title":"Linux Study","tags":["Linux"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n1.소유자가 george이고 그룹이 others일때 data파일의 소유자와 그룹을 동시에 변경하시오.\n\n```bash\n$ chown georage:others data\n```\n\n2.현재 로그인한 사용자의 목록에서 2016­01­07에 접속한 사용자를 출력하시오.\n\n```bash\n$ who | grep '2016-01-07'\n```\n\n3.접근권한이 755인 data 디렉토리를 생성하시오(명령어 1개 이용).\n\n```bash\n$ mkdir -m 755 data\n```\n\n4.현재 디렉토리에서 링크파일만 찾는 lnfind란 alias를 생성하시오.\n\n```bash\n$ alias lnfind='find ./ -type l'\n```\n\n5.현재 디렉토리에서 24시간 내에 수정된 파일을 찾으시오.\n\n```bash\n$ find ./ -mtime -1\n```\n\n6.현재 디렉토리에서 test로 시작하는 디렉토리만 찾아 삭제하시오.\n\n```bash\n$ rm -r `find -name 'test*' -type d`\n```\n\n7.ssh를 이용하여 kumquat란 서버에 /test2란 디렉토리를 생성하시오.\n\n```bash\n$ ssh root@kumquat mkdir /test2\n```\n\n8.test1과 test2의 내용을 비교하는 명령어를 작성하시오.\n\n```bash\n$ diff test1 test2\n```\n\n9.test1 test2 test3을 리다이렉트를 이용하여 test4의 파일로 합치시오.\n\n```bash\n$ cat test1 test2 test3 > test4\n```\n\n10.test5 파일의 마지막 10개의 행을 출력하시오.\n\n```bash\n$ tail test5\n```\n\n11./etc/group과 /etc/passwd에서 root가 있는 라인의 개수를 출력하시오.\n\n```bash\n$ grep -c 'root' /etc/group/* /etc/etc/password/*\n```\n\n12.test6파일에서 시작문자가 a, 마지막 문자가 z로 끝나는 문장을 출력하시오.\n\n```bash\n$ grep -E '^a.*z$' test 6\n```\n\n13.test6파일에서 mail이 나오는 행과 plug가 나오는 행 사이의 모든 행을 출력하시오.\n\n```bash\n$ sed -e '/mail/, /plug/' test6\n```\n\n14.test7파일을 gzip으로 압축하시오.\n\n```bash\n$ gzip test7\n```\n\n15.test8파일의 가장 긴 줄의 길이를 출력하시오.\n\n```bash\n$ wc -L test8\n```\n\n16.vi ex에서 10행부터 파일의 끝까지를 test9로 저장하시오.\n\n```bash\n:10,$ w test9\n```\n\n17.vi ex에서 help 또는 Help라는 단어를 모두 HELP로 변경하시오.\n\n```bash\n:%s/[Hh]elp/HELP/g\n```\n\n18.dd를 사용하여 블록사이즈가 2바이트이고 10블록으로 null(/dev/zero)문자로 채워진 test10파일을 생성하시오.\n\n```bash\n$ dd if=/dev/zero of=test10 bs=2 count=10\n```\n\n19.test11파일의 3번째 필드를 기준으로 정렬하시오.\n\n```bash\n$ sort -k 3 test11\n```\n\n20.test12파일을 역순으로 정렬하고 중복되는 라인을 제거하고 출력하시오.\n\n```bash\n$ sort -ur test12\n```\n\n21.월요일마다 새벽 4시 30분에 /bin/date를 실행하는 cron문을 작성하시오.\n\n```bash\n$ 30 4 * * 1 /bin/date\n```\n\n22.최근에 사용한 명령 20개를 출력하시오.\n\n```bash\n$ history 20\n```\n\n23.cut명령어로 test14파일의 \"_\"를 구분자로 지정하여 두번째 필드를 출력하시오.\n\n```bash\n$ cut -d\"_\" -f2\n```\n\n24.touch명령어를 이용하여 test15파일을 2016년 1월 1일로 변경하시오.\n\n```bash\n$ touch -t 201601010000 test15\n```\n\n25.nginx프로세스에 대한 정보를 출력하시오.\n\n```bash\n$ ps -ef | grep nginx\n```\n\n26.2342의 pid를 가진 프로세스를 종료하시오.\n\n```bash\n$ kill -9 2342\n```\n\n27.ls를 백그라운드로 동작시키시오.\n\n```bash\n$ ls &\n```\n\n28.백그라운듸 작업목록을 출력하시오.\n\n```bash\n$ jobs\n```\n\n29.test16의 파일을 test.tar로 압축하시오.\n\n```bash\n$ tar -cvf test.tar test16\n```\n\n30.일정한 크기를 가진 여러 개의 작은 파일로 분할하는 명령어를 이용하여 test17파일을 20행씩 분할하시오.\n\n```bash\n$ split -l 20 test17\n```\n\n31.memory의 상세정보를 볼수있는 파일의 위치를 작성하시오.\n\n```bash\n$ which free\n\n=> /usr/bin/free\n```\n\n32.명령어의 위치를 찾을 수 있는 명령어를 작성하시오.\n\n```bash\n$ which\n$ whereis\n```\n\n33.60초동안 대기하는 명령어를 작성하시오.\n\n```bash\n$ sleep 60\n```\n\n34./dev/sda5를 /mnt에 마운트하는 명령어를 작성하시오.\n\n```bash\n$ mount /dev/sda5 /mnt\n```\n\n35.작업 중인 터미널창이 종료 되더라도 실행 중인 프로세스를 백그라운드 프로세스로 계속 작업할 수 있도록 하는 명령어를 작성하시오.\n\n```bash\n$ nohup {실행}&\n```\n\n\n36.apt­get 명령이 패키지 관련 정보를 확인하기 위해 참조하는 파일의 위치를 작성하시오.\n\n```bash\n$ /etc/apt/sources.list\n```\n\n37.yum을 이용하여 nginx 패키지를 제거하는 명령어를 작성하시오.\n\n```bash\n$ yum remove nginx\n```\n\n38.커널에 로드되어 있는 모듈을 확인하는 명령어를 작성하시오.\n\n```bash\n$ lsmod\n```\n\n39.현재 파일시스템들의 사용량을 MB단위로 출력하시오.\n\n```bash\n$ df -m\n```\n\n40./home/test18읠 디렉토리의 사용량을 KB단위로 출력하시오.\n\n```bash\n$ du -k ./home/test18\n```\n\n41.awk를 이용하여 test19파일의 필드 개수를 출력하시오.\n\n```bash\n$ awk '{print NF}' test19\n```\n\n42.awk를 이용하여 test20파일의 \"_\"를 구분자로 하는 첫번째와 세번째 필드를 출력하시오.\n\n```bash\n$ awk -F_ '{print $1, $3}' test20\n```\n\n43.cat nofile의 표준에러를 표준출력으로 리다이렉트하시오.\n\n```bash\n$ awk -F_ '{print $1, $3}' test19\n```\n\n44.basename /home/mkel/bin/test.sh 의 결과값을 작성하시오.\n\n```bash\n$ test.sh\n```\n\n45.test21의 계정의 로그인 쉘을 sh로 변경하시오.\n\n```bash\n$ vi /etc/passwd\n\ntest21의 7번째 필드 값을 sh로 변경\n```\n\n46.시스템을 부팅 시 자동으로 마운트되게 하기 위해 설정해야 하는 파일의 위치를 작성하시오.\n\n```bash\n/etc/fstab\n```\n\n47.호스트끼리 메일 메시지를 주고받기 위한 간단하고 확장성이 있는 프롤토콜은 무엇인가?\n\n```bash\n$ SMTP(Simple Mail Transfer Protocol) 프로토콜\n```\n\n48.mailplug.co.kr의 DNS 질의를 할 수 있는 명령어를 작성하시오.\n\n```bash\n$ nslookup mailplug.co.kr\n```\n\n49.listen되고 있는 포트의 네트워크 정보상태를 출력하시오.\n\n```bash\n$ netstat -tnlp\n```\n\n50.bash에서 2MB보다 큰 파일을 만들지 못하게 하는 명령어를 작성하시오.\n\n```bash\n$ ulimit -f 2000\n```\n\n","excerpt":"1.소유자가 george이고 그룹이 others일때 data파일의 소유자와 그룹을 동시에 변경하시오. 2.현재 로그인한 사용자의 목록에서 2016­01­07에 접속한 사용자를 출력하시오. 3.접근권한이 755인 data 디렉토리를 생성하시오(명령어 …","fields":{"slug":"/linuxProblem2/"},"frontmatter":{"date":"Feb 21, 2021","title":"Linux 문제 풀이2","tags":["Linux"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n1. 수정된지 100일이 지난 파일 목록을 출력하시오. (명령어 : find)\n\n```bash\n$ find -mtime +100\n```\n\n2. (a)에서 (b)의 결과를 얻으시오 (명령어: ll)\n![](2번.PNG)\n\n```bash\n$ ll -rt\n```\n\n3. 명령어가 저장되는 history 파일의 경로는 어디인가\n\n```bash\n$ ~/.bash_history\n```\n\n4. 저장된 히스토리를 파일명 ‘myhistory.log’ 으로 저장하시오\n\n```bash\n$ history > myhistory.log\n```\n\n5. 아래 디렉토리의 소유자/그룹을 하위 디렉토리, 파일까지 전부 nobody 로 변경하시오. (명령어:chown)\n![](5번.PNG)\n\n```bash\n$ chown -R nobody:nobody ./*\n```\n\n6. temp 디렉토리의 파일 중, 하루가 지난 파일을 삭제하시오 (명령어: find)\n\n```bash\n$ find /temp -ctime +0 -type f -exec rm -f {} \\;\n```\n\n7. screen 명령어를 사용하여, 서버와의 연결이 비정상종료되더라도, session은 유지한 채 작업을 할 수 있다. 이\n때 단축키를 사용하여 screen에서 빠져 나오시오.\n\n```bash\nCTRL + a + d\n```\n\n8. 자신이 사용하고 있는 tty를 출력하시오.\n\n```bash\ntty\n```\n\n9. 아래 그림과 같이 단계적인 디렉토리를 한번에 생성하시오.\n![](9번.PNG)\n\n```bash\nmkdir -p 1/2/3/4\n```\n\n10. grep 명령어의 위치를 출력하시오.\n\n```bash\n$ which grep\n\n$ whereis grep\n```\n\n11. 상위디렉토리로 이동하는 ‘cd..’ 를 ‘pd’로 정의하시오. (alias)\n\n```bash\nalias pd='cd..'\n``` \n\n12. 이전에 친 ‘vi mytest’ 명령어를 다시 출력하는 방법은 무엇인가.\n\n```bash\n$ !!\n\n$ !{history에 명령어 번호}\n```\n\n13. 아래 출력결과를 현재 경로 내에 result.txt 파일로 저장하시오.\n![](13번.PNG)\n\n```bash\n$ ll > result.txt\n```\n\n14. 5개의 백그라운드(background) 작업 중, 3번 작업을 포그라운드(foreground)로 가져오시오.\n\n```bash\n$ fg %3\n```\n\n15. 이름 ‘vi’ 프로세스를 찾아 종료시키시오. (‘vi’ 프로세스 id는 9140으로 가정한다.)\n\n```bash\n$ ps -ef | grep vi\n\n$ kill 9140\n```\n\n16. (a)에서 (b)의 결과를 얻으시오 (명령어: ll)\n![](16번.PNG)\n\n```bash\n$ ll -d\n```\n\n17. ‘test.txt’ 파일에서 상단 10줄을 읽어 오류만 ‘error.txt’ 에 저장하시오.\n\n```bash\n$ head test.txt 2> error.txt\n```\n\n18. ‘test.txt’ 파일에 ‘link_test’ 이름으로 심볼릭 링크를 생성하시오.\n\n```bash\n$ ln -s test.txt link_test\n```\n\n19. (a)에서 (b)의 결과를 얻으시오 (명령어: du)\n![](19번.PNG)\n\n```bash\n$ du -ah\n``` \n\n20.  현재 디렉토리의 모든 파일에서 ‘mail’ 이라는 패턴이 들어간 파일의 이름을 출력하라. (명령어 : grep)\n\n```bash\n$ grep -l 'mail' *\n```\n\n1.  ‘m’으로 시작하는 모든 파일에서 ‘hamster’ 를 포함하는 모든 행을 찾으시오.(명령어 : grep)\n\n```bash\n$ grep -n hamster m*\n```\n\n22. 현재 디렉토리 내의 ‘test.txt’ 파일에서 ‘:’ 구분자를 이용하여 3번째 필드를 출력하라 (명령어 : awk)\n\n```bash\n$ awk -F: '{ print $3 }' test.txt\n```\n\n23. 현재 디렉토리 내의 ‘test.txt’ 파일에서 1행에서 3행까지 출력하라. (명령어 : sed)\n\n```bash\n$ sed -n '1,3p' test.txt\n```\n\n24. vi 에디터의 탭간격을 4로 설정하시오. (vi 에디터를 실행시켰다고 가정)\n \n```bash\n:set sts=4\n```\n\n25. 다음 vi 화면에서 ‘if’를 ‘testif’ 로 한번에 변경하시오.\n![](25번.PNG)\n\n```bash\n:%s/if/testif/g\n``` \n\n1.  실행중인 터미널의 사이즈를 구하시오.\n\n```bash\n$ stty size\n```\n\n27. 로그인 하고 있는 모든 사용자를 출력하시오.\n\n```bash\n$ who\n```\n\n28. 현재 서버의 메모리와 캐시사용량을 mb 단위로 출력하시오.\n\n```bash\n$ free -m\n```\n\n29. 현재 디렉토리에 linuxwr.txt라는 파일을 만드는 alias를 작성하시오. (alias명 : linuxtest)\n \n```bash\n$ alias linux=\"touch linuxwr.txt\"\n```\n\n30. 포그라운드(foreground)로 실행중인 프로세스를 일시 중지하는 단축키는 무엇인가.\n \n```bash\nCTRL + Z\n```\n\n31.  아래 리스트에서 ‘6자리 단어이자, 대소문자 구분없이 ‘y’ 가 포함되는’ 단어의 개수를 출력하라.\n(명령어:more)\n![](31번.PNG)\n\n```bash\nmore list | grep -w '......' | -ic 'y'\n```\n\n32. ‘diff -u b a’ 명령어를 이용하여 아래와 같은 결과를 도출하였다. 결과값을 가지고 a파일을 만드시오.\n![](32번.PNG)\n\n```bash\ndiff -u b a > a\n```\n\n33. 당일 오후 1시로 알람을 지정한 뒤, 프로세스를 죽이시오 (PID는 9140으로 가정한다.)\n \n```bash\nkill -14 9999 | at 13:00\n```\n\n34.  10G의 더미파일(빈파일)을 만들고자 한다. 흰색을 채우시오. (파일명은 ‘mailplug’로 지정한다.)\n![](34번.PNG)\n\n```bash\n$ dd if=/dev/zero of=파일명 bs=1GB count=10\n```\n\n35. 시그널 이름 중 ‘SIGQUIT’ 는 몇 번에 해당하는가?  \n\n```\na. 19 b.17 c.15 d.3 e.1\n```\n\n```bash\n3\n``` \n\n36.  csh 에서 로그아웃할 때 백그라운드 프로세스들을 자동으로 죽일 때, 어느 파일을 참조하는가?\n```\na. .logout b. .bash_history c. .bashrc d. .bash_logout e. hamster\n```\n\n정답 : a\n\n```bash\n$ ~/logout\n```\n\n37.  grep 을 사용하여 마침표로 시작되는 줄을 찾으시오.\n\n```bash\n$ grep ^\\. {찾을 파일/디렉토리 명}\n```\n\n38. 디렉토리 내에서 가장 새로운 파일의 이름을 출력하는 방법은 무엇인가 (명령어: ls)\n\n```bash\n$ ls -t1 | head -1\n```\n\n39. 연결되지 않은 심볼릭 링크 찾아내는 방법은 무엇인가 (명령어: find)\n\n```bash\n$ find -L . -type l\n```\n\n40. ‘rm’ 명령어 사용시, 바로 삭제시키지 않고 한번 더 물어본 후 삭제시키고자 할 때 사용하는 옵션은?\n\n```bash\n$ rm -l file\n```\n\n41. ‘cat’ 명령어 옵션 중, ‘tab과 행바꿈 문자를 제외한 제어 문자를 ^ 형태로 출력해 주는’ 옵션은?\n\n```bash\n$ cat -v file\n```\n\n42. 0.0.0.0 에서 999.999.999.999 까지 표현할 수 있는 정규표현식을 작성하시오.\n\n```bash\n$ [0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\n```\n\n43. ‘egrep’ 명령어를 이용하여 ‘testfile’ 내 ‘숫자 3이 한 번 이상 등장하는 행을 출력하시오’.\n\n```bash\n$ egrep '3+' testfile\n```\n\n44. 디렉토리 구조는 아래와 같다. a.py 를 vi 편집기로 연 후, 빠져 나오지 않은 채, b.py 로 전환하시오.\n (cf. a.py 파일을 연 후, :q 명령은 내리지 않는다.)  \n\n![](44번.PNG)\n\n```bash\n:e b.py\n```\n\n45. 파일의 제일 앞부분에 있는 100개의 문자를 삭제하시오 (명령어 : dd)\n\n```bash\ndd if={input file이름} of={output file이름} ibs=1 slip100 conv=cotrunc\n```\n\n46. ‘test.log’ 파일을 정렬하여, 동일 디렉토리 내 ‘result.log’ 에 작성하시오. (명령어 : sort)\n\n```bash\n$ sort -o result.log test.log\n```\n\n47. 백그라운드로 실행중인 프로세스나 현재 중지된 프로세스 목록을 PID와 같이 출력하라.\n\n```bash\n$ jobs -l\n```\n\n48. 현재 등록된 crontab에 등록된 작업을 출력하시오\n\n```bash\n$ crontab -l\n```\n\n49. 아래 crontab 에 대해 맞는 설명은?\n![](49번.PNG)\n\n```\n a. 새벽 4시부터 낮12까지 30분 간격으로 로그파일 삭제.\n b. 매주 일요일, 새벽4시 30분과 낮12시 30분에, 로그파일 삭제.\n c. 매월 4일, 12일에 매시간 30분에 로그파일 삭제\n d. 새벽4시와 낮 12시, 30분에 로그파일 삭제\n e. 매월 30일 새벽4시와 낮12시에 로그파일 삭제\n```\n\n정답 : d\n```bash\n매일 4시 30분 12시 30분에 홈디렉토리의 모든 로그파일 삭제\n```\n\n1.   vi 편집기내에서 문서 최상단으로 커서를 위치시키는 명령어는?\n\n```bash\ngg\n\n1G\n```\n","excerpt":"수정된지 100일이 지난 파일 목록을 출력하시오. (명령어 : find) (a)에서 (b)의 결과를 얻으시오 (명령어: ll)\n 명령어가 저장되는 history 파일의 경로는 어디인가 저장된 히스토리를 파일명 ‘myhistory.log’ 으로 저장하…","fields":{"slug":"/linuxProblem1/"},"frontmatter":{"date":"Feb 20, 2021","title":"Linux 문제 풀이1","tags":["Linux"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# 위상 정렬\n> 싸이클이 없는 방향 그래프의 모든 노드를 **방향성에 거스르지 않도록 순서대로 나열**\n\n**Tip!!**\n1. 그래프에서 **방문 조건이 주어질 때 사용!!**\n2. 시간 복잡도 **O(V+E)**이다.\n   (모든 노드를 확인하면서, 해당 노드에서 출발하는 간선을 차례대로 제거하기 때문)\n\n## 구현 방법\n\n### 1. DFS 활용\n\n```\n1. DFS 실행\n2. DFS가 끝날 때 스택에 삽입\n\n```\n\n### 2. BFS와 In-degree 활용\n\n```\n1. 모든 간선을 읽으며 InDegree 테이블을 채운다.\n2. Indegree가 0인 정점을 모두 큐에 넣는다.\n3. 큐의 Front에 있는 정점을 가져와 위상정렬 결과에 추가한다.\n4. 해당 정점으로부터 연결된 모든 정점의 Indegree값을 1 감소 시킨다.\n   이 때 Indegree가 0이면 그 정점을 큐에 추가\n5. 큐게 빌 때까지 3,4번을 반복\n```\n\n**Tip!!**\n - **루프가 V번 돌기전에 큐가 비면** 위상정렬이 **불가능**\n - **큐의 크기가 2이상인 경우가 생기면** 위상정렬 **결과가 2개 이상**\n\n## 백준 2623 - 음악 프로그램\n\n---\n\n![2623pb1](2623pb1.PNG)  \n![2623pb2](2623pb2.PNG)  \n\n---\n\n### 풀이\n---\n\n간선을 입력받을 때 슬라이딩 윈도우 방식을 사용한다. \n\nBFS / Indegree를 활용해 위상정렬\n\n---\n\n```java\npackage TopologySort;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class num2623 {\n\tstatic int N, M;\n\tstatic int[] indegree;\n\tstatic Queue<Integer> q = new LinkedList<Integer>();\n\tstatic ArrayList<Edge>[] edge;\n\tstatic int[] result;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st;\n\t\tst = new StringTokenizer(br.readLine());\n\t\t\n\t\tN = stoi(st.nextToken());\n\t\tM = stoi(st.nextToken());\n\t\t\n\t\tindegree = new int[N+1];\n\t\tresult = new int[N+1];\n\t\tedge = new ArrayList[N+1];\n\t\t\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tedge[i] = new ArrayList<Edge>();\n\t\t}\n\t\t\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tint testCase = stoi(st.nextToken());\n\t\t\tif(testCase==0) continue;\n\t\t\t\n\t\t\tint prev = stoi(st.nextToken());\n\t\t\tfor(int j=1; j<testCase; j++) {\n\t\t\t\tint now = stoi(st.nextToken());\n\t\t\t\tindegree[now]++;\n\t\t\t\tedge[prev].add(new Edge(prev, now));\n\t\t\t\tprev = now;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=1; i<=N; i++)\n\t\t\tif(indegree[i]==0) q.add(i);\n\t\t\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tif(q.isEmpty()) {\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint now = q.poll();\n\t\t\tresult[i] = now;\n\t\t\tfor(Edge e : edge[now]) {\n\t\t\t\tindegree[e.e]--;\n\t\t\t\tif(indegree[e.e]==0)\n\t\t\t\t\tq.add(e.e);\n\t\t\t}\n\t\t}\n\t\tfor(int num : result) {\n\t\t\tSystem.out.println(num);\n\t\t}\n\t\t\n\t}\n\tstatic class Edge{\n\t\tint s, e;\n\t\tEdge(int s, int e){\n\t\t\tthis.s = s;\n\t\t\tthis.e = e;\n\t\t}\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\n}\n\n```\n\n## 백준 1516 - 게임 개발\n\n---\n\n![1516pb1](1516pb1.PNG)  \n![1516pb2](1516pb2.PNG)  \n\n---\n\n### 풀이\n---\n\n이 전 문제와 비슷한데 출력을 비용으로 해준다.\n -> result배열에 간선의 값을 더해준다.\n\n---\n\n```java\npackage TopologySort;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class num1516 {\n\tstatic int N, M;\n\tstatic int[] indegree, result, weight;\n\tstatic Queue<Integer> q = new LinkedList<Integer>();\n\tstatic ArrayList<Edge>[] edge;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\t\n\t\tN = stoi(st.nextToken());\n\t\t\n\t\tindegree = new int[N+1];\n\t\tresult = new int[N+1];\n\t\tedge = new ArrayList[N+1];\n\t\tweight = new int[N+1];\n\t\t\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tedge[i] = new ArrayList<Edge>();\n\t\t}\n\t\t\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tweight[i] = stoi(st.nextToken());\n\t\t\twhile(true) {\n\t\t\t\tint prev = stoi(st.nextToken());\n\t\t\t\tif(prev == -1) break;\n\t\t\t\tindegree[i]++;\n\t\t\t\tedge[prev].add(new Edge(prev, i));\n\t\t\t}\n\t\t\tif(indegree[i] == 0){\n\t            result[i] = weight[i];\n\t            q.add(i);\n\t        }\n\t\t}\n\t\t\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tif(q.isEmpty()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint now = q.poll();\n\t\t\t\n\t\t\tfor(Edge next : edge[now]) {\n\t\t\t\tresult[next.e] = Math.max(result[next.e], result[now]+weight[next.e]);\n\t\t\t\tindegree[next.e]--;\n\t\t\t\tif(indegree[next.e]==0)\n\t\t\t\t\tq.add(next.e);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=1; i<=N; i++)\n\t\t\tSystem.out.println(result[i]);\n\t\t\n\t}\n\tstatic class Edge{\n\t\tint s, e;\n\t\tEdge(int s, int e){\n\t\t\tthis.s = s;\n\t\t\tthis.e = e;\n\t\t}\n\t}\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\n}\n\n```\n\n## 백준 2252 - 줄 세우기\n\n---\n\n![2252pb1](2252pb1.PNG)  \n![2252pb2](2252pb2.PNG)  \n\n---\n\n### 풀이\n---\n\n2623번과 거의 동일하다\n\n---\n\n```java\npackage package34;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class num2252 {\n\tstatic int N, M;\n\tstatic int[] indegree,result;\n\tstatic ArrayList<Edge>[] edge;\n\tstatic Queue<Integer> q = new LinkedList<Integer>();\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tString[] NM = br.readLine().split(\" \");\n\t\t\n\t\tN = stoi(NM[0]);\n\t\tM = stoi(NM[1]);\n\t\tindegree = new int[N+1];\n\t\tresult = new int[N+1];\n\t\tedge = new ArrayList[N+1];\n\t\t\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tedge[i] = new ArrayList<Edge>();\n\t\t}\n\t\t\n\t\tfor(int i=1; i<=M; i++) {\n\t\t\tString[] edgeData = br.readLine().split(\" \");\n\t\t\tint s = stoi(edgeData[0]);\n\t\t\tint e = stoi(edgeData[1]);\n\t\t\t\n\t\t\tedge[s].add(new Edge(s, e));\n\t\t\tindegree[e]++;\n\t\t}\n\t\t\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tif(indegree[i] == 0) q.add(i);\n\t\t}\n\t\t\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tif(q.isEmpty()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint temp = q.poll();\n\t\t\tresult[i] = temp;\n\t\t\tfor(Edge e : edge[temp]) {\n\t\t\t\tindegree[e.e]--;\n\t\t\t\tif(indegree[e.e] == 0)\n\t\t\t\t\tq.add(e.e);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tSystem.out.print(result[i] + \" \");\n\t\t}\n\t\t\n\t}\n\t\n\tstatic class Edge{\n\t\tint s, e;\n\t\tEdge(int s, int e){\n\t\t\tthis.s = s;\n\t\t\tthis.e = e;\n\t\t}\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n\n```\n\n## 백준 3665 - 최종 순위\n\n---\n\n![3665pb1](3665pb1.PNG)  \n![3665pb2](3665pb2.PNG)  \n\n---\n\n### 풀이\n---\n\n일단 문제가 이해가 안되서\n\n[stack07142님 블로그](https://stack07142.tistory.com/223)를 참고했다.\n\n1. 그래프를 인접 행렬로 구현한다.  \n2. 바뀐 순위에 따라 간선과 indegree를 갱신한다.  \n3. 위상 정렬을 한다.  \n   3-1. **정상일 경우**에 1등 팀 부터 순서대로 출력  \n   3-2. **확실한 순위를 찾을 수 없다면** \"?\"출력  \n   3-2. **사이클이 생겨** 순위를 정할 수 없는 경우   \"IMPOSSIBLE\"출력  \n\n어렵당...\n\n---\n\n```java\npackage package34;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class num3665 {\n    static final int NONE = 0;\n    static final int IMPOSSIBLE = 1;\n    static final int NOT_DETERMINED = 2;\n\n    static int T, N, M;\n    static int[] indegree, result, prev;\n    static Queue<Integer> q = new LinkedList<Integer>();\n    static int[][] graph;\n    \n    public static void main(String[] args) throws IOException {\n\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder sb = new StringBuilder();\n\n        T = stoi(br.readLine());\n\n        for(int i=0; i<T; i++){\n            N = stoi(br.readLine());\n\n            indegree = new int[N + 1];\n            result = new int[N+1];\n            prev = new int[N+1];\n            graph = new int[N+1][N+1];\n\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            for (int j=0; j < N; j++) \n                prev[j] = stoi(st.nextToken());\n            \n\n            for (int j = 0; j < N; j++) {\n                for (int k = j + 1; k < N; k++) {\n                    graph[prev[j]][prev[k]] = 1;\n                    indegree[prev[k]]++;\n                }\n            }\n\n            M = stoi(br.readLine());\n\n            for (int j=0; j<M; j++) {\n\n                st = new StringTokenizer(br.readLine());\n\n                int a = stoi(st.nextToken());\n                int b = stoi(st.nextToken());\n\n                if (graph[a][b] == 1) {\n                    graph[a][b] = 0;\n                    graph[b][a] = 1;\n\n                    indegree[a]++;\n                    indegree[b]--;\n                } else {\n                \tgraph[a][b] = 1;\n                    graph[b][a] = 0;\n                    \n                    indegree[b]++;\n                    indegree[a]--;\n                }\n            }\n            \n            for (int j=1; j<=N; j++) {\n                if (indegree[j] == 0) {\n                    q.add(j);\n                }\n            }\n\n            int ans = NONE;\n            for (int j=1; j<=N; j++) {\n                if (q.isEmpty()) {\n                    ans = IMPOSSIBLE;\n                    break;\n                }\n                if (q.size() > 1) {\n                    ans = NOT_DETERMINED;\n                    break;\n                }\n\n                int u = q.poll();\n                result[j] = u;\n\n                for (int k=1; k<=N; k++) {\n                    if (graph[u][k] == 1) {\n                        indegree[k]--;\n                        if (indegree[k] == 0) q.add(k);\n                    }\n                }\n            }\n            \n            if (ans == NONE) {\n                for (int j=1; j<=N; j++)sb.append(result[j] + \" \");\n                sb.append(\"\\n\");\n            } else if (ans == IMPOSSIBLE) sb.append(\"IMPOSSIBLE\\n\");\n            else if (ans == NOT_DETERMINED) sb.append(\"?\\n\");\n        }\n        System.out.println(sb);\n    }\n    \n    public static int stoi(String string) {\n    \treturn Integer.parseInt(string);\n    }\n}\n```\n\n## 백준 1005 - ACM Craft\n\n---\n\n![1005pb1](1005pb1.PNG)  \n![1005pb2](1005pb2.PNG)  \n![1005pb3](1005pb3.PNG)  \n![1005pb4](1005pb4.PNG)  \n![1005pb5](1005pb5.PNG)  \n\n---\n\n### 풀이\n---\n\n1516문제와 비슷하다.\n\n---\n\n```java\npackage package34;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class num1005 {\n\tstatic int T, N, K;\n    static int[] result, indegree, weight;\n\tstatic ArrayList<Edge>[] edge;\n\tstatic Queue<Integer> q = new LinkedList<Integer>();\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuilder sb = new StringBuilder();\n\t\tStringTokenizer st;\n\t\t\n\t\tT = stoi(br.readLine());\n\t\t\n\t\twhile(T-- >0) {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tN = stoi(st.nextToken());\n\t\t\tK = stoi(st.nextToken());\n\t\t\t\n\t\t\tresult = new int[N+1];\n\t\t\tindegree = new int[N+1];\n\t\t\tweight = new int[N+1];\n\t\t\tedge = new ArrayList[N+1];\n\t\t\t\n\t\t\tfor(int i=1; i<=N; i++) {\n\t\t\t\tedge[i] = new ArrayList<Edge>();\n\t\t\t}\n\t\t\t\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tfor(int i=1; i<=N; i++) {\n\t\t\t\tweight[i] = stoi(st.nextToken());\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=1; i<=K; i++) {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\tint s = stoi(st.nextToken());\n\t\t\t\tint e = stoi(st.nextToken());\n\t\t\t\t\n\t\t\t\tedge[s].add(new Edge(s,e));\n\t\t\t\tindegree[e]++;\n\t\t\t}\n\t        for(int i=1; i<=N; i++) {\n\t            result[i] = weight[i];\n\t \n\t            if(indegree[i] == 0)\n\t                q.offer(i);\n\t        }\n\t        \n\t\t\tfor(int i=1; i<=N; i++) {\n\t\t\t\tif(q.isEmpty()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint now = q.poll();\n\t\t\t\tfor(Edge next : edge[now]) {\n\t\t\t\t\t// 요기 중요함 둘 중 큰거 들어감\n\t\t\t\t\tresult[next.e] = Math.max(result[next.e], result[now]+weight[next.e]);\n\t\t\t\t\tindegree[next.e]--;\n\t\t\t\t\tif(indegree[next.e]==0)\n\t\t\t\t\t\tq.add(next.e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint num = stoi(br.readLine());\n\t\t\tsb.append(result[num]+\"\\n\");\n\t\t}\n\t\tSystem.out.println(sb);\n\t\t\n\t}\n\t\n\tstatic class Edge{\n\t\tint s, e;\n\t\tEdge(int s, int e){\n\t\t\tthis.s = s;\n\t\t\tthis.e = e;\n\t\t}\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\t\n}\n```\n\n## 백준 1766 - 문제집\n\n---\n\n![1766pb1](1766pb1.PNG)  \n![1766pb1](1766pb2.PNG)  \n\n---\n\n### 풀이\n---\n\n문제를 보면 **가능한 쉬운 문제부터 풀어야 한다.** 라는 조건이 있다.  \n -> 이 조건은 Queue대신 PriorityQueue를 사용해 minheap에 저장하면 쉽게 구현 가능하다.\n\n---\n\n```java\npackage package34;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class num1766 {\n\tstatic int N, M;\n\tstatic int[] indegree,result;\n\tstatic ArrayList<Edge>[] edge;\n\tstatic PriorityQueue<Integer> q = new PriorityQueue<Integer>();\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tString[] NM = br.readLine().split(\" \");\n\t\t\n\t\tN = stoi(NM[0]);\n\t\tM = stoi(NM[1]);\n\t\tindegree = new int[N+1];\n\t\tresult = new int[N+1];\n\t\tedge = new ArrayList[N+1];\n\t\t\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tedge[i] = new ArrayList<Edge>();\n\t\t}\n\t\t\n\t\tfor(int i=1; i<=M; i++) {\n\t\t\tString[] edgeData = br.readLine().split(\" \");\n\t\t\tint s = stoi(edgeData[0]);\n\t\t\tint e = stoi(edgeData[1]);\n\t\t\t\n\t\t\tedge[s].add(new Edge(s, e));\n\t\t\tindegree[e]++;\n\t\t}\n\t\t\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tif(indegree[i] == 0) q.add(i);\n\t\t}\n\t\t\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tif(q.isEmpty()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint temp = q.poll();\n\t\t\tresult[i] = temp;\n\t\t\tfor(Edge e : edge[temp]) {\n\t\t\t\tindegree[e.e]--;\n\t\t\t\tif(indegree[e.e] == 0)\n\t\t\t\t\tq.add(e.e);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tSystem.out.print(result[i] + \" \");\n\t\t}\n\t\t\n\t}\n\t\n\tstatic class Edge{\n\t\tint s, e;\n\t\tEdge(int s, int e){\n\t\t\tthis.s = s;\n\t\t\tthis.e = e;\n\t\t}\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n```\n\n---\n\n끗\n\n\n# Reference\n\n[[그래프]위상 정렬 - JuticeHui님 블로그](https://justicehui.github.io/easy-algorithm/2018/03/24/TopologicalSort/)   \n[갓킹독님 블로그](https://blog.encrypted.gg/910?category=773649)   \n[라이님 블로그](https://m.blog.naver.com/kks227/220800013823)  \n","excerpt":"위상 정렬 싸이클이 없는 방향 그래프의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열 Tip!! 그래프에서 방문 조건이 주어질 때 사용!! 시간 복잡도 O(V+E)이다.\n(모든 노드를 확인하면서, 해당 노드에서 출발하는 간선을 차례대로 제거하기…","fields":{"slug":"/topologicalSort/"},"frontmatter":{"date":"Feb 09, 2021","title":"위상정렬 정리","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# 신장 트리(Spnning Tree)\n> 하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프\n\n# 최소 신장 트리(Minimum Spanning Tree)\n> 트리의 간선마다 가중치가 있을 때, **간선의 가중치 합이 최소**인 트리\n\n신장 트리의 최소비용을 구하는 크루스칼 알고리즘, 프림 알고리즘 2가지 알고리즘에 대해 정리한다.\n\n## 크루스칼 알고리즘\n---\n> 간선 선택 기반의 알고리즘으로, 탐욕적인 방법을 이용, 간선을 하나씩 선택해서 MST를 찾는 알고리즘입니다.\n\n### 특징\n---\n1. 그리디 알고리즘의 일종 -> 작은 간선부터 훑기 때문에  \n2. 시간 복잡도 : **O(ElogE)**  \n   -> 가중치 별로 정렬 : O(ElogE) + 정점이 같은 컴포넌트에 속해있는지 확인 : 약 O(1) = **O(ElogE)**  \n\n\n### 구현 방법\n---\n\n```\n1. 간선을 비용에 따라 오름차순으로 정리하고, 정점을 초기화한다\n2. 간선을 하나씩 확인하며 간선이 싸이클을 발생시키지 않으면 간선을 포함시킨다.\n3. 간선을 V-1개 뽑았을 때, 이루는 그래프가 MST이다.\n```\n\n## 백준 1197 - 최소 스패닝 트리\n\n---\n\n![1197pb1](1197pb1.PNG)\n![1197pb2.PNG](1197pb2.PNG)\n\n---\n\n### 풀이\n---\n\n1. 간선 클래스를 만들어 우선순위 큐로 저장한다.\n2. union find를 사용해 싸이클 검사와 거리를 더해준다.\n\n---\n\n```java\npackage package29;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\n\npublic class num1197 {\n\tstatic int V, E, result=0, cnt=0;\n\tstatic int[] parent;\n\tstatic PriorityQueue<Edge> pq = new PriorityQueue<Edge>();\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tString[] VE = br.readLine().split(\" \");\n\t\tV = stoi(VE[0]);\n\t\tE = stoi(VE[1]);\n\t\t\n\t\tparent = new int[V+1];\n\t\t\n\t\tfor(int i=0; i<V+1; i++) {\n            parent[i] = i;\n        }\n\t\t\n\t    for(int i=0; i<E; i++) {\n\t    \tStringTokenizer st = new StringTokenizer(br.readLine());\n\t    \tpq.add(new Edge(stoi(st.nextToken()),stoi(st.nextToken()),stoi(st.nextToken())));\n\t    }\n\t\t\n\t    for(int i=0; i<E; i++) {\n\t    \tEdge temp = pq.poll();\n\t    \t\n\t    \tint a = temp.s;\n\t    \tint b = temp.e;\n\t    \tif(!union(a, b))\n\t    \t\tcontinue;\n\t    \tresult+= temp.w;\n\t    \tcnt++;\n\t    \tif(cnt == V-1)\n\t    \t\tbreak;\n\t    }\n\t    System.out.println(result);\n\t}\n\t\n\tstatic class Edge implements Comparable<Edge>{\n\t\tint s, e, w;\n\t\tEdge(int s, int e, int w){\n\t\t\tthis.s = s;\n\t\t\tthis.e = e;\n\t\t\tthis.w = w;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\treturn o.w >= this.w ? -1: 1;\n\t\t}\n\t}\n\t\n\tpublic static int find_parent(int num) {\n\t\tif(parent[num] != num)\n\t\t\treturn parent[num] = find_parent(parent[num]);\n\t\treturn parent[num];\n\t}\n\n\tpublic static boolean union(int a, int b) {\n\t\ta = find_parent(a);\n\t\tb = find_parent(b);\n\t\t\n\t\tif(a==b) {\n\t\t\treturn false;\n\t\t}\n\t\telse if(a < b)\n\t\t\tparent[b] = a;\n\t\telse\n\t\t\tparent[a] = b;\n\t\treturn true;\n\t}\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\t\n}\n\n```\n\n## 백준 4386 - 별자리 만들기\n\n---\n\n![4386pb1](4386pb1.PNG)\n![4386pb2](4386pb2.PNG)\n\n---\n\n### 풀이\n---\n\n정점의 x좌표와 y좌표를 저장할 수 있는 클래스를 만들어 사용했다.\n\n위의 문제는 가중치가 주어졌지만, 4386번문제는 가중치를 두 점사이 거리로 계산해서 넣어야 한다.\n\n---\n\n```java\npackage package29;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\n\npublic class num4386 {\n\tstatic int N, cnt=0;\n\tstatic double result = 0;\n\tstatic int[] parent;\n\tstatic PriorityQueue<Edge> pq = new PriorityQueue<Edge>();\n\tstatic Vertex[] v;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tN = stoi(br.readLine());\n\t\t\n\t\tparent = new int[N+1];\n\t\tv = new Vertex[N+1];\n\t\tfor(int i=1; i<=N+1; i++) {\n            parent[i] = i;\n        }\n\t\t\n\t    for(int i=1; i<=N; i++) {\n\t    \tStringTokenizer st = new StringTokenizer(br.readLine(),\" \");\n\t    \tv[i] = new Vertex(stod(st.nextToken()), stod(st.nextToken()));\n\t    }\n\t    \n\t    for(int i=1; i<=N; i++) {\n\t    \tfor(int j=i+1; j<=N; j++) {\n\t    \t\tpq.add(new Edge(i, j, getDistance(v[i].x, v[j].x, v[i].y, v[j].y)));\n\t    \t}\n\t    }\n\t    \n\t    for(int i=0; i<pq.size(); i++) {\n\t    \tEdge temp = pq.poll();\n\t    \t\n\t    \tint a = temp.s;\n\t    \tint b = temp.e;\n\t    \tif(!union(a, b))\n\t    \t\tcontinue;\n\t    \tresult+= temp.w;\n\t    \tcnt++;\n\t    \tif(cnt == N-1)\n\t    \t\tbreak;\n\t    }\n\t    System.out.println(String.format(\"%.2f\", result));\n\t}\n\t\n\tstatic class Vertex{\n\t\tdouble x, y;\n\t\tVertex(double x, double y){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tstatic class Edge implements Comparable<Edge>{\n\t\tint s, e;\n\t\tdouble w;\n\t\tEdge(int s, int e, double w){\n\t\t\tthis.s = s;\n\t\t\tthis.e = e;\n\t\t\tthis.w = w;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\treturn o.w >= this.w ? -1: 1;\n\t\t}\n\t}\n\t\n\tpublic static int find_parent(int num) {\n\t\tif(parent[num] != num)\n\t\t\treturn parent[num] = find_parent(parent[num]);\n\t\treturn parent[num];\n\t}\n\n\tpublic static boolean union(int a, int b) {\n\t\ta = find_parent(a);\n\t\tb = find_parent(b);\n\t\t\n\t\tif(a==b) {\n\t\t\treturn false;\n\t\t}\n\t\telse if(a < b)\n\t\t\tparent[b] = a;\n\t\telse\n\t\t\tparent[a] = b;\n\t\treturn true;\n\t}\n\t\n\tpublic static double getDistance(double x1, double x2, double y1, double y2) {\n\t\treturn Math.sqrt(Math.pow(Math.abs(x1 - x2), 2) + Math.pow(Math.abs(y1 - y2), 2));\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\t\n\tpublic static double stod(String string) {\n\t\treturn Double.parseDouble(string);\n\t}\n\t\n}\n\n\n```\n\n## 백준 1647 - 도시 분할 계획\n\n---\n\n![1647pb1](1647pb1.PNG)\n![1647pb2](1647pb2.PNG)\n\n---\n\n### 풀이\n---\n\n도시를 2개로 나눈다고 했으니 크루스칼 알고리즘이 끝나는 조건을 N-2로 작성해야 한다.\n\n---\n\n```java\npackage MST;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\n\npublic class num1647 {\n\tstatic int N, M, result=0, cnt=0;\n\tstatic int[] parent;\n\tstatic PriorityQueue<Edge> pq = new PriorityQueue<Edge>();\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st;\n\t\t\n\t\tst = new StringTokenizer(br.readLine());\n\t\tN = stoi(st.nextToken());\n\t\tM = stoi(st.nextToken());\n\t\n\t\tparent = new int[N+1];\n\t\tfor(int i=1; i<=N; i++) {\n            parent[i] = i;\n        }\n\t\t\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tint s = stoi(st.nextToken()), e = stoi(st.nextToken()), w = stoi(st.nextToken());\n\t\t\tpq.add(new Edge(s,e,w));\n\t\t}\n\t\t\n\t\twhile(!pq.isEmpty()) {\n\t\t\tEdge temp = pq.poll();\n\t\t\t\n\t\t\tint a = temp.s;\n\t\t\tint b = temp.e;\n\t\t\tif(!union(a, b))\n\t\t\t\tcontinue;\n\t\t\tresult += temp.w;\n\t\t\tcnt++;\n\t\t\tif(cnt == N-2)\n\t\t\t\tbreak;\n\t\t}\n\t\tSystem.out.println(result);\n\t}\n\t\n\tstatic class Edge implements Comparable<Edge> {\n\t\tint s, e, w;\n\t\tEdge(int s, int e, int w) {\n\t\t\tthis.s = s;\n\t\t\tthis.e = e;\n\t\t\tthis.w = w;\n\t\t}\n\t\t\n\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\treturn o.w >= this.w ? -1 : 1;\n\t\t}\n\t}\n\t\n\tpublic static int find_parent(int num) {\n\t\tif(parent[num] != num)\n\t\t\treturn parent[num] = find_parent(parent[num]);\n\t\treturn parent[num];\n\t}\n\t\n\tpublic static boolean union(int a, int b) {\n\t\ta = find_parent(a);\n\t\tb = find_parent(b);\n\t\t\n\t\tif(a==b)\n\t\t\treturn false;\n\t\tif(a < b)\n\t\t\tparent[b] = a;\n\t\telse\n\t\t\tparent[a] = b;\n\t\treturn true;\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\n}\n\n```\n\n## 백준 1774 - 우주신과의 교감\n\n---\n\n![1774pb1](1774pb1.PNG)\n![1774pb2](1774pb2.PNG)\n\n---\n\n### 풀이\n---\n\n일반적인 최소 스패닝 트리 문제다. 1197번과 풀이가 동일하다.\n\n---\n\n```java\npackage package29;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.PriorityQueue;\n\npublic class num1774 {\n\tstatic int N, M, cnt = 0;\n\tstatic PriorityQueue<Edge> pq = new PriorityQueue<Edge>();\n\tstatic int[] parent;\n\tstatic Node[] arr;\n\tstatic double minLen = 0;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tString[] NM = br.readLine().split(\" \");\n\t\t\n\t\tN = stoi(NM[0]);\n\t\tM = stoi(NM[1]);\n\t\tNode[] arr = new Node[N+1];\n\t\tparent = new int[N+1];\n\t\t\n\t\tfor(int i=1; i<=N; i++) {\n            parent[i] = i;\n        }\n\t\t\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tString[] XY = br.readLine().split(\" \");\n\t\t\tarr[i] = new Node(stoi(XY[0]), stoi(XY[1]));\n\t\t}\n\t\t\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tString[] se = br.readLine().split(\" \");\n\t\t\tint s = stoi(se[0]);\n\t\t\tint e = stoi(se[1]);\n\t\t\tunion(s, e);\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = i + 1; j <= N; j++) {\n\t\t\t\tpq.add(new Edge(i, j, getDistance(arr[i].x, arr[j].x, arr[i].y, arr[j].y)));\n\t\t\t}\n\t\t}\n\t\t\n\t    for(int i=0; i<pq.size(); i++) {\n\t    \tEdge temp = pq.poll();\n\t    \t\n\t    \tint a = temp.s;\n\t    \tint b = temp.e;\n\t    \tif(!union(a, b))\n\t    \t\tcontinue;\n\t    \tminLen+= temp.w;\n\t    }\n\t    System.out.println(String.format(\"%.2f\", minLen));\n\t\t\n\t}\n\tstatic class Edge implements Comparable<Edge>{\n\t\tint s, e;\n\t\tdouble w;\n\t\tEdge(int s, int e, double w){\n\t\t\tthis.s = s;\n\t\t\tthis.e = e;\n\t\t\tthis.w = w;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\treturn o.w >= this.w ? -1: 1;\n\t\t}\n\t}\n\t\n\tpublic static double getDistance(double x1, double x2, double y1, double y2) {\n\t\treturn Math.sqrt(Math.pow(Math.abs(x1 - x2), 2) + Math.pow(Math.abs(y1 - y2), 2));\n\t}\n\t\n\tpublic static int find_parent(int num) {\n\t\tif(parent[num] != num)\n\t\t\treturn parent[num] = find_parent(parent[num]);\n\t\treturn parent[num];\n\t}\n\n\tpublic static boolean union(int a, int b) {\n\t\ta = find_parent(a);\n\t\tb = find_parent(b);\n\t\t\n\t\tif(a==b) {\n\t\t\treturn false;\n\t\t}\n\t\telse if(a < b)\n\t\t\tparent[b] = a;\n\t\telse\n\t\t\tparent[a] = b;\n\t\treturn true;\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\t\n\tstatic class Node{\n\t\tdouble x, y;\n\t\tNode(double x, double y){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n}\n```\n\n## 백준 2887 - 행성 터널\n\n---\n\n![2887pb1](2887pb1.PNG)\n![2887pb2](2887pb2.PNG)\n\n---\n\n### 풀이\n---\n\n이 문제가 어려웠다.\n\nN의 개수가 상당히 커서 모든 간선을 추가하면 시간 초과가 나온다.\n\n간선 비용은 문제에 주어진대로 Min(x좌표 차이, y좌표 차이, z좌표 차이)이다.\n\n행성을 연결할 때 드는 비용을 x, y, z을 각각 오름차순으로 정렬하고\n\n인접한 좌표의 비용을 PriorityQueue에 넣는다.\n\n그 뒤 크루스칼 알고리즘을 통해 답을 구한다.\n\n---\n\n```java\npackage package29;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class num2887 {\n\tstatic int N;\n\tstatic Vertex[] vertexs;\n\tstatic PriorityQueue<Edge> pq = new PriorityQueue<Edge>(new Comparator<Edge>() {\n\t\t@Override\n\t\tpublic int compare(Edge o1,Edge o2) {\n\t\t\treturn (o1.w-o2.w);\n\t\t}\n\t});\t\t\t\n\tstatic int[] parent; \n\t\n\tpublic static void main(String[] args) throws IOException { \n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in)); \n\t\tN = Integer.parseInt(br.readLine()); \n\t\tvertexs = new Vertex[N]; \n\t\t\n\t\tStringTokenizer st; \n\t\tfor (int i = 0; i < N ; i++) { \n\t\t\tst = new StringTokenizer(br.readLine().trim(), \" \");\n\t\t\tint X = stoi(st.nextToken()); \n\t\t\tint Y = stoi(st.nextToken());\n\t\t\tint Z = stoi(st.nextToken()); \n\t\t\tvertexs[i] = new Vertex(X, Y, Z, i);\n\t\t} \n\t\t\n\t\tArrays.sort(vertexs,new Comparator<Vertex>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Vertex o1, Vertex o2) {\n\t\t\t\treturn Integer.compare(o1.x, o2.x);\n\t\t\t}\n\t\t});\n\t\tfor (int i = 1; i <N ; i++) {\n\t\t\tpq.add(new Edge(vertexs[i-1].id, vertexs[i].id, Math.abs(vertexs[i].x-vertexs[i-1].x)));\n\t\t}\n\t\t\t\n\t\tArrays.sort(vertexs,new Comparator<Vertex>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Vertex o1, Vertex o2) {\n\t\t\t\treturn Integer.compare(o1.y, o2.y);\n\t\t\t}\n\t\t});\n\t\tfor (int i = 1; i <N ; i++) {\n\t\t\tpq.add(new Edge(vertexs[i-1].id, vertexs[i].id, Math.abs(vertexs[i].y-vertexs[i-1].y)));\n\t\t} \n\t\t\n\t\tArrays.sort(vertexs,new Comparator<Vertex>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Vertex o1, Vertex o2) {\n\t\t\t\treturn Integer.compare(o1.z, o2.z);\n\t\t\t}\n\t\t});\n\t\tfor (int i = 1; i <N ; i++) {\n\t\t\tpq.add(new Edge(vertexs[i-1].id, vertexs[i].id, Math.abs(vertexs[i].z-vertexs[i-1].z)));\n\t\t} \n\t\t\n\t\t\n\t\tparent = new int[N+1];\n\t\tfor (int i = 1; i <= N ; i++)\n\t\t\tparent[i] = i; \n\t\tlong result=0;\n\t\t\n\t\twhile(!pq.isEmpty()) {\n\t\t\tEdge tmp = pq.poll();\n\t\t\tif(find_parent(tmp.s)!=find_parent(tmp.e)) {\n\t\t\t\tresult +=tmp.w;\n\t\t\t\tunion(tmp.s,tmp.e);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(result);\n\t}\n\t\n\tstatic class Vertex {\n\t\tint x, y, z, id;\n\t\tVertex(int x, int y, int z, int id) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t\tthis.id = id;\n\t\t}\n\t}\n\t\n\tstatic class Edge {\n\t\tint s, e, w;\n\t\tEdge(int s, int e, int w) {\n\t\t\tthis.s = s; \n\t\t\tthis.e = e; \n\t\t\tthis.w = w;\n\t\t} \n\t} \n\t\n\tpublic static int find_parent(int num) {\n\t\tif(parent[num] != num)\n\t\t\treturn parent[num] = find_parent(parent[num]);\n\t\treturn parent[num];\n\t}\n\t\n\tpublic static boolean union(int a, int b) {\n\t\ta = find_parent(a);\n\t\tb = find_parent(b);\n\t\t\n\t\tif(a==b) {\n\t\t\treturn false;\n\t\t}\n\t\telse if(a < b)\n\t\t\tparent[b] = a;\n\t\telse\n\t\t\tparent[a] = b;\n\t\treturn true;\n\t}\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n\n\n```\n\n## 백준 17472 - 다리 만들기2\n\n---\n\n![17472pb1](17472pb1.PNG)\n![17472pb2](17472pb2.PNG)\n![17472pb3](17472pb3.PNG)\n![17472pb4](17472pb4.PNG)\n![17472pb5](17472pb5.PNG)\n![17472pb6](17472pb6.PNG)\n\n---\n\n### 풀이\n---\n\n이전 문제들을 모두 풀어봤으면 어렵진 않은데 삽질을 많이했다.\n\n내가 실수한 부분은 2가지였다.\n\n```\n1. dfs로 체크하는데 자기 자신을 바꾸지 않음\n2. for(int i=0; i<pq.size(); i++) 이런식으로 사용\n```\n\n어떤 친절하신 분이 반례를 정리해놔서 참고했다.  \n\n[반례모음 - promise12mee](https://www.acmicpc.net/board/view/63536)\n\n---\n\n```java\npackage package29;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.PriorityQueue;\n\n\npublic class num17472 {\n\tstatic int N, M, landCount=0, result = 0, cnt=0;\n\tstatic int[] parent;\n\tstatic int[][] map;\n\tstatic int[] dx = new int[]{0,0,1,-1};\n\tstatic int[] dy = new int[]{1,-1,0,0};\n\tstatic PriorityQueue<Edge> pq = new PriorityQueue<Edge>();\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\n\t\tString[] NM = br.readLine().split(\" \");\n\t\t\n\t\tN = stoi(NM[0]);\n\t\tM = stoi(NM[1]);\n\t\tmap = new int[N][M];\n\t\t\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tString[] mapData = br.readLine().split(\" \");\n\t\t\tfor(int j=0; j<M; j++) {\n\t\t\t\tmap[i][j] = stoi(mapData[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcheckLand();\n\t\t\n\t\tparent = new int[landCount+1];\n\t\tfor(int i=0; i<=landCount; i++) {\n\t\t\tparent[i] = i;\n\t\t}\n\t\t\n        for(int i=0; i<N; i++) {\n            for(int j=0; j<M; j++) {\n                if(map[i][j] != 0) {\n                    makeBridge(i, j, map[i][j]);\n                }\n            }\n        }\n        \n        int size = pq.size();\n\t    for(int i=0; i<size; i++) {\n\t    \tEdge temp = pq.poll();\n\t    \tint a = temp.s;\n\t    \tint b = temp.e;\n\t    \tif(!union(a, b))\t\t\n\t    \t\tcontinue;\n\t    \tunion(temp.s, temp.e);\n\t    \tresult+= temp.w;\n\t    \tcnt++;\n\t    }\n\t    if(result == 0 || cnt != landCount-1) {\n            System.out.println(-1);\n        } else {\n            System.out.println(result);\n        }\n\t}\n\t\n\tstatic void makeBridge(int x, int y, int landNum) {\n        int newX = x;\n        int newY = y;\n\t\tint length = 0;\n        \n        for(int i=0; i<4; i++) {\n            while(true) {\n                newX = newX + dx[i];\n                newY = newY + dy[i];\n                \n                if(isPossibleIndex(newX, newY)) {\n                    if(map[newX][newY] == landNum) {\n                        length = 0;\n                        newX = x;\n                        newY = y;\n                        break;\n                    } else if(map[newX][newY] == 0){\n                        length++;\n                    } else {\n                        if(length > 1) {\n                        \tpq.add(new Edge(landNum, map[newX][newY], length));\n                        }\n                        length = 0;\n                        newX = x;\n                        newY = y;\n                        break;\n                    }\n                } else {\n                    length = 0;\n                    newX = x;\n                    newY = y;\n                    break;\n                }\n            }\n        }\t\n\t}\n\t\n\tstatic class Edge implements Comparable<Edge>{\n\t\tint s, e, w;\n\t\tEdge(int s, int e, int w){\n\t\t\tthis.s = s;\n\t\t\tthis.e = e;\n\t\t\tthis.w = w;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\treturn o.w >= this.w ? -1 : 1;\n\t\t}\n\t}\n\t\n\tpublic static int find_parent(int num) {\n\t\tif(parent[num] != num)\n\t\t\treturn parent[num] = find_parent(parent[num]);\n\t\treturn parent[num];\n\t}\n\t\n\tpublic static boolean union(int a, int b) {\n\t\ta = find_parent(a);\n\t\tb = find_parent(b);\n\t\t\n\t\tif(a==b) {\n\t\t\treturn false;\n\t\t}\n\t\telse if(a < b)\n\t\t\tparent[b] = a;\n\t\telse\n\t\t\tparent[a] = b;\n\t\treturn true;\n\t}\n\t\n\tpublic static void checkLand() {\n\t\tboolean[][] visited = new boolean[N][M];\n\t\t\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tfor(int j=0; j<M; j++) {\n\t\t\t\tif(map[i][j] != 0 && !visited[i][j]) {\n\t\t\t\t\tlandCount++;\n\t\t\t\t\tdfs(i, j, visited);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void dfs(int x, int y, boolean[][] visited) {\n\t\tmap[x][y] = landCount;\n\t\tfor(int i=0; i<4; i++) {\n\t\t\tint newX = x + dx[i];\n\t\t\tint newY = y + dy[i];\n\t\t\tif(isPossibleIndex(newX, newY) && !visited[newX][newY] && map[newX][newY] != 0) {\n\t\t\t\tvisited[x + dx[i]][y + dy[i]] = true;\n\t\t\t\tmap[newX][newY] = landCount;\n\t\t\t\tdfs(x + dx[i], y + dy[i], visited);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static boolean isPossibleIndex(int x, int y) {\n\t\treturn x >= 0 && y >= 0 && x < N && y < M ? true : false;\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n\n```\n\n\n## 프림 알고리즘\n---\n> 정점 선택 기반의 알고리즘으로, 하나의 정점에서 연결된 간선들 중에 최소 간선 비용을 가진 정점을 하나씩 선택하면서 MST를 찾는 알고리즘\n\n### 구현 방법\n---\n\n```\n1. 임의의 정점 하나를 선택해서 시작\n2. 선택한 정점과 인접하는 정점들 중에 최소비용의 간선을 가지는 정점을 선택\n3. 모든 정점이 선택될 때 까지 반복\n\n```\n\n---\n\n# Reference\n이것이 취업을 위한 코딩테스트다 - 나동빈  \n[라이님 블로그](https://m.blog.naver.com/kks227/220799105543)  \n[갓킹독님 블로그](https://blog.encrypted.gg/915?category=773649)  \n[주남2님 블로그](https://ju-nam2.tistory.com/112)  \n[두 점 사이의 거리, 좌표평면위의 두 점 사이의 거리](https://mathbang.net/408)  \n[Java - 반올림해서 소수점 n번째 자리까지 출력 - chacha님 블로그](https://codechacha.com/ko/java-round-a-number-to-decimal-point/)  ","excerpt":"신장 트리(Spnning Tree) 하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프 최소 신장 트리(Minimum Spanning Tree) 트리의 간선마다 가중치가 있을 때, 간선의 가중치 합이 최소인 트리 신장…","fields":{"slug":"/MST/"},"frontmatter":{"date":"Feb 04, 2021","title":"최소 신장 트리 정리","tags":["Algorithm"],"update":"Feb 08, 2021"}}},{"node":{"rawMarkdownBody":"\n# 슬라이딩 윈도우\n\n투포인터 알고리즘과 비슷하지만 슬라이딩 윈도우는 **어느 순간에도 그 구간의 넓이가 동일하다**  \n -> 사용하지 않는 값을 삭제하거나 갱신하는 기법이다.\n## 백준 2096번 - 내려가기\n---\n\n![2096pb1](2096pb1.PNG)\n![2096pb2](2096pb2.PNG)\n\n---\n\n### 풀이\n---\n\n이 문제는 슬라이딩 윈도우 + DP문제다. \n\n문제를 보면 메모리 제한이 있다.\n\n계단의 최대값과 최솟값을 저장하는데 이전의 값들만 저장하고 있으면 된다.\n\n---\n\n```java\npackage slidingWindow;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class num2096 {\n\tstatic int N, MAX, MIN;\n\tstatic int[] tempMaxDp, tempMinDp, maxDp, minDp;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tN = stoi(br.readLine());\n\t\ttempMaxDp = new int[3]; tempMinDp = new int[3]; maxDp = new int[3]; minDp = new int[3];\n\t\t\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tString[] step = br.readLine().split(\" \");\n\t\t\tfor(int j=0; j<3; j++) {\n\t\t\t\ttempMinDp[j] = tempMaxDp[j] = stoi(step[j]);\n\t\t\t\ttempMaxDp[j] += Math.max(maxDp[1] , j == 1 ? Math.max(maxDp[0], maxDp[2]) : maxDp[j]);\n\t\t\t\ttempMinDp[j] += Math.min(minDp[1] , j == 1 ? Math.min(minDp[0], minDp[2]) : minDp[j]);\n\t\t\t\tMAX = j==0 ? tempMaxDp[j] : MAX > tempMaxDp[j] ? MAX : tempMaxDp[j];\n\t\t\t\tMIN = j==0 ? tempMinDp[j] : MIN < tempMinDp[j] ? MIN : tempMinDp[j];\n\t\t\t}\n\t\t\tarrayCopy(maxDp, tempMaxDp);\n\t\t\tarrayCopy(minDp, tempMinDp);\n\t\t\t\n\t\t}\n\t\tSystem.out.println(MAX + \" \" + MIN);\n\t}\n\t\n\tpublic static void arrayCopy(int[] to, int[] from) {\n\t\tfor(int i=0; i<3; i++) {\n\t\t\tto[i] = from[i];\n\t\t}\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\n}\n\n```\n\n\n## 백준 11003번 - 최솟값 찾기\n---\n\n![11003번](11003pb1.PNG)\n![11003번](11003pb2.PNG)\n\n---\n\n### 풀이\n---\n\n문제를 보면 범위가 심상치 않다.....ㅋㅋㅋ\n\n문제가 좀 어려워서 노트로 작성하면서 정리했다.\n\n![11003번sol](11003sol.PNG)\n\n---\n\n```java\npackage slidingWindow;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class num11003 {\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        Deque<Integer> deque = new LinkedList<>();\n        StringTokenizer st = new StringTokenizer(br.readLine(), \" \");\n        \n        int N = stoi(st.nextToken());\n        int L = stoi(st.nextToken());\n        \n        int[] arr = new int[N];\n        st = new StringTokenizer(br.readLine(), \" \");\n        \n        \n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < N; i++) {\n        \tarr[i] = stoi(st.nextToken());\n            if (!deque.isEmpty() && deque.getFirst() <= i - L) {\n            \tdeque.removeFirst();\n            }\n            while (!deque.isEmpty() && arr[deque.getLast()] > arr[i]) {\n            \tdeque.removeLast();\n            }\n            deque.addLast(i);\n            sb.append(arr[deque.peekFirst()] + \" \");\n        }\n        bw.write(sb.toString());\n\t\tbw.flush();\n\t\tbw.close();\n    }\n    \n    public static int stoi(String string) {\n    \treturn Integer.parseInt(string);\n    }\n}\n```\n\n## 백준 3078번 - 좋은 친구\n---\n\n![3078pb1](3078pb1.PNG)\n![3078pb2](3078pb2.PNG)\n\n### 풀이\n---\n\n이전 문제를 풀었다면 어렵지 않게 풀 수 있다.\n\ncnt범위 때문에 long으로 설정해야 한다.\n\ncnt 때문에 책상 부술뻔.... 후.....하...후...하...\n\n---\n\n```java\npackage slidingWindow;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\npublic class num3078 {\n\tstatic int N, K;\n\tstatic long cnt=0;\n\tstatic Queue[] qarr;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tN = stoi(st.nextToken());\n\t\tK = stoi(st.nextToken());\n\t\t\n\t\tqarr = new Queue[21];\n\t\tfor(int i=0; i<=20; i++) {\n\t\t\tqarr[i] = new LinkedList<Integer>();\n\t\t}\n\t\t\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tint nowLen = br.readLine().length();\n\t\t\t\n\t\t\tif(qarr[nowLen].isEmpty()) {\n\t\t\t\tqarr[nowLen].offer(i);\n\t\t\t}else {\n\t\t\t\twhile ((i - (int) qarr[nowLen].peek()) > K) {\n\t\t\t\t\tqarr[nowLen].poll();\n\t\t\t\t\tif (qarr[nowLen].isEmpty()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcnt += qarr[nowLen].size();\n\t\t\t\tqarr[nowLen].offer(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(cnt);\n\t}\n\t\n\tstatic int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\n}\n\n```\n\n# Reference\n[라이님 블로그](https://m.blog.naver.com/kks227/220795165570)","excerpt":"슬라이딩 윈도우 투포인터 알고리즘과 비슷하지만 슬라이딩 윈도우는 어느 순간에도 그 구간의 넓이가 동일하다  -> 사용하지 않는 값을 삭제하거나 갱신하는 기법이다. 백준 2096번 - 내려가기 \n 풀이 이 문제는 슬라이딩 윈도우 + DP문제다.  문제…","fields":{"slug":"/slidingWindow/"},"frontmatter":{"date":"Feb 03, 2021","title":"슬라이딩 윈도우 정리","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# 구간합 배열\n> 전처리를 통해 모든 부분합을 O(1)으로 구할 수 있는 방법\n\n\n```\n1. 원래 배열 이외에 pSum배열을 추가로 하나 만들어 준다. \n2. pSum[x] 배열에는 앞에서 부터 x개 원소의 합을 저장한다.\n  -> pSum[i+1] = pSum[i] + A[i]\n\n```\n\n## 백준 11659 - 구간 합 구하기4\n\n---\n\n![11659](11659pb1.PNG)\n\n---\n\n### 풀이\n\npSum[i+1] - pSum[j]를 해주면 된다.\n\n---\n\n```java\npackage sumOfInterval;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class num11659 {\n\tstatic int N, M;\n\tstatic int[] arr, pSum;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuilder sb = new StringBuilder();\n\t\tString[] NM = br.readLine().split(\" \");\n\t\t\n\t\tN = stoi(NM[0]);\n\t\tM = stoi(NM[1]);\n\t\t\n\t\tarr = new int[N];\n\t\tpSum = new int[N+1];\n\t\t\n\t\tString[] arrData = br.readLine().split(\" \");\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tarr[i] = stoi(arrData[i]);\n\t\t\tpSum[i+1] = arr[i] + pSum[i];\n\t\t}\n\t\t\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tString[] AB = br.readLine().split(\" \");\n\t\t\tint a = stoi(AB[0])-1;\n\t\t\tint b = stoi(AB[1])-1;\n\t\t\t\n\t\t\tsb.append(pSum[b+1] - pSum[a] + \"\\n\");\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n\n```\n\n## 백준 11660 - 구간 합 구하기5\n\n---\n\n![11660](11660pb1.PNG)\n![11660](11660pb2.PNG)\n![11660](11660pb3.PNG)\n\n---\n\n### 풀이\n\n이전 문제와 비슷한데 2차원 배열을 사용해 pSum을 저장한다.\n\n빼줄 때 범위 설정에 주의한다.\n\n---\n\n```java\npackage sumOfInterval;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class num11660 {\n\tstatic int N, M, x1, x2, y1, y2;\n\tstatic int[][] map, pSum;\n\t\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuilder sb = new StringBuilder();\n\t\t\n\t\tString[] NM = br.readLine().split(\" \");\n\t\tN = stoi(NM[0]);\n\t\tM = stoi(NM[1]);\n\t\tmap = new int[N+1][N+1];\n\t\tpSum = new int[N+2][N+2];\n\t\t\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tString[] row = br.readLine().split(\" \");\n\t\t\tfor(int j=0; j<N; j++) {\n\t\t\t\tmap[i][j] = stoi(row[j]);\n\t\t\t\tpSum[i+1][j+1] = pSum[i+1][j] + pSum[i][j+1] - pSum[i][j] + map[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=1; i<=M; i++) {\n\t\t\tString[] point = br.readLine().split(\" \");\n\t\t\tx1 = stoi(point[0]);\n\t\t\ty1 = stoi(point[1]);\n\t\t\tx2 = stoi(point[2]);\n\t\t\ty2 = stoi(point[3]);\n\t\t\t\n\t\t\tsb.append(pSum[x2][y2] - pSum[x1-1][y2] - pSum[x2][y1-1] + pSum[x1-1][y1-1] + \"\\n\");\n\t\t}\n\t\t\n\t\tSystem.out.println(sb.toString());\n\t\t\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n\n```\n\n## 백준 10211 - Maximum Subarray\n\n---\n\n![10211](10211pb1.PNG)\n![10211](10211pb2.PNG)\n\n---\n\n### 풀이\n---\n```\n1\n2\n-7 5\n```\n\n별 생각 없이 풀다가 위 CASE에 걸리는 걸 알았다.\n\n**전까지 합이 음수고, 새롭게 들어온 값이 양수라면 새롭게 들어온 값부터 더해준 값이 최대값이다.**\n\n위 문장에 대한 처리를 해야한다.\n\n---\n\n```java\npackage sumOfInterval;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class num10211 {\n\tstatic int N, X, MAX;\n\tstatic int[] arr, pSum;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuilder sb = new StringBuilder();\n\t\t\n\t\tN = stoi(br.readLine());\n\t\t\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tMAX = Integer.MIN_VALUE;\n\t\t\tX = stoi(br.readLine());\n\t\t\tString[] arrData = br.readLine().split(\" \");\n\t\t\tarr = new int[X];\n\t\t\tpSum = new int[X+1];\n\t\t\t\n\t\t\tfor(int j=0; j<X; j++) {\n\t\t\t\tarr[j] = stoi(arrData[j]);\n\t\t\t\tpSum[j+1] = Math.max(pSum[j], 0) + arr[j];\n\t\t\t\tMAX = MAX > pSum[j+1] ? MAX : pSum[j+1];\n\t\t\t}\n\t\t\tsb.append(MAX+\"\\n\");\n\t\t}\n\t\t\n\t\tSystem.out.println(sb.toString());\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n\n```\n\n## 백준 10986 - 나머지 합\n\n---\n\n![10986](10986pb1.PNG)\n![10986](10986pb2.PNG)\n\n---\n\n### 풀이\n\n이 문제는 발상의 전환이 필요하다.\n\npSum[j] % M 와 pSum[i] % M 나머지가 같으면 나누어 떨어지는 구간이다.  \n -> M으로 나눴을 때 나머지를 저장하는 누적합 배열을 만든다.  \n -> 나머지의 개수를 저장하는 배열을 하나 더 만들어서 나머지에 대한 개수를 저장한다.  \n -> 나머지의 순서에 상관없이 2개씩 뽑는 개수를 모두 더한다.   \n\n---\n\n```java\npackage sumOfInterval;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class num10986 {\n\tstatic long N, M, ans;\n\tstatic long[] cnt, pSum;\n\tstatic final int MAX = 1000000 + 1;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tString[] NM = br.readLine().split(\" \");\n\t\t\n\t\tN = stol(NM[0]);\n\t\tM = stol(NM[1]);\n\t\tcnt = new long[(int)M];\n\t\tpSum = new long[(int)N+1];\n\t\t\n\t\tString[] arrData = br.readLine().split(\" \");\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tlong num = stol(arrData[i-1]);\n\t\t\tpSum[i] = (pSum[i - 1] + num) % M;\n\t\t\tcnt[(int) pSum[i]]++;\n\t\t\tif(pSum[i] == 0) ans++;\n\t\t}\n\t\t\n\t\tfor(int i = 0 ; i < M ; ++i) {\n\t\t\tans += cnt[i] * (cnt[i] - 1) / 2;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\tpublic static long stol(String string) {\n\t\treturn Long.parseLong(string);\n\t}\n\n}\n\n```\n\n# Reference\n[라이님 블로그](https://m.blog.naver.com/kks227/220787178657)  ","excerpt":"구간합 배열 전처리를 통해 모든 부분합을 O(1)으로 구할 수 있는 방법 백준 11659 - 구간 합 구하기4  풀이 pSumi+1 - pSumj를 해주면 된다. 백준 11660 - 구간 합 구하기5 \n\n 풀이 이전 문제와 비슷한데 2차원 배열을 사…","fields":{"slug":"/prefixSum/"},"frontmatter":{"date":"Feb 02, 2021","title":"구간합(Prefix Sum) 배열","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# 투 포인터 알고리즘\n---\n\n> 리스트에 순차적으로 접근해야 할 때 2개의 점의 위치를 기록하면서 처리하는 알고리즘을 의미한다.  \n\n -> **2개의 점을 무조건 증가시키는 방향으로 변화하면서 횟수 계산**\n\nTip!!  \n -> 연속된 값을 이용해 풀어나가는 문제에 한정적으로 사용해야 한다.\n (정렬을 통해 연속성을 줄 수 있다.)\n\n## 백준 2470 - 두 용액\n---\n\n![2470pb1](2470pb1.PNG)\n![2470pb2](2470pb2.PNG)\n\n---\n소스를 간략히 설명해보면\n\n1. end점을 마지막, start점을 처음값을 가르키게 설정한다.\n\n2. 입력받은 값을 정렬\n\n3. sum값이 0보다 크면 end점의 index를 -1해주고, 0보다 작으면 start값을 +1해준다.\n   (두 점이 가운데로 모이면서 진행된다.)\n\n---\n\n```java\npackage package25;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class num2470 {\n\tstatic int N, s = 0, e, sum = 0, min = Integer.MAX_VALUE;\n\tstatic int[] arr, result;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tN = stoi(br.readLine());\n\t\te = N-1;\n\t\tarr = new int[N];\n\t\tresult = new int[2];\n\t\t\n\t\tString[] inputData = br.readLine().split(\" \");\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tarr[i] = stoi(inputData[i]);\n\t\t}\n\t\tArrays.sort(arr);\n\t\t\n\t\tgetResult();\n\t\t\n\t\tSystem.out.println(result[0] + \" \" + result[1]);\n\t}\n\t\n\tpublic static void getResult() {\n\t\twhile(s < e) {\n\t\t\tsum = arr[s] + arr[e];\n\t\t\tif(min > Math.abs(sum)) {\n\t\t\t\tmin = Math.abs(sum);\n\t\t\t\tresult[0] = arr[s];\n\t\t\t\tresult[1] = arr[e];\n\t\t\t}\n\t\t\tif(sum > 0) e--;\n\t\t\telse s++;\n\t\t}\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n\n```\n\n## 백준 1806 - 부분 합\n---\n\n![1806pb1](1806pb1.PNG)\n![1806pb2](1806pb2.PNG)\n\n---\n\n연속 된 수들의 부분합이니 정렬 할 필요는 없다.\n\n입력받은 S값 보다 작으면 end점을 늘려주고 S값 보다 크면 S점을 늘려준다.\n\n---\n\n```java\npackage package25;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class num1806 {\n\tstatic int INF = Integer.MAX_VALUE;\n\tstatic int N, S, result=INF, sum = 0, s = 0, e = 0;\n\tstatic int[] arr;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tString[] NS = br.readLine().split(\" \");\n\t\tN = stoi(NS[0]);\n\t\tS = stoi(NS[1]);\n\t\tarr = new int[N];\n\t\t\n\t\tString[] inputArr = br.readLine().split(\" \");\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tarr[i] = stoi(inputArr[i]);\n\t\t}\n\t\t\n\t\tcalcCount();\n\t\t\n\t\tresult = result == INF ? 0 : result;\n\t\tSystem.out.println(result);\n\t}\n\t\n\tpublic static void calcCount() {\n\t\twhile(true) {\n\t\t\tif(sum >= S) {\n\t\t\t\tsum-=arr[s++];\n\t\t\t\tresult = Math.min(result, (e-s)+1);\n\t\t\t}else if(e == N) break;\n\t\t\telse sum+=arr[e++];\n\t\t}\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n\n```\n\n## 백준 1450 - 냅색 문제\n\n이 문제가 어려웠다.\n\n이 친구는 **Meet in the 알고리즘**을 사용한다.\n\n### Meet in the 알고리즘이란?\n\n> 구간을 반으로 나눈다.\n\n범위를 2개로 나누면  \n -> O(2^n)의 시간복잡도가 O(2^(N/2)) 시간으로 줄어든다.\n\n---\n\n![1450pb1](1450pb1.PNG)\n![1450pb2](1450pb2.PNG)\n\n---\n\n앞쪽과 뒤쪽으로 범위를 나눈다. 양쪽 구간에서 가능한 모든 합을 구해다 정렬하고 \n\n한쪽 값들을 순회하면서 다른 구간를 탐색하면서 모든 합을 확인하고 C값보다 작거나 같은 값이 몇개인지 이분 탐색을 사용해 찾는다.\n\n배열의 index값을 사용하기 때문에 count계산할 때 +1을 해주거나, 입력 받을 때 배열값을 장난쳐놔야 한다.\n\n---\n\n```java\npackage package25;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class num1450 {\n\tstatic int N, C, count =0, index;\n\tstatic int[] arr;\n\tstatic ArrayList<Integer> left, right;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tString[] NC = br.readLine().split(\" \");\n\t\tN = stoi(NC[0]);\n\t\tC = stoi(NC[1]);\n\t\tarr = new int[N];\n\t\t\n\t\tString[] arrData = br.readLine().split(\" \");\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tarr[i] = stoi(arrData[i]);\n\t\t}\n\t\t\n\t\tleft = new ArrayList<Integer>();\n\t\tright = new ArrayList<Integer>();\n\t\t\n\t\tcalcPart(0,N/2,0,left);\n\t\tcalcPart(N/2+1,N-1,0,right);\n\t\t\n\t\tCollections.sort(right);\n\t\t\n\t\tfor (int i = 0; i < left.size(); i++) {\n            index = 0;\n            binarySearch(0, right.size() - 1, left.get(i));\n            count += index +1;\n\t\t}\n\t\t\n\t\tSystem.out.println(count);\n\t}\n\t\n    static void binarySearch(int start, int end, int val) {\n        if (start > end) {\n            return;\n        }\n\n        int mid = (start + end) / 2;\n\n        if (right.get(mid) + val <= C) {\n            index = mid;\n            binarySearch(mid + 1, end, val);\n        } else {\n            binarySearch(start, mid - 1, val);\n        }\n    }\n\n\tpublic static void calcPart(int s, int e, int sum, ArrayList<Integer> list) {\n\t\tif (sum > C) return;\n\t\tif (s > e) {\n\t\t\tlist.add(sum);\n\t\t\treturn;\n\t\t}\n\t\tcalcPart(s + 1, e, sum, list);\n\t\tcalcPart(s + 1, e, sum + arr[s], list);\n\t}\n\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n\n```\n\n1450번 문제 풀면서 배열 index때문에 삽질을 너무 오래했다 ㅜㅜ\n\nmeet in the middle 알고리즘은 정리 한번 하고 문제 좀 더 풀어봐야 겠다.\n\n\n# Reference \n[라이님 블로그](https://m.blog.naver.com/kks227/220795165570)  \n[meet in the middle 알고리즘 - 반으로 쪼갠다. - chogahui05님 블로그](https://blog.naver.com/chogahui05/221374387858)  \n이것이 코딩테스트다 - 나동빈","excerpt":"투 포인터 알고리즘 리스트에 순차적으로 접근해야 할 때 2개의 점의 위치를 기록하면서 처리하는 알고리즘을 의미한다.    -> 2개의 점을 무조건 증가시키는 방향으로 변화하면서 횟수 계산 Tip!!  -> 연속된 값을 이용해 풀어나가는 문제에 한정적…","fields":{"slug":"/twoPoint/"},"frontmatter":{"date":"Feb 01, 2021","title":"투포인터 알고리즘","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n백준 단계별 문제 - 투포인터에 있는 1644번 문제를 풀다 소수 구하는 알고리즘이 생각이 안나서 정리 해둘 겸 포스팅한다.\n\n# 에라토스테네스의 체란?\n \n> 소수가 되는 수의 배수를 지우면 남는 건 소수가 된다\n\n요런 알고리즘이다.\n\n![위키 이미지](era.gif)\n\n## 백준 1644 - 소수의 연속 합\n---\n\n```\n1. 에라토스테네스의 체로 소수 구하는 방법을 활용해 소수를 구한다.\n2. 투포인터 알고리즘을 활용해 연속 합 확인\n```\n\n![1644pb1](1644pb1.PNG)\n![1644pb2](1644pb2.PNG)\n\n\n---\n\n```java\npackage package25;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class num1644 {\n\tstatic int N, sum = 0, s = 0, e = 0, count = 0;\n\tstatic boolean primeCheckArr[];\n\tstatic ArrayList<Integer> primeList;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tN = stoi(br.readLine());\n\t\tprimeCheckArr = new boolean[N+1];        \n        primeList = new ArrayList<Integer>();\n        \n        getPrimeNumber();\n        \n        getCountResult();\n        \n        System.out.println(count);\n\t\t\n\t}\n\t\n\tpublic static void getCountResult() {\n\t\twhile(true) {\n\t\t\tif(sum>=N) sum-=primeList.get(s++);\n\t\t\telse if(e == primeList.size()) break;\n\t\t\telse sum+=primeList.get(e++);\n\t\t\tif(sum == N) count++;\t\n\t\t}\n\t}\n\t\n\tpublic static void getPrimeNumber() {\n\t\tprimeCheckArr[0] = primeCheckArr[1] = true;  \n\t\t\n        for(int i=2; i*i<=N; i++){\n            if(!primeCheckArr[i]) {\n            \tfor(int j=i*i; j<=N; j+=i)\n            \t\tprimeCheckArr[j]=true;                \n            }\n        }\n        \n        for(int i=1; i<=N;i++){\n        \tif(!primeCheckArr[i]) primeList.add(i); \n        }\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\n}\n```\n\n---\n추가로 소수를 구하는 부분의 for문을 살펴보면 \n\n```java\nfor(int i=2; i*i<=N; i++){\n    if(!primeCheckArr[i]) {\n    \tfor(int j=i*i; j<=N; j+=i)\n    \t\tprimeCheckArr[j]=true;                \n    }\n}\n```\n\n특정한 소수의 제곱근 까지만 구하면 된다\n -> 약수가 아닌경우는 수가 대칭을 이루기 때문\n\n# Reference\n\n[위키 백과](https://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4)  ","excerpt":"백준 단계별 문제 - 투포인터에 있는 1644번 문제를 풀다 소수 구하는 알고리즘이 생각이 안나서 정리 해둘 겸 포스팅한다. 에라토스테네스의 체란? 소수가 되는 수의 배수를 지우면 남는 건 소수가 된다 요런 알고리즘이다. 위키 이미지 백준 1644 …","fields":{"slug":"/primeNumber/"},"frontmatter":{"date":"Feb 01, 2021","title":"소수 구하기 - 에라토스테네스의 체","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# 서로소 집합 자료구조란?\n---\n\n> 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조\n\nUnion-Find Algorithm 은 그래프내 셀프루프 (self-loop : 자기자신을 가리키는 간선)을 포함하면  \n안되고 **무방향그래프에서 사이클 찾는데 유용**\n\n**Union, find 2개의 연산**이 있다.\n\n\n## 전제 조건\n---\n\n> 같은 집합에 포함되어 있는 정점들끼리는 이미 간선으로 연결 된 것이고, 다른 집합의 정점과는 서로 연결되지 않았다는 것을 기반한다.\n\n## 1. Union 연산\n---\n> 2개의 원소가 포함된 집함을 하나의 집합으로 합치는 연산\n\n- Union연산은 간선으로 표현된다.\n  (실제로는 트리 구조)\n\n## 2. Find 연산\n---\n\n> 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산\n\n- 경로 압축 기법을 적용해 시간 복잡도를 개선한다. \n- 경로압축이란? \n  - 여기선 find함수를 재귀적으로 호출한 뒤에 부모 테이블 값을 갱신하는 기법을 말함\n\n## 시간 복잡도\n---\n\n노드의 개수 : V , 최대 V-1개의 union 연산과 M개의 find연산이 가능할 때  \n -> O(V + M(1+log~2-M/V~V))  \n (O(1)이라고 생각하면 된다고 한다.)\n\n## 구현\n---\n```\n1. 초기값 자기 자신을 원소로 가지고 있게 설정\n2. 간선을 확인하며 두 노드의 루트 노드를 확인.\n   2-1. 루트 노드가 서로 다르면 두 노드에 대하여 union 연산을 수행\n   2-2. 루트 노드가 같다면 사이클이 발생\n3. 그래프에 포함되어 있는 모든 간선에 대하여 과정을 반복\n```\n\n## Tip!!\n> 유니온파인드는 상황에 따라 **여러가지 정보 추가 가능**\n\n# 백준 1717번\n---\n\n![1717pb1](1717pb1.PNG)\n![1717pb2](1717pb2.PNG)\n\n\n---\n\n위에서 설명했던 그대로 Union함수와 Find함수를 구현했다.\n\n---\n\n```java\npackage package28;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class num1717 {\n\tstatic int N, M;\n\tstatic int[] parent;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuilder sb = new StringBuilder();\n\t\tString[] NM = br.readLine().split(\" \");\n\t\t\n\t\tN = stoi(NM[0]);\n\t\tM = stoi(NM[1]);\n\t\tparent = new int[N];\n\t\t\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tparent[i] = i;\n\t\t}\n\t\t\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tString[] inputData = br.readLine().split(\" \");\n\t\t\t\n\t\t\tint action = stoi(inputData[0]);\n\t\t\tint a = stoi(inputData[1])-1;\n\t\t\tint b = stoi(inputData[2])-1;\n\t\t\t\n\t\t\t\n\t\t\tif(action == 0) {\n\t\t\t\tunion(a,b);\n\t\t\t}else {\n\t\t\t\tsb.append(find_parent(a) == find_parent(b) ? \"YES\" : \"NO\");\n\t\t\t\tsb.append(\"\\n\");\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\t\n\tpublic static int find_parent(int num) {\n\t\tif(parent[num] != num)\n\t\t\tparent[num] = find_parent(parent[num]);\n\t\treturn parent[num];\n\t}\n\t\n\tpublic static void union(int a, int b) {\n\t\tint aParent = find_parent(a);\n\t\tint bParent = find_parent(b);\n\t\tif(aParent<bParent)\n\t\t\tparent[b] = a;\n\t\telse\n\t\t\tparent[a] = b;\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\n}\n\n```\n\n\n# 백준 1976번\n---\n\n![1976pb1](1976pb1.PNG)\n![1976pb2](1976pb2.PNG)\n\n\n---\n\n1717번 문제와 거의 동일하다.\n\n마지막에 입력받은 값들이 하나의 부모노드를 가지고 있는지 알아보면 된다.\n\n---\n\n```java\npackage package28;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class num1976 {\n\tstatic int N, M;\n\tstatic int[] parent;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tN = stoi(br.readLine());\n\t\tM = stoi(br.readLine());\n\t\tparent = new int[N+1];\n\t\t\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tparent[i] = i;\n\t\t}\n\t\t\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tString[] inputData = br.readLine().split(\" \");\n\t\t\tfor(int j=0; j<N; j++) {\n\t\t\t\tint num = stoi(inputData[j]);\n\t\t\t\tif(num == 1) {\n\t\t\t\t\tunion(i, j+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tString[] map = br.readLine().split(\" \");\n\t\tboolean resultIndex = true;\n\t\tint index = parent[stoi(map[0])];\n\t\t\n\t\tfor(int i=1; i<map.length; i++) {\n\t\t\tif(index != parent[stoi(map[i])])\n\t\t\t\tresultIndex = false;\n\t\t}\n\t\tSystem.out.println(resultIndex == true ? \"YES\" : \"NO\");\n\t}\n\t\n\tpublic static int find_parent(int num) {\n\t\tif(parent[num] == num)\n\t\t\treturn num;\n\t\treturn parent[num] = find_parent(parent[num]);\n\t}\n\t\n\tpublic static void union(int a, int b) {\n\t\ta = find_parent(a);\n\t\tb = find_parent(b);\n\t\tif (a != b) {\n            if (a < b) {\n                parent[b] = a;\n            } else {\n                parent[a] = b;\n            }\n\t\t}\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n\n```\n\n# 백준 4195번\n---\n\n![4195pb1](4195pb1.PNG)\n![4195pb2](4195pb2.PNG)\n\n\n---\n\n이문제는 위의 문제들과 다르게 입력값이 문자열로 들어온다.\n\nHashMap을 사용해서 문자열마다 index를 할당해주는 방식으로 구현했다.\n\n---\n\n```java\npackage package28;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\npublic class num4195 {\n\tstatic int N, F, index;\n\tstatic HashMap<String, Integer> map;\n\tstatic int[] parent;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuilder sb = new StringBuilder();\n\t\tN = stoi(br.readLine());\n\t\t\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tmap = new HashMap<String, Integer>();\n\t\t\tindex = 1;\n\t\t\t\n\t\t\tF = stoi(br.readLine());\n\t\t\tparent = new int[2*F+1];\n\t\t\tArrays.fill(parent, -1);\n\t\t\t\n\t\t\tfor(int j=0; j<F; j++) {\n\t\t\t\tString[] inputData = br.readLine().split(\" \");\n\t\t\t\tint v1 = getMapValue(inputData[0]);\n\t\t\t\tint v2 = getMapValue(inputData[1]);\n\t\t\t\tint result = union(v1,v2);\n\t\t\t\tsb.append(result+\"\\n\");\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sb.toString());\n\t}\n\t\n\tpublic static int find_parent(int num) {\n\t\tif(parent[num] < 0)\n\t\t\treturn num;\n\t\treturn parent[num] = find_parent(parent[num]);\n\t}\n\t\n\tpublic static int union(int a, int b) {\n\t\ta = find_parent(a);\n\t\tb = find_parent(b);\n\t\tif (a != b) {\n            if (a < b) {\n            \tparent[a] += parent[b];\n                parent[b] = a;\n            } else {\n            \tparent[b] += parent[a];\n                parent[a] = b;\n            }\n\t\t}\n\t\treturn parent[a] < 0 ? parent[a] : parent[b];\n\t}\n\t\n\tpublic static int getMapValue(String string) {\n\t\tif(!map.containsKey(string)) {\n\t\t\tmap.put(string, index);\n\t\t\tindex++;\n\t\t}\n\t\treturn map.get(string);\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n\n```\n\n# 백준 20040번\n---\n\n![20045pb1](20045pb1.PNG)\n![20045pb2](20045pb2.PNG)\n![20045pb3](20045pb3.PNG)\n\n\n---\n\n이문제는 첫번째, 두번째 문제와 비슷한데  \n사이클이 존재하면 사이클이 걸린 입력순서를 출력해주는 문제다.\n\n\n---\n\n```java\npackage package28;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class num20040 {\n\tstatic int N, M;\n\tstatic int[] parent;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st;\n\t\t\n\t\tint index = 0;\n\t\tst = new StringTokenizer(br.readLine());\n\t\tN = stoi(st.nextToken());\n\t\tM = stoi(st.nextToken());\n\t\tparent = new int[N+1];\n\t\tfor(int i =0; i<=N; i++) {\n\t\t\tparent[i] = i;\n\t\t}\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tint v1 = stoi(st.nextToken());\n\t\t\tint v2 = stoi(st.nextToken());\n\t\t\tif(!union(v1,v2)) {\n\t\t\t\tindex = i+1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(index);\n\t}\n\t\n\tpublic static boolean union(int a, int b) {\n\t\ta = find_parent(a);\n\t\tb = find_parent(b);\n\t\tif(a==b)\n\t\t\treturn false;\n\t\tif(a!=b) {\n\t\t\tif(a < b) {\n\t\t\t\tparent[b] = a;\n\t\t\t}else {\n\t\t\t\tparent[a] = b;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static int find_parent(int num) {\n\t\tif(parent[num] == num)\n\t\t\treturn num;\n\t\treturn parent[num] = find_parent(parent[num]);\n\t}\n\t\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n\n```\n\n블로그와 책을 읽고 유니온 파인드 개념을 정리해보았다.  \n\n유니온 파인드는 **최소신장트리**에 이용된다고  한다.  \n궁금하니 빠른 시일내로 공부해야겠다 ㅋㅋ    \n\n# Referece\n[라이님 블로그](https://m.blog.naver.com/kks227/220791837179)  \n[잭팟53님 블로그](https://jackpot53.tistory.com/)  \n이것이 취업을 위한 코딩 테스트다 - 나동빈  ","excerpt":"서로소 집합 자료구조란? 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조 Union-Find Algorithm 은 그래프내 셀프루프 (self-loop : 자기자신을 가리키는 간선)을 포함하면 안되고 무방향그래프에서 사이클 찾…","fields":{"slug":"/unionFind/"},"frontmatter":{"date":"Jan 29, 2021","title":"Union Find 정리","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n머리 식힐 겸 재밌어 보이는 문제 찾다가 풀어봤다.\n\n## 문제\n\n![15686pb1](15686pb1.PNG)\n![15686pb2](15686pb2.PNG)\n![15686pb3](15686pb3.PNG)\n![15686pb4](15686pb4.PNG)\n\n## 풀이\n\n풀이는 다음과 같다.\n```\n1. 조합으로 치킨 집 구함\n2. 치킨 집에서 집까지 거리를 찾는다.\n3. 구한 거리의 합이 현재 가지고 있는 최솟값보다 작으면 교체\n```\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic int N, M, result = Integer.MAX_VALUE;\n\tstatic ArrayList<House> house;\n\tstatic ArrayList<Chicken> chicken;\n\tstatic int[] houseLen;\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tString[] NM = br.readLine().split(\" \");\n\t\tN = stoi(NM[0]);\n\t\tM = stoi(NM[1]);\n\t\tboolean[] visited = new boolean[14];\n\t\thouse = new ArrayList<House>();\n\t\tchicken = new ArrayList<Chicken>();\n\t\t\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tString[] inputData = br.readLine().split(\" \");\n\t\t\tfor(int j=0; j<N; j++) {\n\t\t\t\tint num = stoi(inputData[j]);\n\t\t\t\tif(num == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(num == 1) {\n\t\t\t\t\thouse.add(new House(i,j));\n\t\t\t\t}else {\n\t\t\t\t\tchicken.add(new Chicken(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\thouseLen = new int[house.size()];\n\t\tcombination(visited, 0, chicken.size(), M);\n\t\tSystem.out.println(result);\n\t\t\n\t}\n\tpublic static void combination(boolean[] visited, int start, int n, int r) {\n\t\tif(r==0) {\n\t\t\tint len = 0;\n\t\t\tint index = 0;\n\t\t\tArrayList<Chicken> ncr = new ArrayList<Chicken>();\n\t\t\tfor(int i=0; i<visited.length; i++) {\n\t\t\t\tif(visited[i]==true) {\n\t\t\t\t\tncr.add(chicken.get(i));\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlen = calcMinLen(ncr);\n\t\t\tresult = result < len ? result : len;\n\t\t\treturn;\n\t\t}\n\n\t\tfor(int i=start; i<n; i++) {\n\t\t\tvisited[i] = true;\n\t\t\tcombination(visited, i+1, n, r-1);\n\t\t\tvisited[i] = false;\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static int calcMinLen(ArrayList<Chicken> c) {\n\t\tint minLen = 0;\n\t\tArrays.fill(houseLen, Integer.MAX_VALUE);\n\t\tfor(int i=0; i<c.size(); i++) {\n\t\t\tChicken now = c.get(i);\n\t\t\tfor(int k=0; k<house.size(); k++) {\n\t\t\t\tint houseNowLen = Math.abs(now.x - house.get(k).x) + Math.abs(now.y - house.get(k).y);\n\t\t\t\thouseLen[k] = houseLen[k] < houseNowLen ? houseLen[k] : houseNowLen;\n\t\t\t}\n//\t\t\tSystem.out.println(now.x + \" \" + now.y);\n\t\t}\n\t\tfor(int i=0; i<houseLen.length; i++) {\n\t\t\tminLen += houseLen[i];\n//\t\t\tSystem.out.println(houseLen[i]);\n\t\t}\n//\t\tSystem.out.println(minLen);\n\t\t\n\t\treturn minLen;\n\t}\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\n\tstatic class Chicken{\n\t\tint x, y;\n\t\tChicken(int x, int y){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\tstatic class House{\n\t\tint x, y;\n\t\tHouse(int x, int y){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n}\n\n```\n\n주석 해놓은 부분 주석풀고 실행해보면 과정 살펴볼 수 있다.\n\n상어들로 장난치는 문제들도 있는데 아침 공부 시작할 때 풀어보면 좋을 것 같다. \n\n끗","excerpt":"머리 식힐 겸 재밌어 보이는 문제 찾다가 풀어봤다. 문제 \n\n\n 풀이 풀이는 다음과 같다. 주석 해놓은 부분 주석풀고 실행해보면 과정 살펴볼 수 있다. 상어들로 장난치는 문제들도 있는데 아침 공부 시작할 때 풀어보면 좋을 것 같다.  끗","fields":{"slug":"/backjoon15686/"},"frontmatter":{"date":"Jan 29, 2021","title":"백준 15686 - 치킨 배달","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n트리를 정리해보자 ㅎㅎ\n\n## 특징\n```\n1. 연결 그래프\n2. 방향을 무시하였을 때, 싸이클이 존재하지 않는다.\n3. 트리의 간선개수는 정점 개수보다 1작다.\n```\n\n트리의 서브트리는 절대로 영역이 겹치지 않음 -> **분할정복**, **DP**로 장난을 잘 칠 줄 알아야 한다.\n\n## 순회 방법\n\n트리의 순회 방법은 3가지다.\n```\n1. 전위 순회 (root -> left -> right) \n2. 중위 순회 (left -> root -> right)\n3. 후위 순회 (left -> right -> root)\n```\n보통 BFS, DFS로 구현한다.\n\n## [백준 11725] - 트리의 부모찾기 \n\n![11725pb1](11725pb1.PNG)\n![11725pb2](11725pb2.PNG)\n\n### 풀이\n---\n\nBFS, DFS를 사용해 탐색하는 방식으로 구현했다.\n\n---\n```java\npackage package27;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class num11725 {\n\tstatic int N;\n\tstatic ArrayList<ArrayList<Integer>> tree;\n\tstatic StringBuilder sb;\n\tstatic int[] result;\n\tstatic boolean[] visited;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\ttree = new ArrayList<ArrayList<Integer>>();\n\t\tsb = new StringBuilder();\n\t\t\n\t\tint N = stoi(br.readLine());\n\t\tresult = new int[N+1];\n\t\tvisited = new boolean[N+1];\n\t\tfor(int i=0; i<=N; i++) {\n\t\t\ttree.add(new ArrayList<Integer>());\n\t\t}\n\t\t\n\t\tfor(int i=0; i<N-1; i++) {\n\t\t\tString[] edge = br.readLine().split(\" \");\n\t\t\tint node1 = stoi(edge[0]);\n\t\t\tint node2 = stoi(edge[1]);\n\n\t\t\ttree.get(node1).add(node2);\n\t\t\ttree.get(node2).add(node1);\n\t\t}\n\t\t\n//\t\tdfs(1);\n\t\tbfs();\n\t\t\n\t\tfor(int i=2; i<=N; i++) {\n\t\t\tSystem.out.println(result[i]);\n\t\t}\n\t}\n\t\n    private static void dfs(int num){\n        if(visited[num]){\n            return;\n        }\n        visited[num] =true;\n        for (int node: tree.get(num)) {\n            if(!visited[node]){\n                result[node] = num;\n                dfs(num);\n            }\n\n        }\n\n    }\n\t\n\tpublic static void bfs() {\n\t\tQueue<Integer> queue = new LinkedList<Integer>();\n\t\tfor(int value : tree.get(1)) {\n\t\t\tresult[value] = 1;\n\t\t\tqueue.add(value);\n\t\t}\n\t\t\n\t\twhile(!queue.isEmpty()) {\n\t\t\tint node = queue.remove();\n\t\t\t\n\t\t\tfor(int value : tree.get(node)) {\n\t\t\t\tif(result[value] == 0) {\n\t\t\t\t\tresult[value] = node;\n\t\t\t\t\tqueue.add(value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n\n```\n\n\n## [백준 4803] - 트리\n\n![4803pb1](4803pb1.PNG)\n![4803pb2](4803pb2.PNG)\n\n### 풀이\n\n아.... 이거 풀다가 책상 부실뻔 했다. 너무 헤맸다... ㅜㅜ\n\n일단 문제에 T는 트리의 개수다.\n\ndfs로 입력받은 노드 모두 탐색하고, cycle이 존재하면 no tree로 출력하게 짰는데 계속 틀렸다고 나왔다.  ㅎㅎ 정답을 알려줘\n\n열받아서 [마포 코딩박님 블로그](https://mapocodingpark.blogspot.com/2020/05/4803.html) dfs 부분을 참고해서 코드 작성했다.\n\n일단 정답은 맞췄다고 나오는데 \n\n```\n입력값 \n7 4\n1 2\n2 3\n3 1\n6 7\n0 0\n출력값 \nCase 1: A forest of 3 trees.\n```\n\n이렇게 나오는데 이거 틀린거 아님? cycle 있으면 트리 없다고 나와야 하는거 아닌가 아시는 분 알려주세요ㅜㅜㅜㅜㅜ\n\n아 짜증나 ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ 화 좀 식히고 나중에 생각나면 다시 봐야겠다...\n\n```java\npackage package27;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class num4803 {\n\tstatic int N, M, count, caseIndex = 0;\n\tstatic StringBuilder sb;\n\tstatic BufferedReader br; \n\tstatic ArrayList<Integer>[] graph;\n\tstatic boolean[] visited;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tsb = new StringBuilder();\n\t\t\n\t\twhile(true) {\n\t\t\tString[] NM = br.readLine().split(\" \");\n\t\t\t\n\t\t\tN = stoi(NM[0]);\n\t\t\tM = stoi(NM[1]);\n\t\t\tgraph = new ArrayList[N+1];\n\t\t\tvisited = new boolean[N+1];\n\t\t\t\n\t\t\tif(N==0 && M==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tresetData();\n\t\t\t\n\t\t\tinputTreeData();\n\t\t\t\n\t\t\tcheckTree();\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\t\n\tpublic static void inputTreeData() throws IOException {\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tString[] Edge = br.readLine().split(\" \");\n\t\t\tint v1 = stoi(Edge[0]), v2 = stoi(Edge[1]);\n\t\t\t\n\t\t\tgraph[v1].add(v2);\n\t\t\tgraph[v2].add(v1);\n\t\t}\n\t}\n\t\n\tpublic static void checkTree() {\n\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tif(!visited[i]) {\n\t\t\t\tif(dfs(i, 0))\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(count == 1) {\n\t\t\tsb.append(\"Case \"+caseIndex+\": There is one tree.\\n\");\n\t\t}else if(count==0){\n\t\t\tsb.append(\"Case \"+caseIndex+\": No trees.\\n\");\n\t\t}else {\n\t\t\tsb.append(\"Case \"+caseIndex+\": A forest of \"+count+\" trees.\\n\");\n\t\t}\n\t}\n\t\n\tpublic static boolean dfs(int num, int prev) {\n\t\tvisited[num] = true;\n\t\t\n\t\tfor(int node : graph[num]) {\n\t\t\tif (node == prev) continue;\n\t\t\tif (visited[node]) return false;\n\t\t\tif (dfs(node, num) == false) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static void resetData() {\n\t\tfor(int i=0; i<=N; i++) {\n\t\t\tgraph[i] = new ArrayList<Integer>();\n\t\t\tvisited[i] = false;\n\t\t}\n\t\tcount = 0;\n\t\tcaseIndex++;\n\t}\n\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n\n```\n\n## [백준 1967] - 트리의 지름\n\n처음에 문제 접근하는 법을 잘못해서 좀 헤맸다.\n\n트리의 지름을 구하는 방법은 다음과 같다.\n\n```\n1. 트리의 임의의 정점(x)에서 가장 먼 정점(y)을 찾는다.\n2. 가장 먼 정점(y) 에서 가장 먼 정점(z)을 찾는다.\n => 지름은 y - z 까지의 거리다.\n```\n\n증명이 궁금하면 [전명우님 블로그 - 트리의 지름 구하기](https://blog.myungwoo.kr/112) 에 쉽게 설명한 글이 있다.  \n -> 한줄 요약 : 어떤 한 점에서 가장 먼 점이 지름에 무조건 포함된다 (포함 안되는 경우를 증명)\n\n![1967문제1](1967pb1.PNG)\n![1967문제2](1967pb2.PNG)\n\n```java\n\npackage package27;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class num1967 {\n\tstatic int N, result = 0, start;\n\tstatic ArrayList<ArrayList<Edge>> Vertex;\n\tstatic boolean[] visited;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tN = stoi(br.readLine());\n\t\tVertex = new ArrayList<ArrayList<Edge>>();\n\t\t\n\t\tfor(int i=0; i<=N; i++) {\n\t\t\tVertex.add(new ArrayList<Edge>());\n\t\t}\n\t\t\n\t\tfor(int i=1; i<N; i++) {\n\t\t\tString[] inputData = br.readLine().split(\" \");\n\t\t\tint node1 = stoi(inputData[0]);\n\t\t\tint node2 = stoi(inputData[1]);\n\t\t\tint w = stoi(inputData[2]);\n\t\t\t\n\t\t\tVertex.get(node1).add(new Edge(node2, w));\n\t\t\tVertex.get(node2).add(new Edge(node1, w));\n\t\t}\n\t\t\n\t\tvisited = new boolean[N+1];\n\t\tvisited[1] = true;\n\t\tdfs(0, 1);\n\t\t\n\t\tvisited = new boolean[N+1];\n\t\tvisited[start] = true;\n\t\tdfs(0, start);\n\t\t\n\t\tSystem.out.println(result);\n\t}\n\t\n\tpublic static int dfs(int len, int now) {\n\t\tif (result < len) {\n\t\t\tresult = len;\n\t\t\tstart = now;\n\t\t}\n\t\tSystem.out.println(now);\n\n        for (Edge node: Vertex.get(now)) {\n            if(!visited[node.e]){\n            \tvisited[node.e] = true;\n            \tdfs(len + node.w, node.e);\n            }\n        }\n        return result;\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\t\n\tstatic class Edge{\n\t\tint e, w;\n\t\tEdge(int e,int w){\n\t\t\tthis.e = e;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n}\n\n```\n\n[트리의 지름 - 백준1167](https://www.acmicpc.net/problem/1167)번 비슷한 문제다.  \n\n\n\n## [백준 2250] - 트리의 높이와 너비\n\n이문제 풀면서 많이 헤맸다ㅋㅋㅋㅋㅋㅋㅋ \n\n배열 만들어서 깊이마다 맨 오른쪽 값을 맨 왼쪽 값 빼면 될 것 같다는 생각을 했는데.....\n\n양심고백을 조금 해보면 오늘 삽질을 너무 많이 해서 고민 많이 안해보고 정답 해결 방법부터 찾아봤다.\n\n[쾌락코딩님 블로그 - 백준2250번 문제(트리의 높이와 너비) with Java](https://wooooooak.github.io/algorithm/2018/12/05/%EB%B0%B1%EC%A4%802250%EB%AC%B8%EC%A0%9C/)글을 참고했다.\n\n문제의 포인트는 3가지다.\n\n```\n1. 문제에서 루트가 정해져 있지 않다\n   -> 루트를 확인할 수 있는 뭔가 방법이 필요\n2. 트리의 높이마다 가장 오른쪽 값, 가장 왼쪽값 저장\n   -> 오른쪽 - 왼쪽 + 1\n3. 중위 순회로 순회\n   -> 그림보면 왼쪽 - 루트 - 오른쪽 순으로 index가 표시되있음\n```\n\n![2250pb1](2250pb1.PNG)\n![2250pb2](2250pb2.PNG)\n![2250pb3](2250pb3.PNG)\n\n### 풀이\n\n```java\npackage package27;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class num2250 {\n\tstatic int N, maxWidth, maxDepth, root, vCount = 1;\n\tstatic Node[] tree;\n\t\n\tstatic int[] depthLeft;\n\tstatic int[] depthRight;\n\tstatic BufferedReader br;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tN = stoi(br.readLine());\n\t\t\n\t\tinit();\n\t\t\n\t\tinputTreeData();\n\t\t\n\t\tsearchRootIndex();\n\t\t\n\t\tinOrder(root, 1);\n\t\t\n\t\tprintResult();\n\t\t\n\t}\n\t\n\tpublic static void init() {\n\t\ttree = new Node[N+1];\n\t\tdepthLeft = new int[N+1];\n\t\tdepthRight = new int[N+1];\n\t\t\n\t\tfor(int i=0; i<=N; i++) {\n\t\t\ttree[i] = new Node(-1, -1, -1);\n\t\t\tdepthLeft[i] = N+1;\n\t\t}\n\t}\n\t\n\tpublic static void inputTreeData() throws IOException {\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tString[] inputData = br.readLine().split(\" \");\n\t\t\t\n\t\t\tint num = stoi(inputData[0]);\n\t\t\tint left = stoi(inputData[1]);\n\t\t\tint right = stoi(inputData[2]);\n\t\t\t\n\t\t\ttree[num].left = left;\n            tree[num].right = right;\n            if(left != -1)\n                tree[left].parent = num;\n            \n            if(right != -1)\n                tree[right].parent = num;\n\t\t}\n\t}\n\t\n\tpublic static void searchRootIndex() {\n\t\tfor(int i=1; i <= N; i++) {\n\t\t\tif(tree[i].parent == -1) {\n\t\t\t\troot = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void inOrder(int parentIndex, int depth) {\n        Node root = tree[parentIndex];\n        if(maxDepth < depth) maxDepth = depth;\n        if(root.left != -1) {\n            inOrder(root.left, depth + 1);\n        }\n        \n        depthLeft[depth] = Math.min(depthLeft[depth], vCount);\n        depthRight[depth] = vCount++;\n        \n        if(root.right != -1) {\n            inOrder(root.right, depth + 1);\n        }\n\t}\n\t\n\tpublic static void printResult() {\n        int index = 1;\n        int maxWitdh = depthRight[1] - depthLeft[1] + 1;\n        for(int i=2; i <= maxDepth; i++) {\n            int tmp = depthRight[i] - depthLeft[i] +1;\n            if(maxWitdh < tmp) {\n            \tindex = i;\n            \tmaxWitdh = tmp;\n            }\n        }\n        \n        System.out.println(index + \" \" + maxWitdh);\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\t\n\tstatic class Node{\n\t\tint parent, value, left, right;\n\t\tNode(int value, int left, int right){\n\t\t\tthis.parent = -1;\n\t\t\tthis.value = value;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\t}\n}\n\n```\n\n## 정리\n\n사실 트리는 학교 알고리즘 시간에 다뤄봐서 정리하는데 오래걸리지 않을 줄 알았는데 생각보다 오래걸렸다 ㅜㅜㅜㅜ 문제도 많이 풀어봐야 할 듯.... \n\n정.말.알.고.리.즘.문.제.풀.이.는.너.무.재.밌.다.하.하.하.하.하.하.하.하.하.하.하.하.하\n\n오늘 정리한 문제들은 dfs, bfs로 탐색하는 문제들이었다.\n\n\n아래 사진같은3 유형의 문제들도 있던데.....\n![finish](finish.PNG)\n빠른 시일내로 4문제 풀어봐야겠다. (조금 무서워 보인다ㅋ)\n\n# Reference\n[라이님 블로그](https://m.blog.naver.com/kks227/220788265724)  \n[전명우님 블로그](https://blog.myungwoo.kr/112)  \n[쾌락코딩님 블로그 - 백준2250번 문제(트리의 높이와 너비) with Java](https://wooooooak.github.io/algorithm/2018/12/05/%EB%B0%B1%EC%A4%802250%EB%AC%B8%EC%A0%9C/)  \n[마포 코딩박님 블로그](https://mapocodingpark.blogspot.com/2020/05/4803.html)  ","excerpt":"트리를 정리해보자 ㅎㅎ 특징 트리의 서브트리는 절대로 영역이 겹치지 않음 -> 분할정복, DP로 장난을 잘 칠 줄 알아야 한다. 순회 방법 트리의 순회 방법은 3가지다. 보통 BFS, DFS로 구현한다. 백준 11725 - 트리의 부모찾기 \n 풀이 …","fields":{"slug":"/tree/"},"frontmatter":{"date":"Jan 28, 2021","title":"트리","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n백준 11779, 11780, 1738번 문제를 통해 최단경로의 경로출력을 정리해보려고 한다.\n\n---\n\n# 백준 11779 - 다익스트라\n\n![11779문제 사진1](11779pb1.PNG)\n![11779문제 사진2](11779pb2.PNG)\n\n---\n\n소스를 간략히 설명하면\n\n다익스트라 알고리즘에 값이 조건에 맞아 갱신될 때 배열의 값에 이전 노드를 저장한다.\n\n첫 노드부터 순서대로 출력하기 위해 stack을 사용했다.\n\n---\n\n```java\npackage pakcage26;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.PriorityQueue;\nimport java.util.Stack;\n\npublic class num11779 {\n\tstatic int N, M, count=2,INF = Integer.MAX_VALUE;\n\tstatic ArrayList<ArrayList<Edge>> Vertex;\n\tstatic int[] dist, pre;\n\tstatic boolean[] visited;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tN = stoi(br.readLine());\n\t\tM = stoi(br.readLine());\n\t\tVertex = new ArrayList<ArrayList<Edge>>();\n\t\tdist = new int[N];\n\t\tpre = new int[N];\n\t\tvisited = new boolean[N];\n\t\t\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tVertex.add(new ArrayList<Edge>());\n\t\t\tdist[i] = INF;\n\t\t}\n\t\t\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tString[] uvw = br.readLine().split(\" \");\n\t\t\tint u = stoi(uvw[0])-1;\n\t\t\tint v = stoi(uvw[1])-1;\n\t\t\tint w = stoi(uvw[2]);\n\t\t\tVertex.get(u).add(new Edge(v,w));\n\t\t}\n\t\tString[] point = br.readLine().split(\" \");\n\t\tint start = stoi(point[0])-1;\n\t\tint end = stoi(point[1])-1;\n\t\tdijkstra(start, end);\n\t\t\n\t\tlong answer =dist[end];\n\n\t\tStack<Integer> st = new Stack<Integer>();\n\t\tst.add(end);\n\t\t\n\t\twhile (pre[end] != start) {\n\t\t\tst.add(pre[end]);\n\t\t\tend = pre[end];\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\tst.add(start);\n\t\t\n\t\tSystem.out.println(answer);\n\t\tSystem.out.println(count);\n\t\twhile (!st.isEmpty()) {\n\t\t\tSystem.out.print(st.pop()+1 + \" \");\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void dijkstra(int start, int end) {\n\t\tdist[start] = 0;\n\t\tPriorityQueue<Edge> q = new PriorityQueue<Edge>();\n\t\tq.add(new Edge(start, 0));\n\t\t\n\t\twhile(!q.isEmpty()) {\n\t\t\tEdge now = q.remove();\n\t\t\tif(!visited[now.e]) {\n\t\t\t\tvisited[now.e] = true;\n\t\t\t\tfor(Edge next : Vertex.get(now.e)) {\n\t\t\t\t\tif(!visited[next.e] && dist[next.e] >= dist[now.e] + next.w) {\n\t\t\t\t\t\tdist[next.e] = dist[now.e] + next.w;\n\t\t\t\t\t\tq.add(new Edge(next.e, dist[next.e]));\n\t\t\t\t\t\tpre[next.e] = now.e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\t\n\tstatic class Edge implements Comparable<Edge>{\n\t\tint e, w;\n\t\tEdge(int e, int w){\n\t\t\tthis.e = e;\n\t\t\tthis.w = w;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Edge o){\n\t\t\treturn w - o.w;\n\t\t}\n\t}\n}\n```\n\n# 백준 11780 - 플로이드\n---\n![11780문제 사진1](11780pb1.PNG)\n![11780문제 사진2](11780pb2.PNG)\n![11780문제 사진2](11780pb3.PNG)\n---\nnext배열은 a(정점) -> b(정점) 일 때, 출발 정점(a)의 값을 가지고 있다.\n\n플로이드 알고리즘은 i -> k -> j 의 거리가 짧을 경우 최단거리(dist배열)을 갱신해준다.  \n\n동일하게 최단거리가 짧은 경우 출발 노드(next배열)을 k로 바꿔서 갱신해준다.\n\n---\n```java\npackage pakcage26;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Stack;\n\npublic class num11780 {\n\tstatic int N, M, INF = 100000000;\n\tstatic int[][] dist, next;\n\tstatic boolean[][] visited;\n\tstatic Stack<Integer> stack;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuilder sb = new StringBuilder();\n\t\t\n\t\t\n\t\tN = stoi(br.readLine());\n\t\tM = stoi(br.readLine());\n\t\tdist = new int[N][N];\n\t\tnext = new int[N][N];\n\t\t\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tfor(int j=0; j<N; j++) {\n\t\t\t\tdist[i][j] = i == j ? 0 : INF;\n\t\t\t\tnext[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tString[] abc = br.readLine().split(\" \");\n\t\t\tint a = stoi(abc[0])-1;\n\t\t\tint b = stoi(abc[1])-1;\n\t\t\tint c = stoi(abc[2]);\n\t\t\t\n\t\t\tdist[a][b] = Math.min(dist[a][b], c);\n\t\t\tnext[a][b] = a;\n\t\t}\n\t\t\n\t\tfloyd();\n\t\t\n\t\tprintPath();\n\t}\n\t\n\tpublic static void floyd() {\n\t\tfor(int k = 0; k<N; k++) {\n\t\t\tfor(int i = 0; i<N; i++) {\n\t\t\t\tfor(int j=0; j<N; j++) {\n\t\t\t\t\tif(dist[i][j] > dist[i][k] + dist[k][j]) {\n\t\t\t\t\t\tdist[i][j] = dist[i][k] +dist[k][j];\n\t\t\t\t\t\tnext[i][j] = next[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void printPath() {\n\t\tfor(int[] a : dist) {\n\t\t\tfor(int b: a) {\n\t\t\t\tSystem.out.print(b + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t\n        for(int i=0; i<N; i++) {\n            for(int j=0; j<N; j++) {\n                if(next[i][j]==INF)\n                    System.out.println(0);\n\n                else {\n                \tstack = new Stack<>();\n                    int pre = j;\n                    stack.push(j);\n                    while(i != next[i][pre]) {\n                        pre = next[i][pre];\n                        stack.push(pre);\n                    }\n                    System.out.print((stack.size()+1)+\" \");\n                    System.out.print(i+1+\" \");\n                    while(!stack.empty())\n                        System.out.print(stack.pop()+1+\" \");\n                    System.out.println();\n                }\n            }\n        }\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\t\n}\n```\n\n# 벨만포드 - 백준 1738\n\n---\n\n![1738문제1](1738pb1.PNG)\n![1738문제2](1738pb1.PNG)\n\n---\n일차원 배열을 선언해 이전 경로의 값을 가지고 있는다.\n\n기존의 벨만 포드 알고리즘과는 달리 음의 싸이클이 있으면 끝이 아니라,  \n음의 싸이클에 도착점으로 도달 가능해야 답이 -1이다.\n\n```\n4 4\n1 4 3\n2 3 1\n3 2 1\n4 2 1\n```\n위의 테스트 케이스를 통과해야 정답이다.\n\n이거 때문에 삽질 좀 했다 ㅜㅜ\n\n---\n\n```java\npackage MinPath;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Stack;\n\npublic class num1738 {\n\tstatic int N, M, INF = 987654321, INF2=-987654321;\n\tstatic ArrayList<ArrayList<Edge>> Vertex;\n\tstatic int[] preVertex;\n\tstatic long[] dist;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tString[] NM = br.readLine().split(\" \");\n\t\t\n\t\tN = stoi(NM[0]);\n\t\tM = stoi(NM[1]);\n\t\t\n\t\tdist = new long[N];\n\t\tVertex = new ArrayList<ArrayList<Edge>>();\n\t\tpreVertex = new int[N];\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tVertex.add(new ArrayList<Edge>());\n\t\t\tdist[i] = INF;\n\t\t\tpreVertex[i] = -1;\n\t\t}\n\t\t\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tString[] uvw = br.readLine().split(\" \");\n\t\t\tint u = stoi(uvw[0])-1;\n\t\t\tint v = stoi(uvw[1])-1;\n\t\t\tint w = stoi(uvw[2]);\n\t\t\tVertex.get(u).add(new Edge(v, -w));\n\t\t}\n\t\t\n\t\tbellmanFord();\n\t\t\n\t\tprintPath();\n\t}\n\t\n\tpublic static void bellmanFord() {\n\t\tdist[0] = 0;\n\t\tpreVertex[0] = 0;\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tfor(int j=0; j<N; j++) {\n\t\t\t\tfor(Edge edge : Vertex.get(j)) {\n\t\t\t\t\tint next = edge.e, weight = edge.w;\n\t\t\t\t\tif(dist[j]!=INF && dist[next] > dist[j] + weight) {\n\t\t\t\t\t\tdist[next] = (dist[j] + weight);\n\t\t\t\t\t\tpreVertex[next] = j;\n\t\t\t\t\t\tif(i == N-1) {\n\t\t\t\t\t\t\tdist[next] = INF2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void printPath() {\n\t\tStack<Integer> stack = new Stack<Integer>();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(dist[N-1] == INF || dist[N-1] == INF2)\n\t\t\tsb.append(\"-1\");\n\t\telse{\n\t\t\tfor (int i = N-1 ; i != 0; i = preVertex[i]) {\n\t\t\t\tif(dist[i] == INF2) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}else{\n\t\t\t\t\tstack.push(i);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tstack.push(0);\n\t        for (int i = stack.size(); i > 0; --i)\n\t        {\n\t            sb.append(stack.pop()+1+\" \");\n\t        }\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\t\n\tstatic class Edge{\n\t\tint e, w;\n\t\tEdge(int e, int w){\n\t\t\tthis.e = e;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\n}\n```\n\n# 정리\n\n---\n\n세가지 알고리즘 모두 최단거리를 추적하면서  \n**경로를 저장할 공간을 만들어서 저장하는 방식**이다.\n\n# Reference\n---\n[갓킹독님 블로그](https://blog.encrypted.gg/category/%EA%B0%95%EC%A2%8C/%EC%8B%A4%EC%A0%84%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98?page=1)  \n[라이님 블로그](https://m.blog.naver.com/PostList.nhn?blogId=kks227)  \n","excerpt":"백준 11779, 11780, 1738번 문제를 통해 최단경로의 경로출력을 정리해보려고 한다. 백준 11779 - 다익스트라 \n 소스를 간략히 설명하면 다익스트라 알고리즘에 값이 조건에 맞아 갱신될 때 배열의 값에 이전 노드를 저장한다. 첫 노드부터…","fields":{"slug":"/shortestDistance_2/"},"frontmatter":{"date":"Jan 25, 2021","title":"최단거리 경로복원","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n정리 안해두면 까먹을거 같아서 기억력을 조금이라도 향상시키기 위해 정리해둔다.\n\n자, 최단거리 알고리즘을 이해하기 위해 그래프를 간략히 살펴보면\n\n---\n\n# 그래프란? \n\n---\n\n그래프는 **정점(Vertex)** 와 **간선(Edge)** 을 모아놓은 자료구조다.\n\n그래프라는 친구는 보통 간선에 가중치를 가진다.\n\n## 구현 방법\n---\n1. 인접 행렬\n2. 인접 리스트\n\n# 다익스트라 알고리즘\n---\n\n최단 거리 알고리즘은 기본적으로 **그리디 알고리즘** 으로 분류된다.  \n -> **매번 가장 비용이 적은 노드** 를 선택하는 과정을 반복하기 때문이다.\n\n## 전제조건\n---\n\n1. 시작 노드 - 시작 노드 사이 거리는 0이다.\n2. 모든 간선은 양의 가중치를 가진다.\n\n## 특징\n---\n\n1. 구현 방법은 2가지\n\n## 1. 직관적인 방법 - O(V^2)\n---\n1. 각 노드에 대한 최단 거리를 담는 1차원 리스트 선언\n2. 방문하지 않은 노드 중에서 거리가 가장 짧은 노드 선택  \n(거리가 같으면 일반적으로 번호가 작은 노드)\n3. 거리가 더 짧으면 값 갱신\n\n### 최단거리 - 백준 1753\n---\n![1753문제](1753pb.PNG)\n![1753문제](1753pb2.PNG)\n\n```java\npackage package24;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class num1753 {\n\tstatic int INF = Integer.MAX_VALUE;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tString[] inputVE = br.readLine().split(\" \");\n\t\tint V = stoi(inputVE[0]);\n\t\tint E = stoi(inputVE[1]);\n\t\tint K = stoi(br.readLine())-1;\n\t\t\n\t\tList<Edge>[] graph = new ArrayList[V];\n        for (int i = 0; i < V; i++) \n        \tgraph[i] = new ArrayList<>();\n\t\tint[] distance = new int[V];\n\t\tboolean[] visited = new boolean[V];\n\t\t\n\t\tfor(int i=0; i<V; i++) {\n\t\t\tdistance[i] = INF; \n\t\t}\n\t\t\n\t\tfor(int i=0; i<E; i++) {\n\t\t\tString[] uvw = br.readLine().split(\" \");\n\t\t\tint u = stoi(uvw[0])-1;\n\t\t\tint v = stoi(uvw[1])-1;\n\t\t\tint w = stoi(uvw[2]);\n\t\t\tgraph[u].add(new Edge(v,w));\n\t\t}\n\t\tdijkstra(graph, visited, distance, V, E, K);\n\t\t\n\t\tfor(int value : distance) {\n\t\t\tif(INF == value)\n\t\t\t\tSystem.out.println(\"INF\");\n\t\t\telse\n\t\t\t\tSystem.out.println(value);\n\t\t}\n\t}\n\t\n\tpublic static void dijkstra(List<Edge>[] graph, boolean[] visited, int[] distance, int V, int E, int K) {\n\t\tdistance[K] = 0;\n\t\tfor(int i=0; i<V; i++) {\n\t\t\tint minIndex = getSmallestNodeNotVisited(visited, distance, V);\n            for (Edge next : graph[minIndex]) {\n                if(!visited[next.v] && distance[next.v] > distance[minIndex] + next.weight) {\n                \tdistance[next.v] = distance[minIndex] + next.weight;\n                }\n            }\n\n\t\t\tvisited[minIndex] = true;\n\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static int getSmallestNodeNotVisited(boolean[] visited, int[] distance, int V) {\n\t\tint min = INF;\n\t\tint minIndex = 0;\n\t\tfor(int i=0; i<V; i++) {\n\t\t\tif(visited[i] == false && distance[i]<min) {\n\t\t\t\tmin = distance[i];\n\t\t\t\tminIndex = i;\n\t\t\t}\n\t\t}\n\t\treturn minIndex;\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n\nclass Edge {\n    int v, weight;\n\n    public Edge(int v, int weight) {\n        this.v = v;\n        this.weight = weight;\n    }\n    \n}\n\n```\n---\n\n소스를 간략히 설명하면  \n노드 arrayList를 만들고 Edge는 클래스로 만들어서 넣어주는 방법으로 구현했다.  \n(배열로만 구현하면 메모리 초과난다.)\n\n매번 최단거리가 가장 짧은 노드를 찾기 위해 O(V) 만큼 탐색하기 때문에 비효율적이다.  \n -> Priority Queue 활용\n\n---\n\n## 2. Priority Queue 활용 - O(ElogV)\n\n---\n\n최단 거리 -> **최소 힙**을 사용한다.\n\n```\n1. 각 노드에 대한 최단 거리를 담는 1차원 리스트 선언\n2. 우선순위 큐을 사용해 거리가 짧은 정점부터 Queue에 넣어 줌.(처음 시작 값 : 0)  \n3. 큐가 값이 없을 때까지 반복  \n    3-1) 큐에서 값을 하나 꺼냄 (Vertex 선택)  \n\t3-2) visited 값 true 설정  \n4. 다음 Vertex의 최단거리가 현재Vertex 최단 거리 + 다음 Vertex 가중치보다 크면   \n\t(다음 Vertex가 사용되지 않았을 때)  \n\t4-1) 값 갱신  \n\t4-2) 우선순위 큐에 값 추가  \n```\n\n요약하면\n```\n1. 아직 방문하지 않은 정점 중 거리가 짧은 정점을 하나 선택해 방문\n2. 해당 정점에 인접하고 아직 방문하지 않은 정점의 최단거리 갱신\n```\n\nTip!!  \n**JAVA PriorityQueue 는 기본적으로 minHeap이다.**\n\n\n```java\n// 최소 힙\nPriorityQueue<Integer> minHeap = new PriorityQueue<Integer>();\n\n// 최대 힙\nPriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(Comparator.reverseOrder());\n\n// 최대 힙 version2\nPriorityQueue<Integer> maxHeap = PriorityQueue<>(new Comparator<Integer>(){\n\t@Override\n\tpublic int compare(Integer i1, Integer i2) {\n\t\treturn i2-i1;\n\t}\n});\n```\n\n### 최단거리 - 백준 1504\n\n---\n\n![1504문제](1504pb1.PNG)\n![1504문제2](1504pb2.PNG)\n\n---\n\n문제를 보면 정점 2개를 방문해야 한다는 조건이 있다. 정점을 각각 V1, V2라고 한다면 \n 1. 1 -> V1 -> V2 -> N\n 2. 1 -> V2 -> V1 -> N\n\n두가지 경우에 대해 구간별로 최소값을 구한 후, 더하면 된다.\n\n---\n\n```java\npackage package24;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class num1504 {\n\tstatic int N,E,v1,v2,result;\n\tstatic ArrayList<ArrayList<Edge>> Vertex;\n\tstatic int[] distance;\n\tstatic boolean[] visited;\n\tstatic int INF = 200000000;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tString[] NE = br.readLine().split(\" \");\n\t\tN = stoi(NE[0]);\n\t\tE = stoi(NE[1]);\n\t\tdistance = new int[N+1];\n\t\tvisited = new boolean[N+1];\n\t\tVertex = new ArrayList<>();\n\t\t\n\t\tfor(int i=0; i<=N; i++) {\n\t\t\tVertex.add(new ArrayList<>());\n\t\t}\n\t\t\n\t\tfor(int i=0; i<E; i++) {\n\t\t\tString[] abc = br.readLine().split(\" \");\n\t\t\tint a = stoi(abc[0]);\n\t\t\tint b = stoi(abc[1]);\n\t\t\tint c = stoi(abc[2]);\n\t\t\t\n\t\t\tVertex.get(a).add(new Edge(b,c));\n\t\t\tVertex.get(b).add(new Edge(a,c));\n\t\t}\n\t\tString[] v1v2 = br.readLine().split(\" \");\n\t\tv1 = stoi(v1v2[0]);\n\t\tv2 = stoi(v1v2[1]);\n\t\t\n\t\tresult = solve();\n\t\tSystem.out.println(result);\n\t}\n\n\tpublic static int solve() {\n\t\tint case1=0, case2=0;\n\t\t\n\t\tcase1 = dijkstra(1,v1) + dijkstra(v1,v2) + dijkstra(v2,N);\n\t\tcase2 = dijkstra(1,v2) + dijkstra(v2,v1) + dijkstra(v1,N);\n\n\t\treturn (case1 >= INF && case2 >= INF) ? -1 : Math.min(case1, case2);\n\t}\n\t\n\tpublic static int dijkstra(int start, int end) {\n\t\tArrays.fill(distance, INF);\n\t\tArrays.fill(visited, false);\n\t\t\n\t\tPriorityQueue<Edge> queue = new PriorityQueue<Edge>();\n\t\tqueue.add(new Edge(start,0));\n\t\tdistance[start] = 0;\n\t\t\n\t\twhile(!queue.isEmpty()) {\n\t\t\tEdge now = queue.remove();\n\t\t\tint nowNode = now.e;\n\t\t\tif(!visited[nowNode]) {\n\t\t\t\tvisited[nowNode] = true;\n\t\t\t\t\n\t\t\t\tfor(Edge next : Vertex.get(nowNode)) {\n\t\t\t\t\tif(!visited[next.e] && distance[next.e] > distance[nowNode] + next.weight) {\n\t\t\t\t\t\tdistance[next.e] = distance[nowNode] + next.weight;\n\t\t\t\t\t\tqueue.add(new Edge(next.e, distance[next.e]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn distance[end];\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\t\n\tstatic class Edge implements Comparable<Edge>{\n\t\tint e, weight;\n\t\tEdge(int e, int weight){\n\t\t\tthis.e = e;\n\t\t\tthis.weight = weight;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Edge o){\n\t\t\treturn weight - o.weight;\n\t\t}\n\t}\n}\n```\n\n\n\n# 벨만-포드 알고리즘\n---\n\n## 특징\n---\n\n1. 시간 복잡도 - O(VE)\n2. 다익스트라 알고리즘보다 느리지만 음의 가중치를 가진 경로의 최단거리를 구할 수 있다.\n\n## 전제 조건\n---\n1. **같은 정점을 2번 지날일은 없기 때문에** 간선의 최대 개수는 **V-1**이다.\n2. 음수 사이클이 없는 최단 경로를 구해야 한다.\n\n> 존재하는 모든 간선을 돌아보면서 간선이 통할 수도 있는 거리를 갱신하는 것\n\n## 백준 11657\n---\n![11607문제1](11657pb1.PNG)\n![11607문제2](11657pb2.PNG)\n![11607문제3](11657pb3.PNG)\n\n```java\npackage package24;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class num11657 {\n\tstatic int N, M;\n\tstatic ArrayList<ArrayList<Edge>> Vertex;\n\tstatic long[] dist;\n\tstatic int INF = Integer.MAX_VALUE;\n\tstatic boolean minusCycle=false;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuilder sb = new StringBuilder();\n\t\t\n\t\tString[] inputNM = br.readLine().split(\" \");\n\t\tN = stoi(inputNM[0]);\n\t\tM = stoi(inputNM[1]);\n\t\t\n\t\tdist = new long[N];\n\t\tVertex = new ArrayList<ArrayList<Edge>>();\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tVertex.add(new ArrayList<Edge>());\n\t\t\tdist[i] = INF;\n\t\t}\n\t\t\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tString[] ABC = br.readLine().split(\" \");\n\t\t\tint A = stoi(ABC[0])-1;\n\t\t\tint B = stoi(ABC[1])-1;\n\t\t\tint C = stoi(ABC[2]);\n\t\t\t\n\t\t\tVertex.get(A).add(new Edge(B,C));\n\t\t}\n\t\tbellman();\n\t\t\n\t\tif(minusCycle)\n\t\t\tsb.append(\"-1\\n\");\n\t\telse {\n\t\t\tfor(int i=1; i<N; i++) {\n\t\t\t\tsb.append(dist[i] != INF ? dist[i] : -1);\n\t\t\t\tsb.append(\"\\n\");\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sb.toString());\n\t\t\n\t}\n\tpublic static void bellman() {\n\t\tdist[0] = 0;\n\t\t\n\t    for(int i=0; i<N; i++){ \n\t        for(int j=0; j<N; j++){\n\t            for(Edge edge: Vertex.get(j)){\n\t                int next = edge.e, w = edge.w;\n\t                if(dist[j] != INF && dist[next] > dist[j] + w){\n\t                    dist[next] = dist[j] + w;\n\t                    if(i == N-1) minusCycle = true;\n\t                }\n\t            }\n\t        }\n\t    }\n\t}\n\t\n\tstatic class Edge {\n\t\tint e, w;\n\t\tEdge(int e, int w) {\n\t\t\tthis.e = e;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\t\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n}\n```\n\n---\n\n코드를 간단히 설명해보면\n\n존재하는 모든 간선을 돌아보면서 이 간선을 통할 수도 있는 최단경로들의 거리를 갱신한다.\n같은 정점을 2번 방문하는 경우는 없다는 전제가 있으므로 V-1까지 확인한다\n만약, 음의 사이클이 존재한다면 -> V-1 이후 최단거리가 갱신된다. \n위의 소스에선 V까지 루프의 마지막에 최단거리가 갱신되는지 확인한다.\n\n\n이 문제는 조금 주의할 점이 있다. \n\n최소 가중치가 -10000이라 언더플로우가 생길 수 있기 때문에 **dist를 long[]으로 설정해야 한다.**  \n\n---\n\n# 플로이드 알고리즘 \n---\n## 특징\n---\n\n1. 다익스트라, 벨만 포드 알고리즘 : 하나의 시작점에 대한 최단 거리\n2. 플로이드 워셜 알고리즘 : **모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야 하는 경우**  \n3. 시간 복잡도 : O(V^3)  \n\t-> 노드의 개수 O(V) * **현재 노드를 거쳐가는 모든 경로O(V^2)** -> **O(V^3)**\n4. **DP형태** -> 점화식에 맞게 2차원 리스트를 갱신하기 때문\n\n**Tip!!**  \n상황에 따라 자기 자신으로 이동 가능하면 dis[i][j] = 0 / 불가능하면 dis[i][j] = INF\n\n- 가장 바깥쪽 for문은 경유할 정점\n- 가운데 for문은 출발 정점\n- 가장 안쪽 for문은 도착 정점\n\n---\n\n## 백준 11404\n\n```java\npackage package24;\n\nimport java.io.*;\n\npublic class num11404 {\n\tstatic int N, M, INF = 100000000;\n\tstatic int[][] dis;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tBufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\tStringBuilder sb = new StringBuilder();\n\t\t\n\t\tN = stoi(br.readLine());\n\t\tM = stoi(br.readLine());\n\t\t\n\t\tdis = new int[N][N];\n\t\t\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tfor(int j=0; j<N; j++) {\n\t\t\t\tdis[i][j] = i == j ? 0 : INF;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tString[] abc = br.readLine().split(\" \");\n\t\t\tint a = stoi(abc[0])-1;\n\t\t\tint b = stoi(abc[1])-1;\n\t\t\tint c = stoi(abc[2]);\n\t\t\t\n\t\t\tdis[a][b] = Math.min(dis[a][b], c);\n\t\t}\n\t\t\n\t\tfor(int k=0; k<N; k++) {\n\t\t\tfor(int i=0; i<N; i++) {\n\t\t\t\tfor(int j=0; j<N; j++) {\n\t\t\t\t\tdis[i][j] = Math.min(dis[i][j], dis[i][k] +dis[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n            \tdis[i][j] = dis[i][j] == INF ? 0 : dis[i][j];\n                sb.append(dis[i][j] + \" \");\n            }\n            sb.append(\"\\n\");\n        }\n \n        bw.write(sb.toString());\n        bw.flush();\n        bw.close();\n        br.close();\n\t}\n\tpublic static int stoi(String string) {\n\t\treturn Integer.parseInt(string);\n\t}\n\n}\n```\n\n\n\n# 정리\n---\n\n이렇게 최단거리 알고리즘 3가지를 알아보았다.  \n\n사용하는 경우를 정리해보면  \n```\n1. 다익스트라 알고리즘[우선순위 큐] -> 한 지점에서 다른 지점까지 최단거리 구하는 문제  \n2. 벨만 포드 알고리즘 -> 음의 가중치를 가진 최단거리 구하는 문제  \n3. 플로이드 와샬 알고리즘 -> 모든 경로의 최단거리 구하는 문제\n``` \n로 정리할 수 있다.\n\n\n생각보다 어려워서 정리하는데 시간이 오래걸렸다.  \n다음 글은 최단경로의 경로출력에 대해 정리해 볼 예정이다.\n\n추가로 [라이님 블로그](https://blog.naver.com/kks227/220796029558) 요기 있는 추가문제 하나씩 풀어봐야겠다.\n\n\n# Reference\n---\n[라이님 블로그](https://blog.naver.com/kks227/220796029558)  \n[갓킹독님 블로그](https://blog.encrypted.gg/917?category=773649)  \n[Crocus님 블로그](https://www.crocus.co.kr/546?category=209527)  \n[백준 질문하기 - 출력초과 문제 해결이 되었는데 이유를 모르겠습니다](https://www.acmicpc.net/board/view/55270)  \n이것이 코딩테스트다 - 나동빈\n\n\n","excerpt":"정리 안해두면 까먹을거 같아서 기억력을 조금이라도 향상시키기 위해 정리해둔다. 자, 최단거리 알고리즘을 이해하기 위해 그래프를 간략히 살펴보면 그래프란? 그래프는 정점(Vertex) 와 간선(Edge) 을 모아놓은 자료구조다. 그래프라는 친구는 보통…","fields":{"slug":"/shortestDistance_1/"},"frontmatter":{"date":"Jan 23, 2021","title":"최단거리 알고리즘","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n백준 이분 탐색 문제를 풀다 Parametric Search에 대해 알게 되었고, 정리 할 필요성을 느껴서 포스팅한다.\n\n일단 **이분탐색**은 탐색 기법으로 **원하는 탐색 범위를 두 부분으로 분할**해서 찾는 방식이다  \n -> O(logN)의 시간 복잡도를 가지고 있다.\n\n**파라매트릭 서치**는 **최적화 문제 -> 결정문제로 바꾸어 푸는 것**을 말한다.  \n(문제 상황을 만족하는 특정한 값 - 최소값, 최대값) \n\n백준 2110번 문제가 쉽게 이해하기 좋은 문제인 것 같다.\n\n![문제사진](pro1.PNG)\n![문제사진2](pro2.PNG)\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] inputNK = br.readLine().split(\" \");\n\t\tint N = Integer.parseInt(inputNK[0]);\n\t\tlong K = Long.parseLong(inputNK[1]);\n\t\tlong max = 0;\n\t\t\n\t\tlong[] houseArr = new long[N];\n\t\t\n\t\tfor(int i=0; i<N; i++) {\n\t\t\thouseArr[i] = Long.parseLong(br.readLine());\n\t\t\tmax = max > houseArr[i] ? max : houseArr[i];\n\t\t}\n\t\tArrays.sort(houseArr);\n\t\t\n\t\tmax = Psearch(houseArr, K, max);\n\t\tSystem.out.println(max);\n\t}\n\t\n\tpublic static long Psearch(long[] houseArr, long K, long max) {\n\t\tlong start = 1;\n\t\tlong end = max;\n\t\tlong ans = 0;\n\t\t\n\t\twhile(start<=end) {\n\t\t\tlong mid = (start+end)/2;\n\t\t\t\n\t\t\tif(checkHouse(houseArr, mid, K)) {\n\t\t\t\tstart = mid+1;\n\t\t\t\tans = ans > mid ? ans : mid;\n\t\t\t}else {\n\t\t\t\tend = mid-1;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static boolean checkHouse(long[] houseArr, long mid, long K) {\n\t\tlong temp = houseArr[0];\n\t\tlong index = 0;\n\t\tfor(int i = 1; i<houseArr.length; i++) {\n\t\t\tif(houseArr[i]-temp >= mid) {\n\t\t\t\tindex++;\n\t\t\t\ttemp=houseArr[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(index >=K-1)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n}\n\n```\n\n이 문제의 포인트는  \n1. 공유기 사이 거리를 정한 후, 정한 거리 이상의 간격으로 집에 설치 가능한지 확인\n    - 설치 가능 -> 더 큰 거리값 확인\n    - 설치 불가능 -> 작은 거리값을 확인  \n\n\n추가로 백준 12015번 문제를 풀어보는 것을 추천한다.\ndp를 활용해 가장 긴 증가하는 부분 수열 구할 수 있는데 이분탐색을 사용하면 O(logN)으로 구할 수 있다.\n\n\n \n\n\n\n\n\n\n\n","excerpt":"백준 이분 탐색 문제를 풀다 Parametric Search에 대해 알게 되었고, 정리 할 필요성을 느껴서 포스팅한다. 일단 이분탐색은 탐색 기법으로 원하는 탐색 범위를 두 부분으로 분할해서 찾는 방식이다  -> O(logN)의 시간 복잡도를 가지고…","fields":{"slug":"/ParametricSearch/"},"frontmatter":{"date":"Jan 17, 2021","title":"이분탐색, 파라매트릭 서치(Parametric Search)","tags":["Algorithm","Parametric Search"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n백준 단계별 문제 - 우선순위 큐 마지막 문제다.  \n\n풀다가 조금 헷갈린 부분이 있어 정리하고자 포스팅한다.  \n\n# 문제\n![문제사진](problem1.PNG)\n![문제사진2](problem2.PNG)\n\n일단 문제에 처음 접근할 땐, 우선순위 큐를 사용해 저장하고 중간 값을 계속 뽑아와 StringBuilder에 넣어주는 방식으로 구현했다.  \n\n```java\npackage package21;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.PriorityQueue;\nimport java.util.Stack;\n\npublic class num1655 {\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tPriorityQueue<Integer> q = new PriorityQueue<>();\n\t\tStringBuilder sb = new StringBuilder();\n\t\t\n\t\tint T = Integer.parseInt(br.readLine());\n\t\t\n\t\tfor(int i=0; i<T; i++) {\n\t\t\tint value = Integer.parseInt(br.readLine());\n\t\t\tq.offer(value);\n\t\t\tint len = q.size()/2 + q.size()%2;\n\t\t\tStack<Integer> s = new Stack<>();\n\t\t\tfor(int j=0;j<len;j++) {\n\t\t\t\ts.push(q.remove());\n\t\t\t}\n\t\t\tif(!s.isEmpty())\n\t\t\t\tsb.append(s.peek()+\"\\n\");\n\t\t\twhile(!s.isEmpty()) {\n\t\t\t\tq.offer(s.pop());\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\n}\n```\n![시간초과](no.PNG)\n\n역시 시간초과.....\n\n## 풀이 1\nstack대신 우선순위큐를 하나 더 써서 구현해보려고 생각하였고, 이 부분에서 삽질을 조금 하였다.  \n\n포인트는 4가지다.\n1. Max Heap(최대 값이 가장 앞에 위치)과 Min Heap(최소 값이 가장 앞에 위치) 사용   \n2. 중간 값을 저장(초기 값 = 맨 처음에 입력받은 값)  \n   중간 값 보다 작은 값은 Max Heap / 큰 값은 Min Heap\n3. 큰값을 저장하는 min heap이 길이가 2이상 길면 중앙 값 바꿈  \n    -> 작은 값을 저장하는 max heap에 중간 값 저장  \n    -> 큰 값을 저장하는 min heap에서 가장 작은 값을 중간값으로 바꿈  \n4. 작은 값을 저장하는 max heap이 길이가 1이상 길면 중앙 값 바꿈  \n   (길이가 짝수이면 작은수가 중간 값이니 길이= 1 )  \n   -> 큰 값을 저장하는 min heap에 중간 값 저장  \n   -> 작은 값을 저장하는 max heap에서 가장 큰 값을 중간값으로 바꿈  \n\n```java\npackage package21;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class num1655v2 {\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuilder sb = new StringBuilder();\n\t\tQueue<Integer> min = new PriorityQueue<>();\n\t\tQueue<Integer> max = new PriorityQueue<>(new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\treturn o2.compareTo(o1);\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\tint T = Integer.parseInt(br.readLine());\n\t\t\n\t\tint index=0;\n\t\t\n\t\tfor(int i = 0; i<T; i++) {\n\t\t\tint num = Integer.parseInt(br.readLine());\n\t\t\tif(i==0) {\n\t\t\t\tindex = num;\n\t\t\t\tsb.append(num+\"\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(num<=index) {\n\t\t\t\t// 작은 값이면 max heap에 저장\n\t\t\t\tmax.offer(num);\n\t\t\t\tif(max.size()-min.size()>=1) {\n\t\t\t\t\tmin.offer(index);\n\t\t\t\t\tindex = max.poll();\n\t\t\t\t}\n\t\t\t}else {\n\t\t\t\t// 큰 값이면  min heap에 저장\n\t\t\t\tmin.offer(num);\n\t\t\t\tif(min.size() - max.size() >=2) {\n\t\t\t\t\tmax.offer(index);\n\t\t\t\t\tindex = min.poll();\n\t\t\t\t}\n\t\t\t}\n\t\t\tsb.append(index+\"\\n\");\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\n}\n```\n\n후... 큰 값을 min heap 저장, 작은 값을 max heap 저장, 중간값은 index로 빼놓는게 포인트인데 코드 짜다보니 헷갈려서 헤맸다.\n\n\n\n추가) 다른 사람들은 코드를 어떻게 짰는지 구글링 해봤는데 조금 재밌게 푼 코드가 있어서 추가로 풀어봤다.\n\n## 풀이2\n1. 중간 값은 항상 max heap의 가장 앞의 값으로 유지\n2. 크기가 같으면 max heap에 값 추가\n   (입력한 값이 min heap의 최소값보다 크면 값 swap)\n3. 크기가 다르면 min heap에 값 추가\n   (입력한 값이 max heap의 최대값보다 작으면 값 swap)\n\n이 코드는 입력값 : 521578 을 넣어서 직접 노트에 풀어보는게 이해하는데 도움됐다.\n```java\npackage package21;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class num1655v3 {\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuilder sb = new StringBuilder();\n\t\tQueue<Integer> min = new PriorityQueue<>();\n\t\tQueue<Integer> max = new PriorityQueue<>(new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\treturn o2.compareTo(o1);\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\tint T = Integer.parseInt(br.readLine());\n\t\t\n\t\tint index=0;\n\t\t\n\t\tfor(int i = 0; i<T; i++) {\n\t\t\tint num = Integer.parseInt(br.readLine());\n\t\t\tif(max.size() == min.size()) {\n\t\t\t\tmax.offer(num);\n\t\t\t\tif(!min.isEmpty() && max.peek() > min.peek()) {\n\t\t\t\t\tmin.offer(max.poll());\n\t\t\t\t\tmax.offer(min.poll());\n\t\t\t\t}\n\t\t\t}else {\n\t\t\t\tmin.offer(num);\n\t\t\t\tif(max.peek() > min.peek()) {\n\t\t\t\t\tmin.offer(max.poll());\n\t\t\t\t\tmax.offer(min.poll());\n\t\t\t\t}\n\t\t\t}\n\t\t\tsb.append(max.peek()+\"\\n\");\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n}\n\n```\n\n우선순위 큐는 이렇게 마무리!!\n\n# Update) 2021-01-14\n백준 2981번이 비슷한 유형이라 풀고 추가로 update 한다.\n# 백준 2981\n![문제사진3](problem3.PNG)\n![문제사진4](problem4.PNG)\n\n\n```java\npackage priorityQueue;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class num2696 {\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuilder sb = new StringBuilder();\n\t\tQueue<Integer> minHeap = new PriorityQueue<>();\n\t\tQueue<Integer> maxHeap = new PriorityQueue<>(new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\treturn o2.compareTo(o1);\n\t\t\t}\n\t\t});\n\t\t\n\t\tint T = Integer.parseInt(br.readLine());\n\t\t\n\t\tfor(int i=0; i<T; i++) {\n\t\t\tint count = Integer.parseInt(br.readLine());\n\t\t\tString[] inputData = br.readLine().split(\" \");\n\t\t\tsb.append(count/2+count%2 + \"\\n\");\n\t\t\tint index = 0;\n\t\t\tint jindex = 0;\n\t\t\tfor(int j=0; j<count; j++) {\n\t\t\t\tif(j%10==0 && j>9) {\n\t\t\t\t\tinputData = br.readLine().split(\" \");\n\t\t\t\t\tif(j%20==0) {\n\t\t\t\t\t\tsb.append(\"\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tjindex=0;\n\t\t\t\t}\n\t\t\t\tint num = Integer.parseInt(inputData[jindex]);\n\t\t\t\tif(jindex==0 && j==0) {\n\t\t\t\t\tjindex++;\n\t\t\t\t\tindex = num;\n\t\t\t\t\tsb.append(num + \" \");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(num <= index) {\n\t\t\t\t\tmaxHeap.offer(num);\n\t\t\t\t\tif(maxHeap.size() - minHeap.size()>=1) {\n\t\t\t\t\t\tminHeap.offer(index);\n\t\t\t\t\t\tindex = maxHeap.poll();\n\t\t\t\t\t}\n\t\t\t\t}else {\n\t\t\t\t\tminHeap.offer(num);\n\t\t\t\t\tif(minHeap.size() - maxHeap.size()>=2) {\n\t\t\t\t\t\tmaxHeap.offer(index);\n\t\t\t\t\t\tindex = minHeap.poll();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(jindex%2==0) {\n\t\t\t\t\tsb.append(index + \" \");\n\t\t\t\t}\n\t\t\t\tjindex++;\n\t\t\t}\n\t\t\t\n\t\t\tsb.append(\"\\n\");\n\t\t\tminHeap.clear();\n\t\t\tmaxHeap.clear();\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\n}\n\n```\n\n이 문제는 한 줄에 10개씩 들어온다는게 포인트다. 10개씩 장난쳐줘야 한다.\n\n정말 끝","excerpt":"백준 단계별 문제 - 우선순위 큐 마지막 문제다.   풀다가 조금 헷갈린 부분이 있어 정리하고자 포스팅한다.   문제 \n 일단 문제에 처음 접근할 땐, 우선순위 큐를 사용해 저장하고 중간 값을 계속 뽑아와 StringBuilder에 넣어주는 방식으로…","fields":{"slug":"/backjoon1655/"},"frontmatter":{"date":"Jan 13, 2021","title":"백준 1655 - 가운데를 말해요 풀이","tags":["Algorithm","BackJoon"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n문제를 풀다 조금 재밌는 부분이 생겨 정리한다.\n\n![문제사진](problem1.PNG)\n![문제사진2](problem2.PNG)\n\n백준 문제를 풀 때 한가지 팁은 문제가 낮은 정답비율이면  \n입출력이나 시간복잡도를 확인하는게 좋은거같다.  \n\n일단 뭔가 최대공약수로 장난치는 문제인 느낌을 받아서 규칙을 찾아보았다.\n\n```\narr[1] % M + r = arr[2] % M + r = arr[3] % M + r\n -> 요런 식이 나온다. 조금 장난쳐보면\n\narr[3] % M + r - arr[2] % M - r = arr[2] % M + r - arr[1] % M - r\n\n(arr[3] - arr[2]) % M = (arr[2] - arr[1]) % M\n\n(arr[n] - arr[n-1]) % M\n```\n\nㅋ 찾았다.\n\n```java\npackage package16;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class num2981 {\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tint N = Integer.parseInt(br.readLine());\n\t\tint[] arr = new int[N];\n\t\tint arrGcdValue = 0;\n\t\t\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tarr[i] = Integer.parseInt(br.readLine());\n\t\t}\n\t\t\n\t\tfor(int i=1; i<N; i++) {\n\t\t\tarrGcdValue = gcd(arrGcdValue, Math.abs(arr[i] - arr[i-1]));\n\t\t}\n\t\t\n\t\tfor(int i=2; i<=arrGcdValue; i++) {\n\t\t\tif(arrGcdValue % i == 0)\n\t\t\t\tSystem.out.print(i + \" \");\n\t\t}\n\t}\n\t\n\tpublic static int gcd(int a, int b) {\n\t\treturn a % b == 0 ? b : gcd(b, a % b);\n\t}\n\n}\n```\n아 조금 주의할 점, arr[n] - arr[n-1]값이 음수일 수 있어서 절대값으로 받아야 한다.\n\n오늘은 뭔가 낚이지 않은 기분이다. 👌하핳","excerpt":"문제를 풀다 조금 재밌는 부분이 생겨 정리한다. \n 백준 문제를 풀 때 한가지 팁은 문제가 낮은 정답비율이면 입출력이나 시간복잡도를 확인하는게 좋은거같다.   일단 뭔가 최대공약수로 장난치는 문제인 느낌을 받아서 규칙을 찾아보았다. ㅋ 찾았다. 아 …","fields":{"slug":"/backjoon2981/"},"frontmatter":{"date":"Jan 09, 2021","title":"백준 2981 - 검문 풀이","tags":["Algorithm","BackJoon"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n기술 면접을 준비하면서 면접에 자주 나오는 문항들을 정리해보려고 한다.\n\n본 포스트는 취업 준비를 하면서 부족한 부분을 지속해서 업데이트할 예정이다.\n\n# 시작하기전에\n - 1) 수행한 프로젝트, 준비한 사항은 **분명하고 간결하게** 설명 가능해야 한다.\n - 2) 쫄지말자, 당당하게\n - 3) 답변을 추상적이게 하지 말고, **구체적으로 아는 쪽으로 답변**\n\n\n# 목차\n\n# Part1. CS\n\n\n### 1. 객체 지향 프로그래밍\n\n```\n1. 정의\n  프로그램을 수많은 '객체'라는 기본 단위로 나누고 이 객체들의 상호작용으로 서술\n  - 객체란, 하나의 역할을 수행하는 '메소드와 변수(데이터)'\n\n2. 특징\n - 인간 중심적 프로그래밍 패러다임\n - 프로그램 설계 방법론이자 개념의 일종\n - 현실 세계 사물 -> 객체\n - 어플리케이션 특징(객체의 상호작용) -> 프로그래밍(=추상화)\n\n3. 장점\n - 코드 재사용 용이\n - 유지 보수 쉬움\n - 강한 응집력과 약한 결합력을 가진다\n - (응집력 : 기능을 수행하기 위해 얼마만큼의 연관된 책임과 아이디어가 뭉친 정도)\n - (결합력 : 프로그램의 요소가 다른 것과 얼마나 연결되어 있는지, 의존적인지)\n\n4. 단점\n - 설계시 많은 시간 필요\n - 객체들간의 통신시 오버헤드 발생해서 처리속도가 상대적으로 느림\n```\n\n **1. 객체 지향 프로그래밍이 뭔가요?**  \n    - 프로그램 설계 방법론입니다. 현실 세계의 사물을 추상화하여 객체를 만들고, 객체간의 상호작용을 통해 시스템을 구성하는 프로그래밍 방법입니다.  \n    특징으로는 추상화, 캡슐화, 상속, 다형성이 있습니다\n    장점으로는 코드 재사용이 용이, 유지보수가 쉬움, 강한 응집력과 약한 결합력을 가지는 것이 있고,  \n    단점으로는 설계시 많은 시간이 필요하고, 객체들간의 통신시 오버헤드가 발생해 처리속도가 상대적으로 느립니다.\n\n**1-1. 객체지향에서 말하는 추상화가 뭔가요?**  \n    - 객체에서 공통된 속성과 행위를 뽑아내는 것을 말합니다.  \n\n\n**1-2. 객체지향에서 말하는 캡슐화가 뭔가요?**  \n    - 변수와 함수를 하나의 단위로 묶는 것을 의미합니다. 추가로 자바에서는 접근 제어자를 통해 정보 은닉 기능을 제공합니다. 정보 은닉은, 프로그램의 세부 구현을 외부로 드러내지 않도록 감추는 것을 말합니다.  \n\n\n**1-3. 객체지향에서 말하는 상속이 뭔가요?**  \n    - 기존 클래스를 활용하여 새로운 클래스를 작성하는 것을 말합니다. 상속의 장점은 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램 생산성과 유지보수에 기여합니다.    \n\n\n**1-4. 객체지향에서 말하는 다형성이 뭔가요?**  \n    - 다향한 형태로 나타날 수 있는 특성을 말합니다.  \n\n**1-5. 객체지향에서 말하는 응집력과 결합력이 뭔가요?**  \n    - 응집력은 기능을 수행하기 위해 얼마만큼의 책임과 아이디어가 뭉쳐있는지 나타내는 정도입니다.  \n    - 결합력은 다른 요소와 얼마나 의존적인지 나타내는 정도입니다.\n\n**2. 객체와 인스턴스가 뭔가요?**  \n    - 인스턴스는 객체를 실체화한 것입니다. 즉, 프로그램 코드 상에서 자료형이 임의의 클래스로 선언된 클래스를 객체라 하고, 코드 컴파일 후 프로그램이 실행될 때 해당 객체가 메모리에 적재되면 인스턴스라 합니다. \n\n**3. 객체 지향 프로그래밍과 절차지향 프로그래밍을 설명해주세요**\n    - 절차지향 프로그래밍이란 '프로그램이 무슨일을 하는가'의 관점으로 바라본 프로그래밍 기법이고,\n    - 객체지향 프로그래밍은 '어떤 대상을 모델링하는가'의 관점으로 바라본 프로그래밍 기법입니다.\n    - 즉, 절차지향 프로그래밍은 프로그램의 순서와 흐름을 먼저 세우고 필요한 자료구조와 함수들을 설계하는 방식이고, 객체지향 프로그래밍은 반대로 자료구조와 이를 중심으로 한 모듈들을 먼저 설계한 다음에 이들의 실행순서와 흐름을 짜는 방식이다.\n\n### 2. RESTful API\n\n```\n1. 정의\n - 소프트웨어 아키텍처의 한 형식으로 자원을 정의하고 자원에 대한 주소를 지정하는 방법  \n\n2. 특징\n - 지정한 주소를 HTTP Method를 통해 자원을 처리한다.\n - REST의 6가지 기본 원칙을 성실히 지킨 서비스 디자인을 RESTful하다라고 표현\n\n3. 장점\n - 기존 웹 인프라를 그대로 사용할 수 있다.\n - 쉽고, 빠르다\n - 세부적인 표현 문구를 JSON, XML등 다양한 언어를 이용하여 작성할 수 있다.\n\n4. 단점\n - 메소드 형태가 제한적이다.\n - 표준 규약이 없다.\n - HTTP 통신 모델에 대해서만 지원합니다.\n```\n\n**1. API란 무엇인가요?**  \n    - API란, 응용 프로그램에서 사용할 수 있도록 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻합니다.  \n\n**2. REST API란 무엇인가요?**  \n    - 자원이 있는 곳을 URI로 정의하고, 자원을 이용하는 방법을 HTTP Method를 통해 자원을 처리하는 것을 말합니다.  \n\n**3. RESTful 하게 API를 디자인 한다는 것은 무엇을 의미하는가?**  \n    - REST API의 6가지 기본 원칙을 성실히 지킨 서비스를 RESTful하다라고 표현합니다.  \n\n### 3. TDD\n\n```\n1. 정의\n - 테스트 주도 개발\n - (개발 테스트 단위가 함수단위로 매우 작아서 작성하는 거의 모든 함수가 테스트에 포함된다.)\n\n2. 관련 용어\n 1) BDD : 시나리오 기반으로 테스트 케이스 작성\n  - Given -> When -> Then\n  - 어떤 상태 (Given) -> 어떤 상태 변화를 가했을 때(When) -> 기대하는 상태로 완료(Then)\n\n3. 장점\n - 피드백이 많아진다.\n - (테스트를 통과하는 것으로 개발이 잘 진행되는지 자주 확인가능해진다.)\n - 코드 복잡도가 낮아진다.\n\n4. 단점\n - 개발시간이 길어진다.\n```\n\n**1. TDD에 대해 설명해주세요**\n\n**2. BDD에 대해 아시나요?**\n\n**3. 좋은 코드에 대해 어떻게 생각하시나요? (내생각)**  \n    - 저는 좋은 코드를 판단하는 기준으로 **가독성, 효율성**이 가장 중요하다고 생각합니다.  \n   Coding Convention을 잘 지키고 일관성있게 작성되며, 문제상황에서 필요한 요구사항을 적절히 충족하고 효율적으로 해결하는 코드가 좋은 코드라고 생각합니다.\n\n\n\n### 4. GIT\n\n```\n1. 정의\n - 버전 관리 시스템\n\n2. 장점\n - 여러명이 동시에 작업하는 병렬 개발이 가능하다.\n - 분산 버전관리이기 때문에 인터넷이 연결되지 않은 곳에서도 개발을 진행할 수 있다.\n - 체계적인 개발이 가능해진다.\n```\n\n**1. Git의 장점에 대해 설명해주세요**\n    - 여러명이 동시 작업하는 병렬 개발이 가능하고, 분산 버전관리기 때문에 인터넷이 연결되지 않은 곳에서도 개발을 진행할 수 있는 것이 장점입니다.\n\n## Part 1-2 자료구조\n\n### 1. Array / LinkedList\n\n### 2. Stack / Queue\n\n**1. Stack에 대해 설명해주세요**  \n    - 선형 자료구조의 일종으로 Firt In Last Out (FILO)구조를 가집니다.\n\n\n**2. Queue에 대해 설명해주세요**  \n    - 선형 자료구조의 일종으로 First In First Out (FIFO)구조를 가집니다.\n\n\n### 3. Tree\n```\n 1. Binary Tree(이진트리)\n\n 2. BST(Binary Search Tree)\n\n 3. Binary Heap\n\n 4. Red Black Tree\n\n 5. Graph\n\n```\n**1. Tree에 대해 설명해주세요**  \n    - 비선형 자료구조이다. 트리는 계층적 관계(Hierarchical Relationship)을 표현하는 자료구조이다. \n\n**2. 이진트리(Binary Tree)에 대해 설명해주세요.**\n\n## Part 1-3 알고리즘\n\n## Part 1-4 네트워크\n\n### 1. HTTP Method\n\n\n### 2. TCP/UDP\n\n\n\n### 3. HTTP/HTTPS\n\n\n### 4. 웹 통신의 흐름\n\n\n## Part 1-5 운영체제\n\n### 1. 프로세스/스레드\n\n\n\n\n### 2. 멀티스레드/멀티 프로세스\n\n\n### 3. 동기/비동기\n\n\n**1.재귀 호출의 단점은?**  \n    - 재귀 호출 시, 함수를 반복해서 호출해야 하는데, 매번 호출할 때마다 시간과 스택 공간에서 오버헤드 발생.\n\n\n## Part 1-6 데이터 베이스\n\n### 1. 데이터 베이스 사용하는 이유\n\n\n### 2. 정규화\n\n\n### 3. 트랜잭션\n\n### 4. NoSQL\n\n\n## Part 1-7 디자인 패턴\n\n### 디자인 패턴이란?\n> 프로그램 개발 시에 자주 생기는 에로 상황에 대한 일반적이고 재사용 가능한 추상화된 해결책이다.\n\n\n### 1. MVC 패턴이란?\n\n```\n1. 정의 - Model-View-Controller의 약자로, 개발할 때 3가지 형태로 나눠 개발하는 방법론\n\n2. 특징\n - Model : 어플리케이션이 무엇을 할 지 정의\n - View : 어플리케이션 화면에 무엇을 보여줄지\n - Controller : 어플리케이션이 어떻게 처리할지\n   -> Model, View가 무엇을 해야 할 지를 알고 통제\n\n3. 관련 용어\n - Service\n\n4. 장점\n -\n\n5. 단점\n```\n\n## Part 1-8 보안\n\n# Part2. Language\n\n## 1. JAVA\n\n1. JVM이란?\n   - 자바가상머신의 약자를 줄여서 부르는 용어입니다. **프로그램을 실행하기 위해 물리적 머신과 유사한 머신을 소프트웨어로 구현**한 것을 말합니다.\n\n2. GC이란?\n   - \n\n## 2. JavaScript\n > 프로그래밍 언어로 브라우저가 가진 기능을 코드로 제어\n > (이벤트를 제어하기 위함)\n\n### 2.1 NodeJS\n > 자바스크립트의 언어와 환경이 분리 필요\n -> 웹서버를 동작하기 위한 도구로 구글의 V8 Engine기반 **NodeJS** 탄생!!\n\n## 3. C\n\n1. C에서는 메모리를 어떻게 할당하는가?\n    - d\n\n# Part3. FrontEnd\n**프레임 워크와 플랫폼의 차이가 뭔가요?**\n\n**Cookie, Session Storage, LocalStorage의 차이점을 말해주세요**\n\n\n**UI(User Interface)란?**\n   - 사용자와 시스템의 접점\n\n\n## 1. Vitual DOM\n\n## 2. React.js\n\n\n## 3. Vue.js\n\n\n# Part4. BackEnd\n\n## 1. Spring\n\n## 2. Express\n\n# Part5. Project\n\n\n## IoT\n\n### 1. MQTT\n\n","excerpt":"기술 면접을 준비하면서 면접에 자주 나오는 문항들을 정리해보려고 한다. 본 포스트는 취업 준비를 하면서 부족한 부분을 지속해서 업데이트할 예정이다. 시작하기전에 수행한 프로젝트, 준비한 사항은 분명하고 간결하게 설명 가능해야 한다. 쫄지말자, 당당하…","fields":{"slug":"/techInterview/"},"frontmatter":{"date":"Dec 28, 2020","title":"개발 기술 면접 준비","tags":["면접"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n풀이를 보고 바로 이해하지 못하고 헷갈린 부분이 있어서 정리한다.\n\n![문제사진](problem.PNG)\n\n# LCS란?\n공통적으로 가지고 있는 부분 문자열 중, 가장 긴 문자열(최장 공통 부분 수열)\n\n## 규칙찾기\n\n점화식을 찾아내기 전에 문제에 나온 예제 입력값을 통해 규칙을 찾아보면\n\n```\nindex   C A P C A K\nA       0 1 1 1 1 1\nC       1 1 1 2 2 2\nA       1 2 2 2 3 3\nY       1 2 2 2 3 3\nK       1 2 2 2 3 4\nP       1 2 3 3 3 4\n```\n\n## 접근\n\n문제의 경우는 2가지로 나눌 수 있다.\n\n 1) 두 문자열에 같은 문자가 추가되는 경우\n    - ex) ACAYKP**A** , CAPCAK**A**\n 2) 두 문자열에 다른 문자가 추가되는 경우\n    - ex) ACAYKP**B** , CAPCAK**C**\n\n## 점화식\n두 가지 경우를 각각 점화식으로 나타내 보면\n```\n 1) dp[i][j] = dp[i-1][j-1] + 1\n 2) dp[i][j] = Max(arr[i][j-1], arr[i-1][j])\n```\n\n점화식을 찾아냈으면 코드작성은 쉽다.\n\n## 코드\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class num9251 {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] str1 = br.readLine().split(\"\");\n\t\tString[] str2 = br.readLine().split(\"\");\n\t\t\n\t\tint N = str1.length;\n\t\tint M = str2.length;\n\t\tint[][] arr = new int[N+1][M+1];\n\t\t\n\t\tfor(int i=1;i<=N;i++) {\n\t\t\tfor(int j=1;j<=M;j++) {\n\t\t\t\tif(str1[i-1].equals(str2[j-1])) {\n\t\t\t\t\tarr[i][j] = arr[i-1][j-1] +1;\n\t\t\t\t}else {\n\t\t\t\t\tarr[i][j] = Math.max(arr[i][j-1],arr[i-1][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(arr[N][M]);\n\t}\n}\n```","excerpt":"풀이를 보고 바로 이해하지 못하고 헷갈린 부분이 있어서 정리한다.  LCS란? 공통적으로 가지고 있는 부분 문자열 중, 가장 긴 문자열(최장 공통 부분 수열) 규칙찾기 점화식을 찾아내기 전에 문제에 나온 예제 입력값을 통해 규칙을 찾아보면 접근 문제…","fields":{"slug":"/backjoon9251/"},"frontmatter":{"date":"Dec 28, 2020","title":"백준 9251 - LCS 풀이","tags":["Algorithm","BackJoon"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n백준 DP 단계별 문제에 있는 10844번 문제이다. \n\n접근이 조금 어려웠던 문제라 풀이를 정리해보려고 한다.  \n\n## 접근\n\n일단 이 문제는 DP문제로 2차원 배열을 DP로 사용해야 한다.\n\n규칙을 찾기 위해 값을 적어보고, 개수를 세보면 아래와 같다.  \n(N : 자리수, index : 맨 마지막에오는 숫자)  \n```\nindex   0 1 2 3 4 5 6 7 8 9\nN=1     0 1 1 1 1 1 1 1 1 1  \nN=2     1 1 2 2 2 2 2 2 2 1\nN=3     1 3 3 4 4 4 4 4 3 2\n\nex)\nN=2 -> (10), (21), (32, 12), (43,23), (54,34), (65,45), (76,56), (87,67), (98,78), (89)\n```\ndp[N][index] = dp[N-1][index-1] + dp[N-1][index+1]인 점화식을 얻을 수 있다.\n\n단, 여기서 중요한 점은 index가 0일 경우는 +1 한 값이 허용되고  \n9일 경우는 -1 한 경우만 적용되기 때문에 예외 처리를 해줘야 한다.  \n\n마지막으로 점화식을 정리해보면\n```\n1) index가 1일 경우\ndp[N][index] = dp[N-1][index+1]\n\n2) index가 1~8일 경우\ndp[N][index] = dp[N-1][index-1] + dp[N-1][index+1]\n\n3) index가 9일 경우\ndp[N][index] = dp[N-1][index-1]\n\n```\n\n3가지 경우에 따라 분기처리를 하면 된다.\n\n# Top-down 방식\n\n## 구현코드\n\n```java\npackage package14;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class num10844 {\n\tstatic Long[][] dp;\n\tstatic int N;\n\tfinal static long MOD = 1000000000;\n\t\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tN = Integer.parseInt(br.readLine());\n\t\tdp = new Long[N+1][10];\n\t\t// #1\n\t\tfor(int i = 0; i < 10; i++) {\n\t\t\tdp[1][i] = 1L;\n\t\t}\n\n\t\tlong result = 0;\n\t\t\n\t\tfor(int i = 1; i <= 9; i++) {\n\t\t\tresult += recur(N, i);\n\t\t}\n\t\tSystem.out.println(result % MOD);\n\t}\n\t\n\tstatic long recur(int digit, int val) {\t\t\n\t\t\n\t\tif(digit == 1) {\n\t\t\treturn dp[digit][val];\n\t\t}\n\t\t// #2\n\t\tif(dp[digit][val] == null) {\n\t\t\tif(val == 0) {\n\t\t\t\tdp[digit][val] = recur(digit - 1 ,1);\n\t\t\t}\n\t\t\telse if(val== 9) {\n\t\t\t\tdp[digit][val] = recur(digit - 1, 8);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[digit][val] = recur(digit - 1, val - 1) + recur(digit - 1, val + 1);\n\t\t\t}\n\t\t}\n\t\treturn dp[digit][val] % MOD;\n\t}\n}\n\n\n```\n\n## 코드설명\n 1) N=1인 값들은 값을 초기값으로 값을 넣어준다.\n 2) 점화식과 동일하게 상황에 따라 맞는 값을 재귀로 호출한다.\n\n# Bottom-up 방식\n\n## 구현 코드\n\n```java\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n \npublic class Main {\n\t\n\tfinal static long mod = 1000000000;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tint N = Integer.parseInt(br.readLine());\n\t\t\n\t\tlong[][] dp = new long[N + 1][10];\n\t\t\n\t\tfor(int i = 1; i < 10; i++) {\n\t\t\tdp[1][i] = 1; \n\t\t}\n\t\t\n\t\t// 두 번째 자릿수부터 N까지 탐색 \n\t\tfor(int i = 2; i <= N; i++) {\n\t\t\t\n\t\t\tfor(int j = 0; j < 10; j++) {\n\t\t\t\t\n\t\t\t\tif(j == 0) {\n\t\t\t\t\tdp[i][0] = dp[i - 1][1] % mod;\n\t\t\t\t}\n\t\t\t\telse if (j == 9) {\n\t\t\t\t\tdp[i][9] = dp[i - 1][8] % mod;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j + 1]) % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong result = 0;\n\t\t\n\t\tfor(int i = 0; i < 10; i++) {\n\t\t\tresult += dp[N][i];\n\t\t}\n\t\t\n\t\tSystem.out.println(result % mod);\n\t}\n \n}\n```\n\n## 코드설명\n - Top-down방식과 동일한데 재귀 부분을 for문으로 두번째 자리부터 N까지 탐색한다.\n\n\n# \n<hr>\n\n아직 DP문제를 많이 풀어보지 않아서 그런지 점화식 만들어 내는 과정이 어렵다... ㅜㅜㅜㅜㅜ  \n익숙해질 때까지 열심히 풀어야겠다 (승질 그만내고 ㅎㅎ)","excerpt":"백준 DP 단계별 문제에 있는 10844번 문제이다.  접근이 조금 어려웠던 문제라 풀이를 정리해보려고 한다.   접근 일단 이 문제는 DP문제로 2차원 배열을 DP로 사용해야 한다. 규칙을 찾기 위해 값을 적어보고, 개수를 세보면 아래와 같다. (…","fields":{"slug":"/backjoon10844/"},"frontmatter":{"date":"Dec 03, 2020","title":"백준 10844번 - 쉬운 계단수 풀이","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"알고리즘 문제를 풀면서 많이 하는 실수를 정리할 필요성을 느꼈다.  \n본 포스트는 주의해야 할 실수가 생길 때 마다 update할 예정이다.\n\n# 백트래킹\n > 재귀함수 빠져나오면 상태 값 원래대로 돌려줘야 함.\n\n# 최단거리\n > 값 넣어줄 때, 입력값 -1 해서 받아야 함 (배열 index로 사용하기 때문)","excerpt":"알고리즘 문제를 풀면서 많이 하는 실수를 정리할 필요성을 느꼈다. 본 포스트는 주의해야 할 실수가 생길 때 마다 update할 예정이다. 백트래킹 재귀함수 빠져나오면 상태 값 원래대로 돌려줘야 함. 최단거리 값 넣어줄 때, 입력값 -1 해서 받아야 …","fields":{"slug":"/algoMistake/"},"frontmatter":{"date":"Nov 25, 2020","title":"알고리즘 풀 때 많이하는 실수","tags":["Algorithm"],"update":"Jan 25, 2021"}}},{"node":{"rawMarkdownBody":"\n# Comparable\n > 클래스의 기본 정렬 기준을 설정하는 인터페이스\n\n\n## 1) 특징\n - Comparable 인터페이스 상속 후, compareTo 메소드 오버라이딩\n - compareTo메소드 리턴 값은 음수, 0, 양수가 될 수 있다. **음수가 리턴되면 인자의 순서가 아래로 이동**\n - 자바에서 제공되는 정렬이 가능한 클래스는 모두 Comparable 클래스로 구현되어 있음\n \n## 2) 구현 코드\n\n# Comparator\n > 기본 정렬과 다르게 정렬하고 싶을 때 이용하는 클래스\n## 1) 특징\n - 보통 구현 되어있는 sort함수의 2번째 인자로 Comparator 타입을 받아(익명함수) compare 메소드 오버라이딩을 통해 배열 정렬 순서 재정의\n - 보통 한번 사용하고 사용하지 않기 때문에 익명객체로 만듬\n\n## 2) 구현 코드\n\n# 관련 백준 문제\n - 11650, 11651, 1181, 10814","excerpt":"Comparable 클래스의 기본 정렬 기준을 설정하는 인터페이스 1) 특징 Comparable 인터페이스 상속 후, compareTo 메소드 오버라이딩 compareTo메소드 리턴 값은 음수, 0, 양수가 될 수 있다. 음수가 리턴되면 인자의 순서…","fields":{"slug":"/javaComparableComparator/"},"frontmatter":{"date":"Nov 24, 2020","title":"JAVA Comparable, Comparator 사용","tags":["JAVA"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n이전부터 자주 헷갈렸던 순열, 조합, 부분집합의 개념 정리와 JAVA를 사용해 구현하는 방법을 정리해 보려고 한다.  \n\n1) 대표적인 구현 방법  \n2) 각, 방법의 특징    \n\n두가지 사항으로 정리한다.  \n\n# 순열\n\n  - n개의 원소 중, r개를 일렬로 나열하는 수열  \n  - 중복 X / 순서 고려\n\n## 1. next_permutation\n\n### 1) 특징\n - 이게 이해하기 제일 어려웠다.... (나만 어렵나...ㅜㅜ)\n - 무작위 순열의 다음 순열을 구해내는 알고리즘\n - 시작 조건 : 오름차순 / 종료 조건 : 내림차순\n```\n  순서\n  1.Find largest index i such that array[i − 1] < array[i].\n  (If no such i exists, then this is already the last permutation.)\n\n  2.Find largest index j such that j ≥ i and array[j] > array[i − 1].\n\n  3.Swap array[j] and array[i − 1].\n\n  4.Reverse the suffix starting at array[i].\n```\n\n### 2) 구현 코드\n```java\npublic class num1 {\n    public static void main(String[] args) {\n    \tint[] list = new int[]{5,4,3};\n    \t// #1 시작 조건에 맞게 list 오름차순 정렬 (시작조건)\n    \tArrays.sort(list);\n    \tpermutation(list);\n    }\n    // #2 처음 list값 print 후, 다음 순열 찾음\n    public static void permutation(int[] list) {\n        int[] curArray = list;\n        while (true) {\n        \tprintArray(curArray);\n        \tcurArray = nextPermutation(curArray);\n            if (curArray == null) {\n                break;\n            }\n        }\n    }\n    \n    public static int[] nextPermutation(int[] list) {\n    \t  // #3 수열의 바로 앞 값 보다 큰 값 중 가장 큰 index 찾는다. \n        // (가장 적은 차이로 순서를 바꾸기 위해서 가장 큰 index를 찾음) \n        int i = list.length -1;\n        while(i>0 && list[i-1] >= list[i])\n        \ti--;\n        \n        // #6 list가 내림차순으로 정렬되어 있으면 순열을 끝까지 찾은 것 (종료조건)\n        if(i<=0)\n        \treturn null;\n        \n        int j = list.length -1;\n        // #4 다음 수열의 특징 : 이전 순열보다 값이 큼\n        // -> list[i-1] < list[j] 값을 찾고, 값을 바꿔준다.\n        while(list[j] <= list[i-1])\n        \tj--;\n        \n        int temp = list[i-1];\n        list[i - 1] = list[j];\n        list[j] = temp;\n        // #5 a[i] 이후 부분을 오름차순으로 셋팅 \n        j= list.length-1;\n        while (i < j) {\n            temp = list[i];\n            list[i] = list[j];\n            list[j] = temp;\n            i++;\n            j--;\n        }\n        \n        return list;\n    }\n    \n    public static void printArray(int[] array) {\n    \tfor(int i=0;i<array.length;i++)\n    \t\tSystem.out.print(array[i] + \" \");\n    \tSystem.out.println();\n    }\n    \n}\n\n```\n### 3) 코드 설명\n\n1. 시작 조건에 맞게 list 오름차순 정렬 (시작조건)\n2. 처음 list값 print 후, 다음 순열 찾음\n3. 수열의 바로 앞 값 보다 큰 값 중 가장 큰 index 찾는다.  \n  (가장 적은 차이로 순서를 바꾸기 위해서 가장 큰 index를 찾음)\n4. 다음 수열의 특징 : 이전 순열보다 값이 큼 -> list[i-1] < list[j] 값을 찾고, 값을 바꿔준다.\n5. a[i] 이후 부분을 오름차순으로 셋팅 \n6. list가 내림차순으로 정렬되어 있으면 순열을 끝까지 찾은 것 (종료조건)\n\n### 4) 코드 출력값\n```\n3 4 5 \n3 5 4 \n4 3 5 \n4 5 3 \n5 3 4 \n5 4 3 \n\n```\n\n## 2. Swap\n\n### 1) 특징\n - 순열의 순서가 보장되지 않는다. (사전식 X)\n\n\n### 2) 구현 코드\n```java\npublic class Main {\n  public static void main(String[] args) {\n  \tint[] arr = {1,2,3};\n  \tpermutation(arr,0,3,3);\n  \tSystem.out.println(Arrays.toString(arr));\n  }\n\n  static void permutation(int[] arr, int depth, int n, int r) {\n  \tif (depth == r) {\n  \t\tarrPrint(arr,r);\n  \t\treturn;\n  \t}\n  \tfor (int i=depth; i<n; i++) {\n      // #1\n  \t\tswap(arr, depth, i);\n      // #2\n  \t\tpermutation(arr, depth + 1, n, r);\n      // #3\n     \tswap(arr, depth, i);\n  \t}\n  }\n\n  static void arrPrint(int[] arr, int r) {\n    for (int i=0 ; i<r; i++)\n    \tSystem.out.print(arr[i] + \" \");\n    System.out.println();\n  }\n\n  static void swap(int[] arr, int depth, int i) {\n    int temp = arr[depth];\n    arr[depth] = arr[i];\n    arr[i] = temp;\n  }\n}\n```\n### 3) 코드 설명\n\n1. 배열의 첫번째 값부터 하나씩 바꾸면서 swap\n2. depth를 기준(Inex)으로 depth보다 작은 인데스 값들은 고정, depth보다 큰 값들을 가지고 swap\n3. 재귀함수가 종료조건에 의해 return되면 swap을 한번 더 해줘서 이전 상태 유지\n\n\n### 4) 코드 출력값\n```\n1 2 3 \n1 3 2 \n2 1 3 \n2 3 1 \n3 2 1 \n3 1 2 \n[1, 2, 3]\n```\n\n## 3. Visit Index 사용\n\n### 1) 특징\n - DFS, 재귀 함수\n\n\n### 2) 구현 코드\n\n```java\npublic class Main {\n\tpublic static void main(String[] args) {\n\t    int n = 3;\n\t    int[] arr = {1, 2, 3};\n      // #1\n\t    int[] output = new int[n];\n\t    boolean[] visited = new boolean[n];\n\t    perm(arr, output, visited, 0, n, 2);\n\t    System.out.println();\n\t}\n\n\tstatic void perm(int[] arr, int[] output, boolean[] visited, int depth, int n, int r) {\n\t    if (depth == r) {\n\t        print(output, r);\n\t        return;\n\t    }\n\n\t    for (int i = 0; i < n; i++) {\n\t        if (visited[i] != true) {\n\t            visited[i] = true;\n              output[depth] = arr[i];\n              // #2\n\t            perm(arr, output, visited, depth + 1, n, r);\n              // #3\n\t            visited[i] = false;\n\t        }\n\t    }\n\t}\n\n\tstatic void print(int[] arr, int r) {\n\t    for (int i = 0; i < r; i++)\n\t        System.out.print(arr[i] + \" \");\n\t    System.out.println();\n\t}\n\t\n}\n\n```\n### 3) 코드 설명\n1. output : 코드 출력 값 / visited : 방문 여부 체크\n2. depth -> output 길이라고 생각\n3. 방문 여부 false로 체크 -> 모든 인덱스 방문\n   \n\n### 4) 코드 출력값 \n```\n1 2 \n1 3 \n2 1 \n2 3 \n3 1 \n3 2 \n```\n\n## 관련 백준 문제\n> n과m 시리즈 0 ~ 12\n\n# Reference\n[BaaaaaaaarkingDog님 블로그](https://blog.encrypted.gg/945?category=773649)  \n[뱀귤님 블로그](https://bcp0109.tistory.com/entry/%EC%88%9C%EC%97%B4-Permutation-Java?category=848939)  \n[junhok82님 블로그](https://velog.io/@junhok82/>Java%EB%A1%9C-%EC%88%9C%EC%97%B4Permutation-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0>)  \n[Crocus님 블로그](https://www.crocus.co.kr/1240)","excerpt":"이전부터 자주 헷갈렸던 순열, 조합, 부분집합의 개념 정리와 JAVA를 사용해 구현하는 방법을 정리해 보려고 한다.   대표적인 구현 방법   각, 방법의 특징     두가지 사항으로 정리한다.   순열 n개의 원소 중, r개를 일렬로 나열하는 수열…","fields":{"slug":"/permutation/"},"frontmatter":{"date":"Nov 23, 2020","title":"순열 정리, 구현","tags":["Algorithm"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}},"staticQueryHashes":["2027115977","694178885"]}