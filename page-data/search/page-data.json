{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\r\n","excerpt":"","fields":{"slug":"/javaLiveCoding_2/"},"frontmatter":{"date":"Jan 25, 2021","title":"Java Live Coding - 제목(DAY2)","tags":["Java"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n백준 11779, 11780, 1738번 문제를 통해 최단경로의 경로출력 정리해보려고 한다.\r\n\r\n# 다익스트라 - 백준 11779\r\n\r\n![11779문제 사진1](11779pb1.PNG)\r\n![11779문제 사진2](11779pb2.PNG)\r\n\r\n```java\r\npackage pakcage26;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\nimport java.util.PriorityQueue;\r\nimport java.util.Stack;\r\n\r\npublic class num11779 {\r\n\tstatic int N, M, count=2,INF = Integer.MAX_VALUE;\r\n\tstatic ArrayList<ArrayList<Edge>> Vertex;\r\n\tstatic int[] dist, pre;\r\n\tstatic boolean[] visited;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\r\n\t\tN = stoi(br.readLine());\r\n\t\tM = stoi(br.readLine());\r\n\t\tVertex = new ArrayList<ArrayList<Edge>>();\r\n\t\tdist = new int[N];\r\n\t\tpre = new int[N];\r\n\t\tvisited = new boolean[N];\r\n\t\t\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tVertex.add(new ArrayList<Edge>());\r\n\t\t\tdist[i] = INF;\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<M; i++) {\r\n\t\t\tString[] uvw = br.readLine().split(\" \");\r\n\t\t\tint u = stoi(uvw[0])-1;\r\n\t\t\tint v = stoi(uvw[1])-1;\r\n\t\t\tint w = stoi(uvw[2]);\r\n\t\t\tVertex.get(u).add(new Edge(v,w));\r\n\t\t}\r\n\t\tString[] point = br.readLine().split(\" \");\r\n\t\tint start = stoi(point[0])-1;\r\n\t\tint end = stoi(point[1])-1;\r\n\t\tdijkstra(start, end);\r\n\t\t\r\n\t\tlong answer =dist[end];\r\n\r\n\t\tStack<Integer> st = new Stack<Integer>();\r\n\t\tst.add(end);\r\n\t\t\r\n\t\twhile (pre[end] != start) {\r\n\t\t\tst.add(pre[end]);\r\n\t\t\tend = pre[end];\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\t\r\n\t\tst.add(start);\r\n\t\t\r\n\t\tSystem.out.println(answer);\r\n\t\tSystem.out.println(count);\r\n\t\twhile (!st.isEmpty()) {\r\n\t\t\tSystem.out.print(st.pop()+1 + \" \");\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic static void dijkstra(int start, int end) {\r\n\t\tdist[start] = 0;\r\n\t\tPriorityQueue<Edge> q = new PriorityQueue<Edge>();\r\n\t\tq.add(new Edge(start, 0));\r\n\t\t\r\n\t\twhile(!q.isEmpty()) {\r\n\t\t\tEdge now = q.remove();\r\n\t\t\tif(!visited[now.e]) {\r\n\t\t\t\tvisited[now.e] = true;\r\n\t\t\t\tfor(Edge next : Vertex.get(now.e)) {\r\n\t\t\t\t\tif(!visited[next.e] && dist[next.e] >= dist[now.e] + next.w) {\r\n\t\t\t\t\t\tdist[next.e] = dist[now.e] + next.w;\r\n\t\t\t\t\t\tq.add(new Edge(next.e, dist[next.e]));\r\n\t\t\t\t\t\tpre[next.e] = now.e;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\t\r\n\tstatic class Edge implements Comparable<Edge>{\r\n\t\tint e, w;\r\n\t\tEdge(int e, int w){\r\n\t\t\tthis.e = e;\r\n\t\t\tthis.w = w;\r\n\t\t}\r\n\t\t@Override\r\n\t\tpublic int compareTo(Edge o){\r\n\t\t\treturn w - o.w;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n소스를 간략히 설명하면\r\n\r\n다익스트라 알고리즘에 값이 조건에 맞아 갱신될 때 배열의 값에 이전 노드를 저장한다.\r\n\r\n첫 노드부터 순서대로 출력하기 위해 stack을 사용했다.\r\n\r\n# 플로이드 - 백준 11780\r\n\r\n# 벨만포드 - 백준 1738","excerpt":"백준 11779, 11780, 1738번 문제를 통해 최단경로의 경로출력 정리해보려고 한다. 다익스트라 - 백준 11779 \n 소스를 간략히 설명하면 다익스트라 알고리즘에 값이 조건에 맞아 갱신될 때 배열의 값에 이전 노드를 저장한다. 첫 노드부터 …","fields":{"slug":"/shortestDistance_2/"},"frontmatter":{"date":"Jan 25, 2021","title":"최단거리 경로복원","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"","excerpt":"","fields":{"slug":"/twoPoint/"},"frontmatter":{"date":"Jan 25, 2021","title":"투포인터 알고리즘","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n\r\n![문제사진](kmpProblem1.PNG)\r\n![문제사진2](kmpProblem2.PNG)","excerpt":"","fields":{"slug":"/kmpAlgorithm/"},"frontmatter":{"date":"Jan 25, 2021","title":"KMP 알고리즘","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n정리 안해두면 까먹을거 같아서 기억력을 조금이라도 향상시키기 위해 정리해둔다.\r\n\r\n자, 최단거리 알고리즘을 이해하기 위해 그래프를 간략히 살펴보면\r\n\r\n# 그래프란? \r\n그래프는 **정점(Vertex)** 와 **간선(Edge)** 을 모아놓은 자료구조다.\r\n\r\n그래프라는 친구는 보통 간선에 가중치를 가진다.\r\n\r\n## 구현 방법\r\n1. 인접 행렬\r\n2. 인접 리스트\r\n\r\n# 다익스트라 알고리즘\r\n\r\n최단 거리 알고리즘은 기본적으로 **그리디 알고리즘** 으로 분류된다.  \r\n -> **매번 가장 비용이 적은 노드** 를 선택하는 과정을 반복하기 때문이다.\r\n\r\n## 전제조건\r\n\r\n1. 시작 노드 - 시작 노드 사이 거리는 0이다.\r\n2. 모든 간선은 양의 가중치를 가진다.\r\n\r\n## 특징\r\n\r\n1. 구현 방법은 2가지\r\n\r\n## 1. 직관적인 방법 - O(V^2)\r\n1. 각 노드에 대한 최단 거리를 담는 1차원 리스트 선언\r\n2. 방문하지 않은 노드 중에서 거리가 가장 짧은 노드 선택  \r\n(거리가 같으면 일반적으로 번호가 작은 노드)\r\n3. 거리가 더 짧으면 값 갱신\r\n\r\n### 최단거리 - 백준 1753\r\n![1753문제](1753pb.PNG)\r\n![1753문제](1753pb2.PNG)\r\n\r\n```java\r\npackage package24;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\npublic class num1753 {\r\n\tstatic int INF = Integer.MAX_VALUE;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tString[] inputVE = br.readLine().split(\" \");\r\n\t\tint V = stoi(inputVE[0]);\r\n\t\tint E = stoi(inputVE[1]);\r\n\t\tint K = stoi(br.readLine())-1;\r\n\t\t\r\n\t\tList<Edge>[] graph = new ArrayList[V];\r\n        for (int i = 0; i < V; i++) \r\n        \tgraph[i] = new ArrayList<>();\r\n\t\tint[] distance = new int[V];\r\n\t\tboolean[] visited = new boolean[V];\r\n\t\t\r\n\t\tfor(int i=0; i<V; i++) {\r\n\t\t\tdistance[i] = INF; \r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<E; i++) {\r\n\t\t\tString[] uvw = br.readLine().split(\" \");\r\n\t\t\tint u = stoi(uvw[0])-1;\r\n\t\t\tint v = stoi(uvw[1])-1;\r\n\t\t\tint w = stoi(uvw[2]);\r\n\t\t\tgraph[u].add(new Edge(v,w));\r\n\t\t}\r\n\t\tdijkstra(graph, visited, distance, V, E, K);\r\n\t\t\r\n\t\tfor(int value : distance) {\r\n\t\t\tif(INF == value)\r\n\t\t\t\tSystem.out.println(\"INF\");\r\n\t\t\telse\r\n\t\t\t\tSystem.out.println(value);\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static void dijkstra(List<Edge>[] graph, boolean[] visited, int[] distance, int V, int E, int K) {\r\n\t\tdistance[K] = 0;\r\n\t\tfor(int i=0; i<V; i++) {\r\n\t\t\tint minIndex = getSmallestNodeNotVisited(visited, distance, V);\r\n            for (Edge next : graph[minIndex]) {\r\n                if(!visited[next.v] && distance[next.v] > distance[minIndex] + next.weight) {\r\n                \tdistance[next.v] = distance[minIndex] + next.weight;\r\n                }\r\n            }\r\n\r\n\t\t\tvisited[minIndex] = true;\r\n\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic static int getSmallestNodeNotVisited(boolean[] visited, int[] distance, int V) {\r\n\t\tint min = INF;\r\n\t\tint minIndex = 0;\r\n\t\tfor(int i=0; i<V; i++) {\r\n\t\t\tif(visited[i] == false && distance[i]<min) {\r\n\t\t\t\tmin = distance[i];\r\n\t\t\t\tminIndex = i;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn minIndex;\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n}\r\n\r\nclass Edge {\r\n    int v, weight;\r\n\r\n    public Edge(int v, int weight) {\r\n        this.v = v;\r\n        this.weight = weight;\r\n    }\r\n    \r\n}\r\n\r\n```\r\n\r\n소스를 간략히 설명하면  \r\n노드 arrayList를 만들고 Edge는 클래스로 만들어서 넣어주는 방법으로 구현했다.  \r\n(배열로만 구현하면 메모리 초과난다.)\r\n\r\n매번 최단거리가 가장 짧은 노드를 찾기 위해 O(V) 만큼 탐색하기 때문에 비효율적이다.  \r\n -> Priority Queue 활용\r\n\r\n## 2. Priority Queue 활용 - O(ElogV)\r\n\r\n최단 거리 -> **최소 힙**을 사용한다.\r\n\r\n```\r\n1. 각 노드에 대한 최단 거리를 담는 1차원 리스트 선언\r\n2. 우선순위 큐을 사용해 거리가 짧은 정점부터 Queue에 넣어 줌.(처음 시작 값 : 0)  \r\n3. 큐가 값이 없을 때까지 반복  \r\n    3-1) 큐에서 값을 하나 꺼냄 (Vertex 선택)  \r\n\t3-2) visited 값 true 설정  \r\n4. 다음 Vertex의 최단거리가 현재Vertex 최단 거리 + 다음 Vertex 가중치보다 크면   \r\n\t(다음 Vertex가 사용되지 않았을 때)  \r\n\t4-1) 값 갱신  \r\n\t4-2) 우선순위 큐에 값 추가  \r\n```\r\n\r\n요약하면\r\n```\r\n1. 아직 방문하지 않은 정점 중 거리가 짧은 정점을 하나 선택해 방문\r\n2. 해당 정점에 인접하고 아직 방문하지 않은 정점의 최단거리 갱신\r\n```\r\n\r\nTip!!  \r\n**JAVA PriorityQueue 는 기본적으로 minHeap이다.**\r\n\r\n```java\r\n// 최소 힙\r\nPriorityQueue<Integer> minHeap = new PriorityQueue<Integer>();\r\n\r\n// 최대 힙\r\nPriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(Comparator.reverseOrder());\r\n\r\n// 최대 힙 version2\r\nPriorityQueue<Integer> maxHeap = PriorityQueue<>(new Comparator<Integer>(){\r\n\t@Override\r\n\tpublic int compare(Integer i1, Integer i2) {\r\n\t\treturn i2-i1;\r\n\t}\r\n});\r\n```\r\n\r\n### 최단거리 - 백준 1504\r\n\r\n![1504문제](1504pb1.PNG)\r\n![1504문제2](1504pb2.PNG)\r\n\r\n문제를 보면 정점 2개를 방문해야 한다는 조건이 있다. 정점을 각각 V1, V2라고 한다면 \r\n 1. 1 -> V1 -> V2 -> N\r\n 2. 1 -> V2 -> V1 -> N\r\n\r\n두가지 경우에 대해 구간별로 최소값을 구한 후, 더하면 된다.\r\n\r\n```java\r\npackage package24;\r\n\r\nimport java.io.*;\r\nimport java.util.*;\r\n\r\npublic class num1504 {\r\n\tstatic int N,E,v1,v2,result;\r\n\tstatic ArrayList<ArrayList<Edge>> Vertex;\r\n\tstatic int[] distance;\r\n\tstatic boolean[] visited;\r\n\tstatic int INF = 200000000;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tString[] NE = br.readLine().split(\" \");\r\n\t\tN = stoi(NE[0]);\r\n\t\tE = stoi(NE[1]);\r\n\t\tdistance = new int[N+1];\r\n\t\tvisited = new boolean[N+1];\r\n\t\tVertex = new ArrayList<>();\r\n\t\t\r\n\t\tfor(int i=0; i<=N; i++) {\r\n\t\t\tVertex.add(new ArrayList<>());\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<E; i++) {\r\n\t\t\tString[] abc = br.readLine().split(\" \");\r\n\t\t\tint a = stoi(abc[0]);\r\n\t\t\tint b = stoi(abc[1]);\r\n\t\t\tint c = stoi(abc[2]);\r\n\t\t\t\r\n\t\t\tVertex.get(a).add(new Edge(b,c));\r\n\t\t\tVertex.get(b).add(new Edge(a,c));\r\n\t\t}\r\n\t\tString[] v1v2 = br.readLine().split(\" \");\r\n\t\tv1 = stoi(v1v2[0]);\r\n\t\tv2 = stoi(v1v2[1]);\r\n\t\t\r\n\t\tresult = solve();\r\n\t\tSystem.out.println(result);\r\n\t}\r\n\r\n\tpublic static int solve() {\r\n\t\tint case1=0, case2=0;\r\n\t\t\r\n\t\tcase1 = dijkstra(1,v1) + dijkstra(v1,v2) + dijkstra(v2,N);\r\n\t\tcase2 = dijkstra(1,v2) + dijkstra(v2,v1) + dijkstra(v1,N);\r\n\r\n\t\treturn (case1 >= INF && case2 >= INF) ? -1 : Math.min(case1, case2);\r\n\t}\r\n\t\r\n\tpublic static int dijkstra(int start, int end) {\r\n\t\tArrays.fill(distance, INF);\r\n\t\tArrays.fill(visited, false);\r\n\t\t\r\n\t\tPriorityQueue<Edge> queue = new PriorityQueue<Edge>();\r\n\t\tqueue.add(new Edge(start,0));\r\n\t\tdistance[start] = 0;\r\n\t\t\r\n\t\twhile(!queue.isEmpty()) {\r\n\t\t\tEdge now = queue.remove();\r\n\t\t\tint nowNode = now.e;\r\n\t\t\tif(!visited[nowNode]) {\r\n\t\t\t\tvisited[nowNode] = true;\r\n\t\t\t\t\r\n\t\t\t\tfor(Edge next : Vertex.get(nowNode)) {\r\n\t\t\t\t\tif(!visited[next.e] && distance[next.e] > distance[nowNode] + next.weight) {\r\n\t\t\t\t\t\tdistance[next.e] = distance[nowNode] + next.weight;\r\n\t\t\t\t\t\tqueue.add(new Edge(next.e, distance[next.e]));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn distance[end];\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\t\r\n\tstatic class Edge implements Comparable<Edge>{\r\n\t\tint e, weight;\r\n\t\tEdge(int e, int weight){\r\n\t\t\tthis.e = e;\r\n\t\t\tthis.weight = weight;\r\n\t\t}\r\n\t\t\r\n\t\t@Override\r\n\t\tpublic int compareTo(Edge o){\r\n\t\t\treturn weight - o.weight;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n\r\n\r\n# 벨만-포드 알고리즘\r\n\r\n## 특징\r\n\r\n1. 시간 복잡도 - O(VE)\r\n2. 다익스트라 알고리즘보다 느리지만 음의 가중치를 가진 경로의 최단거리를 구할 수 있다.\r\n\r\n## 전제 조건\r\n\r\n1. **같은 정점을 2번 지날일은 없기 때문에** 간선의 최대 개수는 **V-1**이다.\r\n2. 음수 사이클이 없는 최단 경로를 구해야 한다.\r\n\r\n\r\n## 백준 11657\r\n![11607문제1](11657pb1.PNG)\r\n![11607문제2](11657pb2.PNG)\r\n![11607문제3](11657pb3.PNG)\r\n\r\n```java\r\npackage package24;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\n\r\npublic class num11657 {\r\n\tstatic int N, M;\r\n\tstatic ArrayList<ArrayList<Edge>> Vertex;\r\n\tstatic long[] dist;\r\n\tstatic int INF = Integer.MAX_VALUE;\r\n\tstatic boolean minusCycle=false;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\r\n\t\tString[] inputNM = br.readLine().split(\" \");\r\n\t\tN = stoi(inputNM[0]);\r\n\t\tM = stoi(inputNM[1]);\r\n\t\t\r\n\t\tdist = new long[N];\r\n\t\tVertex = new ArrayList<ArrayList<Edge>>();\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tVertex.add(new ArrayList<Edge>());\r\n\t\t\tdist[i] = INF;\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<M; i++) {\r\n\t\t\tString[] ABC = br.readLine().split(\" \");\r\n\t\t\tint A = stoi(ABC[0])-1;\r\n\t\t\tint B = stoi(ABC[1])-1;\r\n\t\t\tint C = stoi(ABC[2]);\r\n\t\t\t\r\n\t\t\tVertex.get(A).add(new Edge(B,C));\r\n\t\t}\r\n\t\tbellman();\r\n\t\t\r\n\t\tif(minusCycle)\r\n\t\t\tsb.append(\"-1\\n\");\r\n\t\telse {\r\n\t\t\tfor(int i=1; i<N; i++) {\r\n\t\t\t\tsb.append(dist[i] != INF ? dist[i] : -1);\r\n\t\t\t\tsb.append(\"\\n\");\r\n\t\t\t}\r\n\t\t}\r\n\t\tSystem.out.println(sb.toString());\r\n\t\t\r\n\t}\r\n\tpublic static void bellman() {\r\n\t\tdist[0] = 0;\r\n\t\t\r\n\t    for(int i=0; i<N; i++){ \r\n\t        for(int j=0; j<N; j++){\r\n\t            for(Edge edge: Vertex.get(j)){\r\n\t                int next = edge.e, w = edge.w;\r\n\t                if(dist[j] != INF && dist[next] > dist[j] + w){\r\n\t                    dist[next] = dist[j] + w;\r\n\t                    if(i == N-1) minusCycle = true;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t}\r\n\t\r\n\tstatic class Edge {\r\n\t\tint e, w;\r\n\t\tEdge(int e, int w) {\r\n\t\t\tthis.e = e;\r\n\t\t\tthis.w = w;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n}\r\n```\r\n코드를 간단히 설명해보면\r\n\r\n존재하는 모든 간선을 돌아보면서 이 간선을 통할 수도 있는 최단경로들의 거리를 갱신한다.\r\n같은 정점을 2번 방문하는 경우는 없다는 전제가 있으므로 V-1까지 확인한다\r\n만약, 음의 사이클이 존재한다면 -> V-1 이후 최단거리가 갱신된다. \r\n위의 소스에선 V까지 루프의 마지막에 최단거리가 갱신되는지 확인한다.\r\n\r\n\r\n이 문제는 조금 주의할 점이 있다. \r\n\r\n최소 가중치가 -10000이라 언더플로우가 생길 수 있기 때문에 **dist를 long[]으로 설정해야 한다.**  \r\n\r\n# 플로이드 알고리즘 \r\n\r\n## 특징\r\n\r\n1. 다익스트라, 벨만 포드 알고리즘 : 하나의 시작점에 대한 최단 거리\r\n2. 플로이드 워셜 알고리즘 : **모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야 하는 경우**  \r\n3. 시간 복잡도 : O(V^3)  \r\n\t-> 노드의 개수 O(V) * **현재 노드를 거쳐가는 모든 경로O(V^2)** -> **O(V^3)**\r\n4. **DP형태** -> 점화식에 맞게 2차원 리스트를 갱신하기 때문\r\n\r\nTip!! \r\n상황에 따라 자기 자신으로 이동 가능하면 dis[i][j] = 0 / 불가능하면 dis[i][j] = INF\r\n\r\n- 가장 바깥쪽 for문은 경유할 정점\r\n- 가운데 for문은 출발 정점\r\n- 가장 안쪽 for문은 도착 정점\r\n\r\n\r\n## 백준 11404\r\n\r\n```java\r\npackage package24;\r\n\r\nimport java.io.*;\r\n\r\npublic class num11404 {\r\n\tstatic int N, M, INF = 100000000;\r\n\tstatic int[][] dis;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\r\n\t\tN = stoi(br.readLine());\r\n\t\tM = stoi(br.readLine());\r\n\t\t\r\n\t\tdis = new int[N][N];\r\n\t\t\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tfor(int j=0; j<N; j++) {\r\n\t\t\t\tdis[i][j] = i == j ? 0 : INF;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<M; i++) {\r\n\t\t\tString[] abc = br.readLine().split(\" \");\r\n\t\t\tint a = stoi(abc[0])-1;\r\n\t\t\tint b = stoi(abc[1])-1;\r\n\t\t\tint c = stoi(abc[2]);\r\n\t\t\t\r\n\t\t\tdis[a][b] = Math.min(dis[a][b], c);\r\n\t\t}\r\n\t\t\r\n\t\tfor(int k=0; k<N; k++) {\r\n\t\t\tfor(int i=0; i<N; i++) {\r\n\t\t\t\tfor(int j=0; j<N; j++) {\r\n\t\t\t\t\tdis[i][j] = Math.min(dis[i][j], dis[i][k] +dis[k][j]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n        for (int i = 0; i < N; i++) {\r\n            for (int j = 0; j < N; j++) {\r\n            \tdis[i][j] = dis[i][j] == INF ? 0 : dis[i][j];\r\n                sb.append(dis[i][j] + \" \");\r\n            }\r\n            sb.append(\"\\n\");\r\n        }\r\n \r\n        bw.write(sb.toString());\r\n        bw.flush();\r\n        bw.close();\r\n        br.close();\r\n\t}\r\n\tpublic static int stoi(String string) {\r\n\t\treturn Integer.parseInt(string);\r\n\t}\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n# 정리\r\n\r\n이렇게 최단거리 알고리즘 3가지를 알아보았다.  \r\n\r\n사용하는 경우를 정리해보면  \r\n```\r\n1. 다익스트라 알고리즘[우선순위 큐] -> 한 지점에서 다른 지점까지 최단거리 구하는 문제  \r\n2. 벨만 포드 알고리즘 -> 음의 가중치를 가진 최단거리 구하는 문제  \r\n3. 플로이드 와샬 알고리즘 -> 모든 경로의 최단거리 구하는 문제\r\n``` \r\n로 정리할 수 있다.\r\n\r\n\r\n생각보다 어려워서 정리하는데 시간이 오래걸렸다.  \r\n다음 글은 최단경로의 경로출력에 대해 정리해 볼 예정이다.\r\n\r\n추가로 [라이님 블로그](https://blog.naver.com/kks227/220796029558) 요기 있는 추가문제 하나씩 풀어봐야겠다.\r\n\r\n\r\n# Reference\r\n[라이님 블로그](https://blog.naver.com/kks227/220796029558)  \r\n[갓킹독님 블로그](https://blog.encrypted.gg/917?category=773649)  \r\n[Crocus님 블로그](https://www.crocus.co.kr/546?category=209527)  \r\n[백준 질문하기 - 출력초과 문제 해결이 되었는데 이유를 모르겠습니다](https://www.acmicpc.net/board/view/55270)  \r\n이것이 코딩테스트다 - 나동빈\r\n\r\n\r\n","excerpt":"정리 안해두면 까먹을거 같아서 기억력을 조금이라도 향상시키기 위해 정리해둔다. 자, 최단거리 알고리즘을 이해하기 위해 그래프를 간략히 살펴보면 그래프란? 그래프는 정점(Vertex) 와 간선(Edge) 을 모아놓은 자료구조다. 그래프라는 친구는 보통…","fields":{"slug":"/shortestDistance_1/"},"frontmatter":{"date":"Jan 23, 2021","title":"최단거리 알고리즘","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n# 목표\r\n\r\n자바 소스 파일(.java)을 JVM으로 실행하는 과정 이해하기\r\n\r\n# 학습할 것\r\n\r\n- [ ] JVM이란 무엇인가\r\n- [ ] 컴파일 하는 방법\r\n- [ ] 실행하는 방법\r\n- [ ] 바이트코드란 무엇인가\r\n- [ ] JIT 컴파일러란 무엇이며 어떻게 동작하는지\r\n- [ ] JVM 구성 요소\r\n- [ ] JDK와 JRE의 차이\r\n- [ ] Javac 옵션 조사\r\n\r\n# 정리\r\n\r\n## JVM이란 무엇인가\r\n\r\n### 자바 가상 머신(JVM, Java Virtual Machine)\r\n\r\n\r\n\r\n\r\n## 컴파일 하는 방법\r\n\r\n\r\n\r\n## 실행하는 방법\r\n\r\n\r\n\r\n## 바이트코드란 무엇인가\r\n\r\n\r\n\r\n## JIT 컴파일러란 무엇이며 어떻게 동작하는지\r\n\r\n\r\n\r\n## JVM 구성 요소\r\n\r\n\r\n\r\n## JDK와 JRE의 차이\r\n\r\n\r\n","excerpt":"목표 자바 소스 파일(.java)을 JVM으로 실행하는 과정 이해하기 학습할 것 JVM이란 무엇인가 컴파일 하는 방법 실행하는 방법 바이트코드란 무엇인가 JIT 컴파일러란 무엇이며 어떻게 동작하는지 JVM 구성 요소 JDK와 JRE의 차이 Javac…","fields":{"slug":"/javaLiveCoding_1/"},"frontmatter":{"date":"Jan 22, 2021","title":"Java Live Coding - JVM 이해하기(DAY1)","tags":["Java"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n백준 이분 탐색 문제를 풀다 Parametric Search에 대해 알게 되었고, 정리 할 필요성을 느껴서 포스팅한다.\r\n\r\n일단 **이분탐색**은 탐색 기법으로 **원하는 탐색 범위를 두 부분으로 분할**해서 찾는 방식이다  \r\n -> O(logN)의 시간 복잡도를 가지고 있다.\r\n\r\n**파라매트릭 서치**는 **최적화 문제(문제 상황을 만족하는 특정한 값 - ex) 최소값, 최대값)을 결정문제로 바꾸어 푸는 것**을 말한다.  \r\n\r\n백준 2110번 문제가 쉽게 이해하기 좋은 문제인 것 같다.\r\n\r\n![문제사진](pro1.PNG)\r\n![문제사진2](pro2.PNG)\r\n\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.Arrays;\r\n\r\npublic class Main {\r\n\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tString[] inputNK = br.readLine().split(\" \");\r\n\t\tint N = Integer.parseInt(inputNK[0]);\r\n\t\tlong K = Long.parseLong(inputNK[1]);\r\n\t\tlong max = 0;\r\n\t\t\r\n\t\tlong[] houseArr = new long[N];\r\n\t\t\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\thouseArr[i] = Long.parseLong(br.readLine());\r\n\t\t\tmax = max > houseArr[i] ? max : houseArr[i];\r\n\t\t}\r\n\t\tArrays.sort(houseArr);\r\n\t\t\r\n\t\tmax = Psearch(houseArr, K, max);\r\n\t\tSystem.out.println(max);\r\n\t}\r\n\t\r\n\tpublic static long Psearch(long[] houseArr, long K, long max) {\r\n\t\tlong start = 1;\r\n\t\tlong end = max;\r\n\t\tlong ans = 0;\r\n\t\t\r\n\t\twhile(start<=end) {\r\n\t\t\tlong mid = (start+end)/2;\r\n\t\t\t\r\n\t\t\tif(checkHouse(houseArr, mid, K)) {\r\n\t\t\t\tstart = mid+1;\r\n\t\t\t\tans = ans > mid ? ans : mid;\r\n\t\t\t}else {\r\n\t\t\t\tend = mid-1;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn ans;\r\n\t}\r\n\t\r\n\tpublic static boolean checkHouse(long[] houseArr, long mid, long K) {\r\n\t\tlong temp = houseArr[0];\r\n\t\tlong index = 0;\r\n\t\tfor(int i = 1; i<houseArr.length; i++) {\r\n\t\t\tif(houseArr[i]-temp >= mid) {\r\n\t\t\t\tindex++;\r\n\t\t\t\ttemp=houseArr[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif(index >=K-1)\r\n\t\t\treturn true;\r\n\t\telse\r\n\t\t\treturn false;\r\n\t}\r\n\r\n}\r\n\r\n```\r\n\r\n이 문제의 포인트는  \r\n1. 공유기 사이 거리를 정한 후, 정한 거리 이상의 간격으로 집에 설치 가능한지 확인\r\n    - 설치 가능 -> 더 큰 거리값 확인\r\n    - 설치 불가능 -> 작은 거리값을 확인  \r\n\r\n\r\n추가로 백준 12015번 문제를 풀어보는 것을 추천한다.\r\ndp를 활용해 가장 긴 증가하는 부분 수열 구할 수 있는데 이분탐색을 사용하면 O(logN)으로 구할 수 있다.\r\n\r\n\r\n \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","excerpt":"백준 이분 탐색 문제를 풀다 Parametric Search에 대해 알게 되었고, 정리 할 필요성을 느껴서 포스팅한다. 일단 이분탐색은 탐색 기법으로 원하는 탐색 범위를 두 부분으로 분할해서 찾는 방식이다  -> O(logN)의 시간 복잡도를 가지고…","fields":{"slug":"/ParametricSearch/"},"frontmatter":{"date":"Jan 17, 2021","title":"이분탐색, 파라매트릭 서치(Parametric Search)","tags":["Algorithm","Parametric Search"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n백준 단계별 문제 - 우선순위 큐 마지막 문제다.  \r\n\r\n풀다가 조금 헷갈린 부분이 있어 정리하고자 포스팅한다.  \r\n\r\n# 문제\r\n![문제사진](problem1.PNG)\r\n![문제사진2](problem2.PNG)\r\n\r\n일단 문제에 처음 접근할 땐, 우선순위 큐를 사용해 저장하고 중간 값을 계속 뽑아와 StringBuilder에 넣어주는 방식으로 구현했다.  \r\n\r\n```java\r\npackage package21;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.PriorityQueue;\r\nimport java.util.Stack;\r\n\r\npublic class num1655 {\r\n\r\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tPriorityQueue<Integer> q = new PriorityQueue<>();\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\r\n\t\tint T = Integer.parseInt(br.readLine());\r\n\t\t\r\n\t\tfor(int i=0; i<T; i++) {\r\n\t\t\tint value = Integer.parseInt(br.readLine());\r\n\t\t\tq.offer(value);\r\n\t\t\tint len = q.size()/2 + q.size()%2;\r\n\t\t\tStack<Integer> s = new Stack<>();\r\n\t\t\tfor(int j=0;j<len;j++) {\r\n\t\t\t\ts.push(q.remove());\r\n\t\t\t}\r\n\t\t\tif(!s.isEmpty())\r\n\t\t\t\tsb.append(s.peek()+\"\\n\");\r\n\t\t\twhile(!s.isEmpty()) {\r\n\t\t\t\tq.offer(s.pop());\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\tSystem.out.println(sb);\r\n\t}\r\n\r\n}\r\n```\r\n![시간초과](no.PNG)\r\n\r\n역시 시간초과.....\r\n\r\n## 풀이 1\r\nstack대신 우선순위큐를 하나 더 써서 구현해보려고 생각하였고, 이 부분에서 삽질을 조금 하였다.  \r\n\r\n포인트는 4가지다.\r\n1. Max Heap(최대 값이 가장 앞에 위치)과 Min Heap(최소 값이 가장 앞에 위치) 사용   \r\n2. 중간 값을 저장(초기 값 = 맨 처음에 입력받은 값)  \r\n   중간 값 보다 작은 값은 Max Heap / 큰 값은 Min Heap\r\n3. 큰값을 저장하는 min heap이 길이가 2이상 길면 중앙 값 바꿈  \r\n    -> 작은 값을 저장하는 max heap에 중간 값 저장  \r\n    -> 큰 값을 저장하는 min heap에서 가장 작은 값을 중간값으로 바꿈  \r\n4. 작은 값을 저장하는 max heap이 길이가 1이상 길면 중앙 값 바꿈  \r\n   (길이가 짝수이면 작은수가 중간 값이니 길이= 1 )  \r\n   -> 큰 값을 저장하는 min heap에 중간 값 저장  \r\n   -> 작은 값을 저장하는 max heap에서 가장 큰 값을 중간값으로 바꿈  \r\n\r\n```java\r\npackage package21;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.Comparator;\r\nimport java.util.PriorityQueue;\r\nimport java.util.Queue;\r\n\r\npublic class num1655v2 {\r\n\r\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\tQueue<Integer> min = new PriorityQueue<>();\r\n\t\tQueue<Integer> max = new PriorityQueue<>(new Comparator<Integer>() {\r\n\t\t\t@Override\r\n\t\t\tpublic int compare(Integer o1, Integer o2) {\r\n\t\t\t\treturn o2.compareTo(o1);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t});\r\n\t\t\r\n\t\tint T = Integer.parseInt(br.readLine());\r\n\t\t\r\n\t\tint index=0;\r\n\t\t\r\n\t\tfor(int i = 0; i<T; i++) {\r\n\t\t\tint num = Integer.parseInt(br.readLine());\r\n\t\t\tif(i==0) {\r\n\t\t\t\tindex = num;\r\n\t\t\t\tsb.append(num+\"\\n\");\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif(num<=index) {\r\n\t\t\t\t// 작은 값이면 max heap에 저장\r\n\t\t\t\tmax.offer(num);\r\n\t\t\t\tif(max.size()-min.size()>=1) {\r\n\t\t\t\t\tmin.offer(index);\r\n\t\t\t\t\tindex = max.poll();\r\n\t\t\t\t}\r\n\t\t\t}else {\r\n\t\t\t\t// 큰 값이면  min heap에 저장\r\n\t\t\t\tmin.offer(num);\r\n\t\t\t\tif(min.size() - max.size() >=2) {\r\n\t\t\t\t\tmax.offer(index);\r\n\t\t\t\t\tindex = min.poll();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tsb.append(index+\"\\n\");\r\n\t\t}\r\n\t\tSystem.out.println(sb);\r\n\t}\r\n\r\n}\r\n```\r\n\r\n후... 큰 값을 min heap 저장, 작은 값을 max heap 저장, 중간값은 index로 빼놓는게 포인트인데 코드 짜다보니 헷갈려서 헤맸다.\r\n\r\n\r\n\r\n추가) 다른 사람들은 코드를 어떻게 짰는지 구글링 해봤는데 조금 재밌게 푼 코드가 있어서 추가로 풀어봤다.\r\n\r\n## 풀이2\r\n1. 중간 값은 항상 max heap의 가장 앞의 값으로 유지\r\n2. 크기가 같으면 max heap에 값 추가\r\n   (입력한 값이 min heap의 최소값보다 크면 값 swap)\r\n3. 크기가 다르면 min heap에 값 추가\r\n   (입력한 값이 max heap의 최대값보다 작으면 값 swap)\r\n\r\n이 코드는 입력값 : 521578 을 넣어서 직접 노트에 풀어보는게 이해하는데 도움됐다.\r\n```java\r\npackage package21;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.Comparator;\r\nimport java.util.PriorityQueue;\r\nimport java.util.Queue;\r\n\r\npublic class num1655v3 {\r\n\r\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\tQueue<Integer> min = new PriorityQueue<>();\r\n\t\tQueue<Integer> max = new PriorityQueue<>(new Comparator<Integer>() {\r\n\t\t\t@Override\r\n\t\t\tpublic int compare(Integer o1, Integer o2) {\r\n\t\t\t\treturn o2.compareTo(o1);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t});\r\n\t\t\r\n\t\tint T = Integer.parseInt(br.readLine());\r\n\t\t\r\n\t\tint index=0;\r\n\t\t\r\n\t\tfor(int i = 0; i<T; i++) {\r\n\t\t\tint num = Integer.parseInt(br.readLine());\r\n\t\t\tif(max.size() == min.size()) {\r\n\t\t\t\tmax.offer(num);\r\n\t\t\t\tif(!min.isEmpty() && max.peek() > min.peek()) {\r\n\t\t\t\t\tmin.offer(max.poll());\r\n\t\t\t\t\tmax.offer(min.poll());\r\n\t\t\t\t}\r\n\t\t\t}else {\r\n\t\t\t\tmin.offer(num);\r\n\t\t\t\tif(max.peek() > min.peek()) {\r\n\t\t\t\t\tmin.offer(max.poll());\r\n\t\t\t\t\tmax.offer(min.poll());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tsb.append(max.peek()+\"\\n\");\r\n\t\t}\r\n\t\tSystem.out.println(sb);\r\n\t}\r\n}\r\n\r\n```\r\n\r\n우선순위 큐는 이렇게 마무리!!\r\n\r\n# Update) 2021-01-14\r\n백준 2981번이 비슷한 유형이라 풀고 추가로 update 한다.\r\n# 백준 2981\r\n![문제사진3](problem3.PNG)\r\n![문제사진4](problem4.PNG)\r\n\r\n\r\n```java\r\npackage priorityQueue;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.Comparator;\r\nimport java.util.PriorityQueue;\r\nimport java.util.Queue;\r\n\r\npublic class num2696 {\r\n\r\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\tQueue<Integer> minHeap = new PriorityQueue<>();\r\n\t\tQueue<Integer> maxHeap = new PriorityQueue<>(new Comparator<Integer>() {\r\n\t\t\t@Override\r\n\t\t\tpublic int compare(Integer o1, Integer o2) {\r\n\t\t\t\treturn o2.compareTo(o1);\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\tint T = Integer.parseInt(br.readLine());\r\n\t\t\r\n\t\tfor(int i=0; i<T; i++) {\r\n\t\t\tint count = Integer.parseInt(br.readLine());\r\n\t\t\tString[] inputData = br.readLine().split(\" \");\r\n\t\t\tsb.append(count/2+count%2 + \"\\n\");\r\n\t\t\tint index = 0;\r\n\t\t\tint jindex = 0;\r\n\t\t\tfor(int j=0; j<count; j++) {\r\n\t\t\t\tif(j%10==0 && j>9) {\r\n\t\t\t\t\tinputData = br.readLine().split(\" \");\r\n\t\t\t\t\tif(j%20==0) {\r\n\t\t\t\t\t\tsb.append(\"\\n\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tjindex=0;\r\n\t\t\t\t}\r\n\t\t\t\tint num = Integer.parseInt(inputData[jindex]);\r\n\t\t\t\tif(jindex==0 && j==0) {\r\n\t\t\t\t\tjindex++;\r\n\t\t\t\t\tindex = num;\r\n\t\t\t\t\tsb.append(num + \" \");\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif(num <= index) {\r\n\t\t\t\t\tmaxHeap.offer(num);\r\n\t\t\t\t\tif(maxHeap.size() - minHeap.size()>=1) {\r\n\t\t\t\t\t\tminHeap.offer(index);\r\n\t\t\t\t\t\tindex = maxHeap.poll();\r\n\t\t\t\t\t}\r\n\t\t\t\t}else {\r\n\t\t\t\t\tminHeap.offer(num);\r\n\t\t\t\t\tif(minHeap.size() - maxHeap.size()>=2) {\r\n\t\t\t\t\t\tmaxHeap.offer(index);\r\n\t\t\t\t\t\tindex = minHeap.poll();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(jindex%2==0) {\r\n\t\t\t\t\tsb.append(index + \" \");\r\n\t\t\t\t}\r\n\t\t\t\tjindex++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tsb.append(\"\\n\");\r\n\t\t\tminHeap.clear();\r\n\t\t\tmaxHeap.clear();\r\n\t\t}\r\n\t\tSystem.out.println(sb);\r\n\t}\r\n\r\n}\r\n\r\n```\r\n\r\n이 문제는 한 줄에 10개씩 들어온다는게 포인트다. 10개씩 장난쳐줘야 한다.\r\n\r\n정말 끝","excerpt":"백준 단계별 문제 - 우선순위 큐 마지막 문제다.   풀다가 조금 헷갈린 부분이 있어 정리하고자 포스팅한다.   문제 \n 일단 문제에 처음 접근할 땐, 우선순위 큐를 사용해 저장하고 중간 값을 계속 뽑아와 StringBuilder에 넣어주는 방식으로…","fields":{"slug":"/backjoon1655/"},"frontmatter":{"date":"Jan 13, 2021","title":"백준 1655 - 가운데를 말해요 풀이","tags":["Algorithm","BackJoon"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n문제를 풀다 조금 재밌는 부분이 생겨 정리한다.\r\n\r\n![문제사진](problem1.PNG)\r\n![문제사진2](problem2.PNG)\r\n\r\n백준 문제를 풀 때 한가지 팁은 문제가 낮은 정답비율이면  \r\n입출력이나 시간복잡도를 확인하는게 좋은거같다.  \r\n -> ㄹㅇ 꿀팁이다.  \r\n\r\n일단 뭔가 최대공약수로 장난치는 문제인 느낌을 받아서 규칙을 찾아보았다.\r\n\r\n```\r\narr[1] % M + r = arr[2] % M + r = arr[3] % M + r\r\n -> 요런 식이 나온다. 조금 장난쳐보면\r\n\r\narr[3] % M + r - arr[2] % M - r = arr[2] % M + r - arr[1] % M - r\r\n\r\n(arr[3] - arr[2]) % M = (arr[2] - arr[1]) % M\r\n\r\n(arr[n] - arr[n-1]) % M\r\n```\r\n\r\nㅋ 찾았다.\r\n\r\n```java\r\npackage package16;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class num2981 {\r\n\r\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tint N = Integer.parseInt(br.readLine());\r\n\t\tint[] arr = new int[N];\r\n\t\tint arrGcdValue = 0;\r\n\t\t\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tarr[i] = Integer.parseInt(br.readLine());\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=1; i<N; i++) {\r\n\t\t\tarrGcdValue = gcd(arrGcdValue, Math.abs(arr[i] - arr[i-1]));\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=2; i<=arrGcdValue; i++) {\r\n\t\t\tif(arrGcdValue % i == 0)\r\n\t\t\t\tSystem.out.print(i + \" \");\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static int gcd(int a, int b) {\r\n\t\treturn a % b == 0 ? b : gcd(b, a % b);\r\n\t}\r\n\r\n}\r\n```\r\n아 조금 주의할 점, arr[n] - arr[n-1]값이 음수일 수 있어서 절대값으로 받아야 한다.\r\n\r\n오늘은 뭔가 낚이지 않은 기분이다. 👌하핳","excerpt":"문제를 풀다 조금 재밌는 부분이 생겨 정리한다. \n 백준 문제를 풀 때 한가지 팁은 문제가 낮은 정답비율이면 입출력이나 시간복잡도를 확인하는게 좋은거같다.  -> ㄹㅇ 꿀팁이다.   일단 뭔가 최대공약수로 장난치는 문제인 느낌을 받아서 규칙을 찾아보…","fields":{"slug":"/backjoon2981/"},"frontmatter":{"date":"Jan 09, 2021","title":"백준 2981 - 검문 풀이","tags":["Algorithm","BackJoon"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n풀이를 보고 바로 이해하지 못하고 헷갈린 부분이 있어서 정리한다.\r\n\r\n![문제사진](problem.PNG)\r\n\r\n# LCS란?\r\n공통적으로 가지고 있는 부분 문자열 중, 가장 긴 문자열(최장 공통 부분 수열)\r\n\r\n## 규칙찾기\r\n\r\n점화식을 찾아내기 전에 문제에 나온 예제 입력값을 통해 규칙을 찾아보면\r\n\r\n```\r\nindex   C A P C A K\r\nA       0 1 1 1 1 1\r\nC       1 1 1 2 2 2\r\nA       1 2 2 2 3 3\r\nY       1 2 2 2 3 3\r\nK       1 2 2 2 3 4\r\nP       1 2 3 3 3 4\r\n```\r\n\r\n## 접근\r\n\r\n문제의 경우는 2가지로 나눌 수 있다.\r\n\r\n 1) 두 문자열에 같은 문자가 추가되는 경우\r\n    - ex) ACAYKP**A** , CAPCAK**A**\r\n 2) 두 문자열에 다른 문자가 추가되는 경우\r\n    - ex) ACAYKP**B** , CAPCAK**C**\r\n\r\n## 점화식\r\n두 가지 경우를 각각 점화식으로 나타내 보면\r\n```\r\n 1) dp[i][j] = dp[i-1][j-1] + 1\r\n 2) dp[i][j] = Max(arr[i][j-1], arr[i-1][j])\r\n```\r\n\r\n점화식을 찾아냈으면 코드작성은 쉽다.\r\n\r\n## 코드\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class num9251 {\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tString[] str1 = br.readLine().split(\"\");\r\n\t\tString[] str2 = br.readLine().split(\"\");\r\n\t\t\r\n\t\tint N = str1.length;\r\n\t\tint M = str2.length;\r\n\t\tint[][] arr = new int[N+1][M+1];\r\n\t\t\r\n\t\tfor(int i=1;i<=N;i++) {\r\n\t\t\tfor(int j=1;j<=M;j++) {\r\n\t\t\t\tif(str1[i-1].equals(str2[j-1])) {\r\n\t\t\t\t\tarr[i][j] = arr[i-1][j-1] +1;\r\n\t\t\t\t}else {\r\n\t\t\t\t\tarr[i][j] = Math.max(arr[i][j-1],arr[i-1][j]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tSystem.out.println(arr[N][M]);\r\n\t}\r\n}\r\n```","excerpt":"풀이를 보고 바로 이해하지 못하고 헷갈린 부분이 있어서 정리한다.  LCS란? 공통적으로 가지고 있는 부분 문자열 중, 가장 긴 문자열(최장 공통 부분 수열) 규칙찾기 점화식을 찾아내기 전에 문제에 나온 예제 입력값을 통해 규칙을 찾아보면 접근 문제…","fields":{"slug":"/backjoon9251/"},"frontmatter":{"date":"Dec 28, 2020","title":"백준 9251 - LCS 풀이","tags":["Algorithm","BackJoon"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n기술 면접을 준비하면서 면접에 자주 나오는 문항들을 정리해보려고 한다.\r\n\r\n본 포스트는 취업 준비를 하면서 부족한 부분을 지속해서 업데이트할 예정이다.\r\n\r\n# 시작하기전에\r\n - 1) 수행한 프로젝트, 준비한 사항은 **분명하고 간결하게** 설명 가능해야 한다.\r\n - 2) 쫄지말자, 당당하게\r\n - 3) 답변을 추상적이게 하지 말고, **구체적으로 아는 쪽으로 답변**\r\n\r\n\r\n# 목차\r\n\r\n# Part1. CS\r\n\r\n\r\n### 1. 객체 지향 프로그래밍\r\n\r\n```\r\n1. 정의\r\n  프로그램을 수많은 '객체'라는 기본 단위로 나누고 이 객체들의 상호작용으로 서술\r\n  - 객체란, 하나의 역할을 수행하는 '메소드와 변수(데이터)'\r\n\r\n2. 특징\r\n - 인간 중심적 프로그래밍 패러다임\r\n - 프로그램 설계 방법론이자 개념의 일종\r\n - 현실 세계 사물 -> 객체\r\n - 어플리케이션 특징(객체의 상호작용) -> 프로그래밍(=추상화)\r\n\r\n3. 장점\r\n - 코드 재사용 용이\r\n - 유지 보수 쉬움\r\n - 강한 응집력과 약한 결합력을 가진다\r\n - (응집력 : 기능을 수행하기 위해 얼마만큼의 연관된 책임과 아이디어가 뭉친 정도)\r\n - (결합력 : 프로그램의 요소가 다른 것과 얼마나 연결되어 있는지, 의존적인지)\r\n\r\n4. 단점\r\n - 설계시 많은 시간 필요\r\n - 객체들간의 통신시 오버헤드 발생해서 처리속도가 상대적으로 느림\r\n```\r\n\r\n **1. 객체 지향 프로그래밍이 뭔가요?**  \r\n    - 프로그램 설계 방법론입니다. 현실 세계의 사물을 추상화하여 객체를 만들고, 객체간의 상호작용을 통해 시스템을 구성하는 프로그래밍 방법입니다.  \r\n    특징으로는 추상화, 캡슐화, 상속, 다형성이 있습니다\r\n    장점으로는 코드 재사용이 용이, 유지보수가 쉬움, 강한 응집력과 약한 결합력을 가지는 것이 있고,  \r\n    단점으로는 설계시 많은 시간이 필요하고, 객체들간의 통신시 오버헤드가 발생해 처리속도가 상대적으로 느립니다.\r\n\r\n**1-1. 객체지향에서 말하는 추상화가 뭔가요?**  \r\n    - 객체에서 공통된 속성과 행위를 뽑아내는 것을 말합니다.  \r\n\r\n\r\n**1-2. 객체지향에서 말하는 캡슐화가 뭔가요?**  \r\n    - 변수와 함수를 하나의 단위로 묶는 것을 의미합니다. 추가로 자바에서는 접근 제어자를 통해 정보 은닉 기능을 제공합니다. 정보 은닉은, 프로그램의 세부 구현을 외부로 드러내지 않도록 감추는 것을 말합니다.  \r\n\r\n\r\n**1-3. 객체지향에서 말하는 상속이 뭔가요?**  \r\n    - 기존 클래스를 활용하여 새로운 클래스를 작성하는 것을 말합니다. 상속의 장점은 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램 생산성과 유지보수에 기여합니다.    \r\n\r\n\r\n**1-4. 객체지향에서 말하는 다형성이 뭔가요?**  \r\n    - 다향한 형태로 나타날 수 있는 특성을 말합니다.  \r\n\r\n**1-5. 객체지향에서 말하는 응집력과 결합력이 뭔가요?**  \r\n    - 응집력은 기능을 수행하기 위해 얼마만큼의 책임과 아이디어가 뭉쳐있는지 나타내는 정도입니다.  \r\n    - 결합력은 다른 요소와 얼마나 의존적인지 나타내는 정도입니다.\r\n\r\n**2. 객체와 인스턴스가 뭔가요?**  \r\n    - 인스턴스는 객체를 실체화한 것입니다. 즉, 프로그램 코드 상에서 자료형이 임의의 클래스로 선언된 클래스를 객체라 하고, 코드 컴파일 후 프로그램이 실행될 때 해당 객체가 메모리에 적재되면 인스턴스라 합니다. \r\n\r\n**3. 객체 지향 프로그래밍과 절차지향 프로그래밍을 설명해주세요**\r\n    - 절차지향 프로그래밍이란 '프로그램이 무슨일을 하는가'의 관점으로 바라본 프로그래밍 기법이고,\r\n    - 객체지향 프로그래밍은 '어떤 대상을 모델링하는가'의 관점으로 바라본 프로그래밍 기법입니다.\r\n    - 즉, 절차지향 프로그래밍은 프로그램의 순서와 흐름을 먼저 세우고 필요한 자료구조와 함수들을 설계하는 방식이고, 객체지향 프로그래밍은 반대로 자료구조와 이를 중심으로 한 모듈들을 먼저 설계한 다음에 이들의 실행순서와 흐름을 짜는 방식이다.\r\n\r\n### 2. RESTful API\r\n\r\n```\r\n1. 정의\r\n - 소프트웨어 아키텍처의 한 형식으로 자원을 정의하고 자원에 대한 주소를 지정하는 방법  \r\n\r\n2. 특징\r\n - 지정한 주소를 HTTP Method를 통해 자원을 처리한다.\r\n - REST의 6가지 기본 원칙을 성실히 지킨 서비스 디자인을 RESTful하다라고 표현\r\n\r\n3. 장점\r\n - 기존 웹 인프라를 그대로 사용할 수 있다.\r\n - 쉽고, 빠르다\r\n - 세부적인 표현 문구를 JSON, XML등 다양한 언어를 이용하여 작성할 수 있다.\r\n\r\n4. 단점\r\n - 메소드 형태가 제한적이다.\r\n - 표준 규약이 없다.\r\n - HTTP 통신 모델에 대해서만 지원합니다.\r\n```\r\n\r\n**1. API란 무엇인가요?**  \r\n    - API란, 응용 프로그램에서 사용할 수 있도록 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻합니다.  \r\n\r\n**2. REST API란 무엇인가요?**  \r\n    - 자원이 있는 곳을 URI로 정의하고, 자원을 이용하는 방법을 HTTP Method를 통해 자원을 처리하는 것을 말합니다.  \r\n\r\n**3. RESTful 하게 API를 디자인 한다는 것은 무엇을 의미하는가?**  \r\n    - REST API의 6가지 기본 원칙을 성실히 지킨 서비스를 RESTful하다라고 표현합니다.  \r\n\r\n### 3. TDD\r\n\r\n```\r\n1. 정의\r\n - 테스트 주도 개발\r\n - (개발 테스트 단위가 함수단위로 매우 작아서 작성하는 거의 모든 함수가 테스트에 포함된다.)\r\n\r\n2. 관련 용어\r\n 1) BDD : 시나리오 기반으로 테스트 케이스 작성\r\n  - Given -> When -> Then\r\n  - 어떤 상태 (Given) -> 어떤 상태 변화를 가했을 때(When) -> 기대하는 상태로 완료(Then)\r\n\r\n3. 장점\r\n - 피드백이 많아진다.\r\n - (테스트를 통과하는 것으로 개발이 잘 진행되는지 자주 확인가능해진다.)\r\n - 코드 복잡도가 낮아진다.\r\n\r\n4. 단점\r\n - 개발시간이 길어진다.\r\n```\r\n\r\n**1. TDD에 대해 설명해주세요**\r\n\r\n**2. BDD에 대해 아시나요?**\r\n\r\n**3. 좋은 코드에 대해 어떻게 생각하시나요? (내생각)**  \r\n    - 저는 좋은 코드를 판단하는 기준으로 **가독성, 효율성**이 가장 중요하다고 생각합니다.  \r\n   Coding Convention을 잘 지키고 일관성있게 작성되며, 문제상황에서 필요한 요구사항을 적절히 충족하고 효율적으로 해결하는 코드가 좋은 코드라고 생각합니다.\r\n\r\n\r\n\r\n### 4. GIT\r\n\r\n```\r\n1. 정의\r\n - 버전 관리 시스템\r\n\r\n2. 장점\r\n - 여러명이 동시에 작업하는 병렬 개발이 가능하다.\r\n - 분산 버전관리이기 때문에 인터넷이 연결되지 않은 곳에서도 개발을 진행할 수 있다.\r\n - 체계적인 개발이 가능해진다.\r\n```\r\n\r\n**1. Git의 장점에 대해 설명해주세요**\r\n    - 여러명이 동시 작업하는 병렬 개발이 가능하고, 분산 버전관리기 때문에 인터넷이 연결되지 않은 곳에서도 개발을 진행할 수 있는 것이 장점입니다.\r\n\r\n## Part 1-2 자료구조\r\n\r\n### 1. Array / LinkedList\r\n\r\n### 2. Stack / Queue\r\n\r\n**1. Stack에 대해 설명해주세요**  \r\n    - 선형 자료구조의 일종으로 Firt In Last Out (FILO)구조를 가집니다.\r\n\r\n\r\n**2. Queue에 대해 설명해주세요**  \r\n    - 선형 자료구조의 일종으로 First In First Out (FIFO)구조를 가집니다.\r\n\r\n\r\n### 3. Tree\r\n```\r\n 1. Binary Tree(이진트리)\r\n\r\n 2. BST(Binary Search Tree)\r\n\r\n 3. Binary Heap\r\n\r\n 4. Red Black Tree\r\n\r\n 5. Graph\r\n\r\n```\r\n**1. Tree에 대해 설명해주세요**  \r\n    - 비선형 자료구조이다. 트리는 계층적 관계(Hierarchical Relationship)을 표현하는 자료구조이다. \r\n\r\n**2. 이진트리(Binary Tree)에 대해 설명해주세요.**\r\n\r\n## Part 1-3 알고리즘\r\n\r\n## Part 1-4 네트워크\r\n\r\n### 1. HTTP Method\r\n\r\n\r\n### 2. TCP/UDP\r\n\r\n\r\n\r\n### 3. HTTP/HTTPS\r\n\r\n\r\n### 4. 웹 통신의 흐름\r\n\r\n\r\n## Part 1-5 운영체제\r\n\r\n### 1. 프로세스/스레드\r\n\r\n\r\n\r\n\r\n### 2. 멀티스레드/멀티 프로세스\r\n\r\n\r\n### 3. 동기/비동기\r\n\r\n\r\n**1.재귀 호출의 단점은?**  \r\n    - 재귀 호출 시, 함수를 반복해서 호출해야 하는데, 매번 호출할 때마다 시간과 스택 공간에서 오버헤드 발생.\r\n\r\n\r\n## Part 1-6 데이터 베이스\r\n\r\n### 1. 데이터 베이스 사용하는 이유\r\n\r\n\r\n### 2. 정규화\r\n\r\n\r\n### 3. 트랜잭션\r\n\r\n### 4. NoSQL\r\n\r\n\r\n## Part 1-7 디자인 패턴\r\n\r\n### 1. MVC 패턴이란?\r\n\r\n```\r\n1. 정의 - Model-View-Controller의 약자로, 개발할 때 3가지 형태로 나눠 개발하는 방법론\r\n\r\n2. 특징\r\n - Model : 어플리케이션이 무엇을 할 지 정의\r\n - View : 어플리케이션 화면에 무엇을 보여줄지\r\n - Controller : 어플리케이션이 어떻게 처리할지\r\n   -> Model, View가 무엇을 해야 할 지를 알고 통제\r\n\r\n3. 관련 용어\r\n - Service\r\n\r\n4. 장점\r\n -\r\n\r\n5. 단점\r\n```\r\n\r\n## Part 1-8 보안\r\n\r\n# Part2. Language\r\n\r\n## 1. JAVA\r\n\r\n1. JVM이란?\r\n   - 자바가상머신의 약자를 줄여서 부르는 용어입니다. **프로그램을 실행하기 위해 물리적 머신과 유사한 머신을 소프트웨어로 구현**한 것을 말합니다.\r\n\r\n2. GC이란?\r\n   - \r\n\r\n## 2. JavaScript\r\n > 프로그래밍 언어로 브라우저가 가진 기능을 코드로 제어\r\n > (이벤트를 제어하기 위함)\r\n\r\n### 2.1 NodeJS\r\n > 자바스크립트의 언어와 환경이 분리 필요\r\n -> 웹서버를 동작하기 위한 도구로 구글의 V8 Engine기반 **NodeJS** 탄생!!\r\n\r\n## 3. C\r\n\r\n1. C에서는 메모리를 어떻게 할당하는가?\r\n    - d\r\n\r\n# Part3. FrontEnd\r\n**프레임 워크와 플랫폼의 차이가 뭔가요?**\r\n\r\n**Cookie, Session Storage, LocalStorage의 차이점을 말해주세요**\r\n\r\n\r\n**UI(User Interface)란?**\r\n   - 사용자와 시스템의 접점\r\n\r\n\r\n## 1. Vitual DOM\r\n\r\n## 2. React.js\r\n\r\n\r\n## 3. Vue.js\r\n\r\n\r\n# Part4. BackEnd\r\n\r\n## 1. Spring\r\n\r\n## 2. Express\r\n\r\n# Part5. Project\r\n\r\n\r\n## IoT\r\n\r\n### 1. MQTT\r\n\r\n","excerpt":"기술 면접을 준비하면서 면접에 자주 나오는 문항들을 정리해보려고 한다. 본 포스트는 취업 준비를 하면서 부족한 부분을 지속해서 업데이트할 예정이다. 시작하기전에 수행한 프로젝트, 준비한 사항은 분명하고 간결하게 설명 가능해야 한다. 쫄지말자, 당당하…","fields":{"slug":"/techInterview/"},"frontmatter":{"date":"Dec 28, 2020","title":"개발 기술 면접 준비","tags":["면접"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\nAWS EC2를 사용해서 구현해야 할 일이 생겨서 간만에 사용하다 잘 안되서 기록해둔다.\r\n\r\n1. AWS EC2 인스턴스 생성\r\n\r\n2. vscode extensions에서 ftp-simple을 설치해준다.\r\n\r\n3. F1을 눌러 ftp-simple : Config - FTP connection setting 실행.  \r\n 다음 사진과 같이 설정해준다.\r\n\r\n![설정 json](./201205_jsoncapture.PNG \"json파일\")\r\n\r\n1. F1 눌러 Remote directory open to workspace 실행하면 된다.\r\n","excerpt":"AWS EC2를 사용해서 구현해야 할 일이 생겨서 간만에 사용하다 잘 안되서 기록해둔다. AWS EC2 인스턴스 생성 vscode extensions에서 ftp-simple을 설치해준다. F1을 눌러 ftp-simple : Config - FTP c…","fields":{"slug":"/vscode_connect_aws/"},"frontmatter":{"date":"Dec 05, 2020","title":"AWS EC2 Visual Studio Code로 사용하기","tags":["AWS"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n백준 DP 단계별 문제에 있는 10844번 문제이다. \r\n\r\n접근이 조금 어려웠던 문제라 풀이를 정리해보려고 한다.  \r\n\r\n## 접근\r\n\r\n일단 이 문제는 DP문제로 2차원 배열을 DP로 사용해야 한다.\r\n\r\n규칙을 찾기 위해 값을 적어보고, 개수를 세보면 아래와 같다.  \r\n(N : 자리수, index : 맨 마지막에오는 숫자)  \r\n```\r\nindex   0 1 2 3 4 5 6 7 8 9\r\nN=1     0 1 1 1 1 1 1 1 1 1  \r\nN=2     1 1 2 2 2 2 2 2 2 1\r\nN=3     1 3 3 4 4 4 4 4 3 2\r\n\r\nex)\r\nN=2 -> (10), (21), (32, 12), (43,23), (54,34), (65,45), (76,56), (87,67), (98,78), (89)\r\n```\r\ndp[N][index] = dp[N-1][index-1] + dp[N-1][index+1]인 점화식을 얻을 수 있다.\r\n\r\n단, 여기서 중요한 점은 index가 0일 경우는 +1 한 값이 허용되고  \r\n9일 경우는 -1 한 경우만 적용되기 때문에 예외 처리를 해줘야 한다.  \r\n\r\n마지막으로 점화식을 정리해보면\r\n```\r\n1) index가 1일 경우\r\ndp[N][index] = dp[N-1][index+1]\r\n\r\n2) index가 1~8일 경우\r\ndp[N][index] = dp[N-1][index-1] + dp[N-1][index+1]\r\n\r\n3) index가 9일 경우\r\ndp[N][index] = dp[N-1][index-1]\r\n\r\n```\r\n\r\n3가지 경우에 따라 분기처리를 하면 된다.\r\n\r\n# Top-down 방식\r\n\r\n## 구현코드\r\n\r\n```java\r\npackage package14;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class num10844 {\r\n\tstatic Long[][] dp;\r\n\tstatic int N;\r\n\tfinal static long MOD = 1000000000;\r\n\t\r\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tN = Integer.parseInt(br.readLine());\r\n\t\tdp = new Long[N+1][10];\r\n\t\t// #1\r\n\t\tfor(int i = 0; i < 10; i++) {\r\n\t\t\tdp[1][i] = 1L;\r\n\t\t}\r\n\r\n\t\tlong result = 0;\r\n\t\t\r\n\t\tfor(int i = 1; i <= 9; i++) {\r\n\t\t\tresult += recur(N, i);\r\n\t\t}\r\n\t\tSystem.out.println(result % MOD);\r\n\t}\r\n\t\r\n\tstatic long recur(int digit, int val) {\t\t\r\n\t\t\r\n\t\tif(digit == 1) {\r\n\t\t\treturn dp[digit][val];\r\n\t\t}\r\n\t\t// #2\r\n\t\tif(dp[digit][val] == null) {\r\n\t\t\tif(val == 0) {\r\n\t\t\t\tdp[digit][val] = recur(digit - 1 ,1);\r\n\t\t\t}\r\n\t\t\telse if(val== 9) {\r\n\t\t\t\tdp[digit][val] = recur(digit - 1, 8);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tdp[digit][val] = recur(digit - 1, val - 1) + recur(digit - 1, val + 1);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn dp[digit][val] % MOD;\r\n\t}\r\n}\r\n\r\n\r\n```\r\n\r\n## 코드설명\r\n 1) N=1인 값들은 값을 초기값으로 값을 넣어준다.\r\n 2) 점화식과 동일하게 상황에 따라 맞는 값을 재귀로 호출한다.\r\n\r\n# Botton-up 방식\r\n\r\n## 구현 코드\r\n\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.InputStreamReader;\r\nimport java.io.IOException;\r\n \r\npublic class Main {\r\n\t\r\n\tfinal static long mod = 1000000000;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\t\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tint N = Integer.parseInt(br.readLine());\r\n\t\t\r\n\t\tlong[][] dp = new long[N + 1][10];\r\n\t\t\r\n\t\tfor(int i = 1; i < 10; i++) {\r\n\t\t\tdp[1][i] = 1; \r\n\t\t}\r\n\t\t\r\n\t\t// 두 번째 자릿수부터 N까지 탐색 \r\n\t\tfor(int i = 2; i <= N; i++) {\r\n\t\t\t\r\n\t\t\tfor(int j = 0; j < 10; j++) {\r\n\t\t\t\t\r\n\t\t\t\tif(j == 0) {\r\n\t\t\t\t\tdp[i][0] = dp[i - 1][1] % mod;\r\n\t\t\t\t}\r\n\t\t\t\telse if (j == 9) {\r\n\t\t\t\t\tdp[i][9] = dp[i - 1][8] % mod;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tdp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j + 1]) % mod;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tlong result = 0;\r\n\t\t\r\n\t\tfor(int i = 0; i < 10; i++) {\r\n\t\t\tresult += dp[N][i];\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(result % mod);\r\n\t}\r\n \r\n}\r\n```\r\n\r\n## 코드설명\r\n - Top-down방식과 동일한데 재귀 부분을 for문으로 두번째 자리부터 N까지 탐색한다.\r\n\r\n\r\n# \r\n<hr>\r\n\r\n아직 DP문제를 많이 풀어보지 않아서 그런지 점화식 만들어 내는 과정이 어렵다... ㅜㅜㅜㅜㅜ  \r\n익숙해질 때까지 열심히 풀어야겠다 (승질 그만내고 ㅎㅎ)","excerpt":"백준 DP 단계별 문제에 있는 10844번 문제이다.  접근이 조금 어려웠던 문제라 풀이를 정리해보려고 한다.   접근 일단 이 문제는 DP문제로 2차원 배열을 DP로 사용해야 한다. 규칙을 찾기 위해 값을 적어보고, 개수를 세보면 아래와 같다. (…","fields":{"slug":"/backjoon10844/"},"frontmatter":{"date":"Dec 03, 2020","title":"백준 10844번 - 쉬운 계단수 풀이","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"알고리즘 문제를 풀면서 많이 하는 실수를 정리할 필요성을 느꼈다.  \r\n본 포스트는 주의해야 할 실수가 생길 때 마다 update할 예정이다.\r\n\r\n# 백트래킹\r\n > 재귀함수 빠져나오면 상태 값 원래대로 돌려줘야 함.\r\n\r\n# 최단거리\r\n > 값 넣어줄 때, 입력값 -1 해서 받아야 함 (배열 index로 사용하기 때문)","excerpt":"알고리즘 문제를 풀면서 많이 하는 실수를 정리할 필요성을 느꼈다. 본 포스트는 주의해야 할 실수가 생길 때 마다 update할 예정이다. 백트래킹 재귀함수 빠져나오면 상태 값 원래대로 돌려줘야 함. 최단거리 값 넣어줄 때, 입력값 -1 해서 받아야 …","fields":{"slug":"/algoMistake/"},"frontmatter":{"date":"Nov 25, 2020","title":"알고리즘 풀 때 많이하는 실수","tags":["Algorithm"],"update":"Jan 25, 2021"}}},{"node":{"rawMarkdownBody":"\r\n# Comparable\r\n > 클래스의 기본 정렬 기준을 설정하는 인터페이스\r\n\r\n\r\n## 1) 특징\r\n - Comparable 인터페이스 상속 후, compareTo 메소드 오버라이딩\r\n - compareTo메소드 리턴 값은 음수, 0, 양수가 될 수 있다. **음수가 리턴되면 인자의 순서가 아래로 이동**\r\n - 자바에서 제공되는 정렬이 가능한 클래스는 모두 Comparable 클래스로 구현되어 있음\r\n \r\n## 2) 구현 코드\r\n\r\n# Comparator\r\n > 기본 정렬과 다르게 정렬하고 싶을 때 이용하는 클래스\r\n## 1) 특징\r\n - 보통 구현 되어있는 sort함수의 2번째 인자로 Comparator 타입을 받아(익명함수) compare 메소드 오버라이딩을 통해 배열 정렬 순서 재정의\r\n - 보통 한번 사용하고 사용하지 않기 때문에 익명객체로 만듬\r\n\r\n## 2) 구현 코드\r\n\r\n# 관련 백준 문제\r\n - 11650, 11651, 1181, 10814","excerpt":"Comparable 클래스의 기본 정렬 기준을 설정하는 인터페이스 1) 특징 Comparable 인터페이스 상속 후, compareTo 메소드 오버라이딩 compareTo메소드 리턴 값은 음수, 0, 양수가 될 수 있다. 음수가 리턴되면 인자의 순서…","fields":{"slug":"/javaComparableComparator/"},"frontmatter":{"date":"Nov 24, 2020","title":"JAVA Comparable, Comparator 사용","tags":["JAVA"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n이전부터 자주 헷갈렸던 순열, 조합, 부분집합의 개념 정리와 JAVA를 사용해 구현하는 방법을 정리해 보려고 한다.  \n\n1) 대표적인 구현 방법  \n2) 각, 방법의 특징    \n\n두가지 사항으로 정리한다.  \n\n# 순열\n\n  - n개의 원소 중, r개를 일렬로 나열하는 수열  \n  - 중복 X / 순서 고려\n\n## 1. next_permutation\n\n### 1) 특징\n - 이게 이해하기 제일 어려웠다.... (나만 어렵나...ㅜㅜ)\n - 무작위 순열의 다음 순열을 구해내는 알고리즘\n - 시작 조건 : 오름차순 / 종료 조건 : 내림차순\n```\n  순서\n  1.Find largest index i such that array[i − 1] < array[i].\n  (If no such i exists, then this is already the last permutation.)\n\n  2.Find largest index j such that j ≥ i and array[j] > array[i − 1].\n\n  3.Swap array[j] and array[i − 1].\n\n  4.Reverse the suffix starting at array[i].\n```\n\n### 2) 구현 코드\n```java\npublic class num1 {\n    public static void main(String[] args) {\n    \tint[] list = new int[]{5,4,3};\n    \t// #1 시작 조건에 맞게 list 오름차순 정렬 (시작조건)\n    \tArrays.sort(list);\n    \tpermutation(list);\n    }\n    // #2 처음 list값 print 후, 다음 순열 찾음\n    public static void permutation(int[] list) {\n        int[] curArray = list;\n        while (true) {\n        \tprintArray(curArray);\n        \tcurArray = nextPermutation(curArray);\n            if (curArray == null) {\n                break;\n            }\n        }\n    }\n    \n    public static int[] nextPermutation(int[] list) {\n    \t  // #3 수열의 바로 앞 값 보다 큰 값 중 가장 큰 index 찾는다. \n        // (가장 적은 차이로 순서를 바꾸기 위해서 가장 큰 index를 찾음) \n        int i = list.length -1;\n        while(i>0 && list[i-1] >= list[i])\n        \ti--;\n        \n        // #6 list가 내림차순으로 정렬되어 있으면 순열을 끝까지 찾은 것 (종료조건)\n        if(i<=0)\n        \treturn null;\n        \n        int j = list.length -1;\n        // #4 다음 수열의 특징 : 이전 순열보다 값이 큼\n        // -> list[i-1] < list[j] 값을 찾고, 값을 바꿔준다.\n        while(list[j] <= list[i-1])\n        \tj--;\n        \n        int temp = list[i-1];\n        list[i - 1] = list[j];\n        list[j] = temp;\n        // #5 a[i] 이후 부분을 오름차순으로 셋팅 \n        j= list.length-1;\n        while (i < j) {\n            temp = list[i];\n            list[i] = list[j];\n            list[j] = temp;\n            i++;\n            j--;\n        }\n        \n        return list;\n    }\n    \n    public static void printArray(int[] array) {\n    \tfor(int i=0;i<array.length;i++)\n    \t\tSystem.out.print(array[i] + \" \");\n    \tSystem.out.println();\n    }\n    \n}\n\n```\n### 3) 코드 설명\n\n1. 시작 조건에 맞게 list 오름차순 정렬 (시작조건)\n2. 처음 list값 print 후, 다음 순열 찾음\n3. 수열의 바로 앞 값 보다 큰 값 중 가장 큰 index 찾는다.  \n  (가장 적은 차이로 순서를 바꾸기 위해서 가장 큰 index를 찾음)\n4. 다음 수열의 특징 : 이전 순열보다 값이 큼 -> list[i-1] < list[j] 값을 찾고, 값을 바꿔준다.\n5. a[i] 이후 부분을 오름차순으로 셋팅 \n6. list가 내림차순으로 정렬되어 있으면 순열을 끝까지 찾은 것 (종료조건)\n\n### 4) 코드 출력값\n```\n3 4 5 \n3 5 4 \n4 3 5 \n4 5 3 \n5 3 4 \n5 4 3 \n\n```\n\n## 2. Swap\n\n### 1) 특징\n - 순열의 순서가 보장되지 않는다. (사전식 X)\n\n\n### 2) 구현 코드\n```java\npublic class Main {\n  public static void main(String[] args) {\n  \tint[] arr = {1,2,3};\n  \tpermutation(arr,0,3,3);\n  \tSystem.out.println(Arrays.toString(arr));\n  }\n\n  static void permutation(int[] arr, int depth, int n, int r) {\n  \tif (depth == r) {\n  \t\tarrPrint(arr,r);\n  \t\treturn;\n  \t}\n  \tfor (int i=depth; i<n; i++) {\n      // #1\n  \t\tswap(arr, depth, i);\n      // #2\n  \t\tpermutation(arr, depth + 1, n, r);\n      // #3\n     \tswap(arr, depth, i);\n  \t}\n  }\n\n  static void arrPrint(int[] arr, int r) {\n    for (int i=0 ; i<r; i++)\n    \tSystem.out.print(arr[i] + \" \");\n    System.out.println();\n  }\n\n  static void swap(int[] arr, int depth, int i) {\n    int temp = arr[depth];\n    arr[depth] = arr[i];\n    arr[i] = temp;\n  }\n}\n```\n### 3) 코드 설명\n\n1. 배열의 첫번째 값부터 하나씩 바꾸면서 swap\n2. depth를 기준(Inex)으로 depth보다 작은 인데스 값들은 고정, depth보다 큰 값들을 가지고 swap\n3. 재귀함수가 종료조건에 의해 return되면 swap을 한번 더 해줘서 이전 상태 유지\n\n\n### 4) 코드 출력값\n```\n1 2 3 \n1 3 2 \n2 1 3 \n2 3 1 \n3 2 1 \n3 1 2 \n[1, 2, 3]\n```\n\n## 3. Visit Index 사용\n\n### 1) 특징\n - DFS, 재귀 함수\n\n\n### 2) 구현 코드\n\n```java\npublic class Main {\n\tpublic static void main(String[] args) {\n\t    int n = 3;\n\t    int[] arr = {1, 2, 3};\n      // #1\n\t    int[] output = new int[n];\n\t    boolean[] visited = new boolean[n];\n\t    perm(arr, output, visited, 0, n, 2);\n\t    System.out.println();\n\t}\n\n\tstatic void perm(int[] arr, int[] output, boolean[] visited, int depth, int n, int r) {\n\t    if (depth == r) {\n\t        print(output, r);\n\t        return;\n\t    }\n\n\t    for (int i = 0; i < n; i++) {\n\t        if (visited[i] != true) {\n\t            visited[i] = true;\n              output[depth] = arr[i];\n              // #2\n\t            perm(arr, output, visited, depth + 1, n, r);\n              // #3\n\t            visited[i] = false;\n\t        }\n\t    }\n\t}\n\n\tstatic void print(int[] arr, int r) {\n\t    for (int i = 0; i < r; i++)\n\t        System.out.print(arr[i] + \" \");\n\t    System.out.println();\n\t}\n\t\n}\n\n```\n### 3) 코드 설명\n1. output : 코드 출력 값 / visited : 방문 여부 체크\n2. depth -> output 길이라고 생각\n3. 방문 여부 false로 체크 -> 모든 인덱스 방문\n   \n\n### 4) 코드 출력값 \n```\n1 2 \n1 3 \n2 1 \n2 3 \n3 1 \n3 2 \n```\n\n## 관련 백준 문제\n> n과m 시리즈 0 ~ 12\n\n# Reference\n[BaaaaaaaarkingDog님 블로그](https://blog.encrypted.gg/945?category=773649)  \n[뱀귤님 블로그](https://bcp0109.tistory.com/entry/%EC%88%9C%EC%97%B4-Permutation-Java?category=848939)  \n[junhok82님 블로그](https://velog.io/@junhok82/>Java%EB%A1%9C-%EC%88%9C%EC%97%B4Permutation-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0>)  \n[Crocus님 블로그](https://www.crocus.co.kr/1240)","excerpt":"이전부터 자주 헷갈렸던 순열, 조합, 부분집합의 개념 정리와 JAVA를 사용해 구현하는 방법을 정리해 보려고 한다.   대표적인 구현 방법   각, 방법의 특징     두가지 사항으로 정리한다.   순열 n개의 원소 중, r개를 일렬로 나열하는 수열…","fields":{"slug":"/permutation/"},"frontmatter":{"date":"Nov 23, 2020","title":"순열 정리, 구현","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"","excerpt":"","fields":{"slug":"/backjoon2293/"},"frontmatter":{"date":"Nov 23, 2020","title":"순열 정리, 구현","tags":["Algorithm"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}},"staticQueryHashes":["2027115977","694178885"]}